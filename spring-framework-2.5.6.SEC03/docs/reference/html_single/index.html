<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>The Spring Framework - Reference Documentation</title><link rel="stylesheet" href="html.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.60.1"><!--Begin Google Analytics code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            var pageTracker = _gat._getTracker("UA-2728886-3");
            pageTracker._setDomainName("none");
            pageTracker._setAllowLinker(true);
            pageTracker._trackPageview();
        </script><!--End Google Analytics code--></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="d0e1"></a>The Spring Framework - Reference Documentation</h1></div><div><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="authorgroup"><h2>Authors</h2><p></p><span class="author"><span xmlns="" class="firstname">Rod</span> <span xmlns="" class="surname">Johnson</span></span>, <span class="author"><span xmlns="" class="firstname">Juergen</span> <span xmlns="" class="surname">Hoeller</span></span>, <span class="author"><span xmlns="" class="firstname">Alef</span> <span xmlns="" class="surname">Arendsen</span></span>, <span class="author"><span xmlns="" class="firstname">Colin</span> <span xmlns="" class="surname">Sampaleanu</span></span>, <span class="author"><span xmlns="" class="firstname">Rob</span> <span xmlns="" class="surname">Harrop</span></span>, <span class="author"><span xmlns="" class="firstname">Thomas</span> <span xmlns="" class="surname">Risberg</span></span>, <span class="author"><span xmlns="" class="firstname">Darren</span> <span xmlns="" class="surname">Davison</span></span>, <span class="author"><span xmlns="" class="firstname">Dmitriy</span> <span xmlns="" class="surname">Kopylenko</span></span>, <span class="author"><span xmlns="" class="firstname">Mark</span> <span xmlns="" class="surname">Pollack</span></span>, <span class="author"><span xmlns="" class="firstname">Thierry</span> <span xmlns="" class="surname">Templier</span></span>, <span class="author"><span xmlns="" class="firstname">Erwin</span> <span xmlns="" class="surname">Vervaet</span></span>, <span class="author"><span xmlns="" class="firstname">Portia</span> <span xmlns="" class="surname">Tung</span></span>, <span class="author"><span xmlns="" class="firstname">Ben</span> <span xmlns="" class="surname">Hale</span></span>, <span class="author"><span xmlns="" class="firstname">Adrian</span> <span xmlns="" class="surname">Colyer</span></span>, <span class="author"><span xmlns="" class="firstname">John</span> <span xmlns="" class="surname">Lewis</span></span>, <span class="author"><span xmlns="" class="firstname">Costin</span> <span xmlns="" class="surname">Leau</span></span>, <span class="author"><span xmlns="" class="firstname">Mark</span> <span xmlns="" class="surname">Fisher</span></span>, <span class="author"><span xmlns="" class="firstname">Sam</span> <span xmlns="" class="surname">Brannen</span></span>, <span class="author"><span xmlns="" class="firstname">Ramnivas</span> <span xmlns="" class="surname">Laddad</span></span>, <span class="author"><span xmlns="" class="firstname">Arjen</span> <span xmlns="" class="surname">Poutsma</span></span></div></div><div><p class="releaseinfo">2.5.6</p></div><div><div class="legalnotice"><p>Copies of this document may be made for your own use and for
			distribution to others, provided that you do not charge any
			fee for such copies and further provided that each copy
			contains this Copyright Notice, whether distributed in print
			or electronically.</p></div></div></div><div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><a href="#preface">Preface</a></dt><dt>1. <a href="#introduction">Introduction</a></dt><dd><dl><dt>1.1. <a href="#introduction-overview">Overview</a></dt><dt>1.2. <a href="#overview-usagescenarios">Usage scenarios</a></dt></dl></dd><dt>2. <a href="#new-in-2">What's new in Spring 2.0 and 2.5?</a></dt><dd><dl><dt>2.1. <a href="#new-in-2-intro">Introduction</a></dt><dt>2.2. <a href="#new-in-2-ioc">The Inversion of Control (IoC) container</a></dt><dd><dl><dt>2.2.1. <a href="#new-in-2-ioc-scopes">New bean scopes</a></dt><dt>2.2.2. <a href="#new-in-2-ioc-configuration">Easier XML configuration</a></dt><dt>2.2.3. <a href="#new-in-2-ioc-custom-configuration">Extensible XML authoring</a></dt><dt>2.2.4. <a href="#new-in-2-ioc-annotations">Annotation-driven configuration</a></dt><dt>2.2.5. <a href="#new-in-2-ioc-component-scanning">Autodetecting components in the classpath</a></dt></dl></dd><dt>2.3. <a href="#new-in-2-aop">Aspect Oriented Programming (AOP)</a></dt><dd><dl><dt>2.3.1. <a href="#new-in-2-aop-configuration">Easier AOP XML configuration</a></dt><dt>2.3.2. <a href="#new-in-2-aop-aspectj">Support for @AspectJ aspects</a></dt><dt>2.3.3. <a href="#new-in-2-aop-bean-pointcuts">Support for bean name pointcut element</a></dt><dt>2.3.4. <a href="#new-in-2-aop-load-time-weaving">Support for AspectJ load-time weaving</a></dt></dl></dd><dt>2.4. <a href="#new-in-2-middle-tier">The Middle Tier</a></dt><dd><dl><dt>2.4.1. <a href="#new-in-2-middle-tier-transaction-configuration">Easier configuration of declarative transactions in XML</a></dt><dt>2.4.2. <a href="#new-in-2-middle-tier-websphere">Full WebSphere transaction management support</a></dt><dt>2.4.3. <a href="#new-in-2-middle-tier-jpa">JPA</a></dt><dt>2.4.4. <a href="#new-in-2-middle-tier-async-jms">Asynchronous JMS</a></dt><dt>2.4.5. <a href="#new-in-2-middle-tier-jdbc">JDBC</a></dt></dl></dd><dt>2.5. <a href="#new-in-2-web">The Web Tier</a></dt><dd><dl><dt>2.5.1. <a href="#new-in-2-web-convention">Sensible defaulting in Spring MVC</a></dt><dt>2.5.2. <a href="#new-in-2-web-portlet">Portlet framework</a></dt><dt>2.5.3. <a href="#new-in-2-web-annotations">Annotation-based controllers</a></dt><dt>2.5.4. <a href="#new-in-2-web-form-tags">A form tag library for Spring MVC</a></dt><dt>2.5.5. <a href="#new-in-2-web-tiles2">Tiles 2 support</a></dt><dt>2.5.6. <a href="#new-in-2-web-jsf12">JSF 1.2 support</a></dt><dt>2.5.7. <a href="#new-in-2-web-jaxws">JAX-WS support</a></dt></dl></dd><dt>2.6. <a href="#new-in-2-other">Everything else</a></dt><dd><dl><dt>2.6.1. <a href="#new-in-2-other-dynamic-language-support">Dynamic language support</a></dt><dt>2.6.2. <a href="#new-in-2-other-testing">Enhanced testing support</a></dt><dt>2.6.3. <a href="#new-in-2-other-jmx">JMX support</a></dt><dt>2.6.4. <a href="#new-in-2-other-jca">Deploying a Spring application context as JCA adapter</a></dt><dt>2.6.5. <a href="#new-in-2-other-taskexecutor">Task scheduling</a></dt><dt>2.6.6. <a href="#new-in-2-other-java5">Java 5 (Tiger) support</a></dt></dl></dd><dt>2.7. <a href="#new-in-2-migrating">Migrating to Spring 2.5</a></dt><dd><dl><dt>2.7.1. <a href="#new-in-2-migrating-changes">Changes</a></dt><dd><dl><dt>2.7.1.1. <a href="#new-in-2-migrating-jdk">Supported JDK versions</a></dt><dt>2.7.1.2. <a href="#new-in-2-migrating-packaging">Jar packaging in Spring 2.5</a></dt><dt>2.7.1.3. <a href="#new-in-2-migrating-xml-configuration">XML configuration</a></dt><dt>2.7.1.4. <a href="#new-in-2-migrating-deprecated">Deprecated classes and methods</a></dt><dt>2.7.1.5. <a href="#new-in-2-migrating-ojb">Apache OJB</a></dt><dt>2.7.1.6. <a href="#new-in-2-migrating-ibatis">iBATIS</a></dt><dt>2.7.1.7. <a href="#new-in-2-migrating-hibernate">Hibernate</a></dt><dt>2.7.1.8. <a href="#new-in-2-migrating-jdo">JDO</a></dt><dt>2.7.1.9. <a href="#new-in-2-migrating-UrlFilenameViewController">UrlFilenameViewController</a></dt></dl></dd></dl></dd><dt>2.8. <a href="#new-in-2-other-applications">Updated sample applications</a></dt><dt>2.9. <a href="#new-in-2-other-documentation">Improved documentation</a></dt></dl></dd><dt>I. <a href="#spring-core">Core Technologies</a></dt><dd><dl><dt>3. <a href="#beans">The IoC container</a></dt><dd><dl><dt>3.1. <a href="#beans-introduction">Introduction</a></dt><dt>3.2. <a href="#beans-basics">Basics - containers and beans</a></dt><dd><dl><dt>3.2.1. <a href="#beans-factory">The container</a></dt><dd><dl><dt>3.2.1.1. <a href="#beans-factory-metadata">Configuration metadata</a></dt></dl></dd><dt>3.2.2. <a href="#beans-factory-instantiation">Instantiating a container</a></dt><dd><dl><dt>3.2.2.1. <a href="#beans-factory-xml-import">Composing XML-based configuration metadata</a></dt></dl></dd><dt>3.2.3. <a href="#beans-definition">The beans</a></dt><dd><dl><dt>3.2.3.1. <a href="#beans-beanname">Naming beans</a></dt><dt>3.2.3.2. <a href="#beans-factory-class">Instantiating beans</a></dt></dl></dd><dt>3.2.4. <a href="#beans-factory-client">Using the container</a></dt></dl></dd><dt>3.3. <a href="#beans-dependencies">Dependencies</a></dt><dd><dl><dt>3.3.1. <a href="#beans-factory-collaborators">Injecting dependencies</a></dt><dd><dl><dt>3.3.1.1. <a href="#beans-constructor-injection">Constructor Injection</a></dt><dt>3.3.1.2. <a href="#beans-setter-injection">Setter Injection</a></dt><dt>3.3.1.3. <a href="#beans-some-examples">Some examples</a></dt></dl></dd><dt>3.3.2. <a href="#beans-factory-properties-detailed">Dependencies and configuration in detail</a></dt><dd><dl><dt>3.3.2.1. <a href="#beans-value-element">Straight values (primitives, Strings,
        etc.)</a></dt><dt>3.3.2.2. <a href="#beans-ref-element">References to other beans (collaborators)</a></dt><dt>3.3.2.3. <a href="#beans-inner-beans">Inner beans</a></dt><dt>3.3.2.4. <a href="#beans-collection-elements">Collections</a></dt><dt>3.3.2.5. <a href="#beans-null-element">Nulls</a></dt><dt>3.3.2.6. <a href="#xml-config-shortcuts">Shortcuts and other convenience options for XML-based
        configuration metadata</a></dt><dt>3.3.2.7. <a href="#beans-compound-property-names">Compound property names</a></dt></dl></dd><dt>3.3.3. <a href="#beans-factory-dependson">Using depends-on</a></dt><dt>3.3.4. <a href="#beans-factory-lazy-init">Lazily-instantiated beans</a></dt><dt>3.3.5. <a href="#beans-factory-autowire">Autowiring collaborators</a></dt><dd><dl><dt>3.3.5.1. <a href="#beans-factory-autowire-candidate">Excluding a bean from being available for autowiring</a></dt></dl></dd><dt>3.3.6. <a href="#beans-factory-dependencies">Checking for dependencies</a></dt><dt>3.3.7. <a href="#beans-factory-method-injection">Method Injection</a></dt><dd><dl><dt>3.3.7.1. <a href="#beans-factory-lookup-method-injection">Lookup method injection</a></dt><dt>3.3.7.2. <a href="#beans-factory-arbitrary-method-replacement">Arbitrary method replacement</a></dt></dl></dd></dl></dd><dt>3.4. <a href="#beans-factory-scopes">Bean scopes</a></dt><dd><dl><dt>3.4.1. <a href="#beans-factory-scopes-singleton">The singleton scope</a></dt><dt>3.4.2. <a href="#beans-factory-scopes-prototype">The prototype scope</a></dt><dt>3.4.3. <a href="#beans-factory-scopes-sing-prot-interaction">Singleton beans with prototype-bean dependencies</a></dt><dt>3.4.4. <a href="#beans-factory-scopes-other">The other scopes</a></dt><dd><dl><dt>3.4.4.1. <a href="#beans-factory-scopes-other-web-configuration">Initial web configuration</a></dt><dt>3.4.4.2. <a href="#beans-factory-scopes-request">The request scope</a></dt><dt>3.4.4.3. <a href="#beans-factory-scopes-session">The session scope</a></dt><dt>3.4.4.4. <a href="#beans-factory-scopes-global-session">The global session scope</a></dt><dt>3.4.4.5. <a href="#beans-factory-scopes-other-injection">Scoped beans as dependencies</a></dt></dl></dd><dt>3.4.5. <a href="#beans-factory-scopes-custom">Custom scopes</a></dt><dd><dl><dt>3.4.5.1. <a href="#beans-factory-scopes-custom-creating">Creating your own custom scope</a></dt><dt>3.4.5.2. <a href="#beans-factory-scopes-custom-using">Using a custom scope</a></dt></dl></dd></dl></dd><dt>3.5. <a href="#beans-factory-nature">Customizing the nature of a bean</a></dt><dd><dl><dt>3.5.1. <a href="#beans-factory-lifecycle">Lifecycle callbacks</a></dt><dd><dl><dt>3.5.1.1. <a href="#beans-factory-lifecycle-initializingbean">Initialization callbacks</a></dt><dt>3.5.1.2. <a href="#beans-factory-lifecycle-disposablebean">Destruction callbacks</a></dt><dt>3.5.1.3. <a href="#beans-factory-lifecycle-default-init-destroy-methods">Default initialization &amp; destroy methods</a></dt><dt>3.5.1.4. <a href="#beans-factory-lifecycle-combined-effects">Combining lifecycle mechanisms</a></dt><dt>3.5.1.5. <a href="#beans-factory-shutdown">Shutting down the Spring IoC container gracefully in non-web
        applications</a></dt></dl></dd><dt>3.5.2. <a href="#beans-factory-aware">Knowing who you are</a></dt><dd><dl><dt>3.5.2.1. <a href="#beans-factory-aware-beanfactoryaware">BeanFactoryAware</a></dt><dt>3.5.2.2. <a href="#beans-factory-aware-beannameaware">BeanNameAware</a></dt></dl></dd></dl></dd><dt>3.6. <a href="#beans-child-bean-definitions">Bean definition inheritance</a></dt><dt>3.7. <a href="#beans-factory-extension">Container extension points</a></dt><dd><dl><dt>3.7.1. <a href="#beans-factory-extension-bpp">Customizing beans using
      BeanPostProcessors</a></dt><dd><dl><dt>3.7.1.1. <a href="#beans-factory-extension-bpp-examples-hw">Example: Hello World,
        BeanPostProcessor-style</a></dt><dt>3.7.1.2. <a href="#beans-factory-extension-bpp-examples-rabpp">Example: The
        RequiredAnnotationBeanPostProcessor</a></dt></dl></dd><dt>3.7.2. <a href="#beans-factory-extension-factory-postprocessors">Customizing configuration metadata with
      BeanFactoryPostProcessors</a></dt><dd><dl><dt>3.7.2.1. <a href="#beans-factory-placeholderconfigurer">Example: the
        PropertyPlaceholderConfigurer</a></dt><dt>3.7.2.2. <a href="#beans-factory-overrideconfigurer">Example: the
        PropertyOverrideConfigurer</a></dt></dl></dd><dt>3.7.3. <a href="#beans-factory-extension-factorybean">Customizing instantiation logic using
      FactoryBeans</a></dt></dl></dd><dt>3.8. <a href="#context-introduction">The ApplicationContext</a></dt><dd><dl><dt>3.8.1. <a href="#context-introduction-ctx-vs-beanfactory">BeanFactory or
      ApplicationContext?</a></dt><dt>3.8.2. <a href="#context-functionality-messagesource">Internationalization using
      MessageSources</a></dt><dt>3.8.3. <a href="#context-functionality-events">Events</a></dt><dt>3.8.4. <a href="#context-functionality-resources">Convenient access to low-level resources</a></dt><dt>3.8.5. <a href="#context-create">Convenient ApplicationContext
      instantiation for web applications</a></dt></dl></dd><dt>3.9. <a href="#beans-glue-code-and-singletons">Glue code and the evil singleton</a></dt><dt>3.10. <a href="#beans-rar-deployment">Deploying a Spring ApplicationContext as a J2EE RAR file</a></dt><dt>3.11. <a href="#beans-annotation-config">Annotation-based configuration</a></dt><dd><dl><dt>3.11.1. <a href="#beans-required-annotation">@Required</a></dt><dt>3.11.2. <a href="#beans-autowired-annotation">@Autowired</a></dt><dt>3.11.3. <a href="#beans-autowired-annotation-qualifiers">Fine-tuning annotation-based autowiring with qualifiers</a></dt><dt>3.11.4. <a href="#beans-custom-autowire-configurer">CustomAutowireConfigurer</a></dt><dt>3.11.5. <a href="#beans-resource-annotation">@Resource</a></dt><dt>3.11.6. <a href="#beans-postconstruct-and-predestroy-annotations">@PostConstruct and
      @PreDestroy</a></dt></dl></dd><dt>3.12. <a href="#beans-classpath-scanning">Classpath scanning for managed components</a></dt><dd><dl><dt>3.12.1. <a href="#beans-stereotype-annotations">@Component and further stereotype
      annotations</a></dt><dt>3.12.2. <a href="#beans-scanning-autodetection">Auto-detecting components</a></dt><dt>3.12.3. <a href="#beans-scanning-filters">Using filters to customize scanning</a></dt><dt>3.12.4. <a href="#beans-scanning-name-generator">Naming autodetected components</a></dt><dt>3.12.5. <a href="#beans-scanning-scope-resolver">Providing a scope for autodetected components</a></dt><dt>3.12.6. <a href="#beans-scanning-qualifiers">Providing qualifier metadata with annotations</a></dt></dl></dd><dt>3.13. <a href="#context-load-time-weaver">Registering a LoadTimeWeaver</a></dt></dl></dd><dt>4. <a href="#resources">Resources</a></dt><dd><dl><dt>4.1. <a href="#resources-introduction">Introduction</a></dt><dt>4.2. <a href="#resources-resource">The Resource interface</a></dt><dt>4.3. <a href="#resources-implementations">Built-in Resource implementations</a></dt><dd><dl><dt>4.3.1. <a href="#resources-implementations-urlresource">UrlResource</a></dt><dt>4.3.2. <a href="#resources-implementations-classpathresource">ClassPathResource</a></dt><dt>4.3.3. <a href="#resources-implementations-filesystemresource">FileSystemResource</a></dt><dt>4.3.4. <a href="#resources-implementations-servletcontextresource">ServletContextResource</a></dt><dt>4.3.5. <a href="#resources-implementations-inputstreamresource">InputStreamResource</a></dt><dt>4.3.6. <a href="#resources-implementations-bytearrayresource">ByteArrayResource</a></dt></dl></dd><dt>4.4. <a href="#resources-resourceloader">The ResourceLoader</a></dt><dt>4.5. <a href="#resources-resourceloaderaware">The ResourceLoaderAware interface</a></dt><dt>4.6. <a href="#resources-as-dependencies">Resources as dependencies</a></dt><dt>4.7. <a href="#resources-app-ctx">Application contexts and Resource paths</a></dt><dd><dl><dt>4.7.1. <a href="#resources-app-ctx-construction">Constructing application contexts</a></dt><dd><dl><dt>4.7.1.1. <a href="#resources-app-ctx-classpathxml">Constructing ClassPathXmlApplicationContext instances - shortcuts</a></dt></dl></dd><dt>4.7.2. <a href="#resources-app-ctx-wildcards-in-resource-paths">Wildcards in application context constructor resource paths</a></dt><dd><dl><dt>4.7.2.1. <a href="#resources-app-ctx-ant-patterns-in-paths">Ant-style Patterns</a></dt><dt>4.7.2.2. <a href="#resources-classpath-wildcards">The classpath*: prefix</a></dt><dt>4.7.2.3. <a href="#resources-wildcards-in-path-other-stuff">Other notes relating to wildcards</a></dt></dl></dd><dt>4.7.3. <a href="#resources-filesystemresource-caveats">FileSystemResource caveats</a></dt></dl></dd></dl></dd><dt>5. <a href="#validation">Validation, Data-binding, the BeanWrapper, and PropertyEditors</a></dt><dd><dl><dt>5.1. <a href="#validation-introduction">Introduction</a></dt><dt>5.2. <a href="#validator">Validation using Spring's Validator interface</a></dt><dt>5.3. <a href="#validation-conversion">Resolving codes to error messages</a></dt><dt>5.4. <a href="#beans-beans">Bean manipulation and the BeanWrapper</a></dt><dd><dl><dt>5.4.1. <a href="#beans-beans-conventions">Setting and getting basic and nested properties</a></dt><dt>5.4.2. <a href="#beans-beans-conversion">Built-in PropertyEditor implementations</a></dt><dd><dl><dt>5.4.2.1. <a href="#beans-beans-conversion-customeditor-registration">Registering additional custom PropertyEditors</a></dt></dl></dd></dl></dd></dl></dd><dt>6. <a href="#aop">Aspect Oriented Programming with Spring</a></dt><dd><dl><dt>6.1. <a href="#aop-introduction">Introduction</a></dt><dd><dl><dt>6.1.1. <a href="#aop-introduction-defn">AOP concepts</a></dt><dt>6.1.2. <a href="#aop-introduction-spring-defn">Spring AOP capabilities and goals</a></dt><dt>6.1.3. <a href="#aop-introduction-proxies">AOP Proxies</a></dt></dl></dd><dt>6.2. <a href="#aop-ataspectj">@AspectJ support</a></dt><dd><dl><dt>6.2.1. <a href="#aop-aspectj-support">Enabling @AspectJ Support</a></dt><dt>6.2.2. <a href="#aop-at-aspectj">Declaring an aspect</a></dt><dt>6.2.3. <a href="#aop-pointcuts">Declaring a pointcut</a></dt><dd><dl><dt>6.2.3.1. <a href="#aop-pointcuts-designators">Supported Pointcut Designators</a></dt><dt>6.2.3.2. <a href="#aop-pointcuts-combining">Combining pointcut expressions</a></dt><dt>6.2.3.3. <a href="#aop-common-pointcuts">Sharing common pointcut definitions</a></dt><dt>6.2.3.4. <a href="#aop-pointcuts-examples">Examples</a></dt></dl></dd><dt>6.2.4. <a href="#aop-advice">Declaring advice</a></dt><dd><dl><dt>6.2.4.1. <a href="#aop-advice-before">Before advice</a></dt><dt>6.2.4.2. <a href="#aop-advice-after-returning">After returning advice</a></dt><dt>6.2.4.3. <a href="#aop-advice-after-throwing">After throwing advice</a></dt><dt>6.2.4.4. <a href="#aop-advice-after-finally">After (finally) advice</a></dt><dt>6.2.4.5. <a href="#aop-ataspectj-around-advice">Around advice</a></dt><dt>6.2.4.6. <a href="#aop-ataspectj-advice-params">Advice parameters</a></dt><dt>6.2.4.7. <a href="#aop-ataspectj-advice-ordering">Advice ordering</a></dt></dl></dd><dt>6.2.5. <a href="#aop-introductions">Introductions</a></dt><dt>6.2.6. <a href="#aop-instantiation-models">Aspect instantiation models</a></dt><dt>6.2.7. <a href="#aop-ataspectj-example">Example</a></dt></dl></dd><dt>6.3. <a href="#aop-schema">Schema-based AOP support</a></dt><dd><dl><dt>6.3.1. <a href="#aop-schema-declaring-an-aspect">Declaring an aspect</a></dt><dt>6.3.2. <a href="#aop-schema-pointcuts">Declaring a pointcut</a></dt><dt>6.3.3. <a href="#aop-schema-advice">Declaring advice</a></dt><dd><dl><dt>6.3.3.1. <a href="#aop-schema-advice-before">Before advice</a></dt><dt>6.3.3.2. <a href="#aop-schema-advice-after-returning">After returning advice</a></dt><dt>6.3.3.3. <a href="#aop-schema-advice-after-throwing">After throwing advice</a></dt><dt>6.3.3.4. <a href="#aop-schema-advice-after-finally">After (finally) advice</a></dt><dt>6.3.3.5. <a href="#aop-schema-advice-around">Around advice</a></dt><dt>6.3.3.6. <a href="#aop-schema-params">Advice parameters</a></dt><dt>6.3.3.7. <a href="#aop-ordering">Advice ordering</a></dt></dl></dd><dt>6.3.4. <a href="#aop-schema-introductions">Introductions</a></dt><dt>6.3.5. <a href="#aop-schema-instatiation-models">Aspect instantiation models</a></dt><dt>6.3.6. <a href="#aop-schema-advisors">Advisors</a></dt><dt>6.3.7. <a href="#aop-schema-example">Example</a></dt></dl></dd><dt>6.4. <a href="#aop-choosing">Choosing which AOP declaration style to use</a></dt><dd><dl><dt>6.4.1. <a href="#aop-spring-or-aspectj">Spring AOP or full AspectJ?</a></dt><dt>6.4.2. <a href="#aop-ataspectj-or-xml">@AspectJ or XML for Spring AOP?</a></dt></dl></dd><dt>6.5. <a href="#aop-mixing-styles">Mixing aspect types</a></dt><dt>6.6. <a href="#aop-proxying">Proxying mechanisms</a></dt><dd><dl><dt>6.6.1. <a href="#aop-understanding-aop-proxies">Understanding AOP proxies</a></dt></dl></dd><dt>6.7. <a href="#aop-aspectj-programmatic">Programmatic creation of @AspectJ Proxies</a></dt><dt>6.8. <a href="#aop-using-aspectj">Using AspectJ with Spring applications</a></dt><dd><dl><dt>6.8.1. <a href="#aop-atconfigurable">Using AspectJ to dependency inject domain objects with
      Spring</a></dt><dd><dl><dt>6.8.1.1. <a href="#aop-configurable-testing">Unit testing @Configurable
        objects</a></dt><dt>6.8.1.2. <a href="#aop-configurable-container">Working with multiple application contexts</a></dt></dl></dd><dt>6.8.2. <a href="#aop-ajlib-other">Other Spring aspects for AspectJ</a></dt><dt>6.8.3. <a href="#aop-aj-configure">Configuring AspectJ aspects using Spring IoC</a></dt><dt>6.8.4. <a href="#aop-aj-ltw">Load-time weaving with AspectJ in the Spring Framework</a></dt><dd><dl><dt>6.8.4.1. <a href="#aop-aj-ltw-first-example">A first example</a></dt><dt>6.8.4.2. <a href="#aop-aj-ltw-the-aspects">Aspects</a></dt><dt>6.8.4.3. <a href="#aop-aj-ltw-aop_dot_xml">'META-INF/aop.xml'</a></dt><dt>6.8.4.4. <a href="#aop-aj-ltw-libraries">Required libraries (JARS)</a></dt><dt>6.8.4.5. <a href="#aop-aj-ltw-spring">Spring configuration</a></dt><dt>6.8.4.6. <a href="#aop-aj-ltw-environments">Environment-specific configuration</a></dt></dl></dd></dl></dd><dt>6.9. <a href="#aop-resources">Further Resources</a></dt></dl></dd><dt>7. <a href="#aop-api">Spring AOP APIs</a></dt><dd><dl><dt>7.1. <a href="#aop-api-introduction">Introduction</a></dt><dt>7.2. <a href="#aop-api-pointcuts">Pointcut API in Spring</a></dt><dd><dl><dt>7.2.1. <a href="#aop-api-concepts">Concepts</a></dt><dt>7.2.2. <a href="#aop-api-pointcut-ops">Operations on pointcuts</a></dt><dt>7.2.3. <a href="#aop-api-pointcuts-aspectj">AspectJ expression pointcuts</a></dt><dt>7.2.4. <a href="#aop-api-pointcuts-impls">Convenience pointcut implementations</a></dt><dd><dl><dt>7.2.4.1. <a href="#aop-api-pointcuts-static">Static pointcuts</a></dt><dt>7.2.4.2. <a href="#aop-api-pointcuts-dynamic">Dynamic pointcuts</a></dt></dl></dd><dt>7.2.5. <a href="#aop-api-pointcuts-superclasses">Pointcut superclasses</a></dt><dt>7.2.6. <a href="#aop-api-pointcuts-custom">Custom pointcuts</a></dt></dl></dd><dt>7.3. <a href="#aop-api-advice">Advice API in Spring</a></dt><dd><dl><dt>7.3.1. <a href="#aop-api-advice-lifecycle">Advice lifecycles</a></dt><dt>7.3.2. <a href="#aop-api-advice-types">Advice types in Spring</a></dt><dd><dl><dt>7.3.2.1. <a href="#aop-api-advice-around">Interception around advice</a></dt><dt>7.3.2.2. <a href="#aop-api-advice-before">Before advice</a></dt><dt>7.3.2.3. <a href="#aop-api-advice-throws">Throws advice</a></dt><dt>7.3.2.4. <a href="#aop-api-advice-after-returning">After Returning advice</a></dt><dt>7.3.2.5. <a href="#aop-api-advice-introduction">Introduction advice</a></dt></dl></dd></dl></dd><dt>7.4. <a href="#aop-api-advisor">Advisor API in Spring</a></dt><dt>7.5. <a href="#aop-pfb">Using the ProxyFactoryBean to create AOP proxies</a></dt><dd><dl><dt>7.5.1. <a href="#aop-pfb-1">Basics</a></dt><dt>7.5.2. <a href="#aop-pfb-2">JavaBean properties</a></dt><dt>7.5.3. <a href="#aop-pfb-proxy-types">JDK- and CGLIB-based proxies</a></dt><dt>7.5.4. <a href="#aop-api-proxying-intf">Proxying interfaces</a></dt><dt>7.5.5. <a href="#aop-api-proxying-class">Proxying classes</a></dt><dt>7.5.6. <a href="#aop-global-advisors">Using 'global' advisors</a></dt></dl></dd><dt>7.6. <a href="#aop-concise-proxy">Concise proxy definitions</a></dt><dt>7.7. <a href="#aop-prog">Creating AOP proxies programmatically with the ProxyFactory</a></dt><dt>7.8. <a href="#aop-api-advised">Manipulating advised objects</a></dt><dt>7.9. <a href="#aop-autoproxy">Using the "autoproxy" facility</a></dt><dd><dl><dt>7.9.1. <a href="#aop-autoproxy-choices">Autoproxy bean definitions</a></dt><dd><dl><dt>7.9.1.1. <a href="#aop-api-autoproxy">BeanNameAutoProxyCreator</a></dt><dt>7.9.1.2. <a href="#aop-api-autoproxy-default">DefaultAdvisorAutoProxyCreator</a></dt><dt>7.9.1.3. <a href="#aop-api-autoproxy-abstract">AbstractAdvisorAutoProxyCreator</a></dt></dl></dd><dt>7.9.2. <a href="#aop-autoproxy-metadata">Using metadata-driven auto-proxying</a></dt></dl></dd><dt>7.10. <a href="#aop-targetsource">Using TargetSources</a></dt><dd><dl><dt>7.10.1. <a href="#aop-ts-swap">Hot swappable target sources</a></dt><dt>7.10.2. <a href="#aop-ts-pool">Pooling target sources</a></dt><dt>7.10.3. <a href="#aop-ts-prototype">Prototype target sources</a></dt><dt>7.10.4. <a href="#aop-ts-threadlocal">ThreadLocal target sources</a></dt></dl></dd><dt>7.11. <a href="#aop-extensibility">Defining new Advice types</a></dt><dt>7.12. <a href="#aop-api-resources">Further resources</a></dt></dl></dd><dt>8. <a href="#testing">Testing</a></dt><dd><dl><dt>8.1. <a href="#testing-introduction">Introduction</a></dt><dt>8.2. <a href="#unit-testing">Unit testing</a></dt><dd><dl><dt>8.2.1. <a href="#mock-objects">Mock objects</a></dt><dd><dl><dt>8.2.1.1. <a href="#mock-objects-jndi">JNDI</a></dt><dt>8.2.1.2. <a href="#mock-objects-servlet">Servlet API</a></dt><dt>8.2.1.3. <a href="#mock-objects-portlet">Portlet API</a></dt></dl></dd><dt>8.2.2. <a href="#unit-testing-support-classes">Unit testing support classes</a></dt><dd><dl><dt>8.2.2.1. <a href="#unit-testing-utilities">General utilities</a></dt><dt>8.2.2.2. <a href="#unit-testing-spring-mvc">Spring MVC</a></dt></dl></dd></dl></dd><dt>8.3. <a href="#integration-testing">Integration testing</a></dt><dd><dl><dt>8.3.1. <a href="#integration-testing-overview">Overview</a></dt><dt>8.3.2. <a href="#integration-testing-which-framework">Which support framework to use</a></dt><dt>8.3.3. <a href="#integration-testing-common-goals">Common goals</a></dt><dd><dl><dt>8.3.3.1. <a href="#testing-ctx-management">Context management and caching</a></dt><dt>8.3.3.2. <a href="#testing-fixture-di">Dependency Injection of test fixtures</a></dt><dt>8.3.3.3. <a href="#testing-tx">Transaction management</a></dt><dt>8.3.3.4. <a href="#testing-support-classes">Integration testing support classes</a></dt></dl></dd><dt>8.3.4. <a href="#integration-testing-support-jdbc">JDBC testing support</a></dt><dt>8.3.5. <a href="#integration-testing-common-annotations">Common annotations</a></dt><dt>8.3.6. <a href="#junit38-legacy-support">JUnit 3.8 legacy support</a></dt><dd><dl><dt>8.3.6.1. <a href="#junit38-legacy-ctx-management">Context management and caching</a></dt><dt>8.3.6.2. <a href="#junit38-legacy-fixture-di">Dependency Injection of test fixtures</a></dt><dt>8.3.6.3. <a href="#junit38-legacy-tx">Transaction management</a></dt><dt>8.3.6.4. <a href="#junit38-legacy-support-classes">JUnit 3.8 legacy support classes</a></dt><dt>8.3.6.5. <a href="#junit38-legacy-java5-support">Java 5+ specific support</a></dt></dl></dd><dt>8.3.7. <a href="#testcontext-framework">Spring TestContext Framework</a></dt><dd><dl><dt>8.3.7.1. <a href="#testcontext-key-abstractions">Key abstractions</a></dt><dt>8.3.7.2. <a href="#testcontext-ctx-management">Context management and caching</a></dt><dt>8.3.7.3. <a href="#testcontext-fixture-di">Dependency Injection of test fixtures</a></dt><dt>8.3.7.4. <a href="#testcontext-tx">Transaction management</a></dt><dt>8.3.7.5. <a href="#testcontext-support-classes">TestContext support classes</a></dt><dt>8.3.7.6. <a href="#testcontext-annotations">TestContext framework annotation support</a></dt></dl></dd><dt>8.3.8. <a href="#testing-examples-petclinic">PetClinic example</a></dt></dl></dd><dt>8.4. <a href="#testing-resources">Further Resources</a></dt></dl></dd></dl></dd><dt>II. <a href="#spring-middle-tier">Middle Tier Data Access</a></dt><dd><dl><dt>9. <a href="#transaction">Transaction management</a></dt><dd><dl><dt>9.1. <a href="#transaction-intro">Introduction</a></dt><dt>9.2. <a href="#transaction-motivation">Motivations</a></dt><dt>9.3. <a href="#transaction-strategies">Key abstractions</a></dt><dt>9.4. <a href="#tx-resource-synchronization">Resource synchronization with transactions</a></dt><dd><dl><dt>9.4.1. <a href="#tx-resource-synchronization-high">High-level approach</a></dt><dt>9.4.2. <a href="#tx-resource-synchronization-low">Low-level approach</a></dt><dt>9.4.3. <a href="#tx-resource-synchronization-tadsp">TransactionAwareDataSourceProxy</a></dt></dl></dd><dt>9.5. <a href="#transaction-declarative">Declarative transaction management</a></dt><dd><dl><dt>9.5.1. <a href="#tx-decl-explained">Understanding the Spring Framework's declarative transaction implementation</a></dt><dt>9.5.2. <a href="#transaction-declarative-first-example">A first example</a></dt><dt>9.5.3. <a href="#transaction-declarative-rolling-back">Rolling back</a></dt><dt>9.5.4. <a href="#transaction-declarative-diff-tx">Configuring different transactional semantics for different beans</a></dt><dt>9.5.5. <a href="#transaction-declarative-txadvice-settings">&lt;tx:advice/&gt; settings</a></dt><dt>9.5.6. <a href="#transaction-declarative-annotations">Using @Transactional</a></dt><dd><dl><dt>9.5.6.1. <a href="#transaction-declarative-attransactional-settings">@Transactional settings</a></dt></dl></dd><dt>9.5.7. <a href="#tx-propagation">Transaction propagation</a></dt><dd><dl><dt>9.5.7.1. <a href="#tx-propagation-required">Required</a></dt><dt>9.5.7.2. <a href="#tx-propagation-requires_new">RequiresNew</a></dt><dt>9.5.7.3. <a href="#tx-propagation-nested">Nested</a></dt></dl></dd><dt>9.5.8. <a href="#transaction-declarative-applying-more-than-just-tx-advice">Advising transactional operations</a></dt><dt>9.5.9. <a href="#transaction-declarative-aspectj">Using @Transactional with AspectJ</a></dt></dl></dd><dt>9.6. <a href="#transaction-programmatic">Programmatic transaction management</a></dt><dd><dl><dt>9.6.1. <a href="#tx-prog-template">Using the TransactionTemplate</a></dt><dd><dl><dt>9.6.1.1. <a href="#tx-prog-template-settings">Specifying transaction settings</a></dt></dl></dd><dt>9.6.2. <a href="#transaction-programmatic-ptm">Using the PlatformTransactionManager</a></dt></dl></dd><dt>9.7. <a href="#tx-decl-vs-prog">Choosing between programmatic and declarative transaction management</a></dt><dt>9.8. <a href="#transaction-application-server-integration">Application server-specific integration</a></dt><dd><dl><dt>9.8.1. <a href="#transaction-application-server-integration-websphere">IBM WebSphere</a></dt><dt>9.8.2. <a href="#transaction-application-server-integration-weblogic">BEA WebLogic</a></dt><dt>9.8.3. <a href="#transaction-application-server-integration-oc4j">Oracle OC4J</a></dt></dl></dd><dt>9.9. <a href="#transaction-solutions-to-common-problems">Solutions to common problems</a></dt><dd><dl><dt>9.9.1. <a href="#transaction-solutions-to-common-problems-wrong-ptm">Use of the wrong transaction manager for a specific DataSource</a></dt></dl></dd><dt>9.10. <a href="#transaction-resources">Further Resources</a></dt></dl></dd><dt>10. <a href="#dao">DAO support</a></dt><dd><dl><dt>10.1. <a href="#dao-introduction">Introduction</a></dt><dt>10.2. <a href="#dao-exceptions">Consistent exception hierarchy</a></dt><dt>10.3. <a href="#dao-abstract-superclasses">Consistent abstract classes for DAO support</a></dt></dl></dd><dt>11. <a href="#jdbc">Data access using JDBC</a></dt><dd><dl><dt>11.1. <a href="#jdbc-introduction">Introduction</a></dt><dd><dl><dt>11.1.1. <a href="#jdbc-choose-style">Choosing a style</a></dt><dt>11.1.2. <a href="#jdbc-packages">The package hierarchy</a></dt></dl></dd><dt>11.2. <a href="#jdbc-core">Using the JDBC Core classes to control basic JDBC processing and
    error handling</a></dt><dd><dl><dt>11.2.1. <a href="#jdbc-JdbcTemplate">JdbcTemplate</a></dt><dd><dl><dt>11.2.1.1. <a href="#jdbc-JdbcTemplate-examples">Examples</a></dt><dt>11.2.1.2. <a href="#jdbc-JdbcTemplate-idioms">JdbcTemplate idioms (best
        practices)</a></dt></dl></dd><dt>11.2.2. <a href="#jdbc-NamedParameterJdbcTemplate">NamedParameterJdbcTemplate</a></dt><dt>11.2.3. <a href="#jdbc-SimpleJdbcTemplate">SimpleJdbcTemplate</a></dt><dt>11.2.4. <a href="#jdbc-datasource">DataSource</a></dt><dt>11.2.5. <a href="#jdbc-SQLExceptionTranslator">SQLExceptionTranslator</a></dt><dt>11.2.6. <a href="#jdbc-statements-executing">Executing statements</a></dt><dt>11.2.7. <a href="#jdbc-statements-querying">Running Queries</a></dt><dt>11.2.8. <a href="#jdbc-updates">Updating the database</a></dt><dt>11.2.9. <a href="#jdbc-auto-genereted-keys">Retrieving auto-generated keys</a></dt></dl></dd><dt>11.3. <a href="#jdbc-connections">Controlling database connections</a></dt><dd><dl><dt>11.3.1. <a href="#jdbc-DataSourceUtils">DataSourceUtils</a></dt><dt>11.3.2. <a href="#jdbc-SmartDataSource">SmartDataSource</a></dt><dt>11.3.3. <a href="#jdbc-AbstractDataSource">AbstractDataSource</a></dt><dt>11.3.4. <a href="#jdbc-SingleConnectionDataSource">SingleConnectionDataSource</a></dt><dt>11.3.5. <a href="#jdbc-DriverManagerDataSource">DriverManagerDataSource</a></dt><dt>11.3.6. <a href="#jdbc-TransactionAwareDataSourceProxy">TransactionAwareDataSourceProxy</a></dt><dt>11.3.7. <a href="#jdbc-DataSourceTransactionManager">DataSourceTransactionManager</a></dt><dt>11.3.8. <a href="#jdbc-NativeJdbcExtractor">NativeJdbcExtractor</a></dt></dl></dd><dt>11.4. <a href="#jdbc-advanced-jdbc">JDBC batch operations</a></dt><dd><dl><dt>11.4.1. <a href="#jdbc-advanced-classic">Batch operations with the JdbcTemplate</a></dt><dt>11.4.2. <a href="#jdbc-advanced-simple">Batch operations with the SimpleJdbcTemplate</a></dt></dl></dd><dt>11.5. <a href="#jdbc-simple-jdbc">Simplifying JDBC operations with the SimpleJdbc classes</a></dt><dd><dl><dt>11.5.1. <a href="#jdbc-simple-jdbc-insert-1">Inserting data using SimpleJdbcInsert</a></dt><dt>11.5.2. <a href="#jdbc-simple-jdbc-insert-2">Retrieving auto-generated keys using SimpleJdbcInsert</a></dt><dt>11.5.3. <a href="#jdbc-simple-jdbc-insert-3">Specifying the columns to use for a SimpleJdbcInsert</a></dt><dt>11.5.4. <a href="#jdbc-simple-jdbc-parameters">Using SqlParameterSource to provide parameter values</a></dt><dt>11.5.5. <a href="#jdbc-simple-jdbc-call-1">Calling a stored procedure using SimpleJdbcCall</a></dt><dt>11.5.6. <a href="#jdbc-simple-jdbc-call-2">Declaring parameters to use for a SimpleJdbcCall</a></dt><dt>11.5.7. <a href="#jdbc-params">How to define SqlParameters</a></dt><dt>11.5.8. <a href="#jdbc-simple-jdbc-call-3">Calling a stored function using SimpleJdbcCall</a></dt><dt>11.5.9. <a href="#jdbc-simple-jdbc-call-4">Returning ResultSet/REF Cursor from a SimpleJdbcCall</a></dt></dl></dd><dt>11.6. <a href="#jdbc-object">Modeling JDBC operations as Java objects</a></dt><dd><dl><dt>11.6.1. <a href="#jdbc-SqlQuery">SqlQuery</a></dt><dt>11.6.2. <a href="#jdbc-MappingSqlQuery">MappingSqlQuery</a></dt><dt>11.6.3. <a href="#jdbc-SqlUpdate">SqlUpdate</a></dt><dt>11.6.4. <a href="#jdbc-StoredProcedure">StoredProcedure</a></dt><dt>11.6.5. <a href="#jdbc-SqlFunction">SqlFunction</a></dt></dl></dd><dt>11.7. <a href="#jdbc-parameter-handling">Common issues with parameter and data value handling</a></dt><dd><dl><dt>11.7.1. <a href="#jdbc-type-information">Providing SQL type information for parameters</a></dt><dt>11.7.2. <a href="#jdbc-lob">Handling BLOB and CLOB objects</a></dt><dt>11.7.3. <a href="#jdbc-in-clause">Passing in lists of values for IN clause</a></dt><dt>11.7.4. <a href="#jdbc-complex-types">Handling complex types for stored procedure calls</a></dt></dl></dd></dl></dd><dt>12. <a href="#orm">Object Relational Mapping (ORM) data access</a></dt><dd><dl><dt>12.1. <a href="#orm-introduction">Introduction</a></dt><dt>12.2. <a href="#orm-hibernate">Hibernate</a></dt><dd><dl><dt>12.2.1. <a href="#orm-resource-mngmnt">Resource management</a></dt><dt>12.2.2. <a href="#orm-session-factory-setup">SessionFactory setup in a Spring
      container</a></dt><dt>12.2.3. <a href="#orm-hibernate-template">The HibernateTemplate</a></dt><dt>12.2.4. <a href="#orm-hibernate-daos">Implementing Spring-based DAOs without callbacks</a></dt><dt>12.2.5. <a href="#orm-hibernate-straight">Implementing DAOs based on plain Hibernate 3 API</a></dt><dt>12.2.6. <a href="#orm-hibernate-tx-programmatic">Programmatic transaction demarcation</a></dt><dt>12.2.7. <a href="#orm-hibernate-tx-declarative">Declarative transaction demarcation</a></dt><dt>12.2.8. <a href="#orm-hibernate-tx-strategies">Transaction management strategies</a></dt><dt>12.2.9. <a href="#orm-hibernate-resources">Container resources versus local resources</a></dt><dt>12.2.10. <a href="#orm-hibernate-invalid-jdbc-access-error">Spurious application server warnings when using Hibernate</a></dt></dl></dd><dt>12.3. <a href="#orm-jdo">JDO</a></dt><dd><dl><dt>12.3.1. <a href="#orm-jdo-setup">PersistenceManagerFactory
      setup</a></dt><dt>12.3.2. <a href="#orm-jdo-template">JdoTemplate and
      JdoDaoSupport</a></dt><dt>12.3.3. <a href="#orm-jdo-daos-straight">Implementing DAOs based on the plain JDO API</a></dt><dt>12.3.4. <a href="#orm-jdo-tx">Transaction management</a></dt><dt>12.3.5. <a href="#orm-jdo-dialect">JdoDialect</a></dt></dl></dd><dt>12.4. <a href="#orm-toplink">Oracle TopLink</a></dt><dd><dl><dt>12.4.1. <a href="#orm-toplink-abstraction">SessionFactory abstraction</a></dt><dt>12.4.2. <a href="#orm-toplink-template">TopLinkTemplate and
      TopLinkDaoSupport</a></dt><dt>12.4.3. <a href="#orm-toplink-straight">Implementing DAOs based on plain TopLink API</a></dt><dt>12.4.4. <a href="#orm-toplink-tx">Transaction management</a></dt></dl></dd><dt>12.5. <a href="#orm-ibatis">iBATIS SQL Maps</a></dt><dd><dl><dt>12.5.1. <a href="#orm-ibatis-setup">Setting up the SqlMapClient</a></dt><dt>12.5.2. <a href="#orm-ibatis-template">Using SqlMapClientTemplate and
      SqlMapClientDaoSupport</a></dt><dt>12.5.3. <a href="#orm-ibatis-straight">Implementing DAOs based on plain iBATIS API</a></dt></dl></dd><dt>12.6. <a href="#orm-jpa">JPA</a></dt><dd><dl><dt>12.6.1. <a href="#orm-jpa-setup">JPA setup in a Spring environment</a></dt><dd><dl><dt>12.6.1.1. <a href="#orm-jpa-setup-lemfb">LocalEntityManagerFactoryBean</a></dt><dt>12.6.1.2. <a href="#orm-jpa-setup-jndi">Obtaining an EntityManagerFactory from
        JNDI</a></dt><dt>12.6.1.3. <a href="#orm-jpa-setup-lcemfb">LocalContainerEntityManagerFactoryBean</a></dt><dt>12.6.1.4. <a href="#orm-jpa-multiple-pu">Dealing with multiple persistence units</a></dt></dl></dd><dt>12.6.2. <a href="#orm-jpa-template">JpaTemplate and
      JpaDaoSupport</a></dt><dt>12.6.3. <a href="#orm-jpa-straight">Implementing DAOs based on plain JPA</a></dt><dt>12.6.4. <a href="#orm-jpa-exceptions">Exception Translation</a></dt></dl></dd><dt>12.7. <a href="#orm-jpa-tx">Transaction Management</a></dt><dt>12.8. <a href="#orm-jpa-dialect">JpaDialect</a></dt></dl></dd></dl></dd><dt>III. <a href="#spring-web">The Web</a></dt><dd><dl><dt>13. <a href="#mvc">Web MVC framework</a></dt><dd><dl><dt>13.1. <a href="#mvc-introduction">Introduction</a></dt><dd><dl><dt>13.1.1. <a href="#mvc-introduction-pluggability">Pluggability of other MVC implementations</a></dt><dt>13.1.2. <a href="#mvc-features">Features of Spring Web MVC</a></dt></dl></dd><dt>13.2. <a href="#mvc-servlet">The DispatcherServlet</a></dt><dt>13.3. <a href="#mvc-controller">Controllers</a></dt><dd><dl><dt>13.3.1. <a href="#mvc-controller-abstractcontroller">AbstractController and
      WebContentGenerator</a></dt><dt>13.3.2. <a href="#mvc-controller-othersimplecontrollers">Other simple controllers</a></dt><dt>13.3.3. <a href="#mvc-controller-multiaction">The MultiActionController</a></dt><dt>13.3.4. <a href="#mvc-controller-command">Command controllers</a></dt></dl></dd><dt>13.4. <a href="#mvc-handlermapping">Handler mappings</a></dt><dd><dl><dt>13.4.1. <a href="#mvc-handlermapping-beanname">BeanNameUrlHandlerMapping</a></dt><dt>13.4.2. <a href="#mvc-handlermapping-urlhandlermapping">SimpleUrlHandlerMapping</a></dt><dt>13.4.3. <a href="#mvc-handlermapping-interceptor">Intercepting requests - the
      HandlerInterceptor interface</a></dt></dl></dd><dt>13.5. <a href="#mvc-viewresolver">Views and resolving them</a></dt><dd><dl><dt>13.5.1. <a href="#mvc-viewresolver-resolver">Resolving views - the ViewResolver
      interface</a></dt><dt>13.5.2. <a href="#mvc-viewresolver-chaining">Chaining ViewResolvers</a></dt><dt>13.5.3. <a href="#mvc-redirecting">Redirecting to views</a></dt><dd><dl><dt>13.5.3.1. <a href="#mvc-redirecting-redirect-view">RedirectView</a></dt><dt>13.5.3.2. <a href="#mvc-redirecting-redirect-prefix">The redirect: prefix</a></dt><dt>13.5.3.3. <a href="#mvc-redirecting-forward-prefix">The forward: prefix</a></dt></dl></dd></dl></dd><dt>13.6. <a href="#mvc-localeresolver">Using locales</a></dt><dd><dl><dt>13.6.1. <a href="#mvc-localeresolver-acceptheader">AcceptHeaderLocaleResolver</a></dt><dt>13.6.2. <a href="#mvc-localeresolver-cookie">CookieLocaleResolver</a></dt><dt>13.6.3. <a href="#mvc-localeresolver-session">SessionLocaleResolver</a></dt><dt>13.6.4. <a href="#mvc-localeresolver-interceptor">LocaleChangeInterceptor</a></dt></dl></dd><dt>13.7. <a href="#mvc-themeresolver">Using themes</a></dt><dd><dl><dt>13.7.1. <a href="#mvc-themeresolver-introduction">Introduction</a></dt><dt>13.7.2. <a href="#mvc-themeresolver-defining">Defining themes</a></dt><dt>13.7.3. <a href="#mvc-themeresolver-resolving">Theme resolvers</a></dt></dl></dd><dt>13.8. <a href="#mvc-multipart">Spring's multipart (fileupload) support</a></dt><dd><dl><dt>13.8.1. <a href="#mvc-multipart-introduction">Introduction</a></dt><dt>13.8.2. <a href="#mvc-multipart-resolver">Using the
      MultipartResolver</a></dt><dt>13.8.3. <a href="#mvc-multipart-forms">Handling a file upload in a form</a></dt></dl></dd><dt>13.9. <a href="#mvc-exceptionhandlers">Handling exceptions</a></dt><dt>13.10. <a href="#mvc-coc">Convention over configuration</a></dt><dd><dl><dt>13.10.1. <a href="#mvc-coc-ccnhm">The Controller -
      ControllerClassNameHandlerMapping</a></dt><dt>13.10.2. <a href="#mvc-coc-modelmap">The Model - ModelMap
      (ModelAndView)</a></dt><dt>13.10.3. <a href="#mvc-coc-r2vnt">The View -
      RequestToViewNameTranslator</a></dt></dl></dd><dt>13.11. <a href="#mvc-annotation">Annotation-based controller configuration</a></dt><dd><dl><dt>13.11.1. <a href="#mvc-ann-setup">Setting up the dispatcher for annotation support</a></dt><dt>13.11.2. <a href="#mvc-ann-controller">Defining a controller with
      @Controller</a></dt><dt>13.11.3. <a href="#mvc-ann-requestmapping">Mapping requests with
      @RequestMapping</a></dt><dd><dl><dt>13.11.3.1. <a href="#mvc-ann-requestmapping-advanced">Advanced @RequestMapping options</a></dt></dl></dd><dt>13.11.4. <a href="#mvc-ann-requestmapping-arguments">Supported handler method arguments and return types</a></dt><dt>13.11.5. <a href="#mvc-ann-requestparam">Binding request parameters to method parameters with
      @RequestParam</a></dt><dt>13.11.6. <a href="#mvc-ann-modelattrib">Providing a link to data from the model with
      @ModelAttribute</a></dt><dt>13.11.7. <a href="#mvc-ann-sessionattrib">Specifying attributes to store in a Session with
      @SessionAttributes</a></dt><dt>13.11.8. <a href="#mvc-ann-webdatabinder">Customizing WebDataBinder
      initialization</a></dt><dd><dl><dt>13.11.8.1. <a href="#mvc-ann-initbinder">Customizing data binding with
        @InitBinder</a></dt><dt>13.11.8.2. <a href="#mvc-ann-webbindinginitializer">Configuring a custom
        WebBindingInitializer</a></dt></dl></dd></dl></dd><dt>13.12. <a href="#mvc-resources">Further Resources</a></dt></dl></dd><dt>14. <a href="#view">View technologies</a></dt><dd><dl><dt>14.1. <a href="#view-introduction">Introduction</a></dt><dt>14.2. <a href="#view-jsp">JSP &amp; JSTL</a></dt><dd><dl><dt>14.2.1. <a href="#view-jsp-resolver">View resolvers</a></dt><dt>14.2.2. <a href="#view-jsp-jstl">'Plain-old' JSPs versus JSTL</a></dt><dt>14.2.3. <a href="#view-jsp-tags">Additional tags facilitating development</a></dt><dt>14.2.4. <a href="#view-jsp-formtaglib">Using Spring's form tag library</a></dt><dd><dl><dt>14.2.4.1. <a href="#view-jsp-formtaglib-configuration">Configuration</a></dt><dt>14.2.4.2. <a href="#view-jsp-formtaglib-formtag">The form tag</a></dt><dt>14.2.4.3. <a href="#view-jsp-formtaglib-inputtag">The input tag</a></dt><dt>14.2.4.4. <a href="#view-jsp-formtaglib-checkboxtag">The checkbox tag</a></dt><dt>14.2.4.5. <a href="#view-jsp-formtaglib-checkboxestag">The checkboxes tag</a></dt><dt>14.2.4.6. <a href="#view-jsp-formtaglib-radiobuttontag">The radiobutton tag</a></dt><dt>14.2.4.7. <a href="#view-jsp-formtaglib-radiobuttonstag">The radiobuttons tag</a></dt><dt>14.2.4.8. <a href="#view-jsp-formtaglib-passwordtag">The password tag</a></dt><dt>14.2.4.9. <a href="#view-jsp-formtaglib-selecttag">The select tag</a></dt><dt>14.2.4.10. <a href="#view-jsp-formtaglib-optiontag">The option tag</a></dt><dt>14.2.4.11. <a href="#view-jsp-formtaglib-optionstag">The options tag</a></dt><dt>14.2.4.12. <a href="#view-jsp-formtaglib-textAreatag">The textarea tag</a></dt><dt>14.2.4.13. <a href="#view-jsp-formtaglib-hiddeninputtag">The hidden tag</a></dt><dt>14.2.4.14. <a href="#view-jsp-formtaglib-errorstag">The errors tag</a></dt></dl></dd></dl></dd><dt>14.3. <a href="#view-tiles">Tiles</a></dt><dd><dl><dt>14.3.1. <a href="#view-tiles-dependencies">Dependencies</a></dt><dt>14.3.2. <a href="#view-tiles-integrate">How to integrate Tiles</a></dt><dd><dl><dt>14.3.2.1. <a href="#view-tiles-url">UrlBasedViewResolver</a></dt><dt>14.3.2.2. <a href="#view-tiles-resource">ResourceBundleViewResolver</a></dt><dt>14.3.2.3. <a href="#view-tiles-preparer">SimpleSpringPreparerFactory and SpringBeanPreparerFactory</a></dt></dl></dd></dl></dd><dt>14.4. <a href="#view-velocity">Velocity &amp; FreeMarker</a></dt><dd><dl><dt>14.4.1. <a href="#view-velocity-dependencies">Dependencies</a></dt><dt>14.4.2. <a href="#view-velocity-contextconfig">Context configuration</a></dt><dt>14.4.3. <a href="#view-velocity-createtemplates">Creating templates</a></dt><dt>14.4.4. <a href="#view-velocity-advancedconfig">Advanced configuration</a></dt><dd><dl><dt>14.4.4.1. <a href="#view-velocity-example-velocityproperties">velocity.properties</a></dt><dt>14.4.4.2. <a href="#views-freemarker">FreeMarker</a></dt></dl></dd><dt>14.4.5. <a href="#view-velocity-forms">Bind support and form handling</a></dt><dd><dl><dt>14.4.5.1. <a href="#view-bind-macros">The bind macros</a></dt><dt>14.4.5.2. <a href="#view-simple-binding">Simple binding</a></dt><dt>14.4.5.3. <a href="#views-form-macros">Form input generation macros</a></dt><dt>14.4.5.4. <a href="#views-form-macros-html-escaping">HTML escaping and XHTML compliance</a></dt></dl></dd></dl></dd><dt>14.5. <a href="#view-xslt">XSLT</a></dt><dd><dl><dt>14.5.1. <a href="#view-xslt-firstwords">My First Words</a></dt><dd><dl><dt>14.5.1.1. <a href="#view-xslt-beandefs">Bean definitions</a></dt><dt>14.5.1.2. <a href="#view-xslt-controllercode">Standard MVC controller code</a></dt><dt>14.5.1.3. <a href="#view-xslt-subclassing">Convert the model data to XML</a></dt><dt>14.5.1.4. <a href="#view-xslt-viewdefinitions">Defining the view properties</a></dt><dt>14.5.1.5. <a href="#view-xslt-transforming">Document transformation</a></dt></dl></dd><dt>14.5.2. <a href="#view-xslt-summary">Summary</a></dt></dl></dd><dt>14.6. <a href="#view-document">Document views (PDF/Excel)</a></dt><dd><dl><dt>14.6.1. <a href="#view-document-intro">Introduction</a></dt><dt>14.6.2. <a href="#view-document-config">Configuration and setup</a></dt><dd><dl><dt>14.6.2.1. <a href="#view-document-configviews">Document view definitions</a></dt><dt>14.6.2.2. <a href="#view-document-configcontroller">Controller code</a></dt><dt>14.6.2.3. <a href="#view-document-configsubclasses">Subclassing for Excel views</a></dt><dt>14.6.2.4. <a href="#view-document-configsubclasspdf">Subclassing for PDF views</a></dt></dl></dd></dl></dd><dt>14.7. <a href="#view-jasper-reports">JasperReports</a></dt><dd><dl><dt>14.7.1. <a href="#view-jasper-reports-dependencies">Dependencies</a></dt><dt>14.7.2. <a href="#view-jasper-reports-configuration">Configuration</a></dt><dd><dl><dt>14.7.2.1. <a href="#view-jasper-reports-configuration-resolver">Configuring the ViewResolver</a></dt><dt>14.7.2.2. <a href="#view-jasper-reports-configuration-views">Configuring the Views</a></dt><dt>14.7.2.3. <a href="#view-jasper-reports-configuration-report-files">About Report Files</a></dt><dt>14.7.2.4. <a href="#view-jasper-reports-configuration-multiformat-view">Using JasperReportsMultiFormatView</a></dt></dl></dd><dt>14.7.3. <a href="#view-jasper-reports-model">Populating the ModelAndView</a></dt><dt>14.7.4. <a href="#view-jasper-reports-subreports">Working with Sub-Reports</a></dt><dd><dl><dt>14.7.4.1. <a href="#view-jasper-reports-subreports-config-reports">Configuring Sub-Report Files</a></dt><dt>14.7.4.2. <a href="#view-jasper-reports-subreports-config-datasources">Configuring Sub-Report Data Sources</a></dt></dl></dd><dt>14.7.5. <a href="#view-jasper-reports-exporter-parameters">Configuring Exporter Parameters</a></dt></dl></dd></dl></dd><dt>15. <a href="#web-integration">Integrating with other web frameworks</a></dt><dd><dl><dt>15.1. <a href="#intro">Introduction</a></dt><dt>15.2. <a href="#web-integration-common">Common configuration</a></dt><dt>15.3. <a href="#jsf">JavaServer Faces 1.1 and 1.2</a></dt><dd><dl><dt>15.3.1. <a href="#jsf-delegatingvariableresolver">DelegatingVariableResolver (JSF 1.1/1.2)</a></dt><dt>15.3.2. <a href="#jsf-springbeanvariableresolver">SpringBeanVariableResolver (JSF 1.1/1.2)</a></dt><dt>15.3.3. <a href="#jsf-springbeanfaceselresolver">SpringBeanFacesELResolver (JSF 1.2+)</a></dt><dt>15.3.4. <a href="#jsf-facescontextutils">FacesContextUtils</a></dt></dl></dd><dt>15.4. <a href="#struts">Apache Struts 1.x and 2.x</a></dt><dd><dl><dt>15.4.1. <a href="#struts-contextloaderplugin">ContextLoaderPlugin</a></dt><dd><dl><dt>15.4.1.1. <a href="#struts-delegatingrequestprocessor">DelegatingRequestProcessor</a></dt><dt>15.4.1.2. <a href="#struts-delegatingactionproxy">DelegatingActionProxy</a></dt></dl></dd><dt>15.4.2. <a href="#struts-actionsupport">ActionSupport Classes</a></dt></dl></dd><dt>15.5. <a href="#webwork">WebWork 2.x</a></dt><dt>15.6. <a href="#tapestry">Tapestry 3.x and 4.x</a></dt><dd><dl><dt>15.6.1. <a href="#tapestry-di">Injecting Spring-managed beans</a></dt><dd><dl><dt>15.6.1.1. <a href="#tapestry-pre4-style-di">Dependency Injecting Spring Beans into Tapestry pages</a></dt><dt>15.6.1.2. <a href="#tapestry-componentdefs">Component definition files</a></dt><dt>15.6.1.3. <a href="#tapestry-getters">Adding abstract accessors</a></dt><dt>15.6.1.4. <a href="#tapestry-4-style-di">Dependency Injecting Spring Beans into Tapestry pages - Tapestry 4.x style</a></dt></dl></dd></dl></dd><dt>15.7. <a href="#web-integration-resources">Further Resources</a></dt></dl></dd><dt>16. <a href="#portlet">Portlet MVC Framework</a></dt><dd><dl><dt>16.1. <a href="#portlet-introduction">Introduction</a></dt><dd><dl><dt>16.1.1. <a href="#portlet-introduction-controller">Controllers - The C in MVC</a></dt><dt>16.1.2. <a href="#portlet-introduction-view">Views - The V in MVC</a></dt><dt>16.1.3. <a href="#portlet-introduction-scope">Web-scoped beans</a></dt></dl></dd><dt>16.2. <a href="#portlet-dispatcher">The DispatcherPortlet</a></dt><dt>16.3. <a href="#portlet-viewservlet">The ViewRendererServlet</a></dt><dt>16.4. <a href="#portlet-controller">Controllers</a></dt><dd><dl><dt>16.4.1. <a href="#portlet-controller-abstractcontroller">AbstractController and PortletContentGenerator</a></dt><dt>16.4.2. <a href="#portlet-controller-simple">Other simple controllers</a></dt><dt>16.4.3. <a href="#portlet-controller-command">Command Controllers</a></dt><dt>16.4.4. <a href="#portlet-controller-wrapping">PortletWrappingController</a></dt></dl></dd><dt>16.5. <a href="#portlet-handlermapping">Handler mappings</a></dt><dd><dl><dt>16.5.1. <a href="#portlet-handlermapping-portletmode">PortletModeHandlerMapping</a></dt><dt>16.5.2. <a href="#portlet-handlermapping-parameter">ParameterHandlerMapping</a></dt><dt>16.5.3. <a href="#portlet-handlermapping-portletmodeparameter">PortletModeParameterHandlerMapping</a></dt><dt>16.5.4. <a href="#portlet-handlermapping-interceptor">Adding HandlerInterceptors</a></dt><dt>16.5.5. <a href="#portlet-handlermapping-interceptoradapter">HandlerInterceptorAdapter</a></dt><dt>16.5.6. <a href="#portlet-handlermapping-parameterinterceptor">ParameterMappingInterceptor</a></dt></dl></dd><dt>16.6. <a href="#portlet-viewresolver">Views and resolving them</a></dt><dt>16.7. <a href="#portlet-multipart">Multipart (file upload) support</a></dt><dd><dl><dt>16.7.1. <a href="#portlet-multipart-resolver">Using the PortletMultipartResolver</a></dt><dt>16.7.2. <a href="#portlet-multipart-forms">Handling a file upload in a form</a></dt></dl></dd><dt>16.8. <a href="#portlet-exceptionresolver">Handling exceptions</a></dt><dt>16.9. <a href="#portlet-annotation">Annotation-based controller configuration</a></dt><dd><dl><dt>16.9.1. <a href="#portlet-ann-setup">Setting up the dispatcher for annotation support</a></dt><dt>16.9.2. <a href="#portlet-ann-controller">Defining a controller with
      @Controller</a></dt><dt>16.9.3. <a href="#portlet-ann-requestmapping">Mapping requests with
      @RequestMapping</a></dt><dt>16.9.4. <a href="#portlet-ann-requestmapping-arguments">Supported handler method arguments</a></dt><dt>16.9.5. <a href="#portlet-ann-requestparam">Binding request parameters to method parameters with
      @RequestParam</a></dt><dt>16.9.6. <a href="#portlet-ann-modelattrib">Providing a link to data from the model with
      @ModelAttribute</a></dt><dt>16.9.7. <a href="#portlet-ann-sessionattrib">Specifying attributes to store in a Session with
      @SessionAttributes</a></dt><dt>16.9.8. <a href="#portlet-ann-webdatabinder">Customizing WebDataBinder
      initialization</a></dt><dd><dl><dt>16.9.8.1. <a href="#portlet-ann-initbinder">Customizing data binding with
        @InitBinder</a></dt><dt>16.9.8.2. <a href="#portlet-ann-webbindinginitializer">Configuring a custom
        WebBindingInitializer</a></dt></dl></dd></dl></dd><dt>16.10. <a href="#portlet-deployment">Portlet application deployment</a></dt></dl></dd></dl></dd><dt>IV. <a href="#spring-integration">Integration</a></dt><dd><dl><dt>17. <a href="#remoting">Remoting and web services using Spring</a></dt><dd><dl><dt>17.1. <a href="#remoting-introduction">Introduction</a></dt><dt>17.2. <a href="#remoting-rmi">Exposing services using RMI</a></dt><dd><dl><dt>17.2.1. <a href="#remoting-rmi-server">Exporting the service using the RmiServiceExporter</a></dt><dt>17.2.2. <a href="#remoting-rmi-client">Linking in the service at the client</a></dt></dl></dd><dt>17.3. <a href="#remoting-caucho-protocols">Using Hessian or Burlap to remotely call services via HTTP</a></dt><dd><dl><dt>17.3.1. <a href="#remoting-caucho-protocols-hessian">Wiring up the DispatcherServlet for Hessian and co.</a></dt><dt>17.3.2. <a href="#remoting-caucho-protocols-hessian-server">Exposing your beans by using the HessianServiceExporter</a></dt><dt>17.3.3. <a href="#remoting-caucho-protocols-hessian-client">Linking in the service on the client</a></dt><dt>17.3.4. <a href="#remoting-caucho-protocols-burlap">Using Burlap</a></dt><dt>17.3.5. <a href="#remoting-caucho-protocols-security">Applying HTTP basic authentication to a service exposed through Hessian or Burlap</a></dt></dl></dd><dt>17.4. <a href="#remoting-httpinvoker">Exposing services using HTTP invokers</a></dt><dd><dl><dt>17.4.1. <a href="#remoting-httpinvoker-server">Exposing the service object</a></dt><dt>17.4.2. <a href="#remoting-httpinvoker-client">Linking in the service at the client</a></dt></dl></dd><dt>17.5. <a href="#remoting-web-services">Web services</a></dt><dd><dl><dt>17.5.1. <a href="#remoting-web-services-jaxrpc-export">Exposing servlet-based web services using JAX-RPC</a></dt><dt>17.5.2. <a href="#remoting-web-services-jaxrpc-access">Accessing web services using JAX-RPC</a></dt><dt>17.5.3. <a href="#remoting-web-services-jaxrpc-mapping-registration">Registering JAX-RPC Bean Mappings</a></dt><dt>17.5.4. <a href="#remoting-web-services-jaxrpc-handler-registration">Registering your own JAX-RPC Handler</a></dt><dt>17.5.5. <a href="#remoting-web-services-jaxws-export-servlet">Exposing servlet-based web services using JAX-WS</a></dt><dt>17.5.6. <a href="#remoting-web-services-jaxws-export-standalone">Exporting standalone web services using JAX-WS</a></dt><dt>17.5.7. <a href="#remoting-web-services-jaxws-export-ri">Exporting web services using the JAX-WS RI's Spring support</a></dt><dt>17.5.8. <a href="#remoting-web-services-jaxws-access">Accessing web services using JAX-WS</a></dt><dt>17.5.9. <a href="#remoting-web-services-xfire">Exposing web services using XFire</a></dt></dl></dd><dt>17.6. <a href="#remoting-jms">JMS</a></dt><dd><dl><dt>17.6.1. <a href="#remoting-jms-server">Server-side configuration</a></dt><dt>17.6.2. <a href="#remoting-jms-client">Client-side configuration</a></dt></dl></dd><dt>17.7. <a href="#remoting-autodection-remote-interfaces">Auto-detection is not implemented for remote interfaces</a></dt><dt>17.8. <a href="#remoting-considerations">Considerations when choosing a technology</a></dt></dl></dd><dt>18. <a href="#ejb">Enterprise Java Beans (EJB) integration</a></dt><dd><dl><dt>18.1. <a href="#ejb-introduction">Introduction</a></dt><dt>18.2. <a href="#ejb-access">Accessing EJBs</a></dt><dd><dl><dt>18.2.1. <a href="#ejb-access-concepts">Concepts</a></dt><dt>18.2.2. <a href="#ejb-access-local">Accessing local SLSBs</a></dt><dt>18.2.3. <a href="#ejb-access-remote">Accessing remote SLSBs</a></dt><dt>18.2.4. <a href="#ejb-access-ejb2-ejb3">Accessing EJB 2.x SLSBs versus EJB 3 SLSBs</a></dt></dl></dd><dt>18.3. <a href="#ejb-implementation">Using Spring's EJB implementation support classes</a></dt><dd><dl><dt>18.3.1. <a href="#ejb-implementation-ejb2">EJB 2.x base classes</a></dt><dt>18.3.2. <a href="#ejb-implementation-ejb3">EJB 3 injection interceptor</a></dt></dl></dd></dl></dd><dt>19. <a href="#jms">JMS (Java Message Service)</a></dt><dd><dl><dt>19.1. <a href="#jms-introduction">Introduction</a></dt><dt>19.2. <a href="#jms-using">Using Spring JMS</a></dt><dd><dl><dt>19.2.1. <a href="#jms-jmstemplate">JmsTemplate</a></dt><dt>19.2.2. <a href="#jms-connections">Connections</a></dt><dt>19.2.3. <a href="#jms-destinations">Destination Management</a></dt><dt>19.2.4. <a href="#jms-mdp">Message Listener Containers</a></dt><dd><dl><dt>19.2.4.1. <a href="#jms-mdp-simple">SimpleMessageListenerContainer</a></dt><dt>19.2.4.2. <a href="#jms-mdp-default">DefaultMessageListenerContainer</a></dt><dt>19.2.4.3. <a href="#jms-mdp-server-session">ServerSessionMessageListenerContainer</a></dt></dl></dd><dt>19.2.5. <a href="#jms-tx">Transaction management</a></dt></dl></dd><dt>19.3. <a href="#jms-sending">Sending a Message</a></dt><dd><dl><dt>19.3.1. <a href="#jms-msg-conversion">Using Message Converters</a></dt><dt>19.3.2. <a href="#jms-callbacks">SessionCallback and ProducerCallback</a></dt></dl></dd><dt>19.4. <a href="#jms-receiving">Receiving a message</a></dt><dd><dl><dt>19.4.1. <a href="#jms-receiving-sync">Synchronous Reception</a></dt><dt>19.4.2. <a href="#jms-asynchronousMessageReception">Asynchronous Reception - Message-Driven POJOs</a></dt><dt>19.4.3. <a href="#jms-receiving-async-session-aware-message-listener">The SessionAwareMessageListener interface</a></dt><dt>19.4.4. <a href="#jms-receiving-async-message-listener-adapter">The MessageListenerAdapter</a></dt><dt>19.4.5. <a href="#jms-tx-participation">Processing messages within transactions</a></dt></dl></dd><dt>19.5. <a href="#jms-jca-message-endpoint-manager">Support for JCA Message Endpoints</a></dt><dt>19.6. <a href="#jms-namespace">JMS Namespace Support</a></dt></dl></dd><dt>20. <a href="#jmx">JMX</a></dt><dd><dl><dt>20.1. <a href="#jmx-introduction">Introduction</a></dt><dt>20.2. <a href="#jmx-exporting">Exporting your beans to JMX</a></dt><dd><dl><dt>20.2.1. <a href="#jmx-exporting-mbeanserver">Creating an MBeanServer</a></dt><dt>20.2.2. <a href="#jmx-mbean-server">Reusing an existing MBeanServer</a></dt><dt>20.2.3. <a href="#jmx-exporting-lazy">Lazy-initialized MBeans</a></dt><dt>20.2.4. <a href="#jmx-exporting-auto">Automatic registration of MBeans</a></dt><dt>20.2.5. <a href="#jmx-exporting-registration-behavior">Controlling the registration behavior</a></dt></dl></dd><dt>20.3. <a href="#jmx-interface">Controlling the management interface of your beans</a></dt><dd><dl><dt>20.3.1. <a href="#jmx-interface-assembler">The MBeanInfoAssembler
      Interface</a></dt><dt>20.3.2. <a href="#jmx-interface-metadata">Using source-Level metadata</a></dt><dt>20.3.3. <a href="#jmx-interface-annotations">Using JDK 5.0 Annotations</a></dt><dt>20.3.4. <a href="#jmx-interface-metadata-types">Source-Level Metadata Types</a></dt><dt>20.3.5. <a href="#jmx-interface-autodetect">The AutodetectCapableMBeanInfoAssembler
      interface</a></dt><dt>20.3.6. <a href="#jmx-interface-java">Defining management interfaces using Java interfaces</a></dt><dt>20.3.7. <a href="#jmx-interface-methodnames">Using
      MethodNameBasedMBeanInfoAssembler</a></dt></dl></dd><dt>20.4. <a href="#jmx-naming">Controlling the ObjectNames for your beans</a></dt><dd><dl><dt>20.4.1. <a href="#jmx-naming-properties">Reading ObjectNames from Properties</a></dt><dt>20.4.2. <a href="#jmx-naming-metadata">Using the MetadataNamingStrategy</a></dt><dt>20.4.3. <a href="#jmx-context-mbeanexport">The &lt;context:mbean-export/&gt; element</a></dt></dl></dd><dt>20.5. <a href="#jmx-jsr160">JSR-160 Connectors</a></dt><dd><dl><dt>20.5.1. <a href="#jmx-jsr160-server">Server-side Connectors</a></dt><dt>20.5.2. <a href="#jmx-jsr160-client">Client-side Connectors</a></dt><dt>20.5.3. <a href="#jmx-jsr160-protocols">JMX over Burlap/Hessian/SOAP</a></dt></dl></dd><dt>20.6. <a href="#jmx-proxy">Accessing MBeans via Proxies</a></dt><dt>20.7. <a href="#jmx-notifications">Notifications</a></dt><dd><dl><dt>20.7.1. <a href="#jmx-notifications-listeners">Registering Listeners for Notifications</a></dt><dt>20.7.2. <a href="#jmx-notifications-publishing">Publishing Notifications</a></dt></dl></dd><dt>20.8. <a href="#jmx-resources">Further Resources</a></dt></dl></dd><dt>21. <a href="#cci">JCA CCI</a></dt><dd><dl><dt>21.1. <a href="#cci-introduction">Introduction</a></dt><dt>21.2. <a href="#cci-config">Configuring CCI</a></dt><dd><dl><dt>21.2.1. <a href="#cci-config-connector">Connector configuration</a></dt><dt>21.2.2. <a href="#cci-config-connectionfactory">ConnectionFactory configuration in Spring</a></dt><dt>21.2.3. <a href="#cci-config-cci-connections">Configuring CCI connections</a></dt><dt>21.2.4. <a href="#cci-config-single-connection">Using a single CCI connection</a></dt></dl></dd><dt>21.3. <a href="#cci-using">Using Spring's CCI access support</a></dt><dd><dl><dt>21.3.1. <a href="#cci-record-creator">Record conversion</a></dt><dt>21.3.2. <a href="#cci-using-template">The CciTemplate</a></dt><dt>21.3.3. <a href="#cci-using-dao">DAO support</a></dt><dt>21.3.4. <a href="#automatic-output-generation">Automatic output record generation</a></dt><dt>21.3.5. <a href="#template-summary">Summary</a></dt><dt>21.3.6. <a href="#cci-straight">Using a CCI Connection and Interaction directly</a></dt><dt>21.3.7. <a href="#cci-template-example">Example for CciTemplate usage</a></dt></dl></dd><dt>21.4. <a href="#cci-object">Modeling CCI access as operation objects</a></dt><dd><dl><dt>21.4.1. <a href="#cci-object-mapping-record">MappingRecordOperation</a></dt><dt>21.4.2. <a href="#cci-object-mapping-comm-area">MappingCommAreaOperation</a></dt><dt>21.4.3. <a href="#cci-automatic-record-gen">Automatic output record generation</a></dt><dt>21.4.4. <a href="#cci-object-summary">Summary</a></dt><dt>21.4.5. <a href="#cci-objects-mappring-record-example">Example for MappingRecordOperation usage</a></dt><dt>21.4.6. <a href="#cci-objects-mapping-comm-area-example">Example for MappingCommAreaOperation usage</a></dt></dl></dd><dt>21.5. <a href="#cci-tx">Transactions</a></dt></dl></dd><dt>22. <a href="#mail">Email</a></dt><dd><dl><dt>22.1. <a href="#mail-introduction">Introduction</a></dt><dt>22.2. <a href="#mail-usage">Usage</a></dt><dd><dl><dt>22.2.1. <a href="#mail-usage-simple">Basic MailSender and SimpleMailMessage usage</a></dt><dt>22.2.2. <a href="#mail-usage-mime">Using the JavaMailSender and the MimeMessagePreparator</a></dt></dl></dd><dt>22.3. <a href="#mail-javamail-mime">Using the JavaMail MimeMessageHelper</a></dt><dd><dl><dt>22.3.1. <a href="#mail-javamail-mime-attachments">Sending attachments and inline resources</a></dt><dd><dl><dt>22.3.1.1. <a href="#mail-javamail-mime-attachments-attachment">Attachments</a></dt><dt>22.3.1.2. <a href="#mail-javamail-mime-attachments-inline">Inline resources</a></dt></dl></dd><dt>22.3.2. <a href="#mail-templates">Creating email content using a templating library</a></dt><dd><dl><dt>22.3.2.1. <a href="#mail-templates-example">A Velocity-based example</a></dt></dl></dd></dl></dd></dl></dd><dt>23. <a href="#scheduling">Scheduling and Thread Pooling</a></dt><dd><dl><dt>23.1. <a href="#scheduling-introduction">Introduction</a></dt><dt>23.2. <a href="#scheduling-quartz">Using the OpenSymphony Quartz Scheduler</a></dt><dd><dl><dt>23.2.1. <a href="#scheduling-quartz-jobdetail">Using the JobDetailBean</a></dt><dt>23.2.2. <a href="#scheduling-quartz-method-invoking-job">Using the MethodInvokingJobDetailFactoryBean</a></dt><dt>23.2.3. <a href="#scheduling-quartz-cron">Wiring up jobs using triggers and the SchedulerFactoryBean</a></dt></dl></dd><dt>23.3. <a href="#scheduling-jdk-timer">Using JDK Timer support</a></dt><dd><dl><dt>23.3.1. <a href="#scheduling-jdk-timer-creating">Creating custom timers</a></dt><dt>23.3.2. <a href="#scheduling-jdk-timer-method-invoking-task">Using the MethodInvokingTimerTaskFactoryBean</a></dt><dt>23.3.3. <a href="#scheduling-jdk-timer-factory-bean">Wrapping up: setting up the tasks using the TimerFactoryBean</a></dt></dl></dd><dt>23.4. <a href="#scheduling-task-executor">The Spring TaskExecutor abstraction</a></dt><dd><dl><dt>23.4.1. <a href="#scheduling-task-executor-types">TaskExecutor types</a></dt><dt>23.4.2. <a href="#scheduling-task-executor-usage">Using a TaskExecutor</a></dt></dl></dd></dl></dd><dt>24. <a href="#dynamic-language">Dynamic language support</a></dt><dd><dl><dt>24.1. <a href="#dynamic-language-introduction">Introduction</a></dt><dt>24.2. <a href="#dynamic-language-a-first-example">A first example</a></dt><dt>24.3. <a href="#dynamic-language-beans">Defining beans that are backed by dynamic languages</a></dt><dd><dl><dt>24.3.1. <a href="#dynamic-language-beans-concepts">Common concepts</a></dt><dd><dl><dt>24.3.1.1. <a href="#dynamic-language-beans-concepts-xml-language-element">The &lt;lang:language/&gt; element</a></dt><dt>24.3.1.2. <a href="#dynamic-language-refreshable-beans">Refreshable beans</a></dt><dt>24.3.1.3. <a href="#dynamic-language-beans-inline">Inline dynamic language source files</a></dt><dt>24.3.1.4. <a href="#dynamic-language-beans-ctor-injection">Understanding Constructor Injection in the context of dynamic-language-backed beans</a></dt></dl></dd><dt>24.3.2. <a href="#dynamic-language-beans-jruby">JRuby beans</a></dt><dt>24.3.3. <a href="#dynamic-language-beans-groovy">Groovy beans</a></dt><dd><dl><dt>24.3.3.1. <a href="#dynamic-language-beans-groovy-customizer">Customising Groovy objects via a callback</a></dt></dl></dd><dt>24.3.4. <a href="#dynamic-language-beans-bsh">BeanShell beans</a></dt></dl></dd><dt>24.4. <a href="#dynamic-language-scenarios">Scenarios</a></dt><dd><dl><dt>24.4.1. <a href="#dynamic-language-scenarios-controllers">Scripted Spring MVC Controllers</a></dt><dt>24.4.2. <a href="#dynamic-language-scenarios-validators">Scripted Validators</a></dt></dl></dd><dt>24.5. <a href="#dynamic-language-final-notes">Bits and bobs</a></dt><dd><dl><dt>24.5.1. <a href="#dynamic-language-final-notes-aop">AOP - advising scripted beans</a></dt><dt>24.5.2. <a href="#dynamic-language-final-notes-scopes">Scoping</a></dt></dl></dd><dt>24.6. <a href="#dynamic-language-resources">Further Resources</a></dt></dl></dd><dt>25. <a href="#metadata">Annotations and Source Level Metadata Support</a></dt><dd><dl><dt>25.1. <a href="#metadata-introduction">Introduction</a></dt><dt>25.2. <a href="#metadata-spring">Spring's metadata support</a></dt><dt>25.3. <a href="#metadata-annotations">Annotations</a></dt><dd><dl><dt>25.3.1. <a href="#metadata-annotations-required">@Required</a></dt><dt>25.3.2. <a href="#metadata-annotations-other">Other @Annotations in Spring</a></dt></dl></dd><dt>25.4. <a href="#metadata-commons">Integration with Jakarta Commons Attributes</a></dt><dt>25.5. <a href="#metadata-uses">Metadata and Spring AOP autoproxying</a></dt><dd><dl><dt>25.5.1. <a href="#metadata-fundamentals">Fundamentals</a></dt><dt>25.5.2. <a href="#metadata-tx">Declarative transaction management</a></dt></dl></dd></dl></dd></dl></dd><dt>A. <a href="#xsd-config">XML Schema-based configuration</a></dt><dd><dl><dt>A.1. <a href="#xsd-config-introduction">Introduction</a></dt><dt>A.2. <a href="#xsd-config-body">XML Schema-based configuration</a></dt><dd><dl><dt>A.2.1. <a href="#xsd-config-body-referencing">Referencing the schemas</a></dt><dt>A.2.2. <a href="#xsd-config-body-schemas-util">The util schema</a></dt><dd><dl><dt>A.2.2.1. <a href="#xsd-config-body-schemas-util-constant">&lt;util:constant/&gt;</a></dt><dt>A.2.2.2. <a href="#xsd-config-body-schemas-util-property-path">&lt;util:property-path/&gt;</a></dt><dt>A.2.2.3. <a href="#xsd-config-body-schemas-util-properties">&lt;util:properties/&gt;</a></dt><dt>A.2.2.4. <a href="#xsd-config-body-schemas-util-list">&lt;util:list/&gt;</a></dt><dt>A.2.2.5. <a href="#xsd-config-body-schemas-util-map">&lt;util:map/&gt;</a></dt><dt>A.2.2.6. <a href="#xsd-config-body-schemas-util-set">&lt;util:set/&gt;</a></dt></dl></dd><dt>A.2.3. <a href="#xsd-config-body-schemas-jee">The jee schema</a></dt><dd><dl><dt>A.2.3.1. <a href="#xsd-config-body-schemas-jee-jndi-lookup">&lt;jee:jndi-lookup/&gt; (simple)</a></dt><dt>A.2.3.2. <a href="#xsd-config-body-schemas-jee-jndi-lookup-environment-single">&lt;jee:jndi-lookup/&gt; (with single JNDI environment setting)</a></dt><dt>A.2.3.3. <a href="#xsd-config-body-schemas-jee-jndi-lookup-evironment-multiple">&lt;jee:jndi-lookup/&gt; (with multiple JNDI environment settings)</a></dt><dt>A.2.3.4. <a href="#xsd-config-body-schemas-jee-jndi-lookup-complex">&lt;jee:jndi-lookup/&gt; (complex)</a></dt><dt>A.2.3.5. <a href="#xsd-config-body-schemas-jee-local-slsb">&lt;jee:local-slsb/&gt; (simple)</a></dt><dt>A.2.3.6. <a href="#xsd-config-body-schemas-jee-local-slsb-complex">&lt;jee:local-slsb/&gt; (complex)</a></dt><dt>A.2.3.7. <a href="#xsd-config-body-schemas-jee-remote-slsb">&lt;jee:remote-slsb/&gt;</a></dt></dl></dd><dt>A.2.4. <a href="#xsd-config-body-schemas-lang">The lang schema</a></dt><dt>A.2.5. <a href="#xsd-config-body-schemas-jms">The jms schema</a></dt><dt>A.2.6. <a href="#xsd-config-body-schemas-tx">The tx (transaction) schema</a></dt><dt>A.2.7. <a href="#xsd-config-body-schemas-aop">The aop schema</a></dt><dt>A.2.8. <a href="#xsd-config-body-schemas-context">The context schema</a></dt><dd><dl><dt>A.2.8.1. <a href="#xsd-config-body-schemas-context-pphc">&lt;property-placeholder/&gt;</a></dt><dt>A.2.8.2. <a href="#xsd-config-body-schemas-context-ac">&lt;annotation-config/&gt;</a></dt><dt>A.2.8.3. <a href="#xsd-config-body-schemas-context-component-scan">&lt;component-scan/&gt;</a></dt><dt>A.2.8.4. <a href="#xsd-config-body-schemas-context-ltw">&lt;load-time-weaver/&gt;</a></dt><dt>A.2.8.5. <a href="#xsd-config-body-schemas-context-sc">&lt;spring-configured/&gt;</a></dt><dt>A.2.8.6. <a href="#xsd-config-body-schemas-context-mbe">&lt;mbean-export/&gt;</a></dt></dl></dd><dt>A.2.9. <a href="#xsd-config-body-schemas-tool">The tool schema</a></dt><dt>A.2.10. <a href="#xsd-config-body-schemas-beans">The beans schema</a></dt></dl></dd><dt>A.3. <a href="#xsd-config-setup">Setting up your IDE</a></dt><dd><dl><dt>A.3.1. <a href="#xsd-config-setup-eclipse">Setting up Eclipse</a></dt><dt>A.3.2. <a href="#xsd-config-setup-idea">Setting up IntelliJ IDEA</a></dt><dt>A.3.3. <a href="#xsd-config-integration">Integration issues</a></dt><dd><dl><dt>A.3.3.1. <a href="#xsd-config-integration-resin">XML parsing errors in the Resin v.3 application server</a></dt></dl></dd></dl></dd></dl></dd><dt>B. <a href="#extensible-xml">Extensible XML authoring</a></dt><dd><dl><dt>B.1. <a href="#extensible-xml-introduction">Introduction</a></dt><dt>B.2. <a href="#extensible-xml-schema">Authoring the schema</a></dt><dt>B.3. <a href="#extensible-xml-namespacehandler">Coding a NamespaceHandler</a></dt><dt>B.4. <a href="#extensible-xml-parser">Coding a BeanDefinitionParser</a></dt><dt>B.5. <a href="#extensible-xml-registration">Registering the handler and the schema</a></dt><dd><dl><dt>B.5.1. <a href="#extensible-xml-registration-spring-handlers">'META-INF/spring.handlers'</a></dt><dt>B.5.2. <a href="#extensible-xml-registration-spring-schemas">'META-INF/spring.schemas'</a></dt></dl></dd><dt>B.6. <a href="#extensible-xml-using">Using a custom extension in your Spring XML configuration</a></dt><dt>B.7. <a href="#extensible-xml-meat">Meatier examples</a></dt><dd><dl><dt>B.7.1. <a href="#extensible-xml-custom-nested">Nesting custom tags within custom tags</a></dt><dt>B.7.2. <a href="#extensible-xml-custom-just-attributes">Custom attributes on 'normal' elements</a></dt></dl></dd><dt>B.8. <a href="#extensible-xml-resources">Further Resources</a></dt></dl></dd><dt>C. <a href="#springbeansdtd">spring-beans-2.0.dtd</a></dt><dt>D. <a href="#spring.tld">spring.tld</a></dt><dd><dl><dt>D.1. <a href="#spring.tld-intro">Introduction</a></dt><dt>D.2. <a href="#spring.tld.bind">The bind tag</a></dt><dt>D.3. <a href="#spring.tld.escapeBody">The escapeBody tag</a></dt><dt>D.4. <a href="#spring.tld.hasBindErrors">The hasBindErrors tag</a></dt><dt>D.5. <a href="#spring.tld.htmlEscape">The htmlEscape tag</a></dt><dt>D.6. <a href="#spring.tld.message">The message tag</a></dt><dt>D.7. <a href="#spring.tld.nestedPath">The nestedPath tag</a></dt><dt>D.8. <a href="#spring.tld.theme">The theme tag</a></dt><dt>D.9. <a href="#spring.tld.transform">The transform tag</a></dt></dl></dd><dt>E. <a href="#spring-form.tld">spring-form.tld</a></dt><dd><dl><dt>E.1. <a href="#spring-form.tld-intro">Introduction</a></dt><dt>E.2. <a href="#spring-form.tld.checkbox">The checkbox tag</a></dt><dt>E.3. <a href="#spring-form.tld.checkboxes">The checkboxes tag</a></dt><dt>E.4. <a href="#spring-form.tld.errors">The errors tag</a></dt><dt>E.5. <a href="#spring-form.tld.form">The form tag</a></dt><dt>E.6. <a href="#spring-form.tld.hidden">The hidden tag</a></dt><dt>E.7. <a href="#spring-form.tld.input">The input tag</a></dt><dt>E.8. <a href="#spring-form.tld.label">The label tag</a></dt><dt>E.9. <a href="#spring-form.tld.option">The option tag</a></dt><dt>E.10. <a href="#spring-form.tld.options">The options tag</a></dt><dt>E.11. <a href="#spring-form.tld.password">The password tag</a></dt><dt>E.12. <a href="#spring-form.tld.radiobutton">The radiobutton tag</a></dt><dt>E.13. <a href="#spring-form.tld.radiobuttons">The radiobuttons tag</a></dt><dt>E.14. <a href="#spring-form.tld.select">The select tag</a></dt><dt>E.15. <a href="#spring-form.tld.textarea">The textarea tag</a></dt></dl></dd></dl></div><div class="preface" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="preface"></a>Preface</h2></div></div><div></div></div><p>Developing software applications is hard enough even with good tools
  and technologies. Implementing applications using platforms which promise
  everything but turn out to be heavy-weight, hard to control and not very
  efficient during the development cycle makes it even harder. Spring provides
  a light-weight solution for building enterprise-ready applications, while
  still supporting the possibility of using declarative transaction
  management, remote access to your logic using RMI or web services, and
  various options for persisting your data to a database. Spring provides a
  full-featured <a href="#mvc-introduction" title="13.1.&nbsp;Introduction">MVC framework</a>, and
  transparent ways of integrating <a href="#aop-introduction" title="6.1.&nbsp;Introduction">AOP</a>
  into your software.</p><p>Spring could potentially be a one-stop-shop for all your enterprise
  applications; however, Spring is modular, allowing you to use just those
  parts of it that you need, without having to bring in the rest. You can use
  the IoC container, with Struts on top, but you could also choose to use just
  the <a href="#orm-hibernate" title="12.2.&nbsp;Hibernate">Hibernate integration code</a> or the
  <a href="#jdbc-introduction" title="11.1.&nbsp;Introduction">JDBC abstraction layer</a>. Spring has
  been (and continues to be) designed to be non-intrusive, meaning
  dependencies on the framework itself are generally none (or absolutely
  minimal, depending on the area of use).</p><p>This document provides a reference guide to Spring's features. Since
  this document is still to be considered very much work-in-progress, if you
  have any requests or comments, please post them on the user mailing list or
  on the support forums at <a href="http://forum.springframework.org/" target="_top">http://forum.springframework.org/</a>.</p><p>Before we go on, a few words of gratitude are due to Christian Bauer
  (of the <a href="http://www.hibernate.org/" target="_top">Hibernate</a> team), who
  prepared and adapted the DocBook-XSL software in order to be able to create
  Hibernate's reference guide, thus also allowing us to create this one. Also
  thanks to Russell Healy for doing an extensive and valuable review of some
  of the material.</p></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="introduction"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div><div></div></div><div class="sidebar"><a name="background-ioc"></a><p class="title"><b>Background</b></p><p>In early 2004, Martin Fowler asked the readers of his site: when
    talking about Inversion of Control: &#8220;<span class="quote"><span class="emphasis"><em>the question is, what
    aspect of control are [they] inverting?</em></span></span>&#8221;. Fowler then
    suggested renaming the principle (or at least giving it a more
    self-explanatory name), and started to use the term <i class="firstterm">Dependency
    Injection</i>. His article then continued to explain the ideas
    underpinning the Inversion of Control (<span class="acronym">IoC</span>) and
    Dependency Injection (<span class="acronym">DI</span>) principle.</p><p>If you need a decent insight into IoC and DI, please do refer to
    said article : <a href="http://martinfowler.com/articles/injection.html" target="_top">http://martinfowler.com/articles/injection.html</a>.</p></div><p>Java applications (a loose term which runs the gamut from constrained
  applets to full-fledged n-tier server-side enterprise applications)
  typically are composed of a number of objects that collaborate with one
  another to form the application proper. The objects in an application can
  thus be said to have <span class="emphasis"><em>dependencies</em></span> between
  themselves.</p><p>The Java language and platform provides a wealth of functionality for
  architecting and building applications, ranging all the way from the very
  basic building blocks of primitive types and classes (and the means to
  define new classes), to rich full-featured application servers and web
  frameworks. One area that is decidedly conspicuous by its absence is any
  means of taking the basic building blocks and composing them into a coherent
  whole; this area has typically been left to the purvey of the architects and
  developers tasked with building an application (or applications). Now to be
  fair, there are a number of design patterns devoted to the business of
  composing the various classes and object instances that makeup an
  all-singing, all-dancing application. Design patterns such as
  <i class="firstterm">Factory</i>, <i class="firstterm">Abstract Factory</i>,
  <i class="firstterm">Builder</i>, <i class="firstterm">Decorator</i>, and
  <i class="firstterm">Service Locator</i> (to name but a few) have widespread
  recognition and acceptance within the software development industry
  (presumably that is why these patterns have been formalized as patterns in
  the first place). This is all very well, but these patterns are just that:
  best practices given a name, typically together with a description of what
  the pattern does, where the pattern is typically best applied, the problems
  that the application of the pattern addresses, and so forth. Notice that the
  last paragraph used the phrase &#8220;<span class="quote">... a <span class="emphasis"><em>description</em></span>
  of what the pattern does...</span>&#8221;; pattern books and wikis are typically
  listings of such formalized best practice that you can certainly take away,
  mull over, and then <span class="emphasis"><em>implement yourself</em></span> in your
  application.</p><p>The IoC component of the Spring Framework addresses the enterprise
  concern of taking the classes, objects, and services that are to compose an
  application, by providing a formalized means of composing these various
  disparate components into a fully working application ready for use. The
  Spring Framework takes best practices that have been proven over the years
  in numerous applications and formalized as design patterns, and actually
  codifies these patterns as first class objects that you as an architect and
  developer can take away and integrate into your own application(s). This is
  a <i class="firstterm">Very Good Thing Indeed</i> as attested to by the
  numerous organizations and institutions that have used the Spring Framework
  to engineer robust, <span class="emphasis"><em>maintainable</em></span> applications.</p><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="introduction-overview"></a>1.1.&nbsp;Overview</h2></div></div><div></div></div><p>The Spring Framework contains a lot of features, which are
    well-organized in six modules shown in the diagram below. This chapter
    discusses each of the modules in turn.</p><div class="mediaobject" align="center"><img src="images/spring-overview.png" align="middle"><div class="caption"><p>Overview of the Spring Framework</p></div></div><p>The <a href="#beans-introduction" title="3.1.&nbsp;Introduction"><span class="emphasis"><em>Core</em></span></a> package is
    the most fundamental part of the framework and provides the IoC and
    Dependency Injection features. The basic concept here is the
    <tt class="classname">BeanFactory</tt>, which provides a sophisticated
    implementation of the factory pattern which removes the need for
    programmatic singletons and allows you to decouple the configuration and
    specification of dependencies from your actual program logic.</p><p>The <a href="#context-introduction" title="3.8.&nbsp;The ApplicationContext"><span class="emphasis"><em>Context</em></span></a> package
    build on the solid base provided by the <a href="#beans-introduction" title="3.1.&nbsp;Introduction"><span class="emphasis"><em>Core</em></span></a> package: it
    provides a way to access objects in a framework-style manner in a fashion
    somewhat reminiscent of a JNDI-registry. The context package inherits its
    features from the beans package and adds support for internationalization
    (I18N) (using for example resource bundles), event-propagation,
    resource-loading, and the transparent creation of contexts by, for
    example, a servlet container.</p><p>The <a href="#dao-introduction" title="10.1.&nbsp;Introduction"><span class="emphasis"><em>DAO</em></span></a>
    package provides a JDBC-abstraction layer that removes the need to do
    tedious JDBC coding and parsing of database-vendor specific error codes.
    Also, the <a href="#jdbc-introduction" title="11.1.&nbsp;Introduction">JDBC</a> package provides a
    way to do programmatic as well as declarative transaction management, not
    only for classes implementing special interfaces, but for <span class="emphasis"><em>all
    your POJOs (plain old Java objects)</em></span>.</p><p>The <a href="#orm-introduction" title="12.1.&nbsp;Introduction"><span class="emphasis"><em>ORM</em></span></a>
    package provides integration layers for popular object-relational mapping
    APIs, including <a href="#orm-jpa" title="12.6.&nbsp;JPA">JPA</a>, <a href="#orm-jdo" title="12.3.&nbsp;JDO">JDO</a>, <a href="#orm-hibernate" title="12.2.&nbsp;Hibernate">Hibernate</a>, and <a href="#orm-ibatis" title="12.5.&nbsp;iBATIS SQL Maps">iBatis</a>. Using the ORM package you can use all
    those O/R-mappers in combination with all the other features Spring
    offers, such as the simple declarative transaction management feature
    mentioned previously.</p><p>Spring's <a href="#aop-introduction" title="6.1.&nbsp;Introduction"><span class="emphasis"><em>AOP</em></span></a> package
    provides an <span class="emphasis"><em>AOP Alliance</em></span>-compliant aspect-oriented
    programming implementation allowing you to define, for example,
    method-interceptors and pointcuts to cleanly decouple code implementing
    functionality that should logically speaking be separated. Using
    source-level metadata functionality you can also incorporate all kinds of
    behavioral information into your code, in a manner similar to that of .NET
    attributes.</p><p>Spring's <span class="emphasis"><em>Web</em></span> package provides basic
    web-oriented integration features, such as multipart file-upload
    functionality, the initialization of the IoC container using servlet
    listeners and a web-oriented application context. When using Spring
    together with WebWork or Struts, this is the package to integrate
    with.</p><p>Spring's <a href="#mvc-introduction" title="13.1.&nbsp;Introduction"><span class="emphasis"><em>MVC</em></span></a> package
    provides a Model-View-Controller (MVC) implementation for
    web-applications. Spring's MVC framework is not just any old
    implementation; it provides a <span class="emphasis"><em>clean</em></span> separation
    between domain model code and web forms, and allows you to use all the
    other features of the Spring Framework.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="overview-usagescenarios"></a>1.2.&nbsp;Usage scenarios</h2></div></div><div></div></div><p>With the building blocks described above you can use Spring in all
    sorts of scenarios, from applets up to fully-fledged enterprise
    applications using Spring's transaction management functionality and web
    framework integration.</p><div class="mediaobject" align="center"><img src="images/full.gif" align="middle"><div class="caption"><p>Typical full-fledged Spring web
        application</p></div></div><p>By using Spring's <a href="#transaction-declarative" title="9.5.&nbsp;Declarative transaction management">declarative transaction management
    features</a> the web application is fully transactional, just as it
    would be when using container managed transactions as provided by
    Enterprise JavaBeans. All your custom business logic can be implemented
    using simple POJOs, managed by Spring's IoC container. Additional services
    include support for sending email, and validation that is independent of
    the web layer enabling you to choose where to execute validation rules.
    Spring's ORM support is integrated with JPA, Hibernate, JDO and iBatis;
    for example, when using Hibernate, you can continue to use your existing
    mapping files and standard Hibernate
    <tt class="interfacename">SessionFactory</tt> configuration. Form
    controllers seamlessly integrate the web-layer with the domain model,
    removing the need for <tt class="classname">ActionForms</tt> or other classes
    that transform HTTP parameters to values for your domain model.</p><div class="mediaobject" align="center"><img src="images/thirdparty-web.gif" align="middle"><div class="caption"><p>Spring middle-tier using a third-party web
        framework</p></div></div><p>Sometimes the current circumstances do not allow you to completely
    switch to a different framework. The Spring Framework does
    <span class="emphasis"><em>not</em></span> force you to use everything within it; it is not
    an <span class="emphasis"><em>all-or-nothing</em></span> solution. Existing front-ends built
    using WebWork, Struts, Tapestry, or other UI frameworks can be integrated
    perfectly well with a Spring-based middle-tier, allowing you to use the
    transaction features that Spring offers. The only thing you need to do is
    wire up your business logic using an
    <tt class="classname">ApplicationContext</tt> and integrate your web layer
    using a <tt class="classname">WebApplicationContext</tt>.</p><div class="mediaobject" align="center"><img src="images/remoting.gif" align="middle"><div class="caption"><p>Remoting usage scenario</p></div></div><p>When you need to access existing code via web services, you can use
    Spring's <tt class="literal">Hessian-</tt>, <tt class="literal">Burlap-</tt>,
    <tt class="literal">Rmi-</tt> or <tt class="classname">JaxRpcProxyFactory</tt>
    classes. Enabling remote access to existing applications suddenly is not
    that hard anymore.</p><div class="mediaobject" align="center"><img src="images/ejb.gif" align="middle"><div class="caption"><p>EJBs - Wrapping existing POJOs</p></div></div><p>The Spring Framework also provides an <a href="#ejb" title="Chapter&nbsp;18.&nbsp;Enterprise Java Beans (EJB) integration">access-
    and abstraction- layer</a> for Enterprise JavaBeans, enabling you to
    reuse your existing POJOs and wrap them in Stateless Session Beans, for
    use in scalable, failsafe web applications that might need declarative
    security.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="new-in-2"></a>Chapter&nbsp;2.&nbsp;What's new in Spring 2.0 and 2.5?</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-in-2-intro"></a>2.1.&nbsp;Introduction</h2></div></div><div></div></div><p>If you have been using the Spring Framework for some time, you will
    be aware that Spring has undergone two major revisions: Spring 2.0,
    released in October 2006, and Spring 2.5, released in November 2007.</p><div class="sidebar"><a name="new-in-2-intro-java"></a><p class="title"><b>Java SE and Java EE Support</b></p><p>The Spring Framework continues to be compatible with all versions
      of Java since (and including) Java 1.4.2. This means that Java 1.4.2,
      Java 5 and Java 6 are supported, although some advanced functionality of
      the Spring Framework will not be available to you if you are committed to
      using Java 1.4.2. Spring 2.5 introduces dedicated support for Java 6,
      after Spring 2.0's in-depth support for Java 5 throughout the
      framework.</p><p>Furthermore, Spring remains compatible with J2EE 1.3 and higher,
      while at the same time introducing dedicated support for Java EE 5. This
      means that Spring can be consistently used on application servers such
      as BEA WebLogic 8.1, 9.0, 9.2 and 10, IBM WebSphere 5.1, 6.0, 6.1 and 7,
      Oracle OC4J 10.1.3 and 11, JBoss 3.2, 4.0, 4.2 and 5.0, as well as Tomcat
      4.1, 5.0, 5.5 and 6.0, Jetty 4.2, 5.1 and 6.1, Resin 2.1, 3.0 and 3.1
      and GlassFish V1 and V2.</p><p><span class="emphasis"><em>NOTE: We generally recommend using the most recent
			version of each application server generation. In particular,
			make sure you are using BEA WebLogic 8.1 SP6 or higher and
			WebSphere 6.0.2.19 / 6.1.0.9 or higher, respectively, when using
			those WebLogic and WebSphere generations with Spring 2.5.</em></span></p></div><p>This chapter is a guide to the new and improved features of Spring
    2.0 and 2.5. It is intended to provide a high-level summary so that
    seasoned Spring architects and developers can become immediately familiar
    with the new Spring 2.x functionality. For more in-depth information on
    the features, please refer to the corresponding sections hyperlinked from
    within this chapter.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-in-2-ioc"></a>2.2.&nbsp;The Inversion of Control (IoC) container</h2></div></div><div></div></div><p>One of the areas that contains a considerable number of 2.0
    and 2.5 improvements is Spring's IoC container.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-ioc-scopes"></a>2.2.1.&nbsp;New bean scopes</h3></div></div><div></div></div><p>Previous versions of Spring had IoC container level support for
      exactly two distinct bean scopes (singleton and prototype). Spring 2.0
      improves on this by not only providing a number of additional scopes
      depending on the environment in which Spring is being deployed (for
      example, request and session scoped beans in a web environment), but
      also by providing integration points so that Spring users can create
      their own scopes.</p><p>It should be noted that although the underlying (and internal)
      implementation for singleton- and prototype-scoped beans has been
      changed, this change is totally transparent to the end user... no
      existing configuration needs to change, and no existing configuration
      will break.</p><p>Both the new and the original scopes are detailed in the section
      entitled <a href="#beans-factory-scopes" title="3.4.&nbsp;Bean scopes">Section&nbsp;3.4, &#8220;Bean scopes&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-ioc-configuration"></a>2.2.2.&nbsp;Easier XML configuration</h3></div></div><div></div></div><p>Spring XML configuration is now even easier, thanks to the advent
      of the new XML configuration syntax based on XML Schema. If you want to
      take advantage of the new tags that Spring provides (and the Spring team
      certainly suggest that you do because they make configuration less
      verbose and easier to read), then do read the section entitled <a href="#xsd-config" title="Appendix&nbsp;A.&nbsp;XML Schema-based configuration">Appendix&nbsp;A, <i>XML Schema-based configuration</i></a>.</p><p>On a related note, there is a new, updated DTD for Spring 2.0 that
      you may wish to reference if you cannot take advantage of the XML
      Schema-based configuration. The DOCTYPE declaration is included below
      for your convenience, but the interested reader should definitely read
      the <tt class="filename">'spring-beans-2.0.dtd'</tt> DTD included in the
      <tt class="filename">'dist/resources'</tt> directory of the
      Spring 2.5 distribution.</p><pre class="programlisting">&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		  "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-ioc-custom-configuration"></a>2.2.3.&nbsp;Extensible XML authoring</h3></div></div><div></div></div><p>Not only is XML configuration easier to write, it is now also
      extensible.</p><p>What 'extensible' means in this context is that you, as an
      application developer, or (more likely) as a third party framework or
      product vendor, can write custom tags that other developers can then
      plug into their own Spring configuration files. This allows you to have
      your own domain specific language (the term is used loosely here) of
      sorts be reflected in the specific configuration of your own
      components.</p><p>Implementing custom Spring tags may not be of interest to every
      single application developer or enterprise architect using Spring in
      their own projects. We expect third-party vendors to be highly
      interested in developing custom configuration tags for use in Spring
      configuration files.</p><p>The extensible configuration mechanism is documented in <a href="#extensible-xml" title="Appendix&nbsp;B.&nbsp;Extensible XML authoring">Appendix&nbsp;B, <i>Extensible XML authoring</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-ioc-annotations"></a>2.2.4.&nbsp;Annotation-driven configuration</h3></div></div><div></div></div><p>Spring 2.0 introduced support for various annotations for
      configuration purposes, such as <tt class="interfacename">@Transactional</tt>,
      <tt class="interfacename">@Required</tt> and <tt class="interfacename">@PersistenceContext</tt>
      /<tt class="interfacename">@PersistenceUnit</tt>.</p><p>Spring 2.5 introduces support for a complete set of configuration
      annotations: <tt class="interfacename">@Autowired</tt> in combination
      with support for the JSR-250 annotations <tt class="interfacename">@Resource</tt>,
      <tt class="interfacename">@PostConstruct</tt> and <tt class="interfacename">@PreDestroy</tt>
      .</p><p>Annotation-driven bean configuration is discussed in <a href="#beans-annotation-config" title="3.11.&nbsp;Annotation-based configuration">Section&nbsp;3.11, &#8220;Annotation-based configuration&#8221;</a>. Check out annotation support
      for Spring MVC as well: <a href="#new-in-2-web-annotations" title="2.5.3.&nbsp;Annotation-based controllers">Section&nbsp;2.5.3, &#8220;Annotation-based controllers&#8221;</a></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-ioc-component-scanning"></a>2.2.5.&nbsp;Autodetecting components in the classpath</h3></div></div><div></div></div><p>Spring 2.5 introduces support component scanning: autodetecting
      annotated components in the classpath. Typically, such component classes
      will be annotated with stereotypes such as <tt class="interfacename">@Component</tt>,
      <tt class="interfacename">@Repository</tt>, <tt class="interfacename">@Service</tt>,
      <tt class="interfacename">@Controller</tt>. Depending on the application
      context configuration, such component classes will be autodetected and
      turned into Spring bean definitions, not requiring explicit configuration
      for each such bean.</p><p>Annotation-driven bean configuration is discussed in <a href="#beans-stereotype-annotations" title="3.12.1.&nbsp;@Component and further stereotype&#xA;      annotations">Section&nbsp;3.12.1, &#8220;@Component and further stereotype
      annotations&#8221;</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-in-2-aop"></a>2.3.&nbsp;Aspect Oriented Programming (AOP)</h2></div></div><div></div></div><p>Spring 2.0 has a much improved AOP offering. The Spring AOP
    framework itself is markedly easier to configure in XML, and significantly
    less verbose as a result; and Spring 2.0 integrates with the AspectJ
    pointcut language and @AspectJ aspect declaration style. The chapter
    entitled <a href="#aop" title="Chapter&nbsp;6.&nbsp;Aspect Oriented Programming with Spring">Chapter&nbsp;6, <i>Aspect Oriented Programming with Spring</i></a> is dedicated to describing this new
    support.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-aop-configuration"></a>2.3.1.&nbsp;Easier AOP XML configuration</h3></div></div><div></div></div><p>Spring 2.0 introduces new schema support for defining aspects
      backed by regular Java objects. This support takes advantage of the
      AspectJ pointcut language and offers fully typed advice (i.e. no more
      casting and <tt class="literal">Object[]</tt> argument manipulation). Details
      of this support can be found in the section entitled <a href="#aop-schema" title="6.3.&nbsp;Schema-based AOP support">Section&nbsp;6.3, &#8220;Schema-based AOP support&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-aop-aspectj"></a>2.3.2.&nbsp;Support for @AspectJ aspects</h3></div></div><div></div></div><p>Spring 2.0 also supports aspects defined using the @AspectJ
      annotations. These aspects can be shared between AspectJ and Spring AOP,
      and require (honestly!) only some simple configuration. Said support for
      @AspectJ aspects is discussed in <a href="#aop-ataspectj" title="6.2.&nbsp;@AspectJ support">Section&nbsp;6.2, &#8220;@AspectJ support&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-aop-bean-pointcuts"></a>2.3.3.&nbsp;Support for bean name pointcut element</h3></div></div><div></div></div><p>Spring 2.5 introduces support for the <tt class="literal">bean(...)</tt>
      pointcut element, matching specific named beans according to Spring-defined
      bean names. See <a href="#aop-pointcuts-designators" title="6.2.3.1.&nbsp;Supported Pointcut Designators">Section&nbsp;6.2.3.1, &#8220;Supported Pointcut Designators&#8221;</a> for details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-aop-load-time-weaving"></a>2.3.4.&nbsp;Support for AspectJ load-time weaving</h3></div></div><div></div></div><p>Spring 2.5 introduces explicit support AspectJ load-time weaving,
      as alternative to the proxy-based AOP framework. The new
      <tt class="literal">context:load-time-weaver</tt> configuration element
      automatically activates AspectJ aspects as defined in AspectJ's
      <tt class="literal">META-INF/aop.xml</tt> descriptor, applying them to the
      current application context through registering a transformer with the
      underlying ClassLoader. Note that this only works in environments with
      class transformation support. Check out <a href="#aop-aj-ltw" title="6.8.4.&nbsp;Load-time weaving with AspectJ in the Spring Framework">Section&nbsp;6.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221;</a>
      for the capabilities and limitations.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-in-2-middle-tier"></a>2.4.&nbsp;The Middle Tier</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-middle-tier-transaction-configuration"></a>2.4.1.&nbsp;Easier configuration of declarative transactions in XML</h3></div></div><div></div></div><p>The way that transactions are configured in Spring 2.0 has been
      changed significantly. The previous 1.2.x style of configuration
      continues to be valid (and supported), but the new style is markedly
      less verbose and is the recommended style. Spring 2.0 also ships with an
      AspectJ aspects library that you can use to make pretty much any object
      transactional - even objects not created by the Spring IoC container.</p><p>Spring 2.5 supports convenient annotation-driven transaction
      management in combination with load-time weaving, through the use of
      <tt class="literal">context:load-time-weaver</tt> in combination with
      <tt class="literal">tx:annotation-driven mode="aspectj"</tt>.</p><p>The chapter entitled <a href="#transaction" title="Chapter&nbsp;9.&nbsp;Transaction management">Chapter&nbsp;9, <i>Transaction management</i></a> contains all
      of the details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-middle-tier-websphere"></a>2.4.2.&nbsp;Full WebSphere transaction management support</h3></div></div><div></div></div><p>Spring 2.5 explicitly supports IBM's WebSphere Application Server,
      in particular with respect to WebSphere's transaction manager.
      Transaction suspension is now fully supported through the use of
      WebSphere's new <tt class="interfacename">UOWManager</tt> API, which
      is available on WAS 6.0.2.19+ and 6.0.1.9+.</p><p>So if you run a Spring-based application on the WebSphere
      Application Server, we highly recommend to use Spring 2.5's
      <tt class="classname">WebSphereUowTransactionManager</tt> as your
      <tt class="interfacename">PlatformTransactionManager</tt> of choice.
      This is also IBM's official recommendation.</p><p>For automatic detection of the underlying JTA-based transaction
      platform, consider the use of Spring 2.5's new
      <tt class="literal">tx:jta-transaction-manager</tt> configuration element.
      This will autodetect BEA WebLogic and IBM WebSphere, registering the
      appropriate <tt class="interfacename">PlatformTransactionManager</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-middle-tier-jpa"></a>2.4.3.&nbsp;JPA</h3></div></div><div></div></div><p>Spring 2.0 ships with a JPA abstraction layer that is similar in
      intent to Spring's JDBC abstraction layer in terms of scope and general
      usage patterns.</p><p>If you are interested in using a JPA-implementation as the
      backbone of your persistence layer, the section entitled <a href="#orm-jpa" title="12.6.&nbsp;JPA">Section&nbsp;12.6, &#8220;JPA&#8221;</a> is dedicated to detailing Spring's support and
      value-add in this area.</p><p>Spring 2.5 upgrades its OpenJPA support to OpenJPA 1.0,
      with support for advanced features such as savepoints.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-middle-tier-async-jms"></a>2.4.4.&nbsp;Asynchronous JMS</h3></div></div><div></div></div><p>Prior to Spring 2.0, Spring's JMS offering was limited to sending
      messages and the <span class="emphasis"><em>synchronous</em></span> receiving of messages.
      This functionality (encapsulated in the
      <tt class="classname">JmsTemplate</tt> class) is great, but it doesn't
      address the requirement for the <span class="emphasis"><em>asynchronous</em></span>
      receiving of messages.</p><p>Spring 2.0 now ships with full support for the reception of
      messages in an asynchronous fashion, as detailed in the section entitled
      <a href="#jms-asynchronousMessageReception" title="19.4.2.&nbsp;Asynchronous Reception - Message-Driven POJOs">Section&nbsp;19.4.2, &#8220;Asynchronous Reception - Message-Driven POJOs&#8221;</a>.</p><p>As of Spring 2.5, the JCA style of setting up asynchronous
      message listeners is supported as well, through the
      <tt class="classname">GenericMessageEndpointManager</tt> facility.
      This is an alternative to the standard JMS listener facility, allowing
      closer integration with message brokers such as ActiveMQ and JORAM.
      See <a href="#jms-jca-message-endpoint-manager" title="19.5.&nbsp;Support for JCA Message Endpoints">Section&nbsp;19.5, &#8220;Support for JCA Message Endpoints&#8221;</a>.</p><p>Spring 2.5 also introduces an XML namespace for simplifying JMS
      configuration, offering concise configuration of a large numbers of
      listeners. This namespace supports both the standard JMS listener facility
      as well as the JCA setup style, with minimal changes in the configuration.
      See <a href="#jms-namespace" title="19.6.&nbsp;JMS Namespace Support">Section&nbsp;19.6, &#8220;JMS Namespace Support&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-middle-tier-jdbc"></a>2.4.5.&nbsp;JDBC</h3></div></div><div></div></div><p>There are some small (but nevertheless notable) new classes in the
      Spring Framework's JDBC support library. The first, <a href="#jdbc-NamedParameterJdbcTemplate" title="11.2.2.&nbsp;NamedParameterJdbcTemplate"><tt class="classname">NamedParameterJdbcTemplate</tt></a>,
      provides support for programming JDBC statements using named parameters
      (as opposed to programming JDBC statements using only classic
      placeholder (<tt class="literal">'?'</tt>) arguments.</p><p>Another of the new classes, the <a href="#jdbc-SimpleJdbcTemplate" title="11.2.3.&nbsp;SimpleJdbcTemplate"><tt class="classname">SimpleJdbcTemplate</tt></a>,
      is aimed at making using the <tt class="classname">JdbcTemplate</tt> even
      easier to use when you are developing against Java 5+ (Tiger).</p><p>Spring 2.5 significantly extends the functionality of
      <tt class="classname">SimpleJdbcTemplate</tt> and introduces
      <tt class="classname">SimpleJdbcCall</tt> and <tt class="classname">SimpleJdbcInsert</tt>
      operation objects.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-in-2-web"></a>2.5.&nbsp;The Web Tier</h2></div></div><div></div></div><p>The web tier support has been <span class="emphasis"><em>substantially</em></span>
    improved and expanded in Spring 2.0, with annotation-based controllers
    introduced in Spring 2.5.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-web-convention"></a>2.5.1.&nbsp;Sensible defaulting in Spring MVC</h3></div></div><div></div></div><p>For a lot of projects, sticking to established conventions and
      having reasonable defaults is just what the projects need... this theme
      of convention-over-configuration now has explicit support in Spring MVC.
      What this means is that if you establish a set of naming conventions for
      your <tt class="literal">Controllers</tt> and views, you can
      <span class="emphasis"><em>substantially</em></span> cut down on the amount of XML
      configuration that is required to setup handler mappings, view
      resolvers, <tt class="classname">ModelAndView</tt> instances, etc. This is a
      great boon with regards to rapid prototyping, and can also lend a degree
      of (always good-to-have) consistency across a codebase.</p><p>Spring MVC's convention-over-configuration support is detailed in
      the section entitled <a href="#mvc-coc" title="13.10.&nbsp;Convention over configuration">Section&nbsp;13.10, &#8220;Convention over configuration&#8221;</a></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-web-portlet"></a>2.5.2.&nbsp;Portlet framework</h3></div></div><div></div></div><p>Spring 2.0 ships with a Portlet framework that is conceptually
      similar to the Spring MVC framework. Detailed coverage of the Spring
      Portlet framework can be found in the section entitled <a href="#portlet" title="Chapter&nbsp;16.&nbsp;Portlet MVC Framework">Chapter&nbsp;16, <i>Portlet MVC Framework</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-web-annotations"></a>2.5.3.&nbsp;Annotation-based controllers</h3></div></div><div></div></div><p>Spring 2.5 introduces an annotation-based programming model for MVC
      controllers, using annotations such as <tt class="interfacename">@RequestMapping</tt>,
      <tt class="interfacename">@RequestParam</tt>, <tt class="interfacename">@ModelAttribute</tt>,
      etc. This annotation support is available for both Servlet MVC and Portlet
      MVC. Controllers implemented in this style do not have to extend specific 
      base classes or implement specific interfaces. Furthermore, they do not 
      usually have direct dependencies on Servlet or Portlet API's, although 
      they can easily get access to Servlet or Portlet facilities if desired.
      For further details, see <a href="#mvc-annotation" title="13.11.&nbsp;Annotation-based controller configuration">Section&nbsp;13.11, &#8220;Annotation-based controller configuration&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-web-form-tags"></a>2.5.4.&nbsp;A form tag library for Spring MVC</h3></div></div><div></div></div><p>A rich JSP tag library for Spring MVC was <span class="emphasis"><em>the</em></span>
      JIRA issue that garnered the most votes from Spring users (by a wide
      margin).</p><p>Spring 2.0 ships with a full featured JSP tag library that makes
      the job of authoring JSP pages much easier when using Spring MVC; the
      Spring team is confident it will satisfy all of those developers who
      voted for the issue on JIRA. The new tag library is itself covered in
      the section entitled <a href="#view-jsp-formtaglib" title="14.2.4.&nbsp;Using Spring's form tag library">Section&nbsp;14.2.4, &#8220;Using Spring's form tag library&#8221;</a>, and a quick
      reference to all of the new tags can be found in the appendix entitled
      <a href="#spring-form.tld" title="Appendix&nbsp;E.&nbsp;spring-form.tld">Appendix&nbsp;E, <i>spring-form.tld</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-web-tiles2"></a>2.5.5.&nbsp;Tiles 2 support</h3></div></div><div></div></div><p>Spring 2.5 ships support for Tiles 2, the next generation of the
      popular Tiles templating framework. This supersedes Spring's former support
      for Tiles 1, as included in Struts 1.x. See <a href="#view-tiles" title="14.3.&nbsp;Tiles">Section&nbsp;14.3, &#8220;Tiles&#8221;</a>
      for details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-web-jsf12"></a>2.5.6.&nbsp;JSF 1.2 support</h3></div></div><div></div></div><p>Spring 2.5 supports JSF 1.2, providing a JSF 1.2 variant of Spring's
      <tt class="classname">DelegatingVariableResolver</tt> in the form of the new
      <tt class="classname">SpringBeanFacesELResolver</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-web-jaxws"></a>2.5.7.&nbsp;JAX-WS support</h3></div></div><div></div></div><p>Spring 2.5 fully supports JAX-WS 2.0/2.1, as included in Java 6 and Java EE 5.
      JAX-WS is the successor of JAX-RPC, allowing access to WSDL/SOAP-based web
      services as well as JAX-WS style exposure of web services.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-in-2-other"></a>2.6.&nbsp;Everything else</h2></div></div><div></div></div><p>This final section outlines all of the other new and improved Spring
    2.0/2.5 features and functionality.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-other-dynamic-language-support"></a>2.6.1.&nbsp;Dynamic language support</h3></div></div><div></div></div><p>Spring 2.0 introduced support for beans written in languages other
      than Java, with the currently supported dynamic languages being JRuby,
      Groovy and BeanShell. This dynamic language support is comprehensively
      detailed in the section entitled <a href="#dynamic-language" title="Chapter&nbsp;24.&nbsp;Dynamic language support">Chapter&nbsp;24, <i>Dynamic language support</i></a>.</p><p>Spring 2.5 refines the dynamic languages support with autowiring
      and support for the recently released JRuby 1.0.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-other-testing"></a>2.6.2.&nbsp;Enhanced testing support</h3></div></div><div></div></div><p>Spring 2.5 introduces the <span class="emphasis"><em>Spring TestContext
      Framework</em></span> which provides annotation-driven unit and integration
      testing support that is agnostic of the actual testing framework in use.
      The same techniques and annotation-based configuration used in, for
      example, a JUnit 3.8 environment can also be applied to tests written with
      JUnit 4.4, TestNG, etc.</p><p>In addition to providing generic and extensible testing
      infrastructure, the <span class="emphasis"><em>Spring TestContext Framework</em></span>
      provides out-of-the-box support for Spring-specific integration testing
      functionality such as <a href="#testcontext-ctx-management" title="8.3.7.2.&nbsp;Context management and caching">context
      management and caching</a>, <a href="#testcontext-fixture-di" title="8.3.7.3.&nbsp;Dependency Injection of test fixtures">dependency injection of test
      fixtures</a>, and <a href="#testcontext-tx" title="8.3.7.4.&nbsp;Transaction management">transactional test
      management</a> with default rollback semantics.</p><p>To discover how this new testing support can assist you with writing
      unit and integration tests, consult <a href="#testcontext-framework" title="8.3.7.&nbsp;Spring TestContext Framework">Section&nbsp;8.3.7, &#8220;Spring TestContext Framework&#8221;</a>
      of the revised testing chapter.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-other-jmx"></a>2.6.3.&nbsp;JMX support</h3></div></div><div></div></div><p>The Spring Framework 2.0 has support for
      <tt class="literal">Notifications</tt>; it is also possible to exercise
      declarative control over the registration behavior of MBeans with an
      <tt class="literal">MBeanServer</tt>.</p><div class="itemizedlist"><ul type="disc"><li><a href="#jmx-notifications" title="20.7.&nbsp;Notifications">Section&nbsp;20.7, &#8220;Notifications&#8221;</a></li><li><a href="#jmx-exporting-registration-behavior" title="20.2.5.&nbsp;Controlling the registration behavior">Section&nbsp;20.2.5, &#8220;Controlling the registration behavior&#8221;</a></li></ul></div><p>Furthermore, Spring 2.5 provides a
      <a href="#jmx-context-mbeanexport" title="20.4.3.&nbsp;The <context:mbean-export/&gt; element"><tt class="literal">context:mbean-export</tt></a>
      configuration element for convenient registration of annotated bean classes,
      detecting Spring's <tt class="interfacename">@ManagedResource</tt> annotation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-other-jca"></a>2.6.4.&nbsp;Deploying a Spring application context as JCA adapter</h3></div></div><div></div></div><p>Spring 2.5 supports the deployment of a Spring application context
      as JCA resource adapter, packaged as a JCA RAR file. This allows headless
      application modules to be deployed into J2EE servers, getting access to
      all the server's infrastructure e.g. for executing scheduled tasks,
      listening for incoming messages, etc.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-other-taskexecutor"></a>2.6.5.&nbsp;Task scheduling</h3></div></div><div></div></div><p>Spring 2.0 offers an abstraction around the scheduling of tasks.
      For the interested developer, the section entitled <a href="#scheduling-task-executor" title="23.4.&nbsp;The Spring TaskExecutor abstraction">Section&nbsp;23.4, &#8220;The Spring TaskExecutor abstraction&#8221;</a> contains all of the
      details.</p><p>The <tt class="interfacename">TaskExecutor</tt> abstraction is used
      throughout the framework itself as well, e.g. for the asynchronous JMS support.
      In Spring 2.5, it is also used in the JCA environment support.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-other-java5"></a>2.6.6.&nbsp;Java 5 (Tiger) support</h3></div></div><div></div></div><p>Find below pointers to documentation describing some of the new
      Java 5 support in Spring 2.0 and 2.5.</p><div class="itemizedlist"><ul type="disc"><li><a href="#beans-annotation-config" title="3.11.&nbsp;Annotation-based configuration">Section&nbsp;3.11, &#8220;Annotation-based configuration&#8221;</a></li><li><a href="#metadata-annotations-required" title="25.3.1.&nbsp;@Required">Section&nbsp;25.3.1, &#8220;@Required&#8221;</a></li><li><a href="#transaction-declarative-annotations" title="9.5.6.&nbsp;Using @Transactional">Section&nbsp;9.5.6, &#8220;Using @Transactional&#8221;</a></li><li><a href="#jdbc-SimpleJdbcTemplate" title="11.2.3.&nbsp;SimpleJdbcTemplate">Section&nbsp;11.2.3, &#8220;SimpleJdbcTemplate&#8221;</a></li><li><a href="#orm-jpa" title="12.6.&nbsp;JPA">Section&nbsp;12.6, &#8220;JPA&#8221;</a></li><li><a href="#aop-ataspectj" title="6.2.&nbsp;@AspectJ support">Section&nbsp;6.2, &#8220;@AspectJ support&#8221;</a></li><li><a href="#aop-atconfigurable" title="6.8.1.&nbsp;Using AspectJ to dependency inject domain objects with&#xA;      Spring">Section&nbsp;6.8.1, &#8220;Using AspectJ to dependency inject domain objects with
      Spring&#8221;</a></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-in-2-migrating"></a>2.7.&nbsp;Migrating to Spring 2.5</h2></div></div><div></div></div><p>This final section details issues that may arise during any
    migration from Spring 1.2/2.0 to Spring 2.5.</p><p>Upgrading to Spring 2.5 from a Spring 2.0.x application should
    simply be a matter of dropping the Spring 2.5 jar into the appropriate
    location in your application's directory structure. We highly recommend
    upgrading to Spring 2.5 from any Spring 2.0 application that runs on
    JDK 1.4.2 or higher, in particular when running on Java 5 or higher,
    leveraging the significant configuration conveniences and performance
    improvements that Spring 2.5 has to offer.</p><p>Whether an upgrade from Spring 1.2.x will be as seamless depends on
    how much of the Spring APIs you are using in your code. Spring 2.0
    removed pretty much all of the classes and methods previously marked
    as deprecated in the Spring 1.2.x codebase, so if you have been using
    such classes and methods, you will of course have to use alternative
    classes and methods (some of which are summarized below).</p><p>With regards to configuration, Spring 1.2.x style XML configuration
    is 100%, satisfaction-guaranteed compatible with the Spring 2.5 library.
    Of course if you are still using the Spring 1.2.x DTD, then you won't be
    able to take advantage of some of the new Spring 2.0 functionality (such
    as <a href="#new-in-2-ioc-scopes" title="2.2.1.&nbsp;New bean scopes">scopes</a> and <a href="#new-in-2-aop-configuration" title="2.3.1.&nbsp;Easier AOP XML configuration">easier AOP</a> and <a href="#new-in-2-middle-tier-transaction-configuration" title="2.4.1.&nbsp;Easier configuration of declarative transactions in XML">transaction
    configuration</a>), but nothing will blow up.</p><p>The suggested migration strategy is to drop in the Spring 2.5 jar(s)
    to benefit from the improved code present in the release (bug fixes,
    optimizations, etc.). You can then, on an incremental basis, choose to
    start using the new Spring 2.5 features and configuration. For example,
    you could choose to start configuring just your aspects in the new Spring
    2 style; it is perfectly valid to have 90% of your configuration using
    the old-school Spring 1.2.x configuration (which references the 1.2.x
    DTD), and have the other 10% using the new Spring 2 configuration (which
    references the 2.0/2.5 DTD or XSD). Bear in mind that you are not forced to
    upgrade your XML configuration should you choose to drop in the Spring 2.5
    libraries.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="new-in-2-migrating-changes"></a>2.7.1.&nbsp;Changes</h3></div></div><div></div></div><p>For a comprehensive list of changes, consult the
      <tt class="filename">'changelog.txt'</tt> file that is located in the top
      level directory of the Spring Framework distribution.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="new-in-2-migrating-jdk"></a>2.7.1.1.&nbsp;Supported JDK versions</h4></div></div><div></div></div><p>As of Spring 2.5, support for JDK 1.3 has been removed,
        following Sun's official deprecation of JDK 1.3 in late 2006.
        If you haven't done so already, upgrade to JDK 1.4.2 or higher.</p><p>If you need to stick with an application server that only supports
        JDK 1.3, such as WebSphere 4.0 or 5.0, we recommend using the
        Spring Framework version 2.0.7/2.0.8 which still supports JDK 1.3.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="new-in-2-migrating-packaging"></a>2.7.1.2.&nbsp;Jar packaging in Spring 2.5</h4></div></div><div></div></div><p>As of Spring 2.5, Spring Web MVC is no longer part of the
        <tt class="filename">'spring.jar'</tt> file. Spring MVC
        can be found in <tt class="filename">'spring-webmvc.jar'</tt>
        and <tt class="filename">'spring-webmvc-portlet.jar'</tt>
        in the <tt class="literal">lib/modules</tt> directory of the distribution.
        Furthermore, the Struts 1.x support has been factored out into
        <tt class="filename">'spring-webmvc-struts.jar'</tt>.</p><p><span class="emphasis"><em>Note: The commonly used Spring's <tt class="classname">DispatcherServlet</tt>
        is part of Spring's Web MVC framework.</em></span> As a consequence,
        you need to add <tt class="filename">'spring-webmvc.jar'</tt>
        (or <tt class="filename">'spring-webmvc-portlet/struts.jar'</tt>)
        to a <tt class="filename">'spring.jar'</tt> scenario,
        even if you are just using <tt class="classname">DispatcherServlet</tt>
        for remoting purposes (e.g. exporting Hessian or HTTP invoker services).</p><p>Spring 2.0's <tt class="filename">'spring-jmx.jar'</tt>
        and <tt class="filename">'spring-remoting.jar'</tt> have been
        merged into Spring 2.5's <tt class="filename">'spring-context.jar'</tt>
        (for the JMX and non-HTTP remoting support) and partly into
        <tt class="filename">'spring-web.jar'</tt>
        (for the HTTP remoting support).</p><p>Spring 2.0's <tt class="filename">'spring-support.jar'</tt>
        has been renamed to <tt class="filename">'spring-context-support.jar'</tt>,
        expressing the actual support relationship more closely.
        <tt class="filename">'spring-portlet.jar'</tt> has been
        renamed to <tt class="filename">'spring-webmvc-portlet.jar'</tt>,
        since it is technically a submodule of Spring's Web MVC framework.
        Analogously, <tt class="filename">'spring-struts.jar'</tt>
        has been renamed to <tt class="filename">'spring-webmvc-struts.jar'</tt>.
        </p><p>Spring 2.0's <tt class="filename">'spring-jdo.jar'</tt>,
        <tt class="filename">'spring-jpa.jar'</tt>,
        <tt class="filename">'spring-hibernate3.jar'</tt>,
        <tt class="filename">'spring-toplink.jar'</tt>
        and <tt class="filename">'spring-ibatis.jar'</tt>
        have been combined into Spring 2.5's coarse-granular
        <tt class="filename">'spring-orm.jar'</tt>.</p><p>Spring 2.5's <tt class="filename">'spring-test.jar'</tt>
        supersedes the previous <tt class="filename">'spring-mock.jar'</tt>,
        indicating the stronger focus on the test context framework.
        Note that <tt class="filename">'spring-test.jar'</tt>
        contains everything <tt class="filename">'spring-mock.jar'</tt>
        contained in previous Spring versions; hence it can be used as a
        straightforward replacement for unit and integration testing purposes.</p><p>Spring 2.5's <tt class="filename">'spring-tx.jar'</tt>
        supersedes the previous <tt class="filename">'spring-dao.jar'</tt>
        and <tt class="filename">'spring-jca.jar'</tt> files,
        indicating the stronger focus on the transaction framework.</p><p>Spring 2.5 ships its framework jars as OSGi-compliant bundles
        out of the box. This facilitates use of Spring in OSGi environments,
        not requiring custom packaging anymore.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="new-in-2-migrating-xml-configuration"></a>2.7.1.3.&nbsp;XML configuration</h4></div></div><div></div></div><p>Spring 2.0 ships with XSDs that describe Spring's XML metadata
        format in a much richer fashion than the DTD that shipped with
        previous versions. The old DTD is still fully supported, but if
        possible you are encouraged to reference the XSD files at the top of
        your bean definition files.</p><p>One thing that has changed in a (somewhat) breaking fashion is
        the way that bean scopes are defined. If you are using the Spring 1.2
        DTD you can continue to use the <tt class="literal">'singleton'</tt>
        attribute. You can however choose to <a href="#new-in-2-ioc-configuration" title="2.2.2.&nbsp;Easier XML configuration">reference the new Spring 2.0
        DTD</a> which does not permit the use of the
        <tt class="literal">'singleton'</tt> attribute, but rather uses the
        <tt class="literal">'scope'</tt> attribute to define the bean lifecycle
        scope.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="new-in-2-migrating-deprecated"></a>2.7.1.4.&nbsp;Deprecated classes and methods</h4></div></div><div></div></div><p>A number of classes and methods that previously were marked as
        <tt class="literal">@deprecated</tt> have been removed from the Spring 2.0
        codebase. The Spring team decided that the 2.0 release marked a fresh
        start of sorts, and that any deprecated 'cruft' was better excised now
        instead of continuing to haunt the codebase for the foreseeable
        future.</p><p>As mentioned previously, for a comprehensive list of changes,
        consult the <tt class="filename">'changelog.txt'</tt> file that is located
        in the top level directory of the Spring Framework distribution.</p><p>The following classes/interfaces have been removed as of Spring
        2.0:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="interfacename">ResultReader</tt> : Use the
            <tt class="interfacename">RowMapper</tt> interface instead.</p></li><li><p><tt class="classname">BeanFactoryBootstrap</tt> : Consider using
            a <tt class="interfacename">BeanFactoryLocator</tt> or a custom
            bootstrap class instead.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="new-in-2-migrating-ojb"></a>2.7.1.5.&nbsp;Apache OJB</h4></div></div><div></div></div><p>As of Spring 2.0, support for Apache OJB was <span class="emphasis"><em>totally
        removed</em></span> from the main Spring source tree. The Apache OJB
        integration library is still available, but can be found in its new
        home in the <a href="https://springmodules.dev.java.net/" target="_top">Spring
        Modules project</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="new-in-2-migrating-ibatis"></a>2.7.1.6.&nbsp;iBATIS</h4></div></div><div></div></div><p>Please note that support for iBATIS SQL Maps 1.3 has been removed.
        If you haven't done so already, upgrade to iBATIS SQL Maps 2.3.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="new-in-2-migrating-hibernate"></a>2.7.1.7.&nbsp;Hibernate</h4></div></div><div></div></div><p>As of Spring 2.5, support for Hibernate 2.1 and Hibernate 3.0
        has been removed. If you haven't done so already, upgrade to
        Hibernate 3.1 or higher.</p><p>If you need to stick with Hibernate 2.1 or 3.0 for the time
        being, we recommend to keep using the Spring Framework version
        2.0.7/2.0.8 which still supports those versions of Hibernate.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="new-in-2-migrating-jdo"></a>2.7.1.8.&nbsp;JDO</h4></div></div><div></div></div><p>As of Spring 2.5, support for JDO 1.0 has been removed.
        If you haven't done so already, upgrade to JDO 2.0 or higher.</p><p>If you need to stick with JDO 1.0 for the time being,
        we recommend to keep using the Spring Framework version
        2.0.7/2.0.8 which still supports that version of JDO.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="new-in-2-migrating-UrlFilenameViewController"></a>2.7.1.9.&nbsp;<tt class="classname">UrlFilenameViewController</tt></h4></div></div><div></div></div><p>Since Spring 2.0, the view name that is determined by the
        <tt class="classname">UrlFilenameViewController</tt> now takes into
        account the nested path of the request. This is a breaking change
        from the original contract of the
        <tt class="classname">UrlFilenameViewController</tt>, and means that if
        you are upgrading from Spring 1.x to Spring 2.x and you are using this
        class you <span class="emphasis"><em>might</em></span> have to change your Spring Web
        MVC configuration slightly. Refer to the class level Javadocs of the
        <tt class="classname">UrlFilenameViewController</tt> to see examples of
        the new contract for view name determination.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-in-2-other-applications"></a>2.8.&nbsp;Updated sample applications</h2></div></div><div></div></div><p>A number of the sample applications have also been updated to
    showcase the new and improved features of Spring 2.0. So do take the time
    to investigate them. The aforementioned sample applications can be found
    in the <tt class="filename">'samples'</tt> directory of the
    full Spring distribution
    (<tt class="filename">'spring-with-dependencies.[zip|tar.gz]'</tt>).</p><p>Spring 2.5 features revised versions of the PetClinic and PetPortal sample
    applications, reengineered from the ground up for leveraging Spring 2.5's
    annotation configuration features. It also uses Java 5 autoboxing, generics,
    varargs and the enhanced for loop. A Java 5 or 6 SDK is now required to build and
    run the sample. Check out PetClinic and PetPortal to get an impression of what
    Spring 2.5 has to offer!</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="new-in-2-other-documentation"></a>2.9.&nbsp;Improved documentation</h2></div></div><div></div></div><p>The Spring reference documentation has also substantially been
    updated to reflect all of the above features new in Spring 2.0 and 2.5. 
    While every effort has been made to ensure that there are no errors in this
    documentation, some errors may nevertheless have crept in. If you do spot
    any typos or even more serious errors, and you can spare a few cycles
    during lunch, please do bring the error to the attention of the Spring
    team by <a href="http://opensource.atlassian.com/projects/spring/" target="_top">raising an
    issue</a>.</p><p>Special thanks to Arthur Loder for his tireless proofreading of the
    Spring Framework reference documentation and JavaDocs.</p></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="spring-core"></a>Core Technologies</h1></div></div><div></div></div><div class="partintro" lang="en"><div><div></div><div></div></div><p>
				This initial part of the reference documentation covers
				all of those technologies that are absolutely integral
				to the Spring Framework.
			</p><p>
				Foremost amongst these is the Spring Framework's
				Inversion of Control (IoC) container. A thorough treatment
				of the Spring Framework's IoC container is closely followed
				by comprehensive coverage of Spring's Aspect-Oriented
				Programming (AOP) technologies. The Spring Framework has
				its own AOP	framework, which is conceptually easy to understand,
				and	which successfully addresses the 80% sweet spot of AOP
				requirements in Java enterprise programming.
			</p><p>
				Coverage of Spring's integration with AspectJ (currently
				the richest - in terms of features - and certainly most
				mature AOP implementation in the Java enterprise space)
				is also provided.
			</p><p>
			    Finally, the adoption of the test-driven-development (TDD)
			    approach to software development is certainly advocated by
			    the Spring team, and so coverage of Spring's support for
			    integration testing is covered (alongside best practices for
			    unit testing). The Spring team have found that the correct
			    use of IoC certainly does make both unit and integration
			    testing easier (in that the presence of setter methods and
			    appropriate constructors on classes makes them
			    easier to wire together on a test without having to set up
			    service locator registries and suchlike)... the chapter
			    dedicated solely to testing will hopefully convince you of
			    this as well.
			</p><div class="itemizedlist"><ul type="disc"><li><p><a href="#beans" title="Chapter&nbsp;3.&nbsp;The IoC container">Chapter&nbsp;3, <i>The IoC container</i></a></p></li><li><p><a href="#resources" title="Chapter&nbsp;4.&nbsp;Resources">Chapter&nbsp;4, <i>Resources</i></a></p></li><li><p><a href="#validation" title="Chapter&nbsp;5.&nbsp;Validation, Data-binding, the BeanWrapper, and PropertyEditors">Chapter&nbsp;5, <i>Validation, Data-binding, the BeanWrapper, and PropertyEditors</i></a></p></li><li><p><a href="#aop" title="Chapter&nbsp;6.&nbsp;Aspect Oriented Programming with Spring">Chapter&nbsp;6, <i>Aspect Oriented Programming with Spring</i></a></p></li><li><p><a href="#aop-api" title="Chapter&nbsp;7.&nbsp;Spring AOP APIs">Chapter&nbsp;7, <i>Spring AOP APIs</i></a></p></li><li><p><a href="#testing" title="Chapter&nbsp;8.&nbsp;Testing">Chapter&nbsp;8, <i>Testing</i></a></p></li></ul></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="beans"></a>Chapter&nbsp;3.&nbsp;The IoC container</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-introduction"></a>3.1.&nbsp;Introduction</h2></div></div><div></div></div><p>This chapter covers the Spring Framework's implementation of the
    Inversion of Control (IoC)
    <sup>[<a name="d0e1168" href="#ftn.d0e1168">1</a>]</sup>
    principle.</p><div class="sidebar"><p class="title"><b><tt class="interfacename">BeanFactory</tt> or
      <tt class="interfacename">ApplicationContext</tt>?</b></p><p>Users are sometimes unsure whether a
      <tt class="interfacename">BeanFactory</tt> or an
      <tt class="interfacename">ApplicationContext</tt> is best suited for use
      in a particular situation. A <tt class="interfacename">BeanFactory</tt>
      pretty much just instantiates and configures beans. An
      <tt class="interfacename">ApplicationContext</tt> also does that,
      <span class="emphasis"><em>and</em></span> it provides the supporting infrastructure to
      enable <span class="emphasis"><em>lots</em></span> of enterprise-specific features such as
      transactions and AOP.</p><p><span class="bold"><b>In short, favor the use of an
      <tt class="interfacename">ApplicationContext</tt>.</b></span></p><p>(For the specific details behind this recommendation, see <a href="#context-introduction-ctx-vs-beanfactory" title="3.8.1.&nbsp;BeanFactory or&#xA;      ApplicationContext?">this
      section</a>.)</p></div><p>The <tt class="literal">org.springframework.beans</tt> and
    <tt class="literal">org.springframework.context</tt> packages provide the basis
    for the Spring Framework's IoC container. The <tt class="interfacename"><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/BeanFactory.html" target="_top">BeanFactory</a></tt>
    interface provides an advanced configuration mechanism capable of managing
    objects of any nature. The <tt class="literal"><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" target="_top">ApplicationContext</a></tt>
    interface builds on top of the <tt class="interfacename">BeanFactory</tt>
    (it is a sub-interface) and adds other functionality such as easier
    integration with Spring's AOP features, message resource handling (for use
    in internationalization), event propagation, and application-layer
    specific contexts such as the
    <tt class="interfacename">WebApplicationContext</tt> for use in web
    applications.</p><p>In short, the <tt class="interfacename">BeanFactory</tt> provides
    the configuration framework and basic functionality, while the
    <tt class="interfacename">ApplicationContext</tt> adds more
    enterprise-centric functionality to it. The
    <tt class="interfacename">ApplicationContext</tt> is a complete superset
    of the <tt class="interfacename">BeanFactory</tt>, and any description of
    <tt class="interfacename">BeanFactory</tt> capabilities and behavior is to
    be considered to apply to the
    <tt class="interfacename">ApplicationContext</tt> as well.</p><p>This chapter is divided into two parts, with the <a href="#beans-basics" title="3.2.&nbsp;Basics - containers and beans">first part</a> covering the basic principles
    that apply to both the <tt class="interfacename">BeanFactory</tt> and
    <tt class="interfacename">ApplicationContext</tt>, and with the <a href="#context-introduction" title="3.8.&nbsp;The ApplicationContext">second part</a> covering those features
    that apply only to the <tt class="interfacename">ApplicationContext</tt>
    interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-basics"></a>3.2.&nbsp;Basics - containers and beans</h2></div></div><div></div></div><p>In Spring, those objects that form the backbone of your application
    and that are managed by the Spring IoC <i class="firstterm">container</i>
    are referred to as <i class="firstterm">beans</i>. A bean is simply an
    object that is instantiated, assembled and otherwise managed by a Spring
    IoC container; other than that, there is nothing special about a bean (it
    is in all other respects one of probably many objects in your
    application). These beans, and the <i class="firstterm">dependencies</i>
    between them, are reflected in the <i class="firstterm">configuration
    metadata</i> used by a container.</p><div class="sidebar"><p class="title"><b>Why... <span class="emphasis"><em>bean</em></span>?</b></p><p>The motivation for using the name <span class="emphasis"><em>'bean'</em></span>, as
      opposed to <span class="emphasis"><em>'component'</em></span> or
      <span class="emphasis"><em>'object'</em></span> is rooted in the origins of the Spring
      Framework itself (it arose partly as a response to the complexity of
      Enterprise Java<span class="emphasis"><em>Beans</em></span>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory"></a>3.2.1.&nbsp;The container</h3></div></div><div></div></div><p>The
      <tt class="interfacename">org.springframework.beans.factory.BeanFactory</tt>
      is the actual representation of the Spring IoC
      <span class="emphasis"><em>container</em></span> that is responsible for containing and
      otherwise managing the aforementioned beans.</p><p>The <tt class="interfacename">BeanFactory</tt> interface is the
      central IoC container interface in Spring. Its responsibilities include
      instantiating or sourcing application objects, configuring such objects,
      and assembling the dependencies between these objects.</p><p>There are a number of implementations of the
      <tt class="interfacename">BeanFactory</tt> interface that come supplied
      straight out-of-the-box with Spring. The most commonly used
      <tt class="interfacename">BeanFactory</tt> implementation is the
      <tt class="classname">XmlBeanFactory</tt> class. This implementation allows
      you to express the objects that compose your application, and the
      doubtless rich interdependencies between such objects, in terms of XML.
      The <tt class="classname">XmlBeanFactory</tt> takes this XML
      <i class="firstterm">configuration metadata</i> and uses it to create a
      fully configured system or application.</p><p>
        </p><div class="mediaobject" align="center"><img src="images/container-magic.png" align="middle"><div class="caption"><p>The Spring IoC container</p></div></div><p>
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-metadata"></a>3.2.1.1.&nbsp;Configuration metadata</h4></div></div><div></div></div><p>As can be seen in the above image, the Spring IoC container
        consumes some form of <span class="emphasis"><em>configuration metadata</em></span>;
        this configuration metadata is nothing more than how you (as an
        application developer) inform the Spring container as to how to
        <span class="emphasis"><em>&#8220;<span class="quote">instantiate, configure, and assemble [the objects in
        your application]</span>&#8221;.</em></span> This configuration metadata is
        typically supplied in a simple and intuitive XML format. When using
        XML-based configuration metadata, you write <span class="emphasis"><em>bean
        definitions</em></span> for those beans that you want the Spring IoC
        container to manage, and then let the container do its stuff.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>XML-based metadata is by far the most commonly used form of
          configuration metadata. It is <span class="emphasis"><em>not</em></span> however the
          only form of configuration metadata that is allowed. The Spring IoC
          container itself is <span class="emphasis"><em>totally</em></span> decoupled from the
          format in which this configuration metadata is actually written. The
          XML-based configuration metadata format really is simple though, and
          so the majority of this chapter will use the XML format to convey
          key concepts and features of the Spring IoC container.</p><p>You can find details of another form of metadata that the
          Spring container can consume in the section entitled <a href="#beans-annotation-config" title="3.11.&nbsp;Annotation-based configuration">Section&nbsp;3.11, &#8220;Annotation-based configuration&#8221;</a></p></td></tr></table></div></div><div class="sidebar"><p class="title"><b>Resources</b></p><p>The location path or paths supplied to an
        <tt class="interfacename">ApplicationContext</tt> constructor are
        actually resource strings that allow the container to load
        configuration metadata from a variety of external resources such as
        the local file system, from the Java <tt class="literal">CLASSPATH</tt>,
        etc.</p><p>Once you have learned about Spring's IoC container, you may wish
        to learn a little more about Spring's
        <tt class="interfacename">Resource</tt> abstraction, as described in
        the chapter entitled <a href="#resources" title="Chapter&nbsp;4.&nbsp;Resources">Chapter&nbsp;4, <i>Resources</i></a>.</p></div><p>In the vast majority of application scenarios, explicit user code
      is not required to instantiate one or more instances of a Spring IoC
      container. For example, in a web application scenario, a simple eight
      (or so) lines of boilerplate J2EE web descriptor XML in the
      <tt class="literal">web.xml</tt> file of the application will typically
      suffice (see <a href="#context-create" title="3.8.5.&nbsp;Convenient ApplicationContext&#xA;      instantiation for web applications">Section&nbsp;3.8.5, &#8220;Convenient ApplicationContext
      instantiation for web applications&#8221;</a>).</p></div><p>Spring configuration consists of at least one bean definition that
    the container must manage, but typically there will be more than one bean
    definition. When using XML-based configuration metadata, these beans are
    configured as <tt class="literal">&lt;bean/&gt;</tt> elements inside a top-level
    <tt class="literal">&lt;beans/&gt;</tt> element.</p><p>These bean definitions correspond to the actual objects that make up
    your application. Typically you will have bean definitions for your
    service layer objects, your data access objects (DAOs), presentation
    objects such as Struts <tt class="interfacename">Action</tt> instances,
    infrastructure objects such as Hibernate
    <tt class="interfacename">SessionFactories</tt>, JMS
    <tt class="interfacename">Queues</tt>, and so forth. Typically one does
    not configure fine-grained domain objects in the container, because it is
    usually the responsibility of DAOs and business logic to create/load
    domain objects.</p><p>Find below an example of the basic structure of XML-based
    configuration metadata.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

  &lt;bean id="..." class="..."&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></i>
  &lt;/bean&gt;

  &lt;bean id="..." class="..."&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- collaborators and configuration for this bean go here --&gt;</span></i>
  &lt;/bean&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- more bean definitions go here --&gt;</span></i>

&lt;/beans&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-instantiation"></a>3.2.2.&nbsp;Instantiating a container</h3></div></div><div></div></div><p>Instantiating a Spring IoC container is straightforward.</p><pre class="programlisting">ApplicationContext context = new ClassPathXmlApplicationContext(
        new String[] {"services.xml", "daos.xml"});

<i class="lineannotation"><span class="lineannotation">// an <tt class="interfacename">ApplicationContext</tt> is also a <tt class="interfacename">BeanFactory</tt> (via inheritance)</span></i>
BeanFactory factory = context;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-xml-import"></a>3.2.2.1.&nbsp;Composing XML-based configuration metadata</h4></div></div><div></div></div><p>It can often be useful to split up container definitions into
        multiple XML files. One way to then load an application context which
        is configured from all these XML fragments is to use the application
        context constructor which takes multiple
        <tt class="interfacename">Resource</tt> locations. With a bean
        factory, a bean definition reader can be used multiple times to read
        definitions from each file in turn.</p><p>Generally, the Spring team prefers the above approach, since it
        keeps container configuration files unaware of the fact that they are
        being combined with others. An alternate approach is to use one or
        more occurrences of the <tt class="literal">&lt;import/&gt;</tt> element to
        load bean definitions from another file (or files). Let's look at a
        sample:</p><pre class="programlisting">&lt;beans&gt;

    &lt;import resource="services.xml"/&gt;
    &lt;import resource="resources/messageSource.xml"/&gt;
    &lt;import resource="/resources/themeSource.xml"/&gt;

    &lt;bean id="bean1" class="..."/&gt;
    &lt;bean id="bean2" class="..."/&gt;

&lt;/beans&gt;</pre><p>In this example, external bean definitions are being loaded from
        3 files, <tt class="literal">services.xml</tt>,
        <tt class="literal">messageSource.xml</tt>, and
        <tt class="literal">themeSource.xml</tt>. All location paths are considered
        relative to the definition file doing the importing, so
        <tt class="literal">services.xml</tt> in this case must be in the same
        directory or classpath location as the file doing the importing, while
        <tt class="literal">messageSource.xml</tt> and
        <tt class="literal">themeSource.xml</tt> must be in a
        <tt class="literal">resources</tt> location below the location of the
        importing file. As you can see, a leading slash is actually ignored,
        but given that these are considered relative paths, it is probably
        better form not to use the slash at all. The contents of the files
        being imported must be valid XML bean definition files according to
        the Spring Schema or DTD, including the top level
        <tt class="literal">&lt;beans/&gt;</tt> element.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>It is possible to reference files in parent directories using a relative "../"
        path. However, this is not recommended because it creates a dependency on a file
        that is outside the current application. This is in particular not recommended
        for "classpath:" URLs (e.g. "classpath:../services.xml") where the runtime
        resolution process will pick the "nearest" classpath root and then look into
        its parent directory. This is fragile since classpath configuration changes
        may lead to a different directory being picked.</p><p>Note that you can always use fully qualified resource locations
        instead of relative paths: e.g. "file:C:/config/services.xml" or
        "classpath:/config/services.xml". However, be aware that you are coupling
        your application's configuration to specific absolute locations then.
        It is generally preferable to keep an indirection for such absolute
        locations, e.g. through "${...}" placeholders that are resolved
        against JVM system properties at runtime.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-definition"></a>3.2.3.&nbsp;The beans</h3></div></div><div></div></div><p>A Spring IoC container manages one or more
      <span class="emphasis"><em>beans</em></span>. These beans are created using the
      configuration metadata that has been supplied to the container
      (typically in the form of XML <tt class="literal">&lt;bean/&gt;</tt>
      definitions).</p><p>Within the container itself, these bean definitions are
      represented as <tt class="interfacename">BeanDefinition</tt> objects,
      which contain (among other information) the following metadata:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>a package-qualified class name:</em></span> typically
          this is the actual implementation class of the bean being
          defined.</p></li><li><p>bean behavioral configuration elements, which state how the
          bean should behave in the container (scope, lifecycle callbacks, and
          so forth).</p></li><li><p>references to other beans which are needed for the bean to do
          its work; these references are also called
          <span class="emphasis"><em>collaborators</em></span> or
          <span class="emphasis"><em>dependencies</em></span>.</p></li><li><p>other configuration settings to set in the newly created
          object. An example would be the number of connections to use in a
          bean that manages a connection pool, or the size limit of the
          pool.</p></li></ul></div><p>The concepts listed above directly translate to a set of
      properties that each bean definition consists of. Some of these
      properties are listed below, along with a link to further documentation
      about each of them.</p><div class="table"><a name="beans-factory-bean-definition-tbl"></a><p class="title"><b>Table&nbsp;3.1.&nbsp;The bean definition</b></p><table summary="The bean definition" border="1"><colgroup><col><col></colgroup><thead><tr><th>Feature</th><th>Explained in...</th></tr></thead><tbody><tr><td>class</td><td><p>
                  <a href="#beans-factory-class" title="3.2.3.2.&nbsp;Instantiating beans">Section&nbsp;3.2.3.2, &#8220;Instantiating beans&#8221;</a>
                </p></td></tr><tr><td>name</td><td><p>
                  <a href="#beans-beanname" title="3.2.3.1.&nbsp;Naming beans">Section&nbsp;3.2.3.1, &#8220;Naming beans&#8221;</a>
                </p></td></tr><tr><td>scope</td><td><p>
                  <a href="#beans-factory-scopes" title="3.4.&nbsp;Bean scopes">Section&nbsp;3.4, &#8220;Bean scopes&#8221;</a>
                </p></td></tr><tr><td>constructor arguments</td><td><p>
                  <a href="#beans-factory-collaborators" title="3.3.1.&nbsp;Injecting dependencies">Section&nbsp;3.3.1, &#8220;Injecting dependencies&#8221;</a>
                </p></td></tr><tr><td>properties</td><td><p>
                  <a href="#beans-factory-collaborators" title="3.3.1.&nbsp;Injecting dependencies">Section&nbsp;3.3.1, &#8220;Injecting dependencies&#8221;</a>
                </p></td></tr><tr><td>autowiring mode</td><td><p>
                  <a href="#beans-factory-autowire" title="3.3.5.&nbsp;Autowiring collaborators">Section&nbsp;3.3.5, &#8220;Autowiring collaborators&#8221;</a>
                </p></td></tr><tr><td>dependency checking mode</td><td><p>
                  <a href="#beans-factory-dependencies" title="3.3.6.&nbsp;Checking for dependencies">Section&nbsp;3.3.6, &#8220;Checking for dependencies&#8221;</a>
                </p></td></tr><tr><td>lazy-initialization mode</td><td><p>
                  <a href="#beans-factory-lazy-init" title="3.3.4.&nbsp;Lazily-instantiated beans">Section&nbsp;3.3.4, &#8220;Lazily-instantiated beans&#8221;</a>
                </p></td></tr><tr><td>initialization method</td><td><p>
                  <a href="#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&nbsp;Initialization callbacks">Section&nbsp;3.5.1.1, &#8220;Initialization callbacks&#8221;</a>
                </p></td></tr><tr><td>destruction method</td><td><p>
                  <a href="#beans-factory-lifecycle-disposablebean" title="3.5.1.2.&nbsp;Destruction callbacks">Section&nbsp;3.5.1.2, &#8220;Destruction callbacks&#8221;</a>
                </p></td></tr></tbody></table></div><p>Besides bean definitions which contain information on how to
      create a specific bean, certain
      <tt class="interfacename">BeanFactory</tt> implementations also permit
      the registration of existing objects that have been created outside the
      factory (by user code). The
      <tt class="classname">DefaultListableBeanFactory</tt> class supports this
      through the <tt class="methodname">registerSingleton(..)</tt> method.
      (Typical applications solely work with beans defined through metadata
      bean definitions though.)</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-beanname"></a>3.2.3.1.&nbsp;Naming beans</h4></div></div><div></div></div><div class="sidebar"><p class="title"><b>Bean naming conventions</b></p><p>The convention (at least amongst the Spring development team)
          is to use the standard Java convention for instance field names when
          naming beans. That is, bean names start with a lowercase letter, and
          are camel-cased from then on. Examples of such names would be
          (without quotes) <tt class="literal">'accountManager'</tt>,
          <tt class="literal">'accountService'</tt>, <tt class="literal">'userDao'</tt>,
          <tt class="literal">'loginController'</tt>, and so forth.</p><p>Adopting a consistent way of naming your beans will go a long
          way towards making your configuration easier to read and understand;
          adopting such naming standards is not hard to do, and if you are
          using Spring AOP it can pay off handsomely when it comes to applying
          advice to a set of beans related by name.</p></div><p>Every bean has one or more <tt class="literal">id</tt>s (also called
        identifiers, or names; these terms refer to the same thing). These
        <tt class="literal">id</tt>s must be unique within the container the bean is
        hosted in. A bean will almost always have only one id, but if a bean
        has more than one id, the extra ones can essentially be considered
        aliases.</p><p>When using XML-based configuration metadata, you use the
        <tt class="literal">'id'</tt> or <tt class="literal">'name'</tt> attributes to
        specify the bean identifier(s). The <tt class="literal">'id'</tt> attribute
        allows you to specify exactly one id, and as it is a real XML element
        ID attribute, the XML parser is able to do some extra validation when
        other elements reference the id; as such, it is the preferred way to
        specify a bean id. However, the XML specification does limit the
        characters which are legal in XML IDs. This is usually not a
        constraint, but if you have a need to use one of these special XML
        characters, or want to introduce other aliases to the bean, you may
        also or instead specify one or more bean <tt class="literal">id</tt>s,
        separated by a comma (<tt class="literal">,</tt>), semicolon
        (<tt class="literal">;</tt>), or whitespace in the <tt class="literal">'name'</tt>
        attribute.</p><p>Please note that you are not required to supply a name for a
        bean. If no name is supplied explicitly, the container will generate a
        unique name for that bean. The motivations for not supplying a name
        for a bean will be discussed later (one use case is <a href="#beans-inner-beans" title="3.3.2.3.&nbsp;Inner beans">inner beans</a>).</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-beanname-alias"></a>3.2.3.1.1.&nbsp;Aliasing beans</h5></div></div><div></div></div><p>In a bean definition itself, you may supply more than one name
          for the bean, by using a combination of up to one name specified via
          the <tt class="literal">id</tt> attribute, and any number of other names
          via the <tt class="literal">name</tt> attribute. All these names can be
          considered equivalent aliases to the same bean, and are useful for
          some situations, such as allowing each component used in an
          application to refer to a common dependency using a bean name that
          is specific to that component itself.</p><p>Having to specify all aliases when the bean is actually
          defined is not always adequate however. It is sometimes desirable to
          introduce an alias for a bean which is defined elsewhere. In
          XML-based configuration metadata this may be accomplished via the
          use of the <tt class="literal">&lt;alias/&gt;</tt> element.</p><pre class="programlisting">&lt;alias name="fromName" alias="toName"/&gt;</pre><p>In this case, a bean in the same container which is named
          <tt class="literal">'fromName'</tt>, may also after the use of this alias
          definition, be referred to as <tt class="literal">'toName'</tt>.</p><p>As a concrete example, consider the case where component A
          defines a DataSource bean called componentA-dataSource, in its XML
          fragment. Component B would however like to refer to the DataSource
          as componentB-dataSource in its XML fragment. And the main
          application, MyApp, defines its own XML fragment and assembles the
          final application context from all three fragments, and would like
          to refer to the DataSource as myApp-dataSource. This scenario can be
          easily handled by adding to the MyApp XML fragment the following
          standalone aliases:</p><pre class="programlisting">&lt;alias name="componentA-dataSource" alias="componentB-dataSource"/&gt;
&lt;alias name="componentA-dataSource" alias="myApp-dataSource" /&gt;</pre><p>Now each component and the main application can refer to the
          dataSource via a name that is unique and guaranteed not to clash
          with any other definition (effectively there is a namespace), yet
          they refer to the same bean.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-class"></a>3.2.3.2.&nbsp;Instantiating beans</h4></div></div><div></div></div><div class="sidebar"><p class="title"><b>Inner class names</b></p><p>If for whatever reason you want to configure a bean definition
          for a <tt class="literal">static</tt> inner class, you have to use the
          <span class="emphasis"><em>binary</em></span> name of the inner class.</p><p>For example, if you have a class called
          <tt class="classname">Foo</tt> in the <tt class="literal">com.example</tt>
          package, and this <tt class="classname">Foo</tt> class has a
          <tt class="literal">static</tt> inner class called
          <tt class="classname">Bar</tt>, the value of the
          <tt class="literal">'class'</tt> attribute on a bean definition would
          be...</p><p>
            <tt class="classname">com.example.Foo$Bar</tt>
          </p><p>Notice the use of the <tt class="literal">$</tt> character in the
          name to separate the inner class name from the outer class
          name.</p></div><p>A bean definition essentially is a recipe for creating one or
        more objects. The container looks at the recipe for a named bean when
        asked, and uses the configuration metadata encapsulated by that bean
        definition to create (or acquire) an actual object.</p><p>If you are using XML-based configuration metadata, you can
        specify the type (or class) of object that is to be instantiated using
        the <tt class="literal">'class'</tt> attribute of the
        <tt class="literal">&lt;bean/&gt;</tt> element. This
        <tt class="literal">'class'</tt> attribute (which internally eventually
        boils down to being a <tt class="classname">Class</tt> property on a
        <tt class="interfacename">BeanDefinition</tt> instance) is normally
        mandatory (see <a href="#beans-factory-class-instance-factory-method" title="3.2.3.2.3.&nbsp;Instantiation using an instance factory method">Section&nbsp;3.2.3.2.3, &#8220;Instantiation using an instance factory method&#8221;</a> and <a href="#beans-child-bean-definitions" title="3.6.&nbsp;Bean definition inheritance">Section&nbsp;3.6, &#8220;Bean definition inheritance&#8221;</a> for the two exceptions) and
        is used for one of two purposes. The class property specifies the
        class of the bean to be constructed in the common case where the
        container itself directly creates the bean by calling its constructor
        reflectively (somewhat equivalent to Java code using the
        <span class="emphasis"><em>'new'</em></span> operator). In the less common case where
        the container invokes a <tt class="literal">static</tt>,
        <span class="emphasis"><em>factory</em></span> method on a class to create the bean, the
        class property specifies the actual class containing the
        <tt class="literal">static</tt> factory method that is to be invoked to
        create the object (the type of the object returned from the invocation
        of the <tt class="literal">static</tt> factory method may be the same class
        or another class entirely, it doesn't matter).</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-factory-class-ctor"></a>3.2.3.2.1.&nbsp;Instantiation using a constructor</h5></div></div><div></div></div><p>When creating a bean using the constructor approach, all
          normal classes are usable by and compatible with Spring. That is,
          the class being created does not need to implement any specific
          interfaces or be coded in a specific fashion. Just specifying the
          bean class should be enough. However, depending on what type of IoC
          you are going to use for that specific bean, you may need a default
          (empty) constructor.</p><p>Additionally, the Spring IoC container isn't limited to just
          managing true JavaBeans, it is also able to manage virtually
          <span class="emphasis"><em>any</em></span> class you want it to manage. Most people
          using Spring prefer to have actual JavaBeans (having just a default
          (no-argument) constructor and appropriate setters and getters
          modeled after the properties) in the container, but it is also
          possible to have more exotic non-bean-style classes in your
          container. If, for example, you need to use a legacy connection pool
          that absolutely does not adhere to the JavaBean specification,
          Spring can manage it as well.</p><p>When using XML-based configuration metadata you can specify
          your bean class like so:</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"/&gt;

&lt;bean name="anotherExample" class="examples.ExampleBeanTwo"/&gt;</pre><p>The mechanism for supplying arguments to the constructor (if
          required), or setting properties of the object instance after it has
          been constructed, <a href="#beans-factory-collaborators" title="3.3.1.&nbsp;Injecting dependencies">is
          described shortly</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-factory-class-static-factory-method"></a>3.2.3.2.2.&nbsp;Instantiation using a static factory method</h5></div></div><div></div></div><p>When defining a bean which is to be created using a static
          factory method, along with the <tt class="literal">class</tt> attribute
          which specifies the class containing the <tt class="literal">static</tt>
          factory method, another attribute named
          <tt class="literal">factory-method</tt> is needed to specify the name of
          the factory method itself. Spring expects to be able to call this
          method (with an optional list of arguments as described later) and
          get back a live object, which from that point on is treated as if it
          had been created normally via a constructor. One use for such a bean
          definition is to call <tt class="literal">static</tt> factories in legacy
          code.</p><p>The following example shows a bean definition which specifies
          that the bean is to be created by calling a factory-method. Note
          that the definition does not specify the type (class) of the
          returned object, only the class containing the factory method. In
          this example, the <tt class="methodname">createInstance()</tt> method
          must be a <span class="emphasis"><em>static</em></span> method.</p><pre class="programlisting">&lt;bean id="exampleBean"
      class="examples.ExampleBean2"
      factory-method="createInstance"/&gt;</pre><p>The mechanism for supplying (optional) arguments to the
          factory method, or setting properties of the object instance after
          it has been returned from the factory, will be <a href="#beans-factory-properties-detailed" title="3.3.2.&nbsp;Dependencies and configuration in detail">described
          shortly</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-factory-class-instance-factory-method"></a>3.2.3.2.3.&nbsp;Instantiation using an instance factory method</h5></div></div><div></div></div><p>In a fashion similar to instantiation via a <a href="#beans-factory-class-static-factory-method" title="3.2.3.2.2.&nbsp;Instantiation using a static factory method">static factory
          method</a>, instantiation using an instance factory method is
          where a non-static method of an existing bean from the container is
          invoked to create a new bean. To use this mechanism, the
          <tt class="literal">'class'</tt> attribute must be left empty, and the
          <tt class="literal">'factory-bean'</tt> attribute must specify the name of
          a bean in the current (or parent/ancestor) container that contains
          the instance method that is to be invoked to create the object. The
          name of the factory method itself must be set using the
          <tt class="literal">'factory-method'</tt> attribute.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- the factory bean, which contains a method called <tt class="methodname">createInstance()</tt> --&gt;</span></i>
&lt;bean id="serviceLocator" class="com.foo.DefaultServiceLocator"&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></i>
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- the bean to be created via the factory bean --&gt;</span></i>
&lt;bean id="exampleBean"
      factory-bean="serviceLocator"
      factory-method="createInstance"/&gt;</pre><p>Although the mechanisms for <a href="#beans-factory-properties-detailed" title="3.3.2.&nbsp;Dependencies and configuration in detail">setting bean
          properties</a> are still to be discussed, one implication of this
          approach is that the factory bean itself can be managed and
          configured via DI.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>When the Spring documentation makes mention of a 'factory
          bean', this will be a reference to a bean that is configured in the
          Spring container that will create objects via an <a href="#beans-factory-class-instance-factory-method" title="3.2.3.2.3.&nbsp;Instantiation using an instance factory method">instance</a>
          or <a href="#beans-factory-class-static-factory-method" title="3.2.3.2.2.&nbsp;Instantiation using a static factory method">static</a>
          factory method. When the documentation mentions a
          <tt class="interfacename">FactoryBean</tt> (notice the
          capitalization) this is a reference to a Spring-specific <a href="#beans-factory-extension-factorybean" title="3.7.3.&nbsp;Customizing instantiation logic using&#xA;      FactoryBeans">
              <tt class="interfacename">FactoryBean</tt>
            </a>.</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-client"></a>3.2.4.&nbsp;Using the container</h3></div></div><div></div></div><p>A <tt class="interfacename">BeanFactory</tt> is essentially
      nothing more than the interface for an advanced factory capable of
      maintaining a registry of different beans and their dependencies. The
      <tt class="interfacename">BeanFactory</tt> enables you to read bean
      definitions and access them using the bean factory. When using just the
      <tt class="interfacename">BeanFactory</tt> you would create one and read
      in some bean definitions in the XML format as follows:</p><pre class="programlisting">Resource res = new FileSystemResource("beans.xml");
BeanFactory factory = new XmlBeanFactory(res);</pre><p>Basically that is all there is to it. Using
      <tt class="methodname">getBean(String)</tt> you can retrieve instances of
      your beans; the client-side view of the
      <tt class="interfacename">BeanFactory</tt> is simple. The
      <tt class="interfacename">BeanFactory</tt> interface has just a few
      other methods, but ideally your application code should never use
      them... indeed, your application code should have no calls to the
      <tt class="methodname">getBean(String)</tt> method at all, and thus no
      dependency on Spring APIs at all.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-dependencies"></a>3.3.&nbsp;Dependencies</h2></div></div><div></div></div><p>Your typical enterprise application is not made up of a single
    object (or bean in the Spring parlance). Even the simplest of applications
    will no doubt have at least a handful of objects that work together to
    present what the end-user sees as a coherent application. This next
    section explains how you go from defining a number of bean definitions
    that stand-alone, each to themselves, to a fully realized application
    where objects work (or collaborate) together to achieve some goal (usually
    an application that does what the end-user wants).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-collaborators"></a>3.3.1.&nbsp;Injecting dependencies</h3></div></div><div></div></div><p>The basic principle behind <span class="emphasis"><em>Dependency
      Injection</em></span> (DI) is that objects define their dependencies
      (that is to say the other objects they work with) only through
      constructor arguments, arguments to a factory method, or properties
      which are set on the object instance after it has been constructed or
      returned from a factory method. Then, it is the job of the container to
      actually <span class="emphasis"><em>inject</em></span> those dependencies when it creates
      the bean. This is fundamentally the inverse, hence the name
      <span class="emphasis"><em>Inversion of Control</em></span> (IoC), of the bean itself
      being in control of instantiating or locating its dependencies on its
      own using direct construction of classes, or something like the
      <span class="emphasis"><em>Service Locator</em></span> pattern.</p><p>It becomes evident upon usage that code gets much cleaner when the
      DI principle is applied, and reaching a higher grade of decoupling is
      much easier when objects do not look up their dependencies, but are
      provided with them (and additionally do not even know where the
      dependencies are located and of what concrete class they are). DI exists
      in two major variants, namely <a href="#beans-constructor-injection" title="3.3.1.1.&nbsp;Constructor Injection">Constructor Injection</a> and
      <a href="#beans-setter-injection" title="3.3.1.2.&nbsp;Setter Injection">Setter Injection</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-constructor-injection"></a>3.3.1.1.&nbsp;Constructor Injection</h4></div></div><div></div></div><p><span class="emphasis"><em>Constructor-based</em></span> DI is effected by
        invoking a constructor with a number of arguments, each representing a
        dependency. Additionally, calling a <tt class="literal">static</tt> factory
        method with specific arguments to construct the bean, can be
        considered almost equivalent, and the rest of this text will consider
        arguments to a constructor and arguments to a
        <tt class="literal">static</tt> factory method similarly. Find below an
        example of a class that could only be dependency injected using
        constructor injection. Notice that there is nothing
        <span class="emphasis"><em>special</em></span> about this class.</p><pre class="programlisting">public class SimpleMovieLister {

    <i class="lineannotation"><span class="lineannotation">// the <tt class="classname">SimpleMovieLister</tt> has a dependency on a <tt class="interfacename">MovieFinder</tt></span></i>
    private MovieFinder movieFinder;

    <i class="lineannotation"><span class="lineannotation">// a constructor so that the Spring container can 'inject' a <tt class="interfacename">MovieFinder</tt></span></i>
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
    
    <i class="lineannotation"><span class="lineannotation">// business logic that actually 'uses' the injected <tt class="interfacename">MovieFinder</tt> is omitted...</span></i>
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-factory-ctor-arguments-resolution"></a>3.3.1.1.1.&nbsp;Constructor Argument Resolution</h5></div></div><div></div></div><p>Constructor argument resolution matching occurs using the
          argument's type. If there is no potential for ambiguity in the
          constructor arguments of a bean definition, then the order in which
          the constructor arguments are defined in a bean definition is the
          order in which those arguments will be supplied to the appropriate
          constructor when it is being instantiated. Consider the following
          class:</p><pre class="programlisting">package x.y;

public class Foo {

    public Foo(Bar bar, Baz baz) {
        <i class="lineannotation"><span class="lineannotation">// ...</span></i>
    }
}</pre><p>There is no potential for ambiguity here (assuming of course
          that <tt class="classname">Bar</tt> and <tt class="classname">Baz</tt>
          classes are not related in an inheritance hierarchy). Thus the
          following configuration will work just fine, and you do not need to
          specify the constructor argument indexes and / or types
          explicitly.</p><pre class="programlisting">&lt;beans&gt;
    &lt;bean name="foo" class="x.y.Foo"&gt;
        &lt;constructor-arg&gt;
            &lt;bean class="x.y.Bar"/&gt;
        &lt;/constructor-arg&gt;
        &lt;constructor-arg&gt;
            &lt;bean class="x.y.Baz"/&gt;
        &lt;/constructor-arg&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>When another bean is referenced, the type is known, and
          matching can occur (as was the case with the preceding example).
          When a simple type is used, such as
          <tt class="literal">&lt;value&gt;true&lt;value&gt;</tt>, Spring cannot
          determine the type of the value, and so cannot match by type without
          help. Consider the following class:</p><pre class="programlisting">package examples;

public class ExampleBean {

    <i class="lineannotation"><span class="lineannotation">// No. of years to the calculate the Ultimate Answer</span></i>
    private int years;

    <i class="lineannotation"><span class="lineannotation">// The Answer to Life, the Universe, and Everything</span></i>
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="beans-factory-ctor-arguments-type"></a>3.3.1.1.1.1.&nbsp;Constructor Argument Type Matching</h6></div></div><div></div></div><p>The above scenario <span class="emphasis"><em>can</em></span> use type
            matching with simple types by explicitly specifying the type of
            the constructor argument using the <tt class="literal">'type'</tt>
            attribute. For example:</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
  &lt;constructor-arg type="int" value="7500000"/&gt;
  &lt;constructor-arg type="java.lang.String" value="42"/&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h6 class="title"><a name="beans-factory-ctor-arguments-index"></a>3.3.1.1.1.2.&nbsp;Constructor Argument Index</h6></div></div><div></div></div><p>Constructor arguments can have their index specified
            explicitly by use of the <tt class="literal">index</tt> attribute. For
            example:</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
  &lt;constructor-arg index="0" value="7500000"/&gt;
  &lt;constructor-arg index="1" value="42"/&gt;
&lt;/bean&gt;</pre><p>As well as solving the ambiguity problem of multiple simple
            values, specifying an index also solves the problem of ambiguity
            where a constructor may have two arguments of the same type. Note
            that the <span class="emphasis"><em>index is 0 based</em></span>.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-setter-injection"></a>3.3.1.2.&nbsp;Setter Injection</h4></div></div><div></div></div><p><span class="emphasis"><em>Setter-based</em></span> DI is realized by calling
        setter methods on your beans after invoking a no-argument constructor
        or no-argument <tt class="literal">static</tt> factory method to instantiate
        your bean.</p><p>Find below an example of a class that can only be dependency
        injected using pure setter injection. Note that there is nothing
        <span class="emphasis"><em>special</em></span> about this class... it is plain old
        Java.</p><pre class="programlisting">public class SimpleMovieLister {

    <i class="lineannotation"><span class="lineannotation">// the <tt class="classname">SimpleMovieLister</tt> has a dependency on the <tt class="interfacename">MovieFinder</tt></span></i>
    private MovieFinder movieFinder;

    <i class="lineannotation"><span class="lineannotation">// a setter method so that the Spring container can 'inject' a <tt class="interfacename">MovieFinder</tt></span></i>
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    <i class="lineannotation"><span class="lineannotation">// business logic that actually 'uses' the injected <tt class="interfacename">MovieFinder</tt> is omitted...</span></i>
}</pre></div><div class="sidebar"><p class="title"><b>Constructor- or Setter-based DI?</b></p><p>The Spring team generally advocates the usage of setter
        injection, since a large number of constructor arguments can get
        unwieldy, especially when some properties are optional. The presence
        of setter methods also makes objects of that class amenable to being
        re-configured (or re-injected) at some later time (for management via
        <a href="#jmx" title="Chapter&nbsp;20.&nbsp;JMX">JMX MBeans</a> is a particularly compelling use
        case).</p><p>Constructor-injection is favored by some purists though (and
        with good reason). Supplying all of an object's dependencies means
        that that object is never returned to client (calling) code in a less
        than totally initialized state. The flip side is that the object
        becomes less amenable to re-configuration (or re-injection).</p><p>There is no hard and fast rule here. Use whatever type of DI
        makes the most sense for a particular class; sometimes, when dealing
        with third party classes to which you do not have the source, the
        choice will already have been made for you - a legacy class may not
        expose any setter methods, and so constructor injection will be the
        only type of DI available to you.</p></div><p>The <tt class="interfacename">BeanFactory</tt> supports both of
      these variants for injecting dependencies into beans it manages. (It in
      fact also supports injecting setter-based dependencies after some
      dependencies have already been supplied via the constructor approach.)
      The configuration for the dependencies comes in the form of a
      <tt class="interfacename">BeanDefinition</tt>, which is used together
      with <tt class="interfacename">PropertyEditor</tt> instances to know how
      to convert properties from one format to another. However, most users of
      Spring will not be dealing with these classes directly (that is
      programmatically), but rather with an XML definition file which will be
      converted internally into instances of these classes, and used to load
      an entire Spring IoC container instance.</p><p>Bean dependency resolution generally happens as follows:</p><div class="orderedlist"><ol type="1"><li><p>The <tt class="interfacename">BeanFactory</tt> is created and
          initialized with a configuration which describes all the beans.
          (Most Spring users use a <tt class="interfacename">BeanFactory</tt>
          or <tt class="interfacename">ApplicationContext</tt> implementation
          that supports XML format configuration files.)</p></li><li><p>Each bean has dependencies expressed in the form of
          properties, constructor arguments, or arguments to the
          static-factory method when that is used instead of a normal
          constructor. These dependencies will be provided to the bean,
          <span class="emphasis"><em>when the bean is actually created</em></span>.</p></li><li><p>Each property or constructor argument is either an actual
          definition of the value to set, or a reference to another bean in
          the container.</p></li><li><p><a name="beans-factory-collaborators-propertyeditor"></a>
          Each property or constructor argument which is a value must be able
          to be converted from whatever format it was specified in, to the
          actual type of that property or constructor argument. By default
          Spring can convert a value supplied in string format to all built-in
          types, such as <tt class="literal">int</tt>, <tt class="literal">long</tt>,
          <tt class="literal">String</tt>, <tt class="literal">boolean</tt>, etc.</p></li></ol></div><p>The Spring container validates the configuration of each bean as
      the container is created, including the validation that properties which
      are bean references are actually referring to valid beans. However, the
      bean properties themselves are not set until the bean <span class="emphasis"><em>is
      actually created</em></span>. For those beans that are singleton-scoped
      and set to be pre-instantiated (such as singleton beans in an
      <tt class="interfacename">ApplicationContext</tt>), creation happens at
      the time that the container is created, but otherwise this is only when
      the bean is requested. When a bean actually has to be created, this will
      potentially cause a graph of other beans to be created, as its
      dependencies and its dependencies' dependencies (and so on) are created
      and assigned.</p><div class="sidebar"><p class="title"><b>Circular dependencies</b></p><p>If you are using predominantly constructor injection it is
        possible to write and configure your classes and beans such that an
        unresolvable circular dependency scenario is created.</p><p>Consider the scenario where you have class A, which requires an
        instance of class B to be provided via constructor injection, and
        class B, which requires an instance of class A to be provided via
        constructor injection. If you configure beans for classes A and B to
        be injected into each other, the Spring IoC container will detect this
        circular reference at runtime, and throw a
        <tt class="classname">BeanCurrentlyInCreationException</tt>.</p><p>One possible solution to this issue is to edit the source code
        of some of your classes to be configured via setters instead of via
        constructors. Another solution is not to use constructor injection and
        stick to setter injection only. In other words, while it should
        generally be avoided in all but the rarest of circumstances, it is
        possible to configure circular dependencies with setter
        injection.</p><p>Unlike the <span class="emphasis"><em>typical</em></span> case (with no circular
        dependencies), a circular dependency between bean A and bean B will
        force one of the beans to be injected into the other prior to being
        fully initialized itself (a classic chicken/egg scenario).</p></div><p>You can generally trust Spring to do the right thing. It will
      detect misconfiguration issues, such as references to non-existent beans
      and circular dependencies, at container load-time. It will actually set
      properties and resolve dependencies as late as possible, which is when
      the bean is actually created. This means that a Spring container which
      has loaded correctly can later generate an exception when you request a
      bean if there is a problem creating that bean or one of its
      dependencies. This could happen if the bean throws an exception as a
      result of a missing or invalid property, for example. This potentially
      delayed visibility of some configuration issues is why
      <tt class="interfacename">ApplicationContext</tt> implementations by
      default pre-instantiate singleton beans. At the cost of some upfront
      time and memory to create these beans before they are actually needed,
      you find out about configuration issues when the
      <tt class="interfacename">ApplicationContext</tt> is created, not later.
      If you wish, you can still override this default behavior and set any of
      these singleton beans to lazy-initialize (that is not be
      pre-instantiated).</p><p>If no circular dependencies are involved (see sidebar for a
      discussion of circular dependencies), when one or more collaborating
      beans are being injected into a dependent bean, each collaborating bean
      is <span class="emphasis"><em>totally</em></span> configured prior to being passed (via
      one of the DI flavors) to the dependent bean. This means that if bean A
      has a dependency on bean B, the Spring IoC container will
      <span class="emphasis"><em>totally</em></span> configure bean B prior to invoking the
      setter method on bean A; you can read '<span class="emphasis"><em>totally
      configure</em></span>' to mean that the bean will be instantiated (if not
      a pre-instantiated singleton), all of its dependencies will be set, and
      the relevant lifecycle methods (such as a <a href="#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&nbsp;Initialization callbacks">configured init
      method</a> or the <a href="#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&nbsp;Initialization callbacks">IntializingBean
      callback method</a>) will all be invoked.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-some-examples"></a>3.3.1.3.&nbsp;Some examples</h4></div></div><div></div></div><p>First, an example of using XML-based configuration metadata for
        setter-based DI. Find below a small part of a Spring XML configuration
        file specifying some bean definitions.</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- setter injection using the nested <tt class="literal">&lt;ref/&gt;</tt> element --&gt;</span></i>
  &lt;property name="beanOne"&gt;&lt;ref bean="anotherExampleBean"/&gt;&lt;/property&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- setter injection using the neater 'ref' attribute --&gt;</span></i>
  &lt;property name="beanTwo" ref="yetAnotherBean"/&gt;
  &lt;property name="integerProperty" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><pre class="programlisting">public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }    
}</pre><p>As you can see, setters have been declared to match against the
        properties specified in the XML file. Find below an example of using
        constructor-based DI.</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- constructor injection using the nested <tt class="literal">&lt;ref/&gt;</tt> element --&gt;</span></i>
  &lt;constructor-arg&gt;
    &lt;ref bean="anotherExampleBean"/&gt;
  &lt;/constructor-arg&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- constructor injection using the neater 'ref' attribute --&gt;</span></i>
  &lt;constructor-arg ref="yetAnotherBean"/&gt;
  
  &lt;constructor-arg type="int" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><pre class="programlisting">public class ExampleBean {

    private AnotherBean beanOne;
    private YetAnotherBean beanTwo;
    private int i;
    
    public ExampleBean(
        AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}</pre><p>As you can see, the constructor arguments specified in the bean
        definition will be used to pass in as arguments to the constructor of
        the <tt class="classname">ExampleBean</tt>.</p><p>Now consider a variant of this where instead of using a
        constructor, Spring is told to call a <tt class="literal">static</tt>
        factory method to return an instance of the object:</p><pre class="programlisting">&lt;bean id="exampleBean" class="examples.ExampleBean"
      factory-method="createInstance"&gt;
  &lt;constructor-arg ref="anotherExampleBean"/&gt;
  &lt;constructor-arg ref="yetAnotherBean"/&gt;
  &lt;constructor-arg value="1"/&gt; 
&lt;/bean&gt;

&lt;bean id="anotherExampleBean" class="examples.AnotherBean"/&gt;
&lt;bean id="yetAnotherBean" class="examples.YetAnotherBean"/&gt;</pre><pre class="programlisting">public class ExampleBean {

    <i class="lineannotation"><span class="lineannotation">// a private constructor</span></i>
    private ExampleBean(...) {
      ...
    }
    <i class="lineannotation"><span class="lineannotation">
    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.</span></i>
    public static ExampleBean createInstance (
            AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        <i class="lineannotation"><span class="lineannotation">// some other operations...</span></i>
        return eb;
    }
}</pre><p>Note that arguments to the <tt class="literal">static</tt> factory
        method are supplied via <tt class="literal">&lt;constructor-arg/&gt;</tt>
        elements, exactly the same as if a constructor had actually been used.
        Also, it is important to realize that the type of the class being
        returned by the factory method does not have to be of the same type as
        the class which contains the <tt class="literal">static</tt> factory method,
        although in this example it is. An instance (non-static) factory
        method would be used in an essentially identical fashion (aside from
        the use of the <tt class="literal">factory-bean</tt> attribute instead of
        the <tt class="literal">class</tt> attribute), so details will not be
        discussed here.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-properties-detailed"></a>3.3.2.&nbsp;Dependencies and configuration in detail</h3></div></div><div></div></div><p>As mentioned in the previous section, bean properties and
      constructor arguments can be defined as either references to other
      managed beans (collaborators), or values defined inline. Spring's
      XML-based configuration metadata supports a number of sub-element types
      within its <tt class="literal">&lt;property/&gt;</tt> and
      <tt class="literal">&lt;constructor-arg/&gt;</tt> elements for just this
      purpose.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-value-element"></a>3.3.2.1.&nbsp;Straight values (primitives, <tt class="literal">Strings</tt>,
        etc.)</h4></div></div><div></div></div><p>The <tt class="literal">&lt;value/&gt;</tt> element specifies a
        property or constructor argument as a human-readable string
        representation. <a href="#beans-factory-collaborators-propertyeditor">As mentioned
        previously</a>, JavaBeans <tt class="literal">PropertyEditors</tt> are
        used to convert these string values from a
        <tt class="classname">String</tt> to the actual type of the property or
        argument.</p><pre class="programlisting">&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a <tt class="methodname">setDriverClassName(String)</tt> call --&gt;</span></i>
  &lt;property name="driverClassName"&gt;
    &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="url"&gt;
    &lt;value&gt;jdbc:mysql://localhost:3306/mydb&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="username"&gt;
    &lt;value&gt;root&lt;/value&gt;
  &lt;/property&gt;
  &lt;property name="password"&gt;
    &lt;value&gt;masterkaoli&lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The <tt class="literal">&lt;property/&gt;</tt> and
        <tt class="literal">&lt;constructor-arg/&gt;</tt> elements also support the
        use of the <tt class="literal">'value'</tt> attribute, which can lead to
        much more succinct configuration. When using the
        <tt class="literal">'value'</tt> attribute, the above bean definition reads
        like so:</p><pre class="programlisting">&lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a <tt class="methodname">setDriverClassName(String)</tt> call --&gt;</span></i>
  &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt;
  &lt;property name="url" value="jdbc:mysql://localhost:3306/mydb"/&gt;
  &lt;property name="username" value="root"/&gt;
  &lt;property name="password" value="masterkaoli"/&gt;
&lt;/bean&gt;</pre><p>The Spring team generally prefer the attribute style over the
        use of nested <tt class="literal">&lt;value/&gt;</tt> elements. If you are
        reading this reference manual straight through from top to bottom
        (wow!) then we are getting slightly ahead of ourselves here, but you
        can also configure a <tt class="classname">java.util.Properties</tt>
        instance like so:</p><pre class="programlisting">&lt;bean id="mappings" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
            
   <i class="lineannotation"><span class="lineannotation">&lt;!-- typed as a <tt class="classname">java.util.Properties</tt> --&gt;</span></i>
   &lt;property name="properties"&gt;
      &lt;value&gt;
         jdbc.driver.className=com.mysql.jdbc.Driver
         jdbc.url=jdbc:mysql://localhost:3306/mydb
      &lt;/value&gt;
   &lt;/property&gt;
&lt;/bean&gt;</pre><p>Can you see what is happening? The Spring container is
        converting the text inside the <tt class="literal">&lt;value/&gt;</tt>
        element into a <tt class="classname">java.util.Properties</tt> instance
        using the JavaBeans <tt class="interfacename">PropertyEditor</tt>
        mechanism. This is a nice shortcut, and is one of a few places where
        the Spring team do favor the use of the nested
        <tt class="literal">&lt;value/&gt;</tt> element over the
        <tt class="literal">'value'</tt> attribute style.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-idref-element"></a>3.3.2.1.1.&nbsp;The <tt class="literal">idref</tt> element</h5></div></div><div></div></div><p>The <tt class="literal">idref</tt> element is simply an error-proof
          way to pass the <span class="emphasis"><em>id</em></span> of another bean in the
          container (to a <tt class="literal">&lt;constructor-arg/&gt;</tt> or
          <tt class="literal">&lt;property/&gt;</tt> element).</p><pre class="programlisting">&lt;bean id="theTargetBean" class="..."/&gt;

&lt;bean id="theClientBean" class="..."&gt;
    &lt;property name="targetName"&gt;
        &lt;idref bean="theTargetBean" /&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>The above bean definition snippet is
          <span class="emphasis"><em>exactly</em></span> equivalent (at runtime) to the
          following snippet:</p><pre class="programlisting">&lt;bean id="theTargetBean" class="..." /&gt;

&lt;bean id="client" class="..."&gt;
    &lt;property name="targetName" value="theTargetBean" /&gt;
&lt;/bean&gt;</pre><p>The main reason the first form is preferable to the second is
          that using the <tt class="literal">idref</tt> tag allows the container to
          validate <span class="emphasis"><em>at deployment time</em></span> that the
          referenced, named bean actually exists. In the second variation, no
          validation is performed on the value that is passed to the
          <tt class="literal">'targetName'</tt> property of the
          <tt class="literal">'client'</tt> bean. Any typo will only be discovered
          (with most likely fatal results) when the
          <tt class="literal">'client'</tt> bean is actually instantiated. If the
          <tt class="literal">'client'</tt> bean is a <a href="#beans-factory-scopes" title="3.4.&nbsp;Bean scopes">prototype</a> bean, this typo (and
          the resulting exception) may only be discovered long after the
          container is actually deployed.</p><p>Additionally, if the bean being referred to is in the same XML
          unit, and the bean name is the bean <span class="emphasis"><em>id</em></span>, the
          <tt class="literal">'local'</tt> attribute may be used, which allows the
          XML parser itself to validate the bean id even earlier, at XML
          document parse time.</p><pre class="programlisting">&lt;property name="targetName"&gt;
   <i class="lineannotation"><span class="lineannotation">&lt;!-- a bean with an id of '<tt class="literal">theTargetBean</tt>' must exist; otherwise an XML exception will be thrown --&gt;</span></i>
   &lt;idref local="theTargetBean"/&gt;
&lt;/property&gt;</pre><p>By way of an example, one common place (at least in pre-Spring
          2.0 configuration) where the &lt;idref/&gt; element brings value is
          in the configuration of <a href="#aop-pfb-1" title="7.5.1.&nbsp;Basics">AOP
          interceptors</a> in a <tt class="classname">ProxyFactoryBean</tt>
          bean definition. If you use &lt;idref/&gt; elements when specifying
          the interceptor names, there is no chance of inadvertently
          misspelling an interceptor id.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-ref-element"></a>3.3.2.2.&nbsp;References to other beans (collaborators)</h4></div></div><div></div></div><p>The <tt class="literal">ref</tt> element is the final element allowed
        inside a <tt class="literal">&lt;constructor-arg/&gt;</tt> or
        <tt class="literal">&lt;property/&gt;</tt> definition element. It is used to
        set the value of the specified property to be a reference to another
        bean managed by the container (a collaborator). As mentioned in a
        previous section, the referred-to bean is considered to be a
        dependency of the bean who's property is being set, and will be
        initialized on demand as needed (if it is a singleton bean it may have
        already been initialized by the container) before the property is set.
        All references are ultimately just a reference to another object, but
        there are 3 variations on how the id/name of the other object may be
        specified, which determines how scoping and validation is
        handled.</p><p>Specifying the target bean by using the <tt class="literal">bean</tt>
        attribute of the <tt class="literal">&lt;ref/&gt;</tt> tag is the most
        general form, and will allow creating a reference to any bean in the
        same container (whether or not in the same XML file), or parent
        container. The value of the <tt class="literal">'bean'</tt> attribute may be
        the same as either the <tt class="literal">'id'</tt> attribute of the target
        bean, or one of the values in the <tt class="literal">'name'</tt> attribute
        of the target bean.</p><pre class="programlisting">&lt;ref bean="someBean"/&gt;</pre><p>Specifying the target bean by using the <tt class="literal">local</tt>
        attribute leverages the ability of the XML parser to validate XML id
        references within the same file. The value of the
        <tt class="literal">local</tt> attribute must be the same as the
        <tt class="literal">id</tt> attribute of the target bean. The XML parser
        will issue an error if no matching element is found in the same file.
        As such, using the local variant is the best choice (in order to know
        about errors as early as possible) if the target bean is in the same
        XML file.</p><pre class="programlisting">&lt;ref local="someBean"/&gt;</pre><p>Specifying the target bean by using the
        <tt class="literal">'parent'</tt> attribute allows a reference to be created
        to a bean which is in a parent container of the current container. The
        value of the <tt class="literal">'parent'</tt> attribute may be the same as
        either the <tt class="literal">'id'</tt> attribute of the target bean, or
        one of the values in the <tt class="literal">'name'</tt> attribute of the
        target bean, and the target bean must be in a parent container to the
        current one. The main use of this bean reference variant is when you
        have a hierarchy of containers and you want to wrap an existing bean
        in a parent container with some sort of proxy which will have the same
        name as the parent bean.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- in the parent context --&gt;</span></i>
&lt;bean id="accountService" class="com.foo.SimpleAccountService"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- insert dependencies as required as here --&gt;</span></i>
&lt;/bean&gt;</pre><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- in the child (descendant) context --&gt;</span></i>
&lt;bean id="accountService"  <i class="lineannotation"><span class="lineannotation">&lt;-- notice that the name of this bean is the <span class="bold"><b>same</b></span> as the name of the <tt class="literal">'parent'</tt> bean</span></i>
      class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
      &lt;property name="target"&gt;
          &lt;ref parent="accountService"/&gt;  <i class="lineannotation"><span class="lineannotation">&lt;-- notice how we refer to the <span class="bold"><b>parent</b></span> bean</span></i>
      &lt;/property&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- insert other configuration and dependencies as required as here --&gt;</span></i>
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-inner-beans"></a>3.3.2.3.&nbsp;Inner beans</h4></div></div><div></div></div><p>A <tt class="literal">&lt;bean/&gt;</tt> element inside the
        <tt class="literal">&lt;property/&gt;</tt> or
        <tt class="literal">&lt;constructor-arg/&gt;</tt> elements is used to define
        a so-called <i class="firstterm">inner bean</i>. An inner bean
        definition does not need to have any id or name defined, and it is
        best not to even specify any id or name value because the id or name
        value simply will be ignored by the container.</p><pre class="programlisting">&lt;bean id="outer" class="..."&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- instead of using a reference to a target bean, simply define the target bean inline --&gt;</span></i>
  &lt;property name="target"&gt;
    &lt;bean class="com.example.Person"&gt; <i class="lineannotation"><span class="lineannotation">&lt;!-- this is the inner bean --&gt;</span></i>
      &lt;property name="name" value="Fiona Apple"/&gt;
      &lt;property name="age" value="25"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that in the specific case of inner beans, the
        <tt class="literal">'scope'</tt> flag and any <tt class="literal">'id'</tt> or
        <tt class="literal">'name'</tt> attribute are effectively ignored. Inner
        beans are <span class="emphasis"><em>always</em></span> anonymous and they are
        <span class="emphasis"><em>always</em></span> scoped as <a href="#beans-factory-scopes-prototype" title="3.4.2.&nbsp;The prototype scope">prototypes</a>. Please
        also note that it is <span class="emphasis"><em>not</em></span> possible to inject inner
        beans into collaborating beans other than the enclosing bean.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-collection-elements"></a>3.3.2.4.&nbsp;Collections</h4></div></div><div></div></div><p>The <tt class="literal">&lt;list/&gt;</tt>,
        <tt class="literal">&lt;set/&gt;</tt>, <tt class="literal">&lt;map/&gt;</tt>, and
        <tt class="literal">&lt;props/&gt;</tt> elements allow properties and
        arguments of the Java <tt class="interfacename">Collection</tt> type
        <tt class="interfacename">List</tt>,
        <tt class="interfacename">Set</tt>,
        <tt class="interfacename">Map</tt>, and
        <tt class="interfacename">Properties</tt>, respectively, to be defined
        and set.</p><pre class="programlisting">&lt;bean id="moreComplexObject" class="example.ComplexObject"&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a setAdminEmails(<tt class="classname">java.util.Properties</tt>) call --&gt;</span></i>
  &lt;property name="adminEmails"&gt;
    &lt;props&gt;
        &lt;prop key="administrator"&gt;administrator@example.org&lt;/prop&gt;
        &lt;prop key="support"&gt;support@example.org&lt;/prop&gt;
        &lt;prop key="development"&gt;development@example.org&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a setSomeList(<tt class="interfacename">java.util.List</tt>) call --&gt;</span></i>
  &lt;property name="someList"&gt;
    &lt;list&gt;
        &lt;value&gt;a list element followed by a reference&lt;/value&gt;
        &lt;ref bean="myDataSource" /&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a setSomeMap(<tt class="interfacename">java.util.Map</tt>) call --&gt;</span></i>
  &lt;property name="someMap"&gt;
    &lt;map&gt;
        &lt;entry&gt;
            &lt;key&gt;
                &lt;value&gt;an entry&lt;/value&gt;
            &lt;/key&gt;
            &lt;value&gt;just some string&lt;/value&gt;
        &lt;/entry&gt;
        &lt;entry&gt;
            &lt;key&gt;
                &lt;value&gt;a ref&lt;/value&gt;
            &lt;/key&gt;
            &lt;ref bean="myDataSource" /&gt;
        &lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- results in a setSomeSet(java.util.Set) call --&gt;</span></i>
  &lt;property name="someSet"&gt;
    &lt;set&gt;
        &lt;value&gt;just some string&lt;/value&gt;
        &lt;ref bean="myDataSource" /&gt;
    &lt;/set&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The nested element style used this initial
        example tends to become quite verbose. Fortunately, there are
        attribute shortcuts for most elements, which you can read about in 
        <a href="#xml-config-shortcuts" title="3.3.2.6.&nbsp;Shortcuts and other convenience options for XML-based&#xA;        configuration metadata">Section&nbsp;3.3.2.6, &#8220;Shortcuts and other convenience options for XML-based
        configuration metadata&#8221;</a>.</p></td></tr></table></div><p><span class="emphasis"><em>Note that the value of a map key or value, or a set
        value, can also again be any of the following
        elements:</em></span></p><pre class="programlisting">bean | ref | idref | list | set | map | props | value | null</pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-collection-elements-merging"></a>3.3.2.4.1.&nbsp;Collection merging</h5></div></div><div></div></div><p>As of Spring 2.0, the container also supports the
          <span class="emphasis"><em>merging</em></span> of collections. This allows an
          application developer to define a parent-style
          <tt class="literal">&lt;list/&gt;</tt>, <tt class="literal">&lt;map/&gt;</tt>,
          <tt class="literal">&lt;set/&gt;</tt> or <tt class="literal">&lt;props/&gt;</tt>
          element, and have child-style <tt class="literal">&lt;list/&gt;</tt>,
          <tt class="literal">&lt;map/&gt;</tt>, <tt class="literal">&lt;set/&gt;</tt> or
          <tt class="literal">&lt;props/&gt;</tt> elements inherit and override
          values from the parent collection; that is to say the child
          collection's values will be the result obtained from the merging of
          the elements of the parent and child collections, with the child's
          collection elements overriding values specified in the parent
          collection.</p><p><span class="emphasis"><em>Please note that this section on merging makes use
          of the parent-child bean mechanism. This concept has not yet been
          introduced, so readers unfamiliar with the concept of parent and
          child bean definitions may wish to read the <a href="#beans-child-bean-definitions" title="3.6.&nbsp;Bean definition inheritance">relevant section</a>
          before continuing.</em></span></p><p>Find below an example of the collection merging
          feature:</p><pre class="programlisting">&lt;beans&gt;
&lt;bean id="parent" abstract="true" class="example.ComplexObject"&gt;
    &lt;property name="adminEmails"&gt;
        &lt;props&gt;
            &lt;prop key="administrator"&gt;administrator@example.com&lt;/prop&gt;
            &lt;prop key="support"&gt;support@example.com&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;bean id="child" parent="parent"&gt;
    &lt;property name="adminEmails"&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- the merge is specified on the *child* collection definition --&gt;</span></i>
        &lt;props merge="true"&gt;
            &lt;prop key="sales"&gt;sales@example.com&lt;/prop&gt;
            &lt;prop key="support"&gt;support@example.co.uk&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;
&lt;beans&gt;</pre><p>Notice the use of the <tt class="literal">merge=true</tt> attribute
          on the <tt class="literal">&lt;props/&gt;</tt> element of the
          <tt class="literal">adminEmails</tt> property of the
          <tt class="literal">child</tt> bean definition. When the
          <tt class="literal">child</tt> bean is actually resolved and instantiated
          by the container, the resulting instance will have an
          <tt class="literal">adminEmails</tt> <tt class="classname">Properties</tt>
          collection that contains the result of the merging of the child's
          <tt class="literal">adminEmails</tt> collection with the parent's
          <tt class="literal">adminEmails</tt> collection.</p><pre class="programlisting">administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk</pre><p>Notice how the child <tt class="classname">Properties</tt>
          collection's value set will have inherited all the property elements
          from the parent <tt class="literal">&lt;props/&gt;</tt>. Notice also how
          the child's value for the <tt class="literal">support</tt> value overrides
          the value in the parent collection.</p><p>This merging behavior applies similarly to the
          <tt class="literal">&lt;list/&gt;</tt>, <tt class="literal">&lt;map/&gt;</tt>,
          and <tt class="literal">&lt;set/&gt;</tt> collection types. In the
          specific case of the <tt class="literal">&lt;list/&gt;</tt> element, the
          semantics associated with the <tt class="classname">List</tt> collection
          type, that is the notion of an <tt class="literal">ordered</tt> collection
          of values, is maintained; the parent's values will precede all of
          the child list's values. In the case of the
          <tt class="interfacename">Map</tt>,
          <tt class="interfacename">Set</tt>, and
          <tt class="interfacename">Properties</tt> collection types, there is
          no notion of ordering and hence no ordering semantics are in effect
          for the collection types that underlie the associated
          <tt class="interfacename">Map</tt>,
          <tt class="interfacename">Set</tt> and
          <tt class="interfacename">Properties</tt> implementation types used
          internally by the container.</p><p>Finally, some minor notes about the merging support are in
          order; you cannot merge different collection types (e.g. a
          <tt class="interfacename">Map</tt> and a
          <tt class="interfacename">List</tt>), and if you do attempt to do so
          an appropriate <tt class="classname">Exception</tt> will be thrown; and
          in case it is not immediately obvious, the
          <tt class="literal">'merge'</tt> attribute must be specified on the lower
          level, inherited, child definition; specifying the
          <tt class="literal">'merge'</tt> attribute on a parent collection
          definition is redundant and will not result in the desired merging;
          and (lastly), please note that this merging feature is only
          available in Spring 2.0 (and later versions).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-collection-elements-strongly-typed"></a>3.3.2.4.2.&nbsp;Strongly-typed collection (Java 5+ only)</h5></div></div><div></div></div><p>If you are using Java 5 or Java 6, you will be aware that it
          is possible to have strongly typed collections (using generic
          types). That is, it is possible to declare a
          <tt class="interfacename">Collection</tt> type such that it can only
          contain <tt class="classname">String</tt> elements (for example). If you
          are using Spring to dependency inject a strongly-typed
          <tt class="interfacename">Collection</tt> into a bean, you can take
          advantage of Spring's type-conversion support such that the elements
          of your strongly-typed <tt class="interfacename">Collection</tt>
          instances will be converted to the appropriate type prior to being
          added to the <tt class="interfacename">Collection</tt>.</p><pre class="programlisting">public class Foo {
                
    private Map&lt;String, Float&gt; accounts;
    
    public void setAccounts(Map&lt;String, Float&gt; accounts) {
        this.accounts = accounts;
    }
}</pre><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="foo" class="x.y.Foo"&gt;
        &lt;property name="accounts"&gt;
            &lt;map&gt;
                &lt;entry key="one" value="9.99"/&gt;
                &lt;entry key="two" value="2.75"/&gt;
                &lt;entry key="six" value="3.99"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>When the <tt class="literal">'accounts'</tt> property of the
          <tt class="literal">'foo'</tt> bean is being prepared for injection, the
          generics information about the element type of the strongly-typed
          <tt class="classname">Map&lt;String, Float&gt;</tt> is actually
          available via reflection, and so Spring's type conversion
          infrastructure will actually recognize the various value elements as
          being of type <tt class="classname">Float</tt> and so the string values
          <tt class="literal">'9.99', '2.75'</tt>, and <tt class="literal">'3.99'</tt>
          will be converted into an actual <tt class="classname">Float</tt>
          type.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-null-element"></a>3.3.2.5.&nbsp;<tt class="literal">Nulls</tt></h4></div></div><div></div></div><p>The <tt class="literal">&lt;null/&gt;</tt> element is used to handle
        <tt class="literal">null</tt> values. Spring treats empty arguments for
        properties and the like as empty <tt class="literal">Strings</tt>. The
        following XML-based configuration metadata snippet results in the
        email property being set to the empty <tt class="classname">String</tt>
        value ("")</p><pre class="programlisting">&lt;bean class="ExampleBean"&gt;
  &lt;property name="email"&gt;&lt;value/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>This is equivalent to the following Java code:
        <tt class="methodname">exampleBean.setEmail("")</tt>. The special
        <tt class="literal">&lt;null&gt;</tt> element may be used to indicate a
        <tt class="literal">null</tt> value. For example:</p><pre class="programlisting">&lt;bean class="ExampleBean"&gt;
  &lt;property name="email"&gt;&lt;null/&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>The above configuration is equivalent to the following Java
        code: <tt class="methodname">exampleBean.setEmail(null)</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xml-config-shortcuts"></a>3.3.2.6.&nbsp;Shortcuts and other convenience options for XML-based
        configuration metadata</h4></div></div><div></div></div><p>The configuration metadata shown so far is a tad verbose. That
        is why there are several options available for you to limit the amount
        of XML you have to write to configure your components. The first is a
        shortcut to define values and references to other beans as part of a
        <tt class="literal">&lt;property/&gt;</tt> definition. The second is
        slightly different format of specifying properties altogether.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-value-ref-shortcuts"></a>3.3.2.6.1.&nbsp;XML-based configuration metadata shortcuts</h5></div></div><div></div></div><p>The <tt class="literal">&lt;property/&gt;</tt>,
          <tt class="literal">&lt;constructor-arg/&gt;</tt>, and
          <tt class="literal">&lt;entry/&gt;</tt> elements all support a
          <tt class="literal">'value'</tt> attribute which may be used instead of
          embedding a full <tt class="literal">&lt;value/&gt;</tt> element.
          Therefore, the following:</p><pre class="programlisting">&lt;property name="myProperty"&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;constructor-arg&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/constructor-arg&gt;</pre><pre class="programlisting">&lt;entry key="myKey"&gt;
  &lt;value&gt;hello&lt;/value&gt;
&lt;/entry&gt;</pre><p>are equivalent to:</p><pre class="programlisting">&lt;property name="myProperty" value="hello"/&gt;</pre><pre class="programlisting">&lt;constructor-arg value="hello"/&gt;</pre><pre class="programlisting">&lt;entry key="myKey" value="hello"/&gt;</pre><p>The <tt class="literal">&lt;property/&gt;</tt> and
          <tt class="literal">&lt;constructor-arg/&gt;</tt> elements support a
          similar shortcut <tt class="literal">'ref'</tt> attribute which may be
          used instead of a full nested <tt class="literal">&lt;ref/&gt;</tt>
          element. Therefore, the following:</p><pre class="programlisting">&lt;property name="myProperty"&gt;
  &lt;ref bean="myBean"&gt;
&lt;/property&gt;</pre><pre class="programlisting">&lt;constructor-arg&gt;
  &lt;ref bean="myBean"&gt;
&lt;/constructor-arg&gt;</pre><p>... are equivalent to:</p><pre class="programlisting">&lt;property name="myProperty" ref="myBean"/&gt;</pre><pre class="programlisting">&lt;constructor-arg ref="myBean"/&gt;</pre><p>Note however that the shortcut form is equivalent to a
          <tt class="literal">&lt;ref bean="xxx"&gt;</tt> element; there is no
          shortcut for <tt class="literal">&lt;ref local="xxx"</tt>&gt;. To enforce
          a strict local reference, you must use the long form.</p><p>Finally, the entry element allows a shortcut form to specify
          the key and/or value of the map, in the form of the
          <tt class="literal">'key'</tt> / <tt class="literal">'key-ref'</tt> and
          <tt class="literal">'value'</tt> / <tt class="literal">'value-ref'</tt>
          attributes. Therefore, the following:</p><pre class="programlisting">&lt;entry&gt;
  &lt;key&gt;
    &lt;ref bean="myKeyBean" /&gt;
  &lt;/key&gt;
  &lt;ref bean="myValueBean" /&gt;
&lt;/entry&gt;</pre><p>is equivalent to:</p><pre class="programlisting">&lt;entry key-ref="myKeyBean" value-ref="myValueBean"/&gt;</pre><p>Again, the shortcut form is equivalent to a <tt class="literal">&lt;ref
          bean="xxx"&gt;</tt> element; there is no shortcut for
          <tt class="literal">&lt;ref local="xxx"</tt>&gt;.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-p-namespace"></a>3.3.2.6.2.&nbsp;The p-namespace and how to use it to configure
          properties</h5></div></div><div></div></div><p>The second option you have to limit the amount of XML you have
          to write to configure your components is to use the special
          "p-namespace". Spring 2.0 and later features support for extensible
          configuration formats <a href="#xsd-config" title="Appendix&nbsp;A.&nbsp;XML Schema-based configuration">using
          namespaces</a>. Those namespaces are all based on an XML Schema
          definition. In fact, the <tt class="literal">beans</tt> configuration
          format that you've been reading about is defined in an XML Schema
          document.</p><p>One special namespace is not defined in an XSD file, and only
          exists in the core of Spring itself. The so-called p-namespace
          doesn't need a schema definition and is an alternative way of
          configuring your properties differently than the way you have seen
          so far. Instead of using nested <tt class="literal">&lt;property/&gt;</tt>
          elements, using the p-namespace you can use attributes as part of
          the <tt class="literal">bean</tt> element that describe your property
          values. The values of the attributes will be taken as the values for
          your properties.</p><p>The following two XML snippets boil down to the same thing in
          the end: the first is using the standard XML format whereas the
          second example is using the p-namespace.</p><pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;
    
    &lt;bean name="classic" class="com.example.ExampleBean"&gt;
        &lt;property name="email" value="foo@bar.com/&gt;
    &lt;/bean&gt;
    
    &lt;bean name="p-namespace" class="com.example.ExampleBean"
          p:email="foo@bar.com"/&gt;
&lt;/beans&gt;</pre><p>As you can see, we are including an attribute in the
          p-namespace called email in the bean definition - this is telling
          Spring that it should include a property declaration. As previously
          mentioned, the p-namespace doesn't have a schema definition, so the
          name of the attribute can be set to whatever name your property
          has.</p><p>This next example includes two more bean definitions that both
          have a reference to another bean:</p><pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;
    
    &lt;bean name="john-classic" class="com.example.Person"&gt;
        &lt;property name="name" value="John Doe"/&gt;
        &lt;property name="spouse" ref="jane"/&gt;
    &lt;/bean&gt;

    &lt;bean name="john-modern" 
        class="com.example.Person"
        p:name="John Doe"
        p:spouse-ref="jane"/&gt;

    &lt;bean name="jane" class="com.example.Person"&gt;
        &lt;property name="name" value="Jane Doe"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>As you can see, this example doesn't only include a property
          value using the p-namespace, but also uses a special format to
          declare property references. Whereas the first bean definition uses
          <tt class="literal">&lt;property name="spouse" ref="jane"/&gt;</tt> to
          create a reference from bean <tt class="literal">john</tt> to bean
          <tt class="literal">jane</tt>, the second bean definition uses
          <tt class="literal">p:spouse-ref="jane"</tt> as an attribute to do the
          exact same thing. In this case '<tt class="literal">spouse</tt>' is the
          property name whereas the '<tt class="literal">-ref</tt>' part indicates
          that this is not a straight value but rather a reference to another
          bean.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Please note that the p-namespace is not quite as flexible as
            the standard XML format - for example particular, the 'special'
            format used to declare property references will clash with
            properties that end in '<tt class="literal">Ref</tt>', whereas the
            standard XML format would have no problem there. We recommend that
            you choose carefully which approach you are going to use in your
            projects. You should also communicate this to your team members so
            you won't end up with XML documents using all three approaches at
            the same time. This will prevent people from not understanding the
            application because of different ways of configuring it, and will
            add to the overall consistency of your codebase.</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-compound-property-names"></a>3.3.2.7.&nbsp;Compound property names</h4></div></div><div></div></div><p>Compound or nested property names are perfectly legal when
        setting bean properties, as long as all components of the path except
        the final property name are not <tt class="literal">null</tt>. Consider the
        following bean definition...</p><pre class="programlisting">&lt;bean id="foo" class="foo.Bar"&gt;
  &lt;property name="fred.bob.sammy" value="123" /&gt;
&lt;/bean&gt;</pre><p>The <tt class="literal">foo</tt> bean has a <tt class="literal">fred</tt>
        property which has a <tt class="literal">bob</tt> property, which has a
        <tt class="literal">sammy</tt> property, and that final
        <tt class="literal">sammy</tt> property is being set to the value
        <tt class="literal">123</tt>. In order for this to work, the
        <tt class="literal">fred</tt> property of <tt class="literal">foo</tt>, and the
        <tt class="literal">bob</tt> property of <tt class="literal">fred</tt> must not be
        <tt class="literal">null</tt> be non-null after the bean is constructed, or
        a <tt class="exceptionname">NullPointerException</tt> will be
        thrown.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-dependson"></a>3.3.3.&nbsp;Using <tt class="literal">depends-on</tt></h3></div></div><div></div></div><p>For most situations, the fact that a bean is a dependency of
      another is expressed by the fact that one bean is set as a property of
      another. This is typically accomplished with the <a href="#beans-ref-element" title="3.3.2.2.&nbsp;References to other beans (collaborators)"><tt class="literal">&lt;ref/&gt;</tt>
      element</a> in XML-based configuration metadata. For the relatively
      infrequent situations where dependencies between beans are less direct
      (for example, when a static initializer in a class needs to be
      triggered, such as database driver registration), the
      <tt class="literal">'depends-on'</tt> attribute may be used to explicitly
      force one or more beans to be initialized before the bean using this
      element is initialized. Find below an example of using the
      <tt class="literal">'depends-on'</tt> attribute to express a dependency on a
      single bean.</p><pre class="programlisting">&lt;bean id="beanOne" class="ExampleBean" depends-on="<span class="bold"><b>manager</b></span>"/&gt;

&lt;bean id="<span class="bold"><b>manager</b></span>" class="ManagerBean" /&gt;</pre><p>If you need to express a dependency on multiple beans, you can
      supply a list of bean names as the value of the
      <tt class="literal">'depends-on'</tt> attribute, with commas, whitespace and
      semicolons all valid delimiters, like so:</p><pre class="programlisting">&lt;bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao"&gt;
  &lt;property name="manager" ref="manager" /&gt;
&lt;/bean&gt;

&lt;bean id="manager" class="ManagerBean" /&gt;
&lt;bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" /&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The '<tt class="literal">depends-on</tt>' attribute at the bean definition
        level is used not only to specify an initialization time dependency, but
        also to specify the corresponding destroy time dependency (in the case of
        <a href="#beans-factory-scopes-singleton" title="3.4.1.&nbsp;The singleton scope">singleton</a> beans
        only). Dependent beans that define a '<tt class="literal">depends-on</tt>'
        relationship with a given bean will be destroyed first - prior to the given
        bean itself being destroyed. As a consequence, '<tt class="literal">depends-on</tt>'
        may be used to control shutdown order too.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-lazy-init"></a>3.3.4.&nbsp;Lazily-instantiated beans</h3></div></div><div></div></div><p>The default behavior for
      <tt class="interfacename">ApplicationContext</tt> implementations is to
      eagerly pre-instantiate all <tt class="literal">singleton</tt> beans at
      startup. Pre-instantiation means that an
      <tt class="interfacename">ApplicationContext</tt> will eagerly create
      and configure all of its <a href="#beans-factory-scopes-singleton" title="3.4.1.&nbsp;The singleton scope">singleton</a> beans as part
      of its initialization process. Generally this is <span class="emphasis"><em>a good
      thing</em></span>, because it means that any errors in the configuration
      or in the surrounding environment will be discovered immediately (as
      opposed to possibly hours or even days down the line).</p><p>However, there are times when this behavior is
      <span class="emphasis"><em>not</em></span> what is wanted. If you do not want a singleton
      bean to be pre-instantiated when using an
      <tt class="interfacename">ApplicationContext</tt>, you can selectively
      control this by marking a bean definition as lazy-initialized. A
      lazily-initialized bean indicates to the IoC container whether or not a
      bean instance should be created at startup or when it is first
      requested.</p><p>When configuring beans via XML, this lazy loading is controlled by
      the <tt class="literal">'lazy-init'</tt> attribute on the
      <tt class="literal">&lt;bean/&gt;</tt> element; for example:</p><pre class="programlisting">&lt;bean id="lazy" class="com.foo.ExpensiveToCreateBean" <span class="bold"><b>lazy-init="true"</b></span>/&gt;

&lt;bean name="not.lazy" class="com.foo.AnotherBean"/&gt;</pre><p>When the above configuration is consumed by an
      <tt class="interfacename">ApplicationContext</tt>, the bean named
      <tt class="literal">'lazy'</tt> will <span class="emphasis"><em>not</em></span> be eagerly
      pre-instantiated when the
      <tt class="interfacename">ApplicationContext</tt> is starting up,
      whereas the <tt class="literal">'not.lazy'</tt> bean will be eagerly
      pre-instantiated.</p><p>One thing to understand about lazy-initialization is that even
      though a bean definition may be marked up as being lazy-initialized, if
      the lazy-initialized bean is the dependency of a singleton bean that is
      not lazy-initialized, when the
      <tt class="interfacename">ApplicationContext</tt> is eagerly
      pre-instantiating the singleton, it will have to satisfy all of the
      singletons dependencies, one of which will be the lazy-initialized bean!
      So don't be confused if the IoC container creates one of the beans that
      you have explicitly configured as lazy-initialized at startup; all that
      means is that the lazy-initialized bean is being injected into a
      non-lazy-initialized singleton bean elsewhere.</p><p>It is also possible to control lazy-initialization at the
      container level by using the <tt class="literal">'default-lazy-init'</tt>
      attribute on the <tt class="literal">&lt;beans/&gt;</tt> element; for
      example:</p><pre class="programlisting">&lt;beans default-lazy-init="true"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- no beans will be pre-instantiated... --&gt;</span></i>
&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-autowire"></a>3.3.5.&nbsp;Autowiring collaborators</h3></div></div><div></div></div><p>The Spring container is able to <span class="emphasis"><em>autowire</em></span>
      relationships between collaborating beans. This means that it is
      possible to automatically let Spring resolve collaborators (other beans)
      for your bean by inspecting the contents of the
      <tt class="interfacename">BeanFactory</tt>. The autowiring functionality
      has five modes. Autowiring is specified <span class="emphasis"><em>per</em></span> bean
      and can thus be enabled for some beans, while other beans will not be
      autowired. Using autowiring, it is possible to reduce or eliminate the
      need to specify properties or constructor arguments, thus saving a
      significant amount of typing. <sup>[<a name="d0e3240" href="#ftn.d0e3240">2</a>]</sup> When using XML-based configuration metadata, the autowire
      mode for a bean definition is specified by using the
      <tt class="literal">autowire</tt> attribute of the
      <tt class="literal">&lt;bean/&gt;</tt> element. The following values are
      allowed:</p><div class="table"><a name="beans-factory-autowiring-modes-tbl"></a><p class="title"><b>Table&nbsp;3.2.&nbsp;Autowiring modes</b></p><table summary="Autowiring modes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Mode</th><th>Explanation</th></tr></thead><tbody><tr><td>no</td><td><p>No autowiring at all. Bean references must be
              defined via a <tt class="literal">ref</tt> element. This is the
              default, and changing this is discouraged for larger
              deployments, since explicitly specifying collaborators gives
              greater control and clarity. To some extent, it is a form of
              documentation about the structure of a system.</p></td></tr><tr><td>byName</td><td><p>Autowiring by property name. This option will
              inspect the container and look for a bean named exactly the same
              as the property which needs to be autowired. For example, if you
              have a bean definition which is set to autowire by name, and it
              contains a <span class="emphasis"><em>master</em></span> property (that is, it has
              a <span class="emphasis"><em>setMaster(..)</em></span> method), Spring will look
              for a bean definition named <tt class="literal">master</tt>, and use
              it to set the property.</p></td></tr><tr><td>byType</td><td><p>Allows a property to be autowired if there is
              exactly one bean of the property type in the container. If there
              is more than one, a fatal exception is thrown, and this
              indicates that you may not use <span class="emphasis"><em>byType</em></span>
              autowiring for that bean. If there are no matching beans,
              nothing happens; the property is not set. If this is not
              desirable, setting the
              <tt class="literal">dependency-check="objects"</tt> attribute value
              specifies that an error should be thrown in this
              case.</p></td></tr><tr><td>constructor</td><td><p>This is analogous to <span class="emphasis"><em>byType</em></span>,
              but applies to constructor arguments. If there isn't exactly one
              bean of the constructor argument type in the container, a fatal
              error is raised.</p></td></tr><tr><td>autodetect</td><td><p>Chooses <span class="emphasis"><em>constructor</em></span> or
              <span class="emphasis"><em>byType</em></span> through introspection of the bean
              class. If a default constructor is found, the
              <span class="emphasis"><em>byType</em></span> mode will be applied.</p></td></tr></tbody></table></div><p>Note that explicit dependencies in <tt class="literal">property</tt> and
      <tt class="literal">constructor-arg</tt> settings
      <tt class="interfacename">always</tt> override autowiring. Please also
      note that it is not currently possible to autowire so-called
      <span class="emphasis"><em>simple</em></span> properties such as primitives,
      <tt class="classname">Strings</tt>, and <tt class="classname">Classes</tt> (and
      arrays of such simple properties). (This is by-design and should be
      considered a <span class="emphasis"><em>feature</em></span>.) When using either the
      <span class="emphasis"><em>byType</em></span> or <span class="emphasis"><em>constructor</em></span>
      autowiring mode, it is possible to wire arrays and typed-collections. In
      such cases <span class="emphasis"><em>all</em></span> autowire candidates within the
      container that match the expected type will be provided to satisfy the
      dependency. Strongly-typed Maps can even be autowired if the expected
      key type is <tt class="classname">String</tt>. An autowired Map's values
      will consist of all bean instances that match the expected type, and the
      Map's keys will contain the corresponding bean names.</p><p>Autowire behavior can be combined with dependency checking, which
      will be performed after all autowiring has been completed.</p><p>It is important to understand the various advantages and
      disadvantages of autowiring. Some advantages of autowiring
      include:</p><div class="itemizedlist"><ul type="disc"><li><p>Autowiring can significantly reduce the volume of
          configuration required. However, mechanisms such as the use of a
          bean template (<a href="#beans-child-bean-definitions" title="3.6.&nbsp;Bean definition inheritance">discussed elsewhere in this
          chapter</a>) are also valuable in this regard.</p></li><li><p>Autowiring can cause configuration to keep itself up to date
          as your objects evolve. For example, if you need to add an
          additional dependency to a class, that dependency can be satisfied
          automatically without the need to modify configuration. Thus there
          may be a strong case for autowiring during development, without
          ruling out the option of switching to explicit wiring when the code
          base becomes more stable.</p></li></ul></div><p>Some disadvantages of autowiring:</p><div class="itemizedlist"><ul type="disc"><li><p>Autowiring is more magical than explicit wiring. Although, as
          noted in the above table, Spring is careful to avoid guessing in
          case of ambiguity which might have unexpected results, the
          relationships between your Spring-managed objects are no longer
          documented explicitly.</p></li><li><p>Wiring information may not be available to tools that may
          generate documentation from a Spring container.</p></li></ul></div><p>Another issue to consider when autowiring by type is that multiple
      bean definitions within the container may match the type specified by
      the setter method or constructor argument to be autowired. For arrays,
      collections, or Maps, this is not necessarily a problem. However for
      dependencies that expect a single value, this ambiguity will not be
      arbitrarily resolved. Instead, if no unique bean definition is
      available, an Exception will be thrown. You do have several options when
      confronted with this scenario. First, you may abandon autowiring in
      favor of explicit wiring. Second, you may designate that certain bean
      definitions are never to be considered as candidates by setting their
      <tt class="literal">'autowire-candidate'</tt> attributes to
      <tt class="literal">'false'</tt> as described in the next section. Third, you
      may designate a single bean definition as the
      <span class="emphasis"><em>primary</em></span> candidate by setting the
      <tt class="literal">'primary'</tt> attribute of its
      <tt class="literal">&lt;bean/&gt;</tt> element to <tt class="literal">'true'</tt>.
      Finally, if you are using at least Java 5, you may be interested in
      exploring the more fine-grained control available with annotation-based
      configuration as described in the section entitled <a href="#beans-annotation-config" title="3.11.&nbsp;Annotation-based configuration">Section&nbsp;3.11, &#8220;Annotation-based configuration&#8221;</a>.</p><p>When deciding whether to use autowiring, there is no wrong or
      right answer in all cases. A degree of consistency across a project is
      best though; for example, if autowiring is not used in general, it might
      be confusing to developers to use it just to wire one or two bean
      definitions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-autowire-candidate"></a>3.3.5.1.&nbsp;Excluding a bean from being available for autowiring</h4></div></div><div></div></div><p>You can also (on a per-bean basis) totally exclude a bean from
        being an autowire candidate. When configuring beans using Spring's XML
        format, the <tt class="literal">'autowire-candidate'</tt> attribute of the
        <tt class="literal">&lt;bean/&gt;</tt> element can be set to
        <tt class="literal">'false'</tt>; this has the effect of making the
        container totally exclude that specific bean definition from being
        available to the autowiring infrastructure.</p><p>Another option is to limit autowire candidates based on
        pattern-matching against bean names. The top-level
        <tt class="literal">&lt;beans/&gt;</tt> element accepts one or more patterns
        within its <tt class="literal">'default-autowire-candidates'</tt> attribute.
        For example, to limit autowire candidate status to any bean whose name
        ends with <span class="emphasis"><em>'Repository'</em></span>, provide a value of
        '*Repository'. To provide multiple patterns, define them in a
        comma-separated list. Note that an explicit value of
        <tt class="literal">'true'</tt> or <tt class="literal">'false'</tt> for a bean
        definition's <tt class="literal">'autowire-candidate'</tt> attribute always
        takes precedence, and for such beans, the pattern matching rules will
        not apply.</p><p>These techniques can be useful when you have one or more beans
        that you absolutely never ever want to have injected into other beans
        via autowiring. It does not mean that an excluded bean cannot itself
        be configured using autowiring... it can, it is rather that it itself
        will not be considered as a candidate for autowiring other
        beans.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-dependencies"></a>3.3.6.&nbsp;Checking for dependencies</h3></div></div><div></div></div><p>The Spring IoC container also has the ability to check for the
      existence of unresolved dependencies of a bean deployed into the
      container. These are JavaBeans properties of the bean, which do not have
      actual values set for them in the bean definition, or alternately
      provided automatically by the autowiring feature.</p><p>This feature is sometimes useful when you want to ensure that all
      properties (or all properties of a certain type) are set on a bean. Of
      course, in many cases a bean class will have default values for many
      properties, or some properties do not apply to all usage scenarios, so
      this feature is of limited use. Dependency checking can also be enabled
      and disabled per bean, just as with the autowiring functionality. The
      default is to <span class="emphasis"><em>not</em></span> check dependencies. Dependency
      checking can be handled in several different modes. When using XML-based
      configuration metadata, this is specified via the
      <tt class="literal">'dependency-check'</tt> attribute in a bean definition,
      which may have the following values.</p><div class="table"><a name="beans-factory-dependency-check-modes-tbl"></a><p class="title"><b>Table&nbsp;3.3.&nbsp;Dependency checking modes</b></p><table summary="Dependency checking modes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Mode</th><th>Explanation</th></tr></thead><tbody><tr><td>none</td><td><p>No dependency checking. Properties of the bean
              which have no value specified for them are simply not
              set.</p></td></tr><tr><td>simple</td><td><p>Dependency checking is performed for primitive
              types and collections (everything except
              collaborators).</p></td></tr><tr><td>object</td><td><p>Dependency checking is performed for collaborators
              only.</p></td></tr><tr><td>all</td><td><p>Dependency checking is done for collaborators,
              primitive types and collections.</p></td></tr></tbody></table></div><p>If you are using Java 5 and thus have access to source-level
      annotations, you may find the section entitled <a href="#metadata-annotations-required" title="25.3.1.&nbsp;@Required">Section&nbsp;25.3.1, &#8220;@Required&#8221;</a> to be of interest.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-method-injection"></a>3.3.7.&nbsp;Method Injection</h3></div></div><div></div></div><p>For most application scenarios, the majority of the beans in the
      container will be <a href="#beans-factory-scopes-singleton" title="3.4.1.&nbsp;The singleton scope">singletons</a>. When a
      singleton bean needs to collaborate with another singleton bean, or a
      non-singleton bean needs to collaborate with another non-singleton bean,
      the typical and common approach of handling this dependency by defining
      one bean to be a property of the other is quite adequate. There is a
      problem when the bean lifecycles are different. Consider a singleton
      bean A which needs to use a non-singleton (prototype) bean B, perhaps on
      each method invocation on A. The container will only create the
      singleton bean A once, and thus only get the opportunity to set the
      properties once. There is no opportunity for the container to provide
      bean A with a new instance of bean B every time one is needed.</p><p>One solution to this issue is to forego some inversion of control.
      Bean A can be <a href="#beans-factory-aware-beanfactoryaware" title="3.5.2.1.&nbsp;BeanFactoryAware">made
      aware of the container</a> by implementing the
      <tt class="interfacename">BeanFactoryAware</tt> interface, and <a href="#beans-factory-client" title="3.2.4.&nbsp;Using the container">use programmatic means</a> to ask the
      container via a <tt class="methodname">getBean("B")</tt> call for (a
      typically new) bean B instance every time it needs it. Find below an
      admittedly somewhat contrived example of this approach:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// a class that uses a stateful Command-style class to perform some processing</span></i>
package fiona.apple;

<i class="lineannotation"><span class="lineannotation">// lots of Spring-API imports</span></i>
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;

public class CommandManager implements BeanFactoryAware {

   private BeanFactory beanFactory;

   public Object process(Map commandState) {
      <i class="lineannotation"><span class="lineannotation">// grab a new instance of the appropriate <tt class="interfacename">Command</tt></span></i>
      Command command = createCommand();
      <i class="lineannotation"><span class="lineannotation">// set the state on the (hopefully brand new) <tt class="interfacename">Command</tt> instance</span></i>
      command.setState(commandState);
      return command.execute();
   }

   <i class="lineannotation"><span class="lineannotation">// the <tt class="interfacename">Command</tt> returned here could be an implementation that executes asynchronously, or whatever</span></i>
   protected Command createCommand() {
      return (Command) this.beanFactory.getBean("command"); <i class="lineannotation"><span class="lineannotation">// notice the Spring API dependency</span></i>
   }

   public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
      this.beanFactory = beanFactory;
   }
}</pre><p>The above example is generally not a desirable solution since the
      business code is then aware of and coupled to the Spring Framework.
      Method Injection, a somewhat advanced feature of the Spring IoC
      container, allows this use case to be handled in a clean fashion.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lookup-method-injection"></a>3.3.7.1.&nbsp;Lookup method injection</h4></div></div><div></div></div><div class="sidebar"><p class="title"><b>Isn't this Method Injection...</b></p><p>... somewhat like Tapestry 4.0's pages, where folks wrote
          <tt class="literal">abstract</tt> properties that Tapestry would override
          at runtime with implementations that did stuff? It sure is (well,
          somewhat).</p><p>You can read more about the motivation for Method Injection in
          <a href="http://blog.springframework.com/rod/?p=1" target="_top">this blog
          entry</a>.</p></div><p>Lookup method injection refers to the ability of the container
        to override methods on <span class="emphasis"><em>container managed beans</em></span>,
        to return the result of looking up another named bean in the
        container. The lookup will typically be of a prototype bean as in the
        scenario described above. The Spring Framework implements this method
        injection by dynamically generating a subclass overriding the method,
        using bytecode generation via the CGLIB library.</p><p>So if you look at the code from previous code snippet (the
        <tt class="classname">CommandManager</tt> class), the Spring container is
        going to dynamically override the implementation of the
        <tt class="methodname">createCommand()</tt> method. Your
        <tt class="classname">CommandManager</tt> class is not going to have any
        Spring dependencies, as can be seen in this reworked example
        below:</p><pre class="programlisting">package fiona.apple;

<i class="lineannotation"><span class="lineannotation">// no more Spring imports! </span></i>

public abstract class CommandManager {

   public Object process(Object commandState) {
      <i class="lineannotation"><span class="lineannotation">// grab a new instance of the appropriate <tt class="interfacename">Command</tt> interface</span></i>
      Command command = createCommand();
      <i class="lineannotation"><span class="lineannotation">// set the state on the (hopefully brand new) <tt class="interfacename">Command</tt> instance</span></i>
      command.setState(commandState);
      return command.execute();
   }

    <i class="lineannotation"><span class="lineannotation">// okay... but where is the implementation of this method?</span></i>
   protected abstract Command createCommand();
}</pre><p>In the client class containing the method to be injected (the
        <tt class="classname">CommandManager</tt> in this case), the method that
        is to be 'injected' must have a signature of the following
        form:</p><pre class="programlisting">&lt;public|protected&gt; [abstract] &lt;return-type&gt; theMethodName(<i class="lineannotation"><span class="lineannotation">no-arguments</span></i>);</pre><p>If the method is <tt class="literal">abstract</tt>, the
        dynamically-generated subclass will implement the method. Otherwise,
        the dynamically-generated subclass will override the concrete method
        defined in the original class. Let's look at an example:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></i>
&lt;bean id="command" class="fiona.apple.AsyncCommand" scope="prototype"&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- inject dependencies here as required --&gt;</span></i>
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="literal">commandProcessor</tt> uses <tt class="literal">statefulCommandHelper</tt> --&gt;</span></i>
&lt;bean id="commandManager" class="fiona.apple.CommandManager"&gt;
  &lt;lookup-method name="createCommand" bean="command"/&gt;
&lt;/bean&gt;</pre><p>The bean identified as <span class="emphasis"><em>commandManager</em></span> will
        call its own method <tt class="methodname">createCommand()</tt> whenever
        it needs a new instance of the <span class="emphasis"><em>command</em></span> bean. It
        is important to note that the person deploying the beans must be
        careful to deploy the <tt class="literal">command</tt> bean as a prototype
        (if that is actually what is needed). If it is deployed as a <a href="#beans-factory-scopes-singleton" title="3.4.1.&nbsp;The singleton scope">singleton</a>, the same
        instance of the <tt class="literal">command</tt> bean will be returned each
        time!</p><p>Please be aware that in order for this dynamic subclassing to
        work, you will need to have the CGLIB jar(s) on your classpath.
        Additionally, the class that the Spring container is going to subclass
        cannot be <tt class="literal">final</tt>, and the method that is being
        overridden cannot be <tt class="literal">final</tt> either. Also, testing a
        class that has an <tt class="literal">abstract</tt> method can be somewhat
        odd in that you will have to subclass the class yourself and supply a
        stub implementation of the <tt class="literal">abstract</tt> method.
        Finally, objects that have been the target of method injection cannot
        be serialized.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>The interested reader may also find the
          <tt class="classname">ServiceLocatorFactoryBean</tt> (in the
          <tt class="literal">org.springframework.beans.factory.config</tt> package)
          to be of use; the approach is similar to that of the
          <tt class="classname">ObjectFactoryCreatingFactoryBean</tt>, but it
          allows you to specify your own lookup interface as opposed to having
          to use a Spring-specific lookup interface such as the
          <tt class="interfacename">ObjectFactory</tt>. Consult the (copious)
          Javadoc for the <tt class="classname">ServiceLocatorFactoryBean</tt> for
          a full treatment of this alternative approach (that
          <span class="emphasis"><em>does</em></span> reduce the coupling to Spring).</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-arbitrary-method-replacement"></a>3.3.7.2.&nbsp;Arbitrary method replacement</h4></div></div><div></div></div><p>A less commonly useful form of method injection than Lookup
        Method Injection is the ability to replace arbitrary methods in a
        managed bean with another method implementation. Users may safely skip
        the rest of this section (which describes this somewhat advanced
        feature), until this functionality is actually needed.</p><p>When using XML-based configuration metadata, the
        <tt class="literal">replaced-method</tt> element may be used to replace an
        existing method implementation with another, for a deployed bean.
        Consider the following class, with a method computeValue, which we
        want to override:</p><pre class="programlisting">public class MyValueCalculator {

  public String computeValue(String input) {
    <i class="lineannotation"><span class="lineannotation">// some real code...</span></i>
  }

  <i class="lineannotation"><span class="lineannotation">// some other methods...</span></i>

}</pre><p>A class implementing the
        <tt class="interfacename">org.springframework.beans.factory.support.MethodReplacer</tt>
        interface provides the new method definition.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">/** meant to be used to override the existing <tt class="methodname">computeValue(String)</tt>
    implementation in <tt class="classname">MyValueCalculator</tt>
  */</span></i>
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        <i class="lineannotation"><span class="lineannotation">// get the input value, work with it, and return a computed result</span></i>
        String input = (String) args[0];
        ... 
        return ...;
    }
}</pre><p>The bean definition to deploy the original class and specify the
        method override would look like this:</p><pre class="programlisting">&lt;bean id="myValueCalculator class="x.y.z.MyValueCalculator"&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- arbitrary method replacement --&gt;</span></i>
  &lt;replaced-method name="computeValue" replacer="replacementComputeValue"&gt;
    &lt;arg-type&gt;String&lt;/arg-type&gt;
  &lt;/replaced-method&gt;
&lt;/bean&gt;

&lt;bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/&gt;</pre><p>One or more contained <tt class="literal">&lt;arg-type/&gt;</tt>
        elements within the <tt class="literal">&lt;replaced-method/&gt;</tt>
        element may be used to indicate the method signature of the method
        being overridden. Note that the signature for the arguments is
        actually only needed in the case that the method is actually
        overloaded and there are multiple variants within the class. For
        convenience, the type string for an argument may be a substring of the
        fully qualified type name. For example, all the following would match
        <tt class="classname">java.lang.String</tt>.</p><pre class="programlisting">    java.lang.String
    String
    Str</pre><p>Since the number of arguments is often enough to distinguish
        between each possible choice, this shortcut can save a lot of typing,
        by allowing you to type just the shortest string that will match an
        argument type.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-scopes"></a>3.4.&nbsp;Bean scopes</h2></div></div><div></div></div><p>When you create a bean definition what you are actually creating is
    a <span class="emphasis"><em>recipe</em></span> for creating actual instances of the class
    defined by that bean definition. The idea that a bean definition is a
    recipe is important, because it means that, just like a class, you can
    potentially have many object instances created from a single
    recipe.</p><p>You can control not only the various dependencies and configuration
    values that are to be plugged into an object that is created from a
    particular bean definition, but also the <i class="firstterm">scope</i> of
    the objects created from a particular bean definition. This approach is
    very powerful and gives you the flexibility to <span class="emphasis"><em>choose</em></span>
    the scope of the objects you create through configuration instead of
    having to 'bake in' the scope of an object at the Java class level. Beans
    can be defined to be deployed in one of a number of scopes: out of the
    box, the Spring Framework supports exactly five scopes (of which three are
    available only if you are using a web-aware
    <tt class="interfacename">ApplicationContext</tt>).</p><p>The scopes supported out of the box are listed below:</p><div class="table"><a name="beans-factory-scopes-tbl"></a><p class="title"><b>Table&nbsp;3.4.&nbsp;Bean scopes</b></p><table summary="Bean scopes" border="1"><colgroup><col><col></colgroup><thead><tr><th align="center">Scope</th><th align="center">Description</th></tr></thead><tbody><tr><td><p>
                <a href="#beans-factory-scopes-singleton" title="3.4.1.&nbsp;The singleton scope">singleton</a>
              </p></td><td><p>Scopes a single bean definition to a single object
              instance per Spring IoC container.</p></td></tr><tr><td><p>
                <a href="#beans-factory-scopes-prototype" title="3.4.2.&nbsp;The prototype scope">prototype</a>
              </p></td><td><p>Scopes a single bean definition to any number of object
              instances.</p></td></tr><tr><td><p>
                <a href="#beans-factory-scopes-request" title="3.4.4.2.&nbsp;The request scope">request</a>
              </p></td><td><p>Scopes a single bean definition to the lifecycle of a
              single HTTP request; that is each and every HTTP request will
              have its own instance of a bean created off the back of a single
              bean definition. Only valid in the context of a web-aware Spring
              <tt class="interfacename">ApplicationContext</tt>.</p></td></tr><tr><td><p>
                <a href="#beans-factory-scopes-global-session" title="3.4.4.4.&nbsp;The global session scope">session</a>
              </p></td><td><p>Scopes a single bean definition to the lifecycle of a HTTP
              <tt class="interfacename">Session</tt>. Only valid in the
              context of a web-aware Spring
              <tt class="interfacename">ApplicationContext</tt>.</p></td></tr><tr><td><p>
                <a href="#beans-factory-scopes-global-session" title="3.4.4.4.&nbsp;The global session scope">global
                session</a>
              </p></td><td><p>Scopes a single bean definition to the lifecycle of a
              global HTTP <tt class="interfacename">Session</tt>. Typically
              only valid when used in a portlet context. Only valid in the
              context of a web-aware Spring
              <tt class="interfacename">ApplicationContext</tt>.</p></td></tr></tbody></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-scopes-singleton"></a>3.4.1.&nbsp;The singleton scope</h3></div></div><div></div></div><p>When a bean is a singleton, only one <span class="emphasis"><em>shared</em></span>
      instance of the bean will be managed, and all requests for beans with an
      id or <tt class="literal">id</tt>s matching that bean definition will result
      in that one specific bean instance being returned by the Spring
      container.</p><p>To put it another way, when you define a bean definition and it is
      scoped as a singleton, then the Spring IoC container will create
      <span class="emphasis"><em>exactly one</em></span> instance of the object defined by that
      bean definition. This single instance will be stored in a cache of such
      singleton beans, and <span class="emphasis"><em>all subsequent requests and
      references</em></span> for that named bean will result in the cached
      object being returned.</p><p>
        </p><div class="mediaobject" align="center"><img src="images/singleton.png" align="middle"></div><p>
      </p><p>Please be aware that Spring's concept of a singleton bean is quite
      different from the Singleton pattern as defined in the seminal Gang of
      Four (GoF) patterns book. The GoF Singleton hard codes the scope of an
      object such that one <span class="emphasis"><em>and only one</em></span> instance of a
      particular class will ever be created<span class="emphasis"><em> per
      <tt class="classname">ClassLoader</tt></em></span>. The scope of the Spring
      singleton is best described as <span class="emphasis"><em>per container and per
      bean</em></span>. This means that if you define one bean for a particular
      class in a single Spring container, then the Spring container will
      create one <span class="emphasis"><em>and only one</em></span> instance of the class
      defined by that bean definition. <span class="emphasis"><em>The singleton scope is the
      default scope in Spring</em></span>. To define a bean as a singleton in
      XML, you would write configuration like so:</p><pre class="programlisting">&lt;bean id="accountService" class="com.foo.DefaultAccountService"/&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- the following is equivalent, though redundant (singleton scope is the default); using <tt class="literal">spring-beans-2.0.dtd</tt> --&gt;</span></i>
&lt;bean id="accountService" class="com.foo.DefaultAccountService" scope="singleton"/&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- the following is equivalent and preserved for backward compatibility in <tt class="literal">spring-beans.dtd</tt> --&gt;</span></i>
&lt;bean id="accountService" class="com.foo.DefaultAccountService" singleton="true"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-scopes-prototype"></a>3.4.2.&nbsp;The prototype scope</h3></div></div><div></div></div><p>The non-singleton, prototype scope of bean deployment results in
      the <span class="emphasis"><em>creation of a new bean instance</em></span> every time a
      request for that specific bean is made (that is, it is injected into
      another bean or it is requested via a programmatic
      <tt class="literal">getBean()</tt> method call on the container). As a rule of
      thumb, you should use the prototype scope for all beans that are
      stateful, while the singleton scope should be used for stateless
      beans.</p><p>The following diagram illustrates the Spring prototype scope.
      <span class="emphasis"><em>Please note that a DAO would not typically be configured as a
      prototype, since a typical DAO would not hold any conversational state;
      it was just easier for this author to reuse the core of the singleton
      diagram.</em></span></p><p>
        </p><div class="mediaobject" align="center"><img src="images/prototype.png" align="middle"></div><p>
      </p><p>To define a bean as a prototype in XML, you would write
      configuration like so:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- using <tt class="literal">spring-beans-2.0.dtd</tt> --&gt;</span></i>
&lt;bean id="accountService" class="com.foo.DefaultAccountService" scope="prototype"/&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- the following is equivalent and preserved for backward compatibility in <tt class="literal">spring-beans.dtd</tt> --&gt;</span></i>
&lt;bean id="accountService" class="com.foo.DefaultAccountService" singleton="false"/&gt;</pre><p>There is one quite important thing to be aware of when deploying a
      bean in the prototype scope, in that the lifecycle of the bean changes
      slightly. Spring does not manage the complete lifecycle of a prototype
      bean: the container instantiates, configures, decorates and otherwise
      assembles a prototype object, hands it to the client and then has no
      further knowledge of that prototype instance. This means that while
      <span class="emphasis"><em>initialization</em></span> lifecycle callback methods will be
      called on all objects regardless of scope, in the case of prototypes,
      any configured <span class="emphasis"><em>destruction</em></span> lifecycle callbacks will
      <span class="emphasis"><em>not</em></span> be called. It is the responsibility of the
      client code to clean up prototype scoped objects and release any
      expensive resources that the prototype bean(s) are holding onto. (One
      possible way to get the Spring container to release resources used by
      prototype-scoped beans is through the use of a custom <a href="#beans-factory-extension-bpp" title="3.7.1.&nbsp;Customizing beans using&#xA;      BeanPostProcessors">bean post-processor</a> which
      would hold a reference to the beans that need to be cleaned up.)</p><p>In some respects, you can think of the Spring containers role when
      talking about a prototype-scoped bean as somewhat of a replacement for
      the Java <tt class="literal">'new'</tt> operator. All lifecycle aspects past
      that point have to be handled by the client. (The lifecycle of a bean in
      the Spring container is further described in the section entitled <a href="#beans-factory-lifecycle" title="3.5.1.&nbsp;Lifecycle callbacks">Section&nbsp;3.5.1, &#8220;Lifecycle callbacks&#8221;</a>.)</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-scopes-sing-prot-interaction"></a>3.4.3.&nbsp;Singleton beans with prototype-bean dependencies</h3></div></div><div></div></div><p>When using singleton-scoped beans that have dependencies on beans
      that are scoped as prototypes, please be aware that
      <span class="emphasis"><em>dependencies are resolved at instantiation time</em></span>.
      This means that if you dependency inject a prototype-scoped bean into a
      singleton-scoped bean, a brand new prototype bean will be instantiated
      and then dependency injected into the singleton bean... <span class="emphasis"><em>but
      that is all</em></span>. That exact same prototype instance will be the
      sole instance that is ever supplied to the singleton-scoped bean, which
      is fine if that is what you want.</p><p>However, sometimes what you actually want is for the
      singleton-scoped bean to be able to acquire a brand new instance of the
      prototype-scoped bean again and again and again at runtime. In that case
      it is no use just dependency injecting a prototype-scoped bean into your
      singleton bean, because as explained above, that only happens
      <span class="emphasis"><em>once</em></span> when the Spring container is instantiating the
      singleton bean and resolving and injecting its dependencies. If you are
      in the scenario where you need to get a brand new instance of a
      (prototype) bean again and again and again at runtime, you are referred
      to the section entitled <a href="#beans-factory-method-injection" title="3.3.7.&nbsp;Method Injection">Section&nbsp;3.3.7, &#8220;Method Injection&#8221;</a></p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Backwards compatibility note: specifying the lifecycle scope in&#xA;      XML"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Backwards compatibility note: specifying the lifecycle scope in
      XML</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you are referencing the <tt class="filename">'spring-beans.dtd'</tt>
      DTD in a bean definition file(s), and you are being explicit about the
      lifecycle scope of your beans you must use the
      "<tt class="literal">singleton</tt>" attribute to express the lifecycle scope
      (remembering that the <a href="#beans-factory-scopes-singleton" title="3.4.1.&nbsp;The singleton scope">singleton lifecycle
      scope</a> is the default). If you are referencing the
      <tt class="filename">'spring-beans-2.0.dtd'</tt> DTD or the Spring 2.0 XSD
      schema, then you will need to use the "<tt class="literal">scope</tt>"
      attribute (because the "<tt class="literal">singleton</tt>" attribute was
      removed from the definition of the new DTD and XSD files in favor of the
      "<tt class="literal">scope</tt>" attribute).</p><p>To be totally clear about this, this means that if you use the
      "<tt class="literal">singleton</tt>" attribute in an XML bean definition then
      you <span class="emphasis"><em>must</em></span> be referencing the
      <tt class="filename">'spring-beans.dtd'</tt> DTD <span class="emphasis"><em>in that
      file</em></span>. If you are using the "<tt class="literal">scope</tt>"
      attribute then you <span class="emphasis"><em>must</em></span> be referencing either the
      <tt class="filename">'spring-beans-2.0.dtd'</tt> DTD or the
      <tt class="filename">'spring-beans-2.5.xsd'</tt> XSD <span class="emphasis"><em>in that
      file</em></span>.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-scopes-other"></a>3.4.4.&nbsp;The other scopes</h3></div></div><div></div></div><p>The other scopes, namely <tt class="literal">request</tt>,
      <tt class="literal">session</tt>, and <tt class="literal">global session</tt> are
      for use only in web-based applications (and can be used irrespective of
      which particular web application framework you are using, if indeed
      any). In the interest of keeping related concepts together in one place
      in the reference documentation, these scopes are described here.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The scopes that are described in the following paragraphs are
        <span class="emphasis"><em>only</em></span> available if you are using a web-aware
        Spring <tt class="interfacename">ApplicationContext</tt>
        implementation (such as
        <tt class="classname">XmlWebApplicationContext</tt>). If you try using
        these next scopes with regular Spring IoC containers such as the
        <tt class="classname">XmlBeanFactory</tt> or
        <tt class="classname">ClassPathXmlApplicationContext</tt>, you
        <span class="emphasis"><em>will</em></span> get an
        <tt class="classname">IllegalStateException</tt> complaining about an
        unknown bean scope.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-other-web-configuration"></a>3.4.4.1.&nbsp;Initial web configuration</h4></div></div><div></div></div><p>In order to support the scoping of beans at the
        <tt class="literal">request</tt>, <tt class="literal">session</tt>, and
        <tt class="literal">global session</tt> levels (web-scoped beans), some
        minor initial configuration is required before you can set about
        defining your bean definitions. Please note that this extra setup is
        <span class="emphasis"><em>not</em></span> required if you just want to use the
        'standard' scopes (namely singleton and prototype).</p><p>Now as things stand, there are a couple of ways to effect this
        initial setup depending on your particular Servlet
        environment...</p><p>If you are accessing scoped beans within Spring Web MVC, i.e.
        within a request that is processed by the Spring
        <tt class="classname">DispatcherServlet</tt>, or
        <tt class="classname">DispatcherPortlet</tt>, then no special setup is
        necessary: <tt class="classname">DispatcherServlet</tt> and
        <tt class="classname">DispatcherPortlet</tt> already expose all relevant
        state.</p><p>When using a Servlet 2.4+ web container, with requests processed
        outside of Spring's DispatcherServlet (e.g. when using JSF or Struts),
        you need to add the following
        <tt class="interfacename">javax.servlet.ServletRequestListener</tt> to
        the declarations in your web application's
        <tt class="literal">'web.xml'</tt> file.</p><pre class="programlisting">&lt;web-app&gt;
  ...
  &lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt;
  &lt;/listener&gt;
  ...
&lt;/web-app&gt;</pre><p>If you are using an older web container (Servlet 2.3), you will
        need to use the provided
        <tt class="interfacename">javax.servlet.Filter</tt> implementation.
        Find below a snippet of XML configuration that has to be included in
        the <tt class="literal">'web.xml'</tt> file of your web application if you
        want to have access to web-scoped beans in requests outside of
        Spring's DispatcherServlet on a Servlet 2.3 container. (The filter
        mapping depends on the surrounding web application configuration and
        so you will have to change it as appropriate.)</p><pre class="programlisting">&lt;web-app&gt;
  ..
  &lt;filter&gt; 
    &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt; 
    &lt;filter-class&gt;org.springframework.web.filter.RequestContextFilter&lt;/filter-class&gt;
  &lt;/filter&gt; 
  &lt;filter-mapping&gt; 
    &lt;filter-name&gt;requestContextFilter&lt;/filter-name&gt; 
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
  ...
&lt;/web-app&gt;</pre><p>That's it. <tt class="classname">DispatcherServlet</tt>,
        <tt class="classname">RequestContextListener</tt> and
        <tt class="classname">RequestContextFilter</tt> all do exactly the same
        thing, namely bind the HTTP request object to the
        <tt class="classname">Thread</tt> that is servicing that request. This
        makes beans that are request- and session-scoped available further
        down the call chain.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-request"></a>3.4.4.2.&nbsp;The request scope</h4></div></div><div></div></div><p>Consider the following bean definition:</p><pre class="programlisting">&lt;bean id="loginAction" class="com.foo.LoginAction" scope="request"/&gt;</pre><p>With the above bean definition in place, the Spring container
        will create a brand new instance of the
        <tt class="classname">LoginAction</tt> bean using the
        <tt class="literal">'loginAction'</tt> bean definition for each and every
        HTTP request. That is, the <tt class="literal">'loginAction'</tt> bean will
        be effectively scoped at the HTTP request level. You can change or
        dirty the internal state of the instance that is created as much as
        you want, safe in the knowledge that other requests that are also
        using instances created off the back of the same
        <tt class="literal">'loginAction'</tt> bean definition will not be seeing
        these changes in state since they are particular to an individual
        request. When the request is finished processing, the bean that is
        scoped to the request will be discarded.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-session"></a>3.4.4.3.&nbsp;The session scope</h4></div></div><div></div></div><p>Consider the following bean definition:</p><pre class="programlisting">&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="session"/&gt;</pre><p>With the above bean definition in place, the Spring container
        will create a brand new instance of the
        <tt class="classname">UserPreferences</tt> bean using the
        <tt class="literal">'userPreferences'</tt> bean definition for the lifetime
        of a single HTTP <tt class="interfacename">Session</tt>. In other
        words, the <tt class="literal">'userPreferences'</tt> bean will be
        effectively scoped at the HTTP <tt class="interfacename">Session</tt>
        level. Just like <tt class="literal">request-scoped</tt> beans, you can
        change the internal state of the instance that is created as much as
        you want, safe in the knowledge that other HTTP
        <tt class="interfacename">Session</tt> instances that are also using
        instances created off the back of the same
        <tt class="literal">'userPreferences'</tt> bean definition will not be
        seeing these changes in state since they are particular to an
        individual HTTP <tt class="interfacename">Session</tt>. When the HTTP
        <tt class="interfacename">Session</tt> is eventually discarded, the
        bean that is scoped to that particular HTTP
        <tt class="interfacename">Session</tt> will also be discarded.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-global-session"></a>3.4.4.4.&nbsp;The global session scope</h4></div></div><div></div></div><p>Consider the following bean definition:</p><pre class="programlisting">&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="globalSession"/&gt;</pre><p>The <tt class="literal">global session</tt> scope is similar to the
        standard HTTP <tt class="interfacename">Session</tt> scope (<a href="#beans-factory-scopes-session" title="3.4.4.3.&nbsp;The session scope">described immediately
        above</a>), and really only makes sense in the context of
        portlet-based web applications. The portlet specification defines the
        notion of a global <tt class="interfacename">Session</tt> that is
        shared amongst all of the various portlets that make up a single
        portlet web application. Beans defined at the <tt class="literal">global
        session</tt> scope are scoped (or bound) to the lifetime of the
        global portlet <tt class="interfacename">Session</tt>.</p><p>Please note that if you are writing a standard Servlet-based web
        application and you define one or more beans as having <tt class="literal">global
        session</tt> scope, the standard HTTP
        <tt class="interfacename">Session</tt> scope will be used, and no
        error will be raised.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-other-injection"></a>3.4.4.5.&nbsp;Scoped beans as dependencies</h4></div></div><div></div></div><p>Being able to define a bean scoped to a HTTP request or
        <tt class="interfacename">Session</tt> (or indeed <a href="#beans-factory-scopes-custom" title="3.4.5.&nbsp;Custom scopes">a custom scope</a> of your
        own devising) is all very well, but one of the main value-adds of the
        Spring IoC container is that it manages not only the instantiation of
        your objects (beans), but also the wiring up of collaborators (or
        dependencies). If you want to inject a (for example) HTTP request
        scoped bean into another bean, you will need to inject an AOP proxy in
        place of the scoped bean. That is, you need to inject a proxy object
        that exposes the same public interface as the scoped object, but that
        is smart enough to be able to retrieve the real, target object from
        the relevant scope (for example a HTTP request) and delegate method
        calls onto the real object.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>You <span class="emphasis"><em>do not</em></span> need to use the
          <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt> in conjunction with
          beans that are scoped as <tt class="literal">singletons</tt> or
          <tt class="literal">prototypes</tt>. It is an error to try to create a
          scoped proxy for a singleton bean (and the resulting
          <tt class="exceptionname">BeanCreationException</tt> will certainly
          set you straight in this regard).</p></td></tr></table></div><p>Let's look at the configuration that is required to effect this;
        the configuration is not hugely complex (it takes just one line), but
        it is important to understand the &#8220;<span class="quote">why</span>&#8221; as well as the
        &#8220;<span class="quote">how</span>&#8221; behind it.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- a HTTP <tt class="interfacename">Session</tt>-scoped bean exposed as a proxy --&gt;</span></i>
    &lt;bean id="userPreferences" class="com.foo.UserPreferences" <span class="bold"><b>scope="session"</b></span>&gt;
          
          <i class="lineannotation"><span class="lineannotation">&lt;!-- this next element effects the proxying of the surrounding bean --&gt;</span></i>
          <span class="bold"><b>&lt;aop:scoped-proxy/&gt;</b></span>
    &lt;/bean&gt;
    
    <i class="lineannotation"><span class="lineannotation">&lt;!-- a singleton-scoped bean <span class="bold"><b>injected with a proxy to the above bean</b></span> --&gt;</span></i>
    &lt;bean id="userService" class="com.foo.SimpleUserService"&gt;
    
        <i class="lineannotation"><span class="lineannotation">&lt;!-- a reference to the <span class="bold"><b>proxied</b></span> <tt class="literal">'userPreferences'</tt> bean --&gt;</span></i>
        &lt;property name="userPreferences" ref="userPreferences"/&gt;

    &lt;/bean&gt;
&lt;/beans&gt;
</pre><p>To create such a proxy, you need only to insert a child
        <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt> element into a scoped
        bean definition (you may also need the CGLIB library on your classpath
        so that the container can effect class-based proxying; you will also
        need to be using <a href="#xsd-config" title="Appendix&nbsp;A.&nbsp;XML Schema-based configuration">Appendix&nbsp;A, <i>XML Schema-based configuration</i></a>). So, just why do you
        need this <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt> element in the
        definition of beans scoped at the <tt class="literal">request</tt>,
        <tt class="literal">session</tt>, <tt class="literal">globalSession</tt> and
        '<span class="emphasis"><em>insert your custom scope here</em></span>' level? The reason
        is best explained by picking apart the following bean definition
        (please note that the following <tt class="literal">'userPreferences'</tt>
        bean definition as it stands is
        <span class="emphasis"><em>incomplete</em></span>):</p><pre class="programlisting">&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="session"/&gt;

&lt;bean id="userManager" class="com.foo.UserManager"&gt;
    &lt;property name="userPreferences" ref="userPreferences"/&gt;
&lt;/bean&gt;</pre><p>From the above configuration it is evident that the singleton
        bean <tt class="literal">'userManager'</tt> is being injected with a
        reference to the HTTP <tt class="interfacename">Session</tt>-scoped
        bean <tt class="literal">'userPreferences'</tt>. The salient point here is
        that the <tt class="literal">'userManager'</tt> bean is a singleton... it
        will be instantiated <span class="emphasis"><em>exactly once</em></span> per container,
        and its dependencies (in this case only one, the
        <tt class="literal">'userPreferences'</tt> bean) will also only be injected
        (once!). This means that the <tt class="literal">'userManager'</tt> will
        (conceptually) only ever operate on the exact same
        <tt class="literal">'userPreferences'</tt> object, that is the one that it
        was originally injected with. This is <span class="emphasis"><em>not</em></span> what
        you want when you inject a HTTP
        <tt class="interfacename">Session</tt>-scoped bean as a dependency
        into a collaborating object (typically). Rather, what we
        <span class="emphasis"><em>do</em></span> want is a single
        <tt class="literal">'userManager'</tt> object, and then, for the lifetime of
        a HTTP <tt class="interfacename">Session</tt>, we want to see and use
        a <tt class="literal">'userPreferences'</tt> object that is specific to said
        HTTP <tt class="interfacename">Session</tt>.</p><p>Rather what you need then is to inject some sort of object that
        exposes the exact same public interface as the
        <tt class="classname">UserPreferences</tt> class (ideally an object that
        <span class="emphasis"><em>is a</em></span> <tt class="classname">UserPreferences</tt>
        instance) and that is smart enough to be able to go off and fetch the
        <tt class="interfacename">real</tt>
        <tt class="classname">UserPreferences</tt> object from whatever underlying
        scoping mechanism we have chosen (HTTP request,
        <tt class="interfacename">Session</tt>, etc.). We can then safely
        inject this proxy object into the <tt class="literal">'userManager'</tt>
        bean, which will be blissfully unaware that the
        <tt class="classname">UserPreferences</tt> reference that it is holding
        onto is a proxy. In the case of this example, when a
        <tt class="interfacename">UserManager</tt> instance invokes a method
        on the dependency-injected <tt class="classname">UserPreferences</tt>
        object, it is really invoking a method on the proxy... the proxy will
        then go off and fetch the real <tt class="classname">UserPreferences</tt>
        object from (in this case) the HTTP
        <tt class="interfacename">Session</tt>, and delegate the method
        invocation onto the retrieved real
        <tt class="classname">UserPreferences</tt> object.</p><p>That is why you need the following, correct and complete,
        configuration when injecting <tt class="literal">request-</tt>,
        <tt class="literal">session-</tt>, and
        <tt class="literal">globalSession-scoped</tt> beans into collaborating
        objects:</p><pre class="programlisting">&lt;bean id="userPreferences" class="com.foo.UserPreferences" scope="session"&gt;
    <span class="bold"><b><tt class="literal">&lt;aop:scoped-proxy/&gt;</tt></b></span>
&lt;/bean&gt;

&lt;bean id="userManager" class="com.foo.UserManager"&gt;
    &lt;property name="userPreferences" ref="userPreferences"/&gt;
&lt;/bean&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-factory-scopes-other-injection-proxies"></a>3.4.4.5.1.&nbsp;Choosing the type of proxy created</h5></div></div><div></div></div><p>By default, when the Spring container is creating a proxy for
          a bean that is marked up with the <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt>
          element, <span class="emphasis"><em>a CGLIB-based class proxy will be created</em></span>.
          This means that you need to have the CGLIB library on the classpath
          of your application.</p><p><span class="emphasis"><em>Note: CGLIB proxies will only intercept public method
          calls!</em></span> Do not call non-public methods on such a proxy;
          they will not be delegated to the scoped target object.</p><p>You can choose to have the Spring container create 'standard'
          JDK interface-based proxies for such scoped beans by specifying
          '<tt class="literal">false</tt>' for the value of the
          '<tt class="literal">proxy-target-class</tt>' attribute of the
          <tt class="literal">&lt;aop:scoped-proxy/&gt;</tt> element. Using JDK
          interface-based proxies does mean that you don't need any additional
          libraries on your application's classpath to effect such proxying,
          but it does mean that the class of the scoped bean must implement at
          least one interface, and <span class="emphasis"><em>all</em></span> of the
          collaborators into which the scoped bean is injected must be
          referencing the bean via one of its interfaces.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="classname">DefaultUserPreferences</tt> implements the <tt class="interfacename">UserPreferences</tt> interface --&gt;</span></i>
&lt;bean id="userPreferences" class="com.foo.DefaultUserPreferences" scope="session"&gt;
    &lt;aop:scoped-proxy <span class="bold"><b>proxy-target-class="false"<tt class="literal"></tt></b></span>/&gt;
&lt;/bean&gt;

&lt;bean id="userManager" class="com.foo.UserManager"&gt;
    &lt;property name="userPreferences" ref="userPreferences"/&gt;
&lt;/bean&gt;</pre><p>The section entitled <a href="#aop-proxying" title="6.6.&nbsp;Proxying mechanisms">Section&nbsp;6.6, &#8220;Proxying mechanisms&#8221;</a> may also
          be of some interest with regard to understanding the nuances of
          choosing whether class-based or interface-based proxying is right
          for you.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-scopes-custom"></a>3.4.5.&nbsp;Custom scopes</h3></div></div><div></div></div><p>As of Spring 2.0, the bean scoping mechanism in Spring is
      extensible. This means that you are not limited to just the bean scopes
      that Spring provides out of the box; you can define your own scopes, or
      even redefine the existing scopes (although that last one would probably
      be considered bad practice - please note that you
      <span class="emphasis"><em>cannot</em></span> override the built-in
      <tt class="literal">singleton</tt> and <tt class="literal">prototype</tt>
      scopes).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-custom-creating"></a>3.4.5.1.&nbsp;Creating your own custom scope</h4></div></div><div></div></div><p>Scopes are defined by the
        <tt class="interfacename">org.springframework.beans.factory.config.Scope</tt>
        interface. This is the interface that you will need to implement in
        order to integrate your own custom scope(s) into the Spring container,
        and is described in detail below. You may wish to look at the
        <tt class="interfacename">Scope</tt> implementations that are supplied
        with the Spring Framework itself for an idea of how to go about
        implementing your own. The <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/config/Scope.html" target="_top">Scope
        Javadoc</a> explains the main class to implement when you need
        your own scope in more detail too.</p><p>The <tt class="literal">Scope</tt> interface has four methods dealing
        with getting objects from the scope, removing them from the scope and
        allowing them to be 'destroyed' if needed.</p><p>The first method should return the object from the underlying
        scope. The session scope implementation for example will return the
        session-scoped bean (and if it does not exist, return a new instance
        of the bean, after having bound it to the session for future
        reference).</p><pre class="programlisting">Object get(String name, ObjectFactory objectFactory)</pre><p>The second method should remove the object from the underlying
        scope. The session scope implementation for example, removes the
        session-scoped bean from the underlying session. The object should be
        returned (you are allowed to return null if the object with the
        specified name wasn't found)</p><pre class="programlisting">Object remove(String name)</pre><p>The third method is used to register callbacks the scope should
        execute when it is destroyed or when the specified object in the scope
        is destroyed. Please refer to the Javadoc or a Spring scope
        implementation for more information on destruction callbacks.</p><pre class="programlisting">void registerDestructionCallback(String name, Runnable destructionCallback)</pre><p>The last method deals with obtaining the conversation identifier
        for the underlying scope. This identifier is different for each scope.
        For a session for example, this can be the session identifier.</p><pre class="programlisting">String getConversationId()</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-scopes-custom-using"></a>3.4.5.2.&nbsp;Using a custom scope</h4></div></div><div></div></div><p>After you have written and tested one or more custom
        <tt class="interfacename">Scope</tt> implementations, you then need to
        make the Spring container aware of your new scope(s). The central
        method to register a new <tt class="interfacename">Scope</tt> with the
        Spring container is declared on the
        <tt class="interfacename">ConfigurableBeanFactory</tt> interface
        (implemented by most of the concrete
        <tt class="interfacename">BeanFactory</tt> implementations that ship
        with Spring); this central method is displayed below:</p><pre class="programlisting">void registerScope(String scopeName, Scope scope);</pre><p>The first argument to the
        <tt class="methodname">registerScope(..)</tt> method is the unique name
        associated with a scope; examples of such names in the Spring
        container itself are <tt class="literal">'singleton'</tt> and
        <tt class="literal">'prototype'</tt>. The second argument to the
        <tt class="methodname">registerScope(..)</tt> method is an actual
        instance of the custom <tt class="interfacename">Scope</tt>
        implementation that you wish to register and use.</p><p>Let's assume that you have written your own custom
        <tt class="interfacename">Scope</tt> implementation, and you have
        registered it like so:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// note: the <tt class="classname">ThreadScope</tt> class does <span class="bold"><b>not</b></span> ship with the Spring Framework</span></i>
Scope customScope = new ThreadScope();
beanFactory.registerScope("<span class="bold"><b>thread</b></span>", customScope);</pre><p>You can then create bean definitions that adhere to the scoping
        rules of your custom <tt class="interfacename">Scope</tt> like
        so:</p><pre class="programlisting">&lt;bean id="..." class="..." <span class="bold"><b>scope="thread"</b></span>/&gt;</pre><p>If you have your own custom <tt class="interfacename">Scope</tt>
        implementation(s), you are not just limited to only programmatic
        registration of the custom scope(s). You can also do the
        <tt class="interfacename">Scope</tt> registration declaratively, using
        the <tt class="classname">CustomScopeConfigurer</tt> class.</p><p>The declarative registration of custom
        <tt class="interfacename">Scope</tt> implementations using the
        <tt class="classname">CustomScopeConfigurer</tt> class is shown
        below:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

    &lt;bean class="org.springframework.beans.factory.config.CustomScopeConfigurer"&gt;
        &lt;property name="scopes"&gt;
            &lt;map&gt;<span class="bold"><b>
                &lt;entry key="thread"&gt;
                    &lt;bean class="com.foo.ThreadScope"/&gt;
                &lt;/entry&gt;</b></span>
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="bar" class="x.y.Bar" <span class="bold"><b>scope="thread"</b></span>&gt;
        &lt;property name="name" value="Rick"/&gt;
        &lt;aop:scoped-proxy/&gt;
    &lt;/bean&gt;

    &lt;bean id="foo" class="x.y.Foo"&gt;
        &lt;property name="bar" ref="bar"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre></div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Note that, when placing a &lt;aop:scoped-proxy/&gt; in a <tt class="interfacename">FactoryBean</tt>
      implementation, it is the factory bean itself that is scoped, not the object returned from
      <tt class="methodname">getObject()</tt>.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-nature"></a>3.5.&nbsp;Customizing the nature of a bean</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-lifecycle"></a>3.5.1.&nbsp;Lifecycle callbacks</h3></div></div><div></div></div><p>The Spring Framework provides several callback interfaces to change
      the behavior of your bean in the container; they include
      <tt class="interfacename">InitializingBean</tt> and
      <tt class="interfacename">DisposableBean</tt>. Implementing these
      interfaces will result in the container calling
      <tt class="methodname">afterPropertiesSet()</tt> for the former and
      <tt class="methodname">destroy()</tt> for the latter to allow the bean to
      perform certain actions upon initialization and destruction.</p><p>Internally, the Spring Framework uses
      <tt class="interfacename">BeanPostProcessor</tt> implementations to
      process any callback interfaces it can find and call the appropriate
      methods. If you need custom features or other lifecycle behavior Spring
      doesn't offer out-of-the-box, you can implement a
      <tt class="interfacename">BeanPostProcessor</tt> yourself. More
      information about this can be found in the section entitled <a href="#beans-factory-extension" title="3.7.&nbsp;Container extension points">Section&nbsp;3.7, &#8220;Container extension points&#8221;</a>.</p><p>All the different lifecycle callback interfaces are described below.
      In one of the appendices, you can find diagrams that show how Spring
      manages beans, how those lifecycle features change the nature of your
      beans, and how they are managed.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lifecycle-initializingbean"></a>3.5.1.1.&nbsp;Initialization callbacks</h4></div></div><div></div></div><p>Implementing the
        <tt class="interfacename">org.springframework.beans.factory.InitializingBean</tt>
        interface allows a bean to perform initialization work after all
        necessary properties on the bean have been set by the container. The
        <tt class="interfacename">InitializingBean</tt> interface specifies
        exactly one method:</p><pre class="programlisting">void afterPropertiesSet() throws Exception;</pre><p>Generally, the use of the
        <tt class="interfacename">InitializingBean</tt> interface can be
        avoided and is actually discouraged since it unnecessarily couples the
        code to Spring. As an alternative, bean definitions provide support
        for a generic initialization method to be specified. In the case of
        XML-based configuration metadata, this is done using the
        <tt class="literal">'init-method'</tt> attribute. For example, the following
        definition:</p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.ExampleBean" init-method="init"/&gt;</pre><pre class="programlisting">public class ExampleBean {
    
    public void init() {
        <i class="lineannotation"><span class="lineannotation">// do some initialization work</span></i>
    }
}</pre><p>...is exactly the same as...</p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;</pre><pre class="programlisting">public class AnotherExampleBean implements InitializingBean {
    
    public void afterPropertiesSet() {
        <i class="lineannotation"><span class="lineannotation">// do some initialization work</span></i>
    }
}</pre><p>... but does not couple the code to Spring.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lifecycle-disposablebean"></a>3.5.1.2.&nbsp;Destruction callbacks</h4></div></div><div></div></div><p>Implementing the
        <tt class="interfacename">org.springframework.beans.factory.DisposableBean</tt>
        interface allows a bean to get a callback when the container
        containing it is destroyed. The
        <tt class="interfacename">DisposableBean</tt> interface specifies a
        single method:</p><pre class="programlisting">void destroy() throws Exception;</pre><p>Generally, the use of the
        <tt class="interfacename">DisposableBean</tt> callback interface can be
        avoided and is actually discouraged since it unnecessarily couples the
        code to Spring. As an alternative, bean definitions provide support
        for a generic destroy method to be specified. When using XML-based
        configuration metadata this is done via the
        <tt class="literal">'destroy-method'</tt> attribute on the
        <tt class="literal">&lt;bean/&gt;</tt>. For example, the following
        definition:</p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.ExampleBean" destroy-method="cleanup"/&gt;</pre><pre class="programlisting">public class ExampleBean {

    public void cleanup() {
        <i class="lineannotation"><span class="lineannotation">// do some destruction work (like releasing pooled connections)</span></i>
    }
}</pre><p>...is exactly the same as...</p><pre class="programlisting">&lt;bean id="exampleInitBean" class="examples.AnotherExampleBean"/&gt;</pre><pre class="programlisting">public class AnotherExampleBean implements DisposableBean {

    public void destroy() {
        <i class="lineannotation"><span class="lineannotation">// do some destruction work (like releasing pooled connections)</span></i>
    }
}</pre><p>... but does not couple the code to Spring.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lifecycle-default-init-destroy-methods"></a>3.5.1.3.&nbsp;Default initialization &amp; destroy methods</h4></div></div><div></div></div><p>When writing initialization and destroy method callbacks that do
        not use the Spring-specific
        <tt class="interfacename">InitializingBean</tt> and
        <tt class="interfacename">DisposableBean</tt> callback interfaces, one
        typically finds oneself writing methods with names such as
        <tt class="literal">init()</tt>, <tt class="literal">initialize()</tt>,
        <tt class="literal">dispose()</tt>, etc. The names of such lifecycle
        callback methods are (hopefully!) standardized across a project so
        that all developers on a team use the same method names and thus
        ensure some level of consistency.</p><p>The Spring container can be configured to
        <tt class="literal">'look'</tt> for named initialization and destroy
        callback method names on <span class="emphasis"><em>every</em></span> bean. This means
        that you, as an application developer, can simply write your
        application classes, use a convention of having an initialization
        callback called <tt class="literal">init()</tt>, and then (without having to
        configure each and every bean with, in the case of XML-based
        configuration, an <tt class="literal">'init-method="init"'</tt> attribute)
        be safe in the knowledge that the Spring IoC container
        <span class="emphasis"><em>will</em></span> call that method when the bean is being
        created (and in accordance with the standard lifecycle callback
        contract described previously).</p><p>Let's look at an example to make the use of this feature
        completely clear. For the sake of the example, let us say that one of
        the coding conventions on a project is that all initialization
        callback methods are to be named <tt class="literal">init()</tt> and that
        destroy callback methods are to be called
        <tt class="literal">destroy()</tt>. This leads to classes like so...</p><pre class="programlisting">public class DefaultBlogService implements BlogService {

    private BlogDao blogDao;

    public void setBlogDao(BlogDao blogDao) {
        this.blogDao = blogDao;
    }

    <i class="lineannotation"><span class="lineannotation">// this is (unsurprisingly) the initialization callback method</span></i>
    public void init() {
        if (this.blogDao == null) {
            throw new IllegalStateException("The [blogDao] property must be set.");
        }
    }
}</pre><pre class="programlisting">&lt;beans <span class="bold"><b>default-init-method="init"</b></span>&gt;

    &lt;bean id="blogService" class="com.foo.DefaultBlogService"&gt;
        &lt;property name="blogDao" ref="blogDao" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Notice the use of the <tt class="literal">'default-init-method'</tt>
        attribute on the top-level <tt class="literal">&lt;beans/&gt;</tt> element.
        The presence of this attribute means that the Spring IoC container
        will recognize a method called <tt class="literal">'init'</tt> on beans as
        being the initialization method callback, and when a bean is being
        created and assembled, if the bean's class has such a method, it will
        be invoked at the appropriate time.</p><p>Destroy method callbacks are configured similarly (in XML that
        is) using the <tt class="literal">'default-destroy-method'</tt> attribute on
        the top-level <tt class="literal">&lt;beans/&gt;</tt> element.</p><p>The use of this feature can save you the (small) housekeeping
        chore of specifying an initialization and destroy method callback on
        each and every bean, and it is great for enforcing a consistent naming
        convention for initialization and destroy method callbacks, as
        consistency is something that should always be aimed for.</p><p>Consider the case where you have some existing beans where the
        underlying classes already have initialization callback methods that
        are named at variance with the convention. You can
        <span class="emphasis"><em>always</em></span> override the default by specifying (in XML
        that is) the method name using the <tt class="literal">'init-method'</tt>
        and <tt class="literal">'destroy-method'</tt> attributes on the
        <tt class="literal">&lt;bean/&gt;</tt> element itself.</p><p>Finally, please be aware that the Spring container guarantees
        that a configured initialization callback is called immediately after
        a bean has been supplied with all of its dependencies. This means that
        the initialization callback will be called on the raw bean reference,
        which means that any AOP interceptors or suchlike that will ultimately
        be applied to the bean will not yet be in place. A target bean is
        fully created <span class="emphasis"><em>first</em></span>, <span class="emphasis"><em>then</em></span> an
        AOP proxy (for example) with its interceptor chain is applied. Note
        that, if the target bean and the proxy are defined separately, your
        code can even interact with the raw target bean, bypassing the proxy.
        Hence, it would be very inconsistent to apply the interceptors to the
        init method, since that would couple the lifecycle of the target bean
        with its proxy/interceptors and leave strange semantics when talking
        to the raw target bean directly.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-lifecycle-combined-effects"></a>3.5.1.4.&nbsp;Combining lifecycle mechanisms</h4></div></div><div></div></div><p>As of Spring 2.5, there are three options for controlling bean
        lifecycle behavior: the <a href="#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&nbsp;Initialization callbacks"><tt class="interfacename">InitializingBean</tt></a>
        and <a href="#beans-factory-lifecycle-disposablebean" title="3.5.1.2.&nbsp;Destruction callbacks"><tt class="interfacename">DisposableBean</tt></a>
        callback interfaces; custom <tt class="literal">init()</tt> and
        <tt class="literal">destroy()</tt> methods; and the <a href="#beans-postconstruct-and-predestroy-annotations" title="3.11.6.&nbsp;@PostConstruct and&#xA;      @PreDestroy"><tt class="interfacename">@PostConstruct</tt>
        and <tt class="interfacename">@PreDestroy</tt>
        annotations</a>.</p><p>When combining different lifecycle mechanisms - for example, in
        a class hierarchy in which various lifecycle mechanisms are in use -
        developers should be aware of the order in which these mechanisms are
        applied. The following is the ordering for initialization
        methods:</p><div class="itemizedlist"><ul type="disc"><li><p>Methods annotated with
            <tt class="interfacename">@PostConstruct</tt></p></li><li><p><tt class="literal">afterPropertiesSet()</tt> as defined by the
            <tt class="interfacename">InitializingBean</tt> callback
            interface</p></li><li><p>A custom configured <tt class="literal">init()</tt> method</p></li></ul></div><p>Destroy methods are called in the same order:</p><div class="itemizedlist"><ul type="disc"><li><p>Methods annotated with
            <tt class="interfacename">@PreDestroy</tt></p></li><li><p><tt class="literal">destroy()</tt> as defined by the
            <tt class="interfacename">DisposableBean</tt> callback
            interface</p></li><li><p>A custom configured <tt class="literal">destroy()</tt>
            method</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If multiple lifecycle mechanisms are configured for a given
          bean, and each mechanism is configured with a different method name,
          then each configured method will be executed in the order listed
          above; however, if the same method name is configured - for example,
          <tt class="literal">init()</tt> for an initialization method - for more
          than one of the aforementioned lifecycle mechanisms, that method
          will only be executed once.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-shutdown"></a>3.5.1.5.&nbsp;Shutting down the Spring IoC container gracefully in non-web
        applications</h4></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>This next section does not apply to web applications (in case
          the title of this section did not make that abundantly clear).
          Spring's web-based <tt class="interfacename">ApplicationContext</tt>
          implementations already have code in place to handle shutting down
          the Spring IoC container gracefully when the relevant web
          application is being shutdown.</p></td></tr></table></div><p>If you are using Spring's IoC container in a non-web application
        environment, for example in a rich client desktop environment, and you
        want the container to shutdown gracefully and call the relevant
        destroy callbacks on your singleton beans, you will need to register a
        shutdown hook with the JVM. This is quite easy to do (see below), and
        will ensure that your Spring IoC container shuts down gracefully and
        that all resources held by your singletons are released. Of course it
        is still up to you to both configure the destroy callbacks for your
        singletons and implement such destroy callbacks correctly.</p><p>So to register a shutdown hook that enables the graceful
        shutdown of the relevant Spring IoC container, you simply need to call
        the <tt class="methodname">registerShutdownHook()</tt> method that is
        declared on the <tt class="classname">AbstractApplicationContext</tt>
        class. To wit...</p><pre class="programlisting">import org.springframework.context.support.AbstractApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        AbstractApplicationContext ctx
            = new ClassPathXmlApplicationContext(new String []{"beans.xml"});

        <i class="lineannotation"><span class="lineannotation">// add a shutdown hook for the above context... </span></i>
        ctx.registerShutdownHook();

        <i class="lineannotation"><span class="lineannotation">// app runs here...</span></i>

        <i class="lineannotation"><span class="lineannotation">// main method exits, hook is called prior to the app shutting down...</span></i>
    }
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-aware"></a>3.5.2.&nbsp;Knowing who you are</h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-aware-beanfactoryaware"></a>3.5.2.1.&nbsp;<tt class="interfacename">BeanFactoryAware</tt></h4></div></div><div></div></div><p>A class which implements the
        <tt class="interfacename">org.springframework.beans.factory.BeanFactoryAware</tt>
        interface is provided with a reference to the
        <tt class="interfacename">BeanFactory</tt> that created it, when it is
        created by that <tt class="interfacename">BeanFactory</tt>.</p><pre class="programlisting">public interface BeanFactoryAware {

    void setBeanFactory(BeanFactory beanFactory) throws BeansException;
}</pre><p>This allows beans to manipulate the
        <tt class="interfacename">BeanFactory</tt> that created them
        programmatically, through the
        <tt class="interfacename">BeanFactory</tt> interface, or by casting
        the reference to a known subclass of this which exposes additional
        functionality. Primarily this would consist of programmatic retrieval
        of other beans. While there are cases when this capability is useful,
        it should generally be avoided, since it couples the code to Spring
        and does not follow the Inversion of Control style, where
        collaborators are provided to beans as properties.</p><p>An alternative option that is equivalent in effect to the
        <tt class="interfacename">BeanFactoryAware</tt>-based approach is to
        use the
        <tt class="classname">org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean</tt>.
        (It should be noted that this approach still does not reduce the
        coupling to Spring, but it does not violate the central principle of
        IoC as much as the
        <tt class="interfacename">BeanFactoryAware</tt>-based
        approach.)</p><p>The <tt class="classname">ObjectFactoryCreatingFactoryBean</tt> is a
        <a href="#beans-factory-extension-factorybean" title="3.7.3.&nbsp;Customizing instantiation logic using&#xA;      FactoryBeans"><tt class="interfacename">FactoryBean</tt></a>
        implementation that returns a reference to an object (factory) that
        can in turn be used to effect a bean lookup. The
        <tt class="classname">ObjectFactoryCreatingFactoryBean</tt> class does
        itself implement the <tt class="interfacename">BeanFactoryAware</tt>
        interface; what client beans are actually injected with is an instance
        of the <tt class="interfacename">ObjectFactory</tt> interface. This is
        a Spring-specific interface (and hence there is still no total
        decoupling from Spring), but clients can then use the
        <tt class="interfacename">ObjectFactory</tt>'s
        <tt class="methodname">getObject()</tt> method to effect the bean lookup
        (under the hood the <tt class="interfacename">ObjectFactory</tt>
        implementation instance that is returned simply delegates down to a
        <tt class="interfacename">BeanFactory</tt> to actually lookup a bean
        by name). All that you need to do is supply the
        <tt class="classname">ObjectFactoryCreatingFactoryBean</tt> with the name
        of the bean that is to be looked up. Let's look at an example:</p><pre class="programlisting">package x.y;

public class NewsFeed {
    
    private String news;

    public void setNews(String news) {
        this.news = news;
    }

    public String getNews() {
        return this.toString() + ": '" + news + "'";
    }
}</pre><pre class="programlisting">package x.y;

import org.springframework.beans.factory.ObjectFactory;

public class NewsFeedManager {

    private ObjectFactory factory;

    public void setFactory(ObjectFactory factory) {
        this.factory = factory;
    }

    public void printNews() {
        // here is where the lookup is performed; note that there is no
        // need to hard code the name of the bean that is being looked up...
        NewsFeed news = (NewsFeed) factory.getObject();
        System.out.println(news.getNews());
    }
}</pre><p>Find below the XML configuration to wire together the above
        classes using the
        <tt class="classname">ObjectFactoryCreatingFactoryBean</tt>
        approach.</p><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="newsFeedManager" class="x.y.NewsFeedManager"&gt;
        &lt;property name="factory"&gt;
            &lt;bean
class="org.springframework.beans.factory.config.ObjectFactoryCreatingFactoryBean"&gt;
                &lt;property name="targetBeanName"&gt;
                    &lt;idref local="newsFeed" /&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id="newsFeed" class="x.y.NewsFeed" scope="prototype"&gt;
        &lt;property name="news" value="... that's fit to print!" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>And here is a small driver program to test the fact that new
        (prototype) instances of the <tt class="literal">newsFeed</tt> bean are
        actually being returned for each call to the injected
        <tt class="interfacename">ObjectFactory</tt> inside the
        <tt class="classname">NewsFeedManager</tt>'s
        <tt class="methodname">printNews()</tt> method.</p><pre class="programlisting">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import x.y.NewsFeedManager;

public class Main {

    public static void main(String[] args) throws Exception {

        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
        NewsFeedManager manager = (NewsFeedManager) ctx.getBean("newsFeedManager");
        manager.printNews();
        manager.printNews();
    }
}</pre><p>The output from running the above program will look like so
        (results will of course vary on your machine).</p><pre class="programlisting">x.y.NewsFeed@1292d26: '... that's fit to print!'
x.y.NewsFeed@5329c5: '... that's fit to print!'</pre><p>As of Spring 2.5, you can rely upon autowiring of the
        <tt class="interfacename">BeanFactory</tt> as yet another alternative
        to implementing the <tt class="interfacename">BeanFactoryAware</tt>
        interface. The "traditional" <tt class="literal">constructor</tt> and
        <tt class="literal">byType</tt> autowiring modes (as described in the
        section entitled <a href="#beans-factory-autowire" title="3.3.5.&nbsp;Autowiring collaborators">Section&nbsp;3.3.5, &#8220;Autowiring collaborators&#8221;</a>) are now
        capable of providing a dependency of type
        <tt class="interfacename">BeanFactory</tt> for either a constructor
        argument or setter method parameter respectively. For more flexibility
        (including the ability to autowire fields and multiple parameter
        methods), consider using the new annotation-based autowiring features.
        In that case, the <tt class="interfacename">BeanFactory</tt> will be
        autowired into a field, constructor argument, or method parameter that
        is expecting the <tt class="interfacename">BeanFactory</tt> type as
        long as the field, constructor, or method in question carries the
        <tt class="interfacename">@Autowired</tt> annotation. For more
        information, see the section entitled <a href="#beans-autowired-annotation" title="3.11.2.&nbsp;@Autowired">Section&nbsp;3.11.2, &#8220;@Autowired&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-aware-beannameaware"></a>3.5.2.2.&nbsp;<tt class="interfacename">BeanNameAware</tt></h4></div></div><div></div></div><p>If a bean implements the
        <tt class="interfacename">org.springframework.beans.factory.BeanNameAware</tt>
        interface and is deployed in a
        <tt class="interfacename">BeanFactory</tt>, the
        <tt class="interfacename">BeanFactory</tt> will call the bean through
        this interface to inform the bean of the <span class="emphasis"><em>name</em></span> it
        was deployed under. The callback will be invoked after population of
        normal bean properties but before an initialization callback like
        <tt class="interfacename">InitializingBean</tt>'s
        <span class="emphasis"><em>afterPropertiesSet</em></span> or a custom
        init-method.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-child-bean-definitions"></a>3.6.&nbsp;Bean definition inheritance</h2></div></div><div></div></div><p>A bean definition potentially contains a large amount of
    configuration information, including container specific information (for
    example initialization method, static factory method name, and so forth)
    and constructor arguments and property values. A child bean definition is
    a bean definition that inherits configuration data from a parent
    definition. It is then able to override some values, or add others, as
    needed. Using parent and child bean definitions can potentially save a lot
    of typing. Effectively, this is a form of templating.</p><p>When working with a <tt class="interfacename">BeanFactory</tt>
    programmatically, child bean definitions are represented by the
    <tt class="classname">ChildBeanDefinition</tt> class. Most users will never
    work with them on this level, instead configuring bean definitions
    declaratively in something like the <tt class="classname">XmlBeanFactory</tt>.
    When using XML-based configuration metadata a child bean definition is
    indicated simply by using the <tt class="literal">'parent'</tt> attribute,
    specifying the parent bean as the value of this attribute.</p><pre class="programlisting">&lt;bean id="inheritedTestBean" abstract="true"
    class="org.springframework.beans.TestBean"&gt;
  &lt;property name="name" value="parent"/&gt;
  &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithDifferentClass"
      class="org.springframework.beans.DerivedTestBean"
      <span class="bold"><b>parent="inheritedTestBean"</b></span> init-method="initialize"&gt;
    
  &lt;property name="name" value="override"/&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- the age property value of 1 will be inherited from  parent --&gt;</span></i>

&lt;/bean&gt;</pre><p>A child bean definition will use the bean class from the parent
    definition if none is specified, but can also override it. In the latter
    case, the child bean class must be compatible with the parent, that is it
    must accept the parent's property values.</p><p>A child bean definition will inherit constructor argument values,
    property values and method overrides from the parent, with the option to
    add new values. If any init-method, destroy-method and/or
    <tt class="literal">static</tt> factory method settings are specified, they will
    override the corresponding parent settings.</p><p>The remaining settings will <span class="emphasis"><em>always</em></span> be taken
    from the child definition: <span class="emphasis"><em>depends on</em></span>,
    <span class="emphasis"><em>autowire mode</em></span>, <span class="emphasis"><em>dependency check</em></span>,
    <span class="emphasis"><em>singleton</em></span>, <span class="emphasis"><em>scope</em></span>, <span class="emphasis"><em>lazy
    init</em></span>.</p><p>Note that in the example above, we have explicitly marked the parent
    bean definition as abstract by using the <tt class="literal">abstract</tt>
    attribute. In the case that the parent definition does not specify a
    class, and so explicitly marking the parent bean definition as
    <tt class="literal">abstract</tt> is required:</p><pre class="programlisting">&lt;bean id="inheritedTestBeanWithoutClass" abstract="true"&gt;
    &lt;property name="name" value="parent"/&gt;
    &lt;property name="age" value="1"/&gt;
&lt;/bean&gt;

&lt;bean id="inheritsWithClass" class="org.springframework.beans.DerivedTestBean"
    parent="inheritedTestBeanWithoutClass" init-method="initialize"&gt;
  &lt;property name="name" value="override"/&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- age will inherit the value of <tt class="literal">1</tt> from the parent bean definition--&gt;</span></i>
&lt;/bean&gt;</pre><p>The parent bean cannot get instantiated on its own since it is
    incomplete, and it is also explicitly marked as
    <tt class="literal">abstract</tt>. When a definition is defined to be
    <tt class="literal">abstract</tt> like this, it is usable only as a pure
    template bean definition that will serve as a parent definition for child
    definitions. Trying to use such an <tt class="literal">abstract</tt> parent bean
    on its own (by referring to it as a ref property of another bean, or doing
    an explicit <tt class="methodname">getBean()</tt> call with the parent bean
    id), will result in an error. Similarly, the container's internal
    <tt class="methodname">preInstantiateSingletons()</tt> method will completely
    ignore bean definitions which are defined as abstract.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p><tt class="literal">ApplicationContexts</tt> (but
      <span class="emphasis"><em>not</em></span> <tt class="literal">BeanFactories</tt>) will by
      default pre-instantiate all singletons. Therefore it is important (at
      least for singleton beans) that if you have a (parent) bean definition
      which you intend to use only as a template, and this definition
      specifies a class, you must make sure to set the
      <span class="emphasis"><em>'abstract'</em></span> attribute to
      <span class="emphasis"><em>'true'</em></span>, otherwise the application context will
      actually (attempt to) pre-instantiate the <tt class="literal">abstract</tt>
      bean.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-factory-extension"></a>3.7.&nbsp;Container extension points</h2></div></div><div></div></div><p>The IoC component of the Spring Framework has been designed for
    extension. There is typically no need for an application developer to
    subclass any of the various <tt class="interfacename">BeanFactory</tt> or
    <tt class="interfacename">ApplicationContext</tt> implementation classes.
    The Spring IoC container can be infinitely extended by plugging in
    implementations of special integration interfaces. The next few sections
    are devoted to detailing all of these various integration
    interfaces.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-extension-bpp"></a>3.7.1.&nbsp;Customizing beans using
      <tt class="literal">BeanPostProcessors</tt></h3></div></div><div></div></div><p>The first extension point that we will look at is the
      <tt class="interfacename">BeanPostProcessor</tt> interface. This
      interface defines a number of <i class="firstterm">callback methods</i>
      that you as an application developer can implement in order to provide
      your own (or override the containers default) instantiation logic,
      dependency-resolution logic, and so forth. If you want to do some custom
      logic after the Spring container has finished instantiating, configuring
      and otherwise initializing a bean, you can plug in one or more
      <tt class="interfacename">BeanPostProcessor</tt> implementations.</p><p>You can configure multiple <tt class="literal">BeanPostProcessors</tt>
      if you wish. You can control the order in which these
      <tt class="literal">BeanPostProcessors</tt> execute by setting the
      <tt class="literal">'order'</tt> property (you can only set this property if
      the <tt class="interfacename">BeanPostProcessor</tt> implements the
      <tt class="interfacename">Ordered</tt> interface; if you write your own
      <tt class="interfacename">BeanPostProcessor</tt> you should consider
      implementing the <tt class="interfacename">Ordered</tt> interface too);
      consult the Javadoc for the
      <tt class="interfacename">BeanPostProcessor</tt> and
      <tt class="interfacename">Ordered</tt> interfaces for more
      details.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p><tt class="literal">BeanPostProcessors</tt> operate on bean (or
        object) <span class="emphasis"><em>instances</em></span>; that is to say, the Spring IoC
        container will have instantiated a bean instance for you, and
        <span class="emphasis"><em>then</em></span> <tt class="literal">BeanPostProcessors</tt> get a
        chance to do their stuff.</p><p>If you want to change the actual bean definition (that is the
        recipe that defines the bean), then you rather need to use a
        <tt class="interfacename">BeanFactoryPostProcessor</tt> (described
        below in the section entitled <a href="#beans-factory-extension-factory-postprocessors" title="3.7.2.&nbsp;Customizing configuration metadata with&#xA;      BeanFactoryPostProcessors">Section&nbsp;3.7.2, &#8220;Customizing configuration metadata with
      BeanFactoryPostProcessors&#8221;</a>.</p><p>Also, <tt class="literal">BeanPostProcessors</tt> are scoped
        <span class="emphasis"><em>per-container</em></span>. This is only relevant if you are
        using container hierarchies. If you define a
        <tt class="interfacename">BeanPostProcessor</tt> in one container, it
        will <span class="emphasis"><em>only</em></span> do its stuff on the beans in that
        container. Beans that are defined in another container will not be
        post-processed by <tt class="literal">BeanPostProcessors</tt> in another
        container, even if both containers are part of the same
        hierarchy.</p></td></tr></table></div><p>The
      <tt class="interfacename">org.springframework.beans.factory.config.BeanPostProcessor</tt>
      interface consists of exactly two callback methods. When such a class is
      registered as a post-processor with the container (see below for how
      this registration is effected), for each bean instance that is created
      by the container, the post-processor will get a callback from the
      container both <span class="emphasis"><em>before</em></span> any container initialization
      methods (such as <span class="emphasis"><em>afterPropertiesSet</em></span> and any
      declared init method) are called, and also afterwards. The
      post-processor is free to do what it wishes with the bean instance,
      including ignoring the callback completely. A bean post-processor will
      typically check for callback interfaces, or do something such as wrap a
      bean with a proxy; some of the Spring AOP infrastructure classes are
      implemented as bean post-processors and they do this proxy-wrapping
      logic.</p><p>It is important to know that a
      <tt class="interfacename">BeanFactory</tt> treats bean post-processors
      slightly differently than an
      <tt class="interfacename">ApplicationContext</tt>. An
      <tt class="interfacename">ApplicationContext</tt> will
      <span class="emphasis"><em>automatically detect</em></span> any beans which are defined in
      the configuration metadata which is supplied to it that implement the
      <tt class="interfacename">BeanPostProcessor</tt> interface, and register
      them as post-processors, to be then called appropriately by the
      container on bean creation. Nothing else needs to be done other than
      deploying the post-processors in a similar fashion to any other bean. On
      the other hand, when using a <tt class="interfacename">BeanFactory</tt>
      implementation, bean post-processors explicitly have to be registered,
      with code like this:</p><pre class="programlisting">ConfigurableBeanFactory factory = new XmlBeanFactory(...);
            
<i class="lineannotation"><span class="lineannotation">// now register any needed <tt class="interfacename">BeanPostProcessor</tt> instances</span></i>
MyBeanPostProcessor postProcessor = new MyBeanPostProcessor();
factory.addBeanPostProcessor(postProcessor);

<i class="lineannotation"><span class="lineannotation">// now start using the factory</span></i></pre><p>This explicit registration step is not convenient, and this is one
      of the reasons why the various
      <tt class="interfacename">ApplicationContext</tt> implementations are
      preferred above plain <tt class="interfacename">BeanFactory</tt>
      implementations in the vast majority of Spring-backed applications,
      especially when using <tt class="literal">BeanPostProcessors</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: BeanPostProcessors and AOP&#xA;        auto-proxying"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">BeanPostProcessors and AOP
        auto-proxying</th></tr><tr><td colspan="2" align="left" valign="top"><p>Classes that implement the
        <tt class="interfacename">BeanPostProcessor</tt> interface are
        <span class="emphasis"><em>special</em></span>, and so they are treated differently by
        the container. All <tt class="interfacename">BeanPostProcessors</tt>
        <span class="emphasis"><em>and their directly referenced beans</em></span> will be
        instantiated on startup, as part of the special startup phase of the
        <tt class="interfacename">ApplicationContext</tt>,
        <span class="emphasis"><em>then</em></span> all those
        <tt class="interfacename">BeanPostProcessors</tt> will be registered
        in a sorted fashion - and applied to all further beans. Since AOP
        auto-proxying is implemented as a
        <tt class="interfacename">BeanPostProcessor</tt> itself, no
        <tt class="interfacename">BeanPostProcessors</tt> or directly
        referenced beans are eligible for auto-proxying (and thus will not
        have aspects 'woven' into them.</p><p>For any such bean, you should see an info log message:
        <span class="emphasis"><em>&#8220;<span class="quote">Bean 'foo' is not eligible for getting processed by
        all BeanPostProcessors (for example: not eligible for
        auto-proxying)</span>&#8221;.</em></span></p></td></tr></table></div><p>Find below some examples of how to write, register, and use
      <tt class="literal">BeanPostProcessors</tt> in the context of an
      <tt class="interfacename">ApplicationContext</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-extension-bpp-examples-hw"></a>3.7.1.1.&nbsp;Example: Hello World,
        <tt class="interfacename">BeanPostProcessor</tt>-style</h4></div></div><div></div></div><p>This first example is hardly compelling, but serves to
        illustrate basic usage. All we are going to do is code a custom
        <tt class="interfacename">BeanPostProcessor</tt> implementation that
        simply invokes the <tt class="methodname">toString()</tt> method of each
        bean as it is created by the container and prints the resulting string
        to the system console. Yes, it is not hugely useful, but serves to get
        the basic concepts across before we move into the second example which
        <span class="emphasis"><em>is</em></span> actually useful.</p><p>Find below the custom
        <tt class="interfacename">BeanPostProcessor</tt> implementation class
        definition:</p><pre class="programlisting">package scripting;

import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.beans.BeansException;

public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor {

    <i class="lineannotation"><span class="lineannotation">// simply return the instantiated bean as-is</span></i>
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return bean; <i class="lineannotation"><span class="lineannotation">// we could potentially return <span class="emphasis"><em>any</em></span> object reference here...</span></i>
    }

    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("Bean '" + beanName + "' created : " + bean.toString());
        return bean;
    }
}</pre><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:lang="http://www.springframework.org/schema/lang"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-2.5.xsd"&gt;

    &lt;lang:groovy id="messenger"
          script-source="classpath:org/springframework/scripting/groovy/Messenger.groovy"&gt;
        &lt;lang:property name="message" value="Fiona Apple Is Just So Dreamy."/&gt; 
    &lt;/lang:groovy&gt;
    
    <i class="lineannotation"><span class="lineannotation">&lt;!-- 
        when the above bean ('messenger') is instantiated, this custom
        <tt class="interfacename">BeanPostProcessor</tt> implementation will output the fact to the system console
     --&gt;</span></i>
    &lt;bean class="scripting.InstantiationTracingBeanPostProcessor"/&gt;

&lt;/beans&gt;</pre><p>Notice how the
        <tt class="classname">InstantiationTracingBeanPostProcessor</tt> is simply
        defined; it doesn't even have a name, and because it is a bean it can
        be dependency injected just like any other bean. (The above
        configuration also just so happens to define a bean that is backed by
        a Groovy script. The Spring 2.0 dynamic language support is detailed
        in the chapter entitled <a href="#dynamic-language" title="Chapter&nbsp;24.&nbsp;Dynamic language support">Chapter&nbsp;24, <i>Dynamic language support</i></a>.)</p><p>Find below a small driver script to exercise the above code and
        configuration;</p><pre class="programlisting">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.scripting.Messenger;

public final class Boot {

    public static void main(final String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("scripting/beans.xml");
        Messenger messenger = (Messenger) ctx.getBean("messenger");
        System.out.println(messenger);
    }
}</pre><p>The output of executing the above program will be (something
        like) this:</p><pre class="programlisting">Bean 'messenger' created : org.springframework.scripting.groovy.GroovyMessenger@272961
org.springframework.scripting.groovy.GroovyMessenger@272961</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-extension-bpp-examples-rabpp"></a>3.7.1.2.&nbsp;Example: The
        <tt class="classname">RequiredAnnotationBeanPostProcessor</tt></h4></div></div><div></div></div><p>Using callback interfaces or annotations in conjunction with a
        custom <tt class="interfacename">BeanPostProcessor</tt> implementation
        is a common means of extending the Spring IoC container. This next
        example is a bit of a cop-out, in that you are directed to the section
        entitled <a href="#metadata-annotations-required" title="25.3.1.&nbsp;@Required">Section&nbsp;25.3.1, &#8220;@Required&#8221;</a> which
        demonstrates the usage of a custom
        <tt class="interfacename">BeanPostProcessor</tt> implementation that
        ships with the Spring distribution which ensures that JavaBean
        properties on beans that are marked with an (arbitrary) annotation are
        actually (configured to be) dependency-injected with a value.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-extension-factory-postprocessors"></a>3.7.2.&nbsp;Customizing configuration metadata with
      <tt class="literal">BeanFactoryPostProcessors</tt></h3></div></div><div></div></div><p>The next extension point that we will look at is the
      <tt class="interfacename">org.springframework.beans.factory.config.BeanFactoryPostProcessor</tt>.
      The semantics of this interface are similar to the
      <tt class="interfacename">BeanPostProcessor</tt>, with one major
      difference: <tt class="literal">BeanFactoryPostProcessors</tt> operate on the <span class="emphasis"><em>bean 
      configuration metadata</em></span>; that is, the Spring IoC container will allow
      <tt class="literal">BeanFactoryPostProcessors</tt> to read the configuration
      metadata and potentially change it <span class="emphasis"><em>before</em></span> the
      container has actually instantiated any other beans.</p><p>You can configure multiple
      <tt class="literal">BeanFactoryPostProcessors</tt> if you wish. You can
      control the order in which these
      <tt class="literal">BeanFactoryPostProcessors</tt> execute by setting the
      <tt class="literal">'order'</tt> property (you can only set this property if
      the <tt class="interfacename">BeanFactoryPostProcessor</tt> implements
      the <tt class="interfacename">Ordered</tt> interface; if you write your
      own <tt class="interfacename">BeanFactoryPostProcessor</tt> you should
      consider implementing the <tt class="interfacename">Ordered</tt>
      interface too); consult the Javadoc for the
      <tt class="interfacename">BeanFactoryPostProcessor</tt> and
      <tt class="interfacename">Ordered</tt> interfaces for more
      details.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you want to change the actual bean
        <span class="emphasis"><em>instances</em></span> (the objects that are created from the
        configuration metadata), then you rather need to use a
        <tt class="interfacename">BeanPostProcessor</tt> (described above in
        the section entitled <a href="#beans-factory-extension-bpp" title="3.7.1.&nbsp;Customizing beans using&#xA;      BeanPostProcessors">Section&nbsp;3.7.1, &#8220;Customizing beans using
      BeanPostProcessors&#8221;</a>.</p><p>Also, <tt class="literal">BeanFactoryPostProcessors</tt> are scoped
        <span class="emphasis"><em>per-container</em></span>. This is only relevant if you are
        using container hierarchies. If you define a
        <tt class="interfacename">BeanFactoryPostProcessor</tt> in one
        container, it will <span class="emphasis"><em>only</em></span> do its stuff on the bean
        definitions in that container. Bean definitions in another container
        will not be post-processed by
        <tt class="literal">BeanFactoryPostProcessors</tt> in another container,
        even if both containers are part of the same hierarchy.</p></td></tr></table></div><p>A bean factory post-processor is executed manually (in the case of
      a <tt class="interfacename">BeanFactory</tt>) or automatically (in the
      case of an <tt class="interfacename">ApplicationContext</tt>) to apply
      changes of some sort to the configuration metadata that defines a
      container. Spring includes a number of pre-existing bean factory
      post-processors, such as <tt class="classname">PropertyOverrideConfigurer</tt>
      and <tt class="classname">PropertyPlaceholderConfigurer</tt>, both described
      below. A custom <tt class="interfacename">BeanFactoryPostProcessor</tt>
      can also be used to register custom property editors, for example.</p><p>In a <tt class="interfacename">BeanFactory</tt>, the process of
      applying a <tt class="interfacename">BeanFactoryPostProcessor</tt> is
      manual, and will be similar to this:</p><pre class="programlisting">XmlBeanFactory factory = new XmlBeanFactory(new FileSystemResource("beans.xml"));

<i class="lineannotation"><span class="lineannotation">// bring in some property values from a <tt class="classname">Properties</tt> file</span></i>
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));

<i class="lineannotation"><span class="lineannotation">// now actually do the replacement</span></i>
cfg.postProcessBeanFactory(factory);</pre><p>This explicit registration step is not convenient, and this is one
      of the reasons why the various
      <tt class="interfacename">ApplicationContext</tt> implementations are
      preferred above plain <tt class="interfacename">BeanFactory</tt>
      implementations in the vast majority of Spring-backed applications,
      especially when using
      <tt class="literal">BeanFactoryPostProcessors</tt>.</p><a name="beans-factory-autodetect-beanfactorypostprocessors"></a><p>An <tt class="interfacename">ApplicationContext</tt> will detect
      any beans which are deployed into it which implement the
      <tt class="interfacename">BeanFactoryPostProcessor</tt> interface, and
      automatically use them as bean factory post-processors, at the
      appropriate time. Nothing else needs to be done other than deploying
      these post-processor in a similar fashion to any other bean.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Just as in the case of <tt class="literal">BeanPostProcessors</tt>,
        you typically don't want to have
        <tt class="literal">BeanFactoryPostProcessors</tt> marked as being
        lazily-initialized. If they are marked as such, then the Spring
        container will never instantiate them, and thus they won't get a
        chance to apply their custom logic. If you are using the
        <tt class="literal">'default-lazy-init'</tt> attribute on the declaration of
        your <tt class="literal">&lt;beans/&gt;</tt> element, be sure to mark your
        various <tt class="interfacename">BeanFactoryPostProcessor</tt> bean
        definitions with <tt class="literal">'lazy-init="false"'</tt>.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-placeholderconfigurer"></a>3.7.2.1.&nbsp;Example: the
        <tt class="interfacename">PropertyPlaceholderConfigurer</tt></h4></div></div><div></div></div><p>The <tt class="interfacename">PropertyPlaceholderConfigurer</tt>
        is used to externalize property values from a
        <tt class="interfacename">BeanFactory</tt> definition, into another
        separate file in the standard Java <tt class="classname">Properties</tt>
        format. This is useful to allow the person deploying an application to
        customize environment-specific properties (for example database URLs,
        usernames and passwords), without the complexity or risk of modifying
        the main XML definition file or files for the container.</p><p>Consider the following XML-based configuration metadata
        fragment, where a <tt class="interfacename">DataSource</tt> with
        placeholder values is defined. We will configure some properties from
        an external <tt class="classname">Properties</tt> file, and at runtime, we
        will apply a <tt class="classname">PropertyPlaceholderConfigurer</tt> to
        the metadata which will replace some properties of the
        DataSource:</p><pre class="programlisting">&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;property name="locations"&gt;
        &lt;value&gt;classpath:com/foo/jdbc.properties&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="dataSource" destroy-method="close"
      class="org.apache.commons.dbcp.BasicDataSource"&gt;
    &lt;property name="driverClassName" value="<span class="bold"><b>${jdbc.driverClassName}</b></span>"/&gt;
    &lt;property name="url" value="<span class="bold"><b>${jdbc.url}</b></span>"/&gt;
    &lt;property name="username" value="<span class="bold"><b>${jdbc.username}</b></span>"/&gt;
    &lt;property name="password" value="<span class="bold"><b>${jdbc.password}</b></span>"/&gt;
&lt;/bean&gt;</pre><p>The actual values come from another file in the standard Java
        <tt class="classname">Properties</tt> format:</p><pre class="programlisting">jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root</pre><p>With the <tt class="literal">context</tt> namespace introduced in
        Spring 2.5, it is possible to configure property placeholders with a
        dedicated configuration element. Multiple locations may be provided as a
        comma-separated list for the <tt class="literal">location</tt> attribute.</p><pre class="programlisting">&lt;context:property-placeholder location="classpath:com/foo/jdbc.properties"/&gt;</pre><p>The <tt class="classname">PropertyPlaceholderConfigurer</tt> doesn't
        only look for properties in the <tt class="classname">Properties</tt> file
        you specify, but also checks against the Java
        <tt class="classname">System</tt> properties if it cannot find a property
        you are trying to use. This behavior can be customized by setting the
        <tt class="literal">systemPropertiesMode</tt> property of the configurer. It
        has three values, one to tell the configurer to always override, one
        to let it <span class="emphasis"><em>never</em></span> override and one to let it
        override only if the property cannot be found in the properties file
        specified. Please consult the Javadoc for the
        <tt class="classname">PropertyPlaceholderConfigurer</tt> for more
        information.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip: Class name substitution"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Class name substitution</th></tr><tr><td colspan="2" align="left" valign="top"><p>The <tt class="classname">PropertyPlaceholderConfigurer</tt> can
          be used to substitute class names, which is sometimes useful when
          you have to pick a particular implementation class at runtime. For
          example:</p><pre class="programlisting">&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;
    &lt;property name="locations"&gt;
        &lt;value&gt;classpath:com/foo/strategy.properties&lt;/value&gt;
    &lt;/property&gt;
    &lt;property name="properties"&gt;
        &lt;value&gt;custom.strategy.class=com.foo.DefaultStrategy&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="serviceStrategy" class="${custom.strategy.class}"/&gt;</pre><p>If the class is unable to be resolved at runtime to a valid
          class, resolution of the bean will fail once it is about to be
          created (which is during the
          <tt class="methodname">preInstantiateSingletons()</tt> phase of an
          <tt class="interfacename">ApplicationContext</tt> for a
          non-lazy-init bean.)</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-factory-overrideconfigurer"></a>3.7.2.2.&nbsp;Example: the
        <tt class="classname">PropertyOverrideConfigurer</tt></h4></div></div><div></div></div><p>The <tt class="classname">PropertyOverrideConfigurer</tt>, another
        bean factory post-processor, is similar to the
        <tt class="interfacename">PropertyPlaceholderConfigurer</tt>, but in
        contrast to the latter, the original definitions can have default
        values or no values at all for bean properties. If an overriding
        <tt class="classname">Properties</tt> file does not have an entry for a
        certain bean property, the default context definition is used.</p><p>Note that the bean factory definition is
        <span class="emphasis"><em>not</em></span> aware of being overridden, so it is not
        immediately obvious when looking at the XML definition file that the
        override configurer is being used. In case that there are multiple
        <tt class="classname">PropertyOverrideConfigurer</tt> instances that
        define different values for the same bean property, the last one will
        win (due to the overriding mechanism).</p><p>Properties file configuration lines are expected to be in the
        format:</p><pre class="programlisting">beanName.property=value</pre><p>An example properties file might look like this:</p><pre class="programlisting">dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb</pre><p>This example file would be usable against a container definition
        which contains a bean called <span class="emphasis"><em>dataSource</em></span>, which
        has <span class="emphasis"><em>driver</em></span> and <span class="emphasis"><em>url</em></span>
        properties.</p><p>Note that compound property names are also supported, as long as
        every component of the path except the final property being overridden
        is already non-null (presumably initialized by the constructors). In
        this example...</p><pre class="programlisting">foo.fred.bob.sammy=123</pre><p>... the <tt class="literal">sammy</tt> property of the
        <tt class="literal">bob</tt> property of the <tt class="literal">fred</tt>
        property of the <tt class="literal">foo</tt> bean is being set to the scalar
        value <tt class="literal">123</tt>.</p><p><span class="emphasis"><em>Note:</em></span> Specified override values are always
        <span class="emphasis"><em>literal</em></span> values; they are not translated into bean
        references. This also applies when the original value in the XML bean
        definition specifies a bean reference</p><p>With the <tt class="literal">context</tt> namespace introduced in
        Spring 2.5, it is possible to configure property overriding with a
        dedicated configuration element:</p><pre class="programlisting">&lt;context:property-override location="classpath:override.properties"/&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-factory-extension-factorybean"></a>3.7.3.&nbsp;Customizing instantiation logic using
      <tt class="literal">FactoryBeans</tt></h3></div></div><div></div></div><p>The
      <tt class="interfacename">org.springframework.beans.factory.FactoryBean</tt>
      interface is to be implemented by objects that <span class="emphasis"><em>are themselves
      factories</em></span>.</p><p>The <tt class="interfacename">FactoryBean</tt> interface is a
      point of pluggability into the Spring IoC containers instantiation
      logic. If you have some complex initialization code that is better
      expressed in Java as opposed to a (potentially) verbose amount of XML,
      you can create your own <tt class="interfacename">FactoryBean</tt>,
      write the complex initialization inside that class, and then plug your
      custom <tt class="interfacename">FactoryBean</tt> into the
      container.</p><p>The <tt class="interfacename">FactoryBean</tt> interface provides
      three methods:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">Object getObject()</tt>: has to return an
          instance of the object this factory creates. The instance can
          possibly be shared (depending on whether this factory returns
          singletons or prototypes).</p></li><li><p><tt class="methodname">boolean isSingleton()</tt>: has to return
          <tt class="literal">true</tt> if this
          <tt class="interfacename">FactoryBean</tt> returns singletons,
          <tt class="literal">false</tt> otherwise</p></li><li><p><tt class="methodname">Class getObjectType()</tt>: has to return
          either the object type returned by the
          <tt class="methodname">getObject()</tt> method or
          <tt class="literal">null</tt> if the type isn't known in advance</p></li></ul></div><p>The <tt class="interfacename">FactoryBean</tt> concept and
      interface is used in a number of places within the Spring Framework; at
      the time of writing there are over 50 implementations of the
      <tt class="interfacename">FactoryBean</tt> interface that ship with
      Spring itself.</p><p>Finally, there is sometimes a need to ask a container for an
      actual <tt class="interfacename">FactoryBean</tt> instance itself, not
      the bean it produces. This may be achieved by prepending the bean id
      with <tt class="literal">'&amp;'</tt> (sans quotes) when calling the
      <tt class="methodname">getBean</tt> method of the
      <tt class="interfacename">BeanFactory</tt> (including
      <tt class="interfacename">ApplicationContext</tt>). So for a given
      <tt class="interfacename">FactoryBean</tt> with an id of
      <tt class="literal">myBean</tt>, invoking <tt class="literal">getBean("myBean")</tt>
      on the container will return the product of the
      <tt class="interfacename">FactoryBean</tt>, but invoking
      <tt class="literal">getBean("&amp;myBean")</tt> will return the
      <tt class="interfacename">FactoryBean</tt> instance itself.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="context-introduction"></a>3.8.&nbsp;The <tt class="interfacename">ApplicationContext</tt></h2></div></div><div></div></div><p>While the <tt class="literal">beans</tt> package provides basic
    functionality for managing and manipulating beans, including in a
    programmatic way, the <tt class="literal">context</tt> package adds the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/ApplicationContext.html" target="_top"><tt class="interfacename">ApplicationContext</tt></a>
    interface, which enhances <tt class="interfacename">BeanFactory</tt>
    functionality in a more <span class="emphasis"><em>framework-oriented style</em></span>.
    Many users will use <tt class="interfacename">ApplicationContext</tt> in a
    completely declarative fashion, not even having to create it manually, but
    instead relying on support classes such as
    <tt class="classname">ContextLoader</tt> to automatically instantiate an
    <tt class="interfacename">ApplicationContext</tt> as part of the normal
    startup process of a J2EE web-app. (Of course, it is still possible to
    create an <tt class="interfacename">ApplicationContext</tt>
    programmatically.)</p><p>The basis for the context package is the
    <tt class="interfacename">ApplicationContext</tt> interface, located in
    the <tt class="literal">org.springframework.context</tt> package. Deriving from
    the <tt class="interfacename">BeanFactory</tt> interface, it provides all
    the functionality of <tt class="interfacename">BeanFactory</tt>. To allow
    working in a more framework-oriented fashion, using layering and
    hierarchical contexts, the context package also provides the following
    functionality:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="interfacename">MessageSource</tt>, providing access
        to messages in i18n-style.</p></li><li><p><span class="emphasis"><em>Access to resources</em></span>, such as URLs and
        files.</p></li><li><p><span class="emphasis"><em>Event propagation</em></span> to beans implementing the
        <tt class="interfacename">ApplicationListener</tt> interface.</p></li><li><p><span class="emphasis"><em>Loading of multiple (hierarchical)
        contexts</em></span>, allowing each to be focused on one particular
        layer, for example the web layer of an application.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-introduction-ctx-vs-beanfactory"></a>3.8.1.&nbsp;<tt class="interfacename">BeanFactory</tt> or
      <tt class="interfacename">ApplicationContext</tt>?</h3></div></div><div></div></div><p>Short version: <span class="emphasis"><em>use an
      <tt class="interfacename">ApplicationContext</tt> unless you have a
      really good reason for not doing so. For those of you that are looking
      for slightly more depth as to the 'but why' of the above recommendation,
      keep reading.</em></span></p><p>As the <tt class="interfacename">ApplicationContext</tt> includes
      all functionality of the <tt class="interfacename">BeanFactory</tt>, it
      is generally recommended that it be used in preference to the
      <tt class="interfacename">BeanFactory</tt>, except for a few limited
      situations such as in an <tt class="classname">Applet</tt>, where memory
      consumption might be critical and a few extra kilobytes might make a
      difference. However, for most 'typical' enterprise applications and
      systems, the <tt class="interfacename">ApplicationContext</tt> is what
      you will want to use. Versions of Spring 2.0 and above make
      <span class="emphasis"><em>heavy</em></span> use of the <a href="#beans-factory-extension-bpp" title="3.7.1.&nbsp;Customizing beans using&#xA;      BeanPostProcessors"><tt class="interfacename">BeanPostProcessor</tt>
      extension point</a> (to effect proxying and suchlike), and if you are
      using just a plain <tt class="interfacename">BeanFactory</tt> then a
      fair amount of support such as transactions and AOP will not take effect
      (at least not without some extra steps on your part), which could be
      confusing because nothing will actually be wrong with the
      configuration.</p><p>Find below a feature matrix that lists what features are provided
      by the <tt class="interfacename">BeanFactory</tt> and
      <tt class="interfacename">ApplicationContext</tt> interfaces (and
      attendant implementations). (The following sections describe
      functionality that <tt class="interfacename">ApplicationContext</tt>
      adds to the basic <tt class="interfacename">BeanFactory</tt>
      capabilities in a lot more depth than the said feature matrix.)</p><div class="table"><a name="context-introduction-ctx-vs-beanfactory-feature-matrix"></a><p class="title"><b>Table&nbsp;3.5.&nbsp;Feature Matrix</b></p><table summary="Feature Matrix" width="100%" border="1"><colgroup><col align="left"><col><col></colgroup><thead><tr><th align="center">Feature</th><th align="center"><tt class="interfacename">BeanFactory</tt></th><th align="center"><tt class="interfacename">ApplicationContext</tt></th></tr></thead><tbody><tr><td align="left"><p>Bean instantiation/wiring</p></td><td align="center"><p>Yes</p></td><td align="center"><p>Yes</p></td></tr><tr><td align="left"><p>Automatic
              <tt class="interfacename">BeanPostProcessor</tt>
              registration</p></td><td align="center"><p>No</p></td><td align="center"><p>Yes</p></td></tr><tr><td align="left"><p>Automatic
              <tt class="interfacename">BeanFactoryPostProcessor</tt>
              registration</p></td><td align="center"><p>No</p></td><td align="center"><p>Yes</p></td></tr><tr><td align="left"><p>Convenient
              <tt class="interfacename">MessageSource</tt> access (for
              i18n)</p></td><td align="center"><p>No</p></td><td align="center"><p>Yes</p></td></tr><tr><td align="left"><p><tt class="interfacename">ApplicationEvent</tt>
              publication</p></td><td align="center"><p>No</p></td><td align="center"><p>Yes</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-messagesource"></a>3.8.2.&nbsp;Internationalization using
      <tt class="literal">MessageSources</tt></h3></div></div><div></div></div><p>The <tt class="interfacename">ApplicationContext</tt> interface
      extends an interface called
      <tt class="interfacename">MessageSource</tt>, and therefore provides
      messaging (i18n or internationalization) functionality. Together with
      the <tt class="classname">HierarchicalMessageSource</tt>, capable of
      resolving hierarchical messages, these are the basic interfaces Spring
      provides to do message resolution. Let's quickly review the methods
      defined there:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">String getMessage(String code, Object[] args,
          String default, Locale loc)</tt>: the basic method used to
          retrieve a message from the
          <tt class="interfacename">MessageSource</tt>. When no message is
          found for the specified locale, the default message is used. Any
          arguments passed in are used as replacement values, using the
          <tt class="interfacename">MessageFormat</tt> functionality provided
          by the standard library.</p></li><li><p><tt class="methodname">String getMessage(String code, Object[] args,
          Locale loc)</tt>: essentially the same as the previous
          method, but with one difference: no default message can be
          specified; if the message cannot be found, a
          <tt class="classname">NoSuchMessageException</tt> is thrown.</p></li><li><p><tt class="methodname">String getMessage(MessageSourceResolvable
          resolvable, Locale locale)</tt>: all properties used in the
          methods above are also wrapped in a class named
          <tt class="interfacename">MessageSourceResolvable</tt>, which you
          can use via this method.</p></li></ul></div><p>When an <tt class="interfacename">ApplicationContext</tt> gets
      loaded, it automatically searches for a
      <tt class="interfacename">MessageSource</tt> bean defined in the
      context. The bean has to have the name
      <tt class="literal">'messageSource'</tt>. If such a bean is found, all calls
      to the methods described above will be delegated to the message source
      that was found. If no message source was found, the
      <tt class="interfacename">ApplicationContext</tt> attempts to see if it
      has a parent containing a bean with the same name. If so, it uses that
      bean as the <tt class="interfacename">MessageSource</tt>. If it can't
      find any source for messages, an empty
      <tt class="classname">DelegatingMessageSource</tt> will be instantiated
      in order to be able to accept calls to the methods defined above.</p><p>Spring currently provides two
      <tt class="interfacename">MessageSource</tt> implementations. These are
      the <tt class="classname">ResourceBundleMessageSource</tt> and the
      <tt class="classname">StaticMessageSource</tt>. Both implement
      <tt class="interfacename">HierarchicalMessageSource</tt> in order to do
      nested messaging. The <tt class="classname">StaticMessageSource</tt> is
      hardly ever used but provides programmatic ways to add messages to the
      source. The <tt class="classname">ResourceBundleMessageSource</tt> is more
      interesting and is the one we will provide an example for:</p><pre class="programlisting">&lt;beans&gt;
  &lt;bean id="messageSource"
        class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
    &lt;property name="basenames"&gt;
      &lt;list&gt;
        &lt;value&gt;format&lt;/value&gt;
        &lt;value&gt;exceptions&lt;/value&gt;
        &lt;value&gt;windows&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
&lt;/beans&gt;</pre><p>This assumes you have three resource bundles defined on your
      classpath called <tt class="literal">format</tt>,
      <tt class="literal">exceptions</tt> and <tt class="literal">windows</tt>. Using the
      JDK standard way of resolving messages through ResourceBundles, any
      request to resolve a message will be handled. For the purposes of the
      example, lets assume the contents of two of the above resource bundle
      files are...</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation"># in 'format.properties'</span></i>
message=Alligators rock!</pre><pre class="programlisting"><i class="lineannotation"><span class="lineannotation"># in 'exceptions.properties'</span></i>
argument.required=The '{0}' argument is required.</pre><p>Some (admittedly trivial) driver code to exercise the
      <tt class="classname">MessageSource</tt> functionality can be found below.
      Remember that all <tt class="classname">ApplicationContext</tt>
      implementations are also <tt class="classname">MessageSource</tt>
      implementations and so can be cast to the
      <tt class="classname">MessageSource</tt> interface.</p><pre class="programlisting">public static void main(String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("message", null, "Default", null);
    System.out.println(message);
}</pre><p>The resulting output from the above program will be...</p><pre class="programlisting">Alligators rock!</pre><p>So to summarize, the <tt class="classname">MessageSource</tt> is
      defined in a file called <tt class="literal">'beans.xml'</tt> (this file
      exists at the root of your classpath). The
      <tt class="literal">'messageSource'</tt> bean definition refers to a number of
      resource bundles via its <tt class="literal">basenames</tt> property; the
      three files that are passed in the list to the
      <tt class="literal">basenames</tt> property exist as files at the root of your
      classpath (and are called <tt class="literal">format.properties</tt>,
      <tt class="literal">exceptions.properties</tt>, and
      <tt class="literal">windows.properties</tt> respectively).</p><p>Lets look at another example, and this time we will look at
      passing arguments to the message lookup; these arguments will be
      converted into Strings and inserted into placeholders in the lookup
      message. This is perhaps best explained with an example:</p><pre class="programlisting">&lt;beans&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- this <tt class="interfacename">MessageSource</tt> is being used in a web application --&gt;</span></i>
    &lt;bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource"&gt;
        &lt;property name="basename" value="test-messages"/&gt;
    &lt;/bean&gt;
    
    <i class="lineannotation"><span class="lineannotation">&lt;!-- let's inject the above <tt class="interfacename">MessageSource</tt> into this POJO --&gt;</span></i>
    &lt;bean id="example" class="com.foo.Example"&gt;
        &lt;property name="messages" ref="messageSource"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class Example {

    private MessageSource messages;

    public void setMessages(MessageSource messages) {
        this.messages = messages;
    }

    public void execute() {
        String message = this.messages.getMessage("argument.required",
            new Object [] {"userDao"}, "Required", null);
        System.out.println(message);
    }

}</pre><p>The resulting output from the invocation of the
      <tt class="methodname">execute()</tt> method will be...</p><pre class="programlisting">The 'userDao' argument is required.</pre><p>With regard to internationalization (i18n), Spring's various
      <tt class="classname">MessageResource</tt> implementations follow the same
      locale resolution and fallback rules as the standard JDK
      <tt class="classname">ResourceBundle</tt>. In short, and continuing with the
      example <tt class="literal">'messageSource'</tt> defined previously, if you
      want to resolve messages against the British (en-GB) locale, you would
      create files called <tt class="literal">format_en_GB.properties</tt>,
      <tt class="literal">exceptions_en_GB.properties</tt>, and
      <tt class="literal">windows_en_GB.properties</tt> respectively.</p><p>Locale resolution is typically going to be managed by the
      surrounding environment of the application. For the purpose of this
      example though, we'll just manually specify the locale that we want to
      resolve our (British) messages against.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation"># in 'exceptions_en_GB.properties'</span></i>
argument.required=Ebagum lad, the '{0}' argument is required, I say, required.</pre><pre class="programlisting">public static void main(final String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("argument.required",
        new Object [] {"userDao"}, "Required", Locale.UK);
    System.out.println(message);
}</pre><p>The resulting output from the running of the above program will
      be...</p><pre class="programlisting">Ebagum lad, the 'userDao' argument is required, I say, required.</pre><p>The <tt class="classname">MessageSourceAware</tt> interface can also
      be used to acquire a reference to any
      <tt class="classname">MessageSource</tt> that has been defined. Any bean
      that is defined in an <tt class="classname">ApplicationContext</tt> that
      implements the <tt class="classname">MessageSourceAware</tt> interface will
      be injected with the application context's
      <tt class="classname">MessageSource</tt> when it (the bean) is being created
      and configured.</p><p><span class="emphasis"><em>Note: As an alternative to <tt class="classname">ResourceBundleMessageSource</tt>,
      Spring also provides a <tt class="classname">ReloadableResourceBundleMessageSource</tt> class.
      This variant supports the same bundle file format but is more flexible than the standard
      JDK based <tt class="classname">ResourceBundleMessageSource</tt> implementation.</em></span>
      In particular, it allows for reading files from any Spring resource location
      (not just from the classpath) and supports hot reloading of bundle property files
      (while efficiently caching them in between). Check out the
      <tt class="classname">ReloadableResourceBundleMessageSource</tt> javadoc for details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-events"></a>3.8.3.&nbsp;Events</h3></div></div><div></div></div><p>Event handling in the
      <tt class="interfacename">ApplicationContext</tt> is provided through
      the <tt class="classname">ApplicationEvent</tt> class and
      <tt class="interfacename">ApplicationListener</tt> interface. If a bean
      which implements the <tt class="interfacename">ApplicationListener</tt>
      interface is deployed into the context, every time an
      <tt class="classname">ApplicationEvent</tt> gets published to the
      <tt class="interfacename">ApplicationContext</tt>, that bean will be
      notified. Essentially, this is the standard
      <span class="emphasis"><em>Observer</em></span> design pattern. Spring provides the
      following standard events:</p><div class="table"><a name="beans-ctx-events-tbl"></a><p class="title"><b>Table&nbsp;3.6.&nbsp;Built-in Events</b></p><table summary="Built-in Events" border="1"><colgroup><col><col></colgroup><thead><tr><th>Event</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="classname">ContextRefreshedEvent</tt></td><td>Published when the
              <tt class="interfacename">ApplicationContext</tt> is initialized
              or refreshed, e.g. using the <tt class="methodname">refresh()</tt>
              method on the
              <tt class="interfacename">ConfigurableApplicationContext</tt>
              interface. "Initialized" here means that all beans are loaded,
              post-processor beans are detected and activated, singletons are
              pre-instantiated, and the
              <tt class="interfacename">ApplicationContext</tt> object is
              ready for use. A refresh may be triggered multiple times,
              as long as the context hasn't been closed - provided that
              the chosen <tt class="interfacename">ApplicationContext</tt>
              actually supports such "hot" refreshes (which e.g.
              <tt class="classname">XmlWebApplicationContext</tt> does but
              <tt class="classname">GenericApplicationContext</tt> doesn't).</td></tr><tr><td><tt class="classname">ContextStartedEvent</tt></td><td>Published when the
              <tt class="interfacename">ApplicationContext</tt> is started,
              using the <tt class="methodname">start()</tt> method on the
              <tt class="interfacename">ConfigurableApplicationContext</tt>
              interface. "Started" here means that all
              <tt class="interfacename">Lifecycle</tt> beans will receive
              an explicit start signal. This will typically be used for
              restarting after an explicit stop, but may also be used
              for starting components that haven't been configured for
              autostart (e.g. haven't started on initialization already).</td></tr><tr><td><tt class="classname">ContextStoppedEvent</tt></td><td>Published when the
              <tt class="interfacename">ApplicationContext</tt> is stopped,
              using the <tt class="methodname">stop()</tt> method on the
              <tt class="interfacename">ConfigurableApplicationContext</tt>
              interface. "Stopped" here means that all
              <tt class="interfacename">Lifecycle</tt> beans will receive
              an explicit stop signal. A stopped context may be restarted
              through a <tt class="methodname">start()</tt> call.</td></tr><tr><td><tt class="classname">ContextClosedEvent</tt></td><td>Published when the
              <tt class="interfacename">ApplicationContext</tt> is closed,
              using the <tt class="methodname">close()</tt> method on the
              <tt class="interfacename">ConfigurableApplicationContext</tt>
              interface. "Closed" here means that all singleton beans
              are destroyed. A closed context has reached its end of life;
              it cannot be refreshed or restarted.</td></tr><tr><td><tt class="classname">RequestHandledEvent</tt></td><td>A web-specific event telling all beans that an
              HTTP request has been serviced (this will be published
              <span class="emphasis"><em>after</em></span> the request has been finished).
              Note that this event is only applicable for web applications
              using Spring's
              <tt class="classname">DispatcherServlet</tt>.</td></tr></tbody></table></div><p>Implementing custom events can be done as well. Simply call the
      <tt class="methodname">publishEvent()</tt> method on the
      <tt class="interfacename">ApplicationContext</tt>, specifying a
      parameter which is an instance of your custom event class implementing
      <tt class="classname">ApplicationEvent</tt>. Event listeners receive events
      synchronously. This means the <tt class="methodname">publishEvent()</tt>
      method blocks until all listeners have finished processing the event (it
      is possible to supply an alternate event publishing strategy via a
      <tt class="interfacename">ApplicationEventMulticaster</tt>
      implementation). Furthermore, when a listener receives an event it
      operates inside the transaction context of the publisher, if a
      transaction context is available.</p><p>Let's look at an example. First, the
      <tt class="interfacename">ApplicationContext</tt>:</p><pre class="programlisting">&lt;bean id="emailer" class="example.EmailBean"&gt;
  &lt;property name="blackList"&gt;
    &lt;list&gt;
      &lt;value&gt;black@list.org&lt;/value&gt;
      &lt;value&gt;white@list.org&lt;/value&gt;
      &lt;value&gt;john@doe.org&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="blackListListener" class="example.BlackListNotifier"&gt;
  &lt;property name="notificationAddress" value="spam@list.org"/&gt;
&lt;/bean&gt;</pre><p>Now, let's look at the actual classes:</p><pre class="programlisting">public class EmailBean implements ApplicationContextAware {

    private List blackList;
    private ApplicationContext ctx;

    public void setBlackList(List blackList) {
        this.blackList = blackList;
    }

    public void setApplicationContext(ApplicationContext ctx) {
        this.ctx = ctx;
    }

    public void sendEmail(String address, String text) {
        if (blackList.contains(address)) {
            BlackListEvent event = new BlackListEvent(address, text);
            ctx.publishEvent(event);
            return;
        }
        <i class="lineannotation"><span class="lineannotation">// send email...</span></i>
    }
}</pre><pre class="programlisting">public class BlackListNotifier implements ApplicationListener {

    private String notificationAddress;
    
    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(ApplicationEvent event) {
        if (event instanceof BlackListEvent) {
            <i class="lineannotation"><span class="lineannotation">// notify appropriate person...</span></i>
        }
    }
}</pre><p>Of course, this particular example could probably be implemented
      in better ways (perhaps by using AOP features), but it should be
      sufficient to illustrate the basic event mechanism.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-functionality-resources"></a>3.8.4.&nbsp;Convenient access to low-level resources</h3></div></div><div></div></div><p>For optimal usage and understanding of application contexts, users
      should generally familiarize themselves with Spring's
      <tt class="interfacename">Resource</tt> abstraction, as described in the
      chapter entitled <a href="#resources" title="Chapter&nbsp;4.&nbsp;Resources">Chapter&nbsp;4, <i>Resources</i></a>.</p><p>An application context is a
      <tt class="interfacename">ResourceLoader</tt>, able to be used to load
      <tt class="interfacename">Resource</tt>s. A
      <tt class="interfacename">Resource</tt> is essentially a
      <tt class="literal">java.net.URL</tt> on steroids (in fact, it just wraps and
      uses a URL where appropriate), which can be used to obtain low-level
      resources from almost any location in a transparent fashion, including
      from the classpath, a filesystem location, anywhere describable with a
      standard URL, and some other variations. If the resource location string
      is a simple path without any special prefixes, where those resources
      come from is specific and appropriate to the actual application context
      type.</p><p>A bean deployed into the application context may implement the
      special callback interface,
      <tt class="interfacename">ResourceLoaderAware</tt>, to be automatically
      called back at initialization time with the application context itself
      passed in as the <tt class="interfacename">ResourceLoader</tt>. A bean
      may also expose properties of type
      <tt class="interfacename">Resource</tt>, to be used to access static
      resources, and expect that they will be injected into it like any other
      properties. The person deploying the bean may specify those
      <tt class="interfacename">Resource</tt> properties as simple String
      paths, and rely on a special JavaBean
      <tt class="interfacename">PropertyEditor</tt> that is automatically
      registered by the context, to convert those text strings to actual
      <tt class="interfacename">Resource</tt> objects.</p><p>The location path or paths supplied to an
      <tt class="interfacename">ApplicationContext</tt> constructor are
      actually resource strings, and in simple form are treated appropriately
      to the specific context implementation (
      <tt class="classname">ClassPathXmlApplicationContext</tt> treats a simple
      location path as a classpath location), but may also be used with
      special prefixes to force loading of definitions from the classpath or a
      URL, regardless of the actual context type.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="context-create"></a>3.8.5.&nbsp;Convenient <tt class="interfacename">ApplicationContext</tt>
      instantiation for web applications</h3></div></div><div></div></div><p>As opposed to the <tt class="interfacename">BeanFactory</tt>,
      which will often be created programmatically,
      <tt class="interfacename">ApplicationContext</tt> instances can be
      created declaratively using for example a
      <tt class="classname">ContextLoader</tt>. Of course you can also create
      <tt class="interfacename">ApplicationContext</tt> instances
      programmatically using one of the
      <tt class="interfacename">ApplicationContext</tt> implementations.
      First, let's examine the <tt class="classname">ContextLoader</tt> mechanism
      and its implementations.</p><p>The <tt class="classname">ContextLoader</tt> mechanism comes in two
      flavors: the <tt class="classname">ContextLoaderListener</tt> and the
      <tt class="classname">ContextLoaderServlet</tt>. They both have the same
      functionality but differ in that the listener version cannot be reliably
      used in Servlet 2.3 containers. Since the Servlet 2.4 specification,
      servlet context listeners are required to execute immediately after the
      servlet context for the web application has been created and is
      available to service the first request (and also when the servlet
      context is about to be shut down): as such a servlet context listener is
      an ideal place to initialize the Spring
      <tt class="interfacename">ApplicationContext</tt>. It is up to you as to
      which one you use, but all things being equal you should probably prefer
      <tt class="classname">ContextLoaderListener</tt>; for more information on
      compatibility, have a look at the Javadoc for the
      <tt class="classname">ContextLoaderServlet</tt>.</p><p>You can register an
      <tt class="interfacename">ApplicationContext</tt> using the
      <tt class="classname">ContextLoaderListener</tt> as follows:</p><pre class="programlisting">&lt;context-param&gt;
  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
  &lt;param-value&gt;/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- or use the <tt class="classname">ContextLoaderServlet</tt> instead of the above listener</span></i><span class="emphasis"><em>
&lt;servlet&gt;
  &lt;servlet-name&gt;context&lt;/servlet-name&gt;
  &lt;servlet-class&gt;org.springframework.web.context.ContextLoaderServlet&lt;/servlet-class&gt;
  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;
--</em></span>&gt;</pre><p>The listener inspects the
      <tt class="literal">'contextConfigLocation'</tt> parameter. If the parameter
      does not exist, the listener will use
      <tt class="literal">/WEB-INF/applicationContext.xml</tt> as a default. When it
      <span class="emphasis"><em>does</em></span> exist, it will separate the String using
      predefined delimiters (comma, semicolon and whitespace) and use the
      values as locations where application contexts will be searched for.
      Ant-style path patterns are supported as well: e.g.
      <tt class="literal">/WEB-INF/*Context.xml</tt> (for all files whose name ends
      with "Context.xml", residing in the "WEB-INF" directory) or
      <tt class="literal">/WEB-INF/**/*Context.xml</tt> (for all such files in any
      subdirectory of "WEB-INF").</p><p>The <tt class="classname">ContextLoaderServlet</tt> can be used
      instead of the <tt class="classname">ContextLoaderListener</tt>. The servlet
      will use the <tt class="literal">'contextConfigLocation'</tt> parameter just
      as the listener does.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-glue-code-and-singletons"></a>3.9.&nbsp;Glue code and the evil singleton</h2></div></div><div></div></div><p>The majority of the code inside an application is best written in a
    DI style, where that code is served out of a Spring IoC container, has its
    own dependencies supplied by the container when it is created, and is
    completely unaware of the container. However, for the small glue layers of
    code that are sometimes needed to tie other code together, there is
    sometimes a need for singleton (or quasi-singleton) style access to a
    Spring IoC container. For example, third party code may try to construct
    new objects directly (<tt class="literal">Class.forName()</tt> style), without
    the ability to force it to get these objects out of a Spring IoC
    container. If the object constructed by the third party code is just a
    small stub or proxy, which then uses a singleton style access to a Spring
    IoC container to get a real object to delegate to, then inversion of
    control has still been achieved for the majority of the code (the object
    coming out of the container); thus most code is still unaware of the
    container or how it is accessed, and remains decoupled from other code,
    with all ensuing benefits. EJBs may also use this stub/proxy approach to
    delegate to a plain Java implementation object, coming out of a Spring IoC
    container. While the Spring IoC container itself ideally does not have to
    be a singleton, it may be unrealistic in terms of memory usage or
    initialization times (when using beans in the Spring IoC container such as
    a Hibernate <tt class="interfacename">SessionFactory</tt>) for each bean
    to use its own, non-singleton Spring IoC container.</p><p>As another example, in complex J2EE applications with multiple
    layers (various JAR files, EJBs, and WAR files packaged as an EAR), with
    each layer having its own Spring IoC container definition (effectively
    forming a hierarchy), the preferred approach when there is only one
    web-app (WAR) in the top hierarchy is to simply create one composite
    Spring IoC container from the multiple XML definition files from each
    layer. All of the various Spring IoC container implementations may be
    constructed from multiple definition files in this fashion. However, if
    there are multiple sibling web-applications at the root of the hierarchy,
    it is problematic to create a Spring IoC container for each
    web-application which consists of mostly identical bean definitions from
    lower layers, as there may be issues due to increased memory usage, issues
    with creating multiple copies of beans which take a long time to
    initialize (for example a Hibernate
    <tt class="interfacename">SessionFactory</tt>), and possible issues due to
    side-effects. As an alternative, classes such as <tt class="literal"><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html" target="_top">ContextSingletonBeanFactoryLocator</a></tt>
    or <tt class="literal"><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html" target="_top">SingletonBeanFactoryLocator</a></tt>
    may be used to demand-load multiple hierarchical (that is one container is
    the parent of another) Spring IoC container instances in a singleton
    fashion, which may then be used as the parents of the web-application
    Spring IoC container instances. The result is that bean definitions for
    lower layers are loaded only as needed, and loaded only once.</p><p>You can see a detailed example of the usage of these classes by
    viewing the Javadoc for the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/access/SingletonBeanFactoryLocator.html" target="_top">SingletonBeanFactoryLocator</a>
    and <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html" target="_top">ContextSingletonBeanFactoryLocator</a>
    classes. As mentioned in the <a href="#ejb" title="Chapter&nbsp;18.&nbsp;Enterprise Java Beans (EJB) integration">chapter on EJBs</a>,
    the Spring convenience base classes for EJBs normally use a non-singleton
    <tt class="interfacename">BeanFactoryLocator</tt> implementation, which is
    easily replaced by the use of
    <tt class="classname">SingletonBeanFactoryLocator</tt> and
    <tt class="classname">ContextSingletonBeanFactoryLocator</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-rar-deployment"></a>3.10.&nbsp;Deploying a Spring ApplicationContext as a J2EE RAR file</h2></div></div><div></div></div><p>Since Spring 2.5, it is possible to deploy a Spring ApplicationContext
    as a RAR file, encapsulating the context and all of its required bean classes
    and library JARs in a J2EE RAR deployment unit. This is the equivalent of
    bootstrapping a standalone ApplicationContext, just hosted in J2EE environment,
    being able to access the J2EE server's facilities. RAR deployment is intended
    as a more 'natural' alternative to the not uncommon scenario of deploying a
    headless WAR file - i.e. a WAR file without any HTTP entry points, just used
    for bootstrapping a Spring ApplicationContext in a J2EE environment.</p><p>RAR deployment is ideal for application contexts that do not need any
    HTTP entry points but rather just consist of message endpoints and scheduled
    jobs etc. Beans in such a context may use application server resources such
    as the JTA transaction manager and JNDI-bound JDBC DataSources and JMS
    ConnectionFactory instances, and may also register with the platform's
    JMX server - all through Spring's standard transaction management and
    JNDI and JMX support facilities. Application components may also interact
    with the application's server JCA WorkManager through Spring's
    <tt class="interfacename">TaskExecutor</tt> abstraction.</p><p>Check out the JavaDoc of the
    <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/jca/context/SpringContextResourceAdapter.html" target="_top">SpringContextResourceAdapter</a>
    class for the configuration details involved in RAR deployment.</p><p><span class="emphasis"><em>For simple deployment needs, all you need to do is the following:</em></span>
    Package all application classes into a RAR file (which is just a standard
    JAR file with a different file extension), add all required library jars
    into the root of the RAR archive, add a "META-INF/ra.xml" deployment descriptor
    (as shown in <tt class="classname">SpringContextResourceAdapter</tt>'s JavaDoc)
    as well as the corresponding Spring XML bean definition file(s)
    (typically "META-INF/applicationContext.xml"), and drop the resulting RAR
    file into your application server's deployment directory!</p><p><span class="emphasis"><em>NOTE:</em></span> Such RAR deployment units are usually self-contained;
    they do not expose components to the 'outside' world, not even to other
    modules of the same application. Interaction with a RAR-based ApplicationContext
    usually happens through JMS destinations that it shares with other modules.
    A RAR-based ApplicationContext may also - for example - schedule some jobs,
    reacting to new files in the file system (or the like). If it actually needs
    to allow for synchronous access from the outside, it could for example export
    RMI endpoints, which of course may be used by other application modules
    on the same machine as well.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-annotation-config"></a>3.11.&nbsp;Annotation-based configuration</h2></div></div><div></div></div><p>As mentioned in the section entitled <a href="#beans-factory-extension-bpp-examples-rabpp" title="3.7.1.2.&nbsp;Example: The&#xA;        RequiredAnnotationBeanPostProcessor">Section&nbsp;3.7.1.2, &#8220;Example: The
        RequiredAnnotationBeanPostProcessor&#8221;</a>, using a
    <tt class="interfacename">BeanPostProcessor</tt> in conjunction with
    annotations is a common means of extending the Spring IoC container. For
    example, Spring 2.0 introduced the possibility of enforcing required
    properties with the <a href="#metadata-annotations-required" title="25.3.1.&nbsp;@Required">@Required</a> annotation. As of
    Spring 2.5, it is now possible to follow that same general approach to
    drive Spring's dependency injection. Essentially, the
    <tt class="interfacename">@Autowired</tt> annotation provides the same
    capabilities as described in <a href="#beans-factory-autowire" title="3.3.5.&nbsp;Autowiring collaborators">Section&nbsp;3.3.5, &#8220;Autowiring collaborators&#8221;</a> but
    with more fine-grained control and wider applicability. Spring 2.5 also
    adds support for JSR-250 annotations such as
    <tt class="interfacename">@Resource</tt>,
    <tt class="interfacename">@PostConstruct</tt>, and
    <tt class="interfacename">@PreDestroy</tt>. Of course, these options are
    only available if you are using at least Java 5 (Tiger) and thus have
    access to source level annotations. Use of these annotations also requires
    that certain <tt class="interfacename">BeanPostProcessors</tt> be
    registered within the Spring container. As always, these can be registered
    as individual bean definitions, but they can also be implicitly registered
    by including the following tag in an XML-based Spring configuration
    (notice the inclusion of the '<tt class="literal">context</tt>'
    namespace):</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       <i class="lineannotation"><span class="lineannotation">xmlns:context="http://www.springframework.org/schema/context"</span></i>
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;
               
     <i class="lineannotation"><span class="lineannotation">&lt;context:annotation-config/&gt;</span></i>
     
&lt;/beans&gt;</pre><p>(The implicitly registered post-processors include <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/annotation/AutowiredAnnotationBeanPostProcessor.html" target="_top"><tt class="classname">AutowiredAnnotationBeanPostProcessor</tt></a>,
    <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/annotation/CommonAnnotationBeanPostProcessor.html" target="_top"><tt class="classname">CommonAnnotationBeanPostProcessor</tt></a>,
    <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/orm/jpa/support/PersistenceAnnotationBeanPostProcessor.html" target="_top"><tt class="classname">PersistenceAnnotationBeanPostProcessor</tt></a>,
    as well as the aforementioned <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/annotation/RequiredAnnotationBeanPostProcessor.html" target="_top"><tt class="classname">RequiredAnnotationBeanPostProcessor</tt></a>.)</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Note that <tt class="literal">&lt;context:annotation-config/&gt;</tt> only looks for
        annotations  on beans in the same application context it is defined in.
        This means that, if you put <tt class="literal">&lt;context:annotation-config/&gt;</tt> in a
        <tt class="interfacename">WebApplicationContext</tt> for a <tt class="classname">DispatcherServlet</tt>, it only
        checks for <tt class="interfacename">@Autowired</tt> beans in your controllers, and not your services.
        See <a href="#mvc-servlet" title="13.2.&nbsp;The DispatcherServlet">Section&nbsp;13.2, &#8220;The DispatcherServlet&#8221;</a> for more information.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-required-annotation"></a>3.11.1.&nbsp;<tt class="interfacename">@Required</tt></h3></div></div><div></div></div><p>The <tt class="interfacename">@Required</tt> annotation applies
      to bean property setter methods, as in the following example:</p><pre class="programlisting">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>This annotation simply indicates that the affected bean property must
      be populated at configuration time: either through an explicit property value
      in a bean definition or through autowiring. The container will throw an exception
      if the affected bean property has not been populated; this allows for eager and
      explicit failure, avoiding <tt class="classname">NullPointerException</tt>s or the
      like later on. Note that it is still recommended to put assertions into the
      bean class itself (for example into an init method) in order to enforce those
      required references and values even when using the class outside of a container.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-autowired-annotation"></a>3.11.2.&nbsp;<tt class="interfacename">@Autowired</tt></h3></div></div><div></div></div><p>As expected, the <tt class="interfacename">@Autowired</tt>
      annotation may be applied to "traditional" setter methods:</p><pre class="programlisting">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>The annotation may also be applied to methods with arbitrary names
      and/or multiple arguments:</p><pre class="programlisting">public class MovieRecommender {

    private MovieCatalog movieCatalog;
    
    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>The <tt class="interfacename">@Autowired</tt> annotation may even
      be applied on constructors and fields:</p><pre class="programlisting">public class MovieRecommender {

    @Autowired
    private MovieCatalog movieCatalog;
    
    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>It is also possible to provide <span class="emphasis"><em>all</em></span> beans of a
      particular type from the
      <tt class="interfacename">ApplicationContext</tt> by adding the
      annotation to a field or method that expects an array of that
      type:</p><pre class="programlisting">public class MovieRecommender {

    @Autowired
    private MovieCatalog[] movieCatalogs;

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>The same applies for typed collections:</p><pre class="programlisting">public class MovieRecommender {

    private Set&lt;MovieCatalog&gt; movieCatalogs;
    
    @Autowired
    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>Even typed Maps may be autowired as long as the expected key type
      is <tt class="classname">String</tt>. The Map values will contain all beans
      of the expected type, and the keys will contain the corresponding bean
      names:</p><pre class="programlisting">public class MovieRecommender {

    private Map&lt;String, MovieCatalog&gt; movieCatalogs;
    
    @Autowired
    public void setMovieCatalogs(Map&lt;String, MovieCatalog&gt; movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>By default, the autowiring will fail whenever
      <span class="emphasis"><em>zero</em></span> candidate beans are available; the default
      behavior is to treat annotated methods, constructors, and fields as
      indicating <span class="emphasis"><em>required</em></span> dependencies. This behavior can
      be changed as demonstrated below.</p><pre class="programlisting">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired(required=false)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Only <span class="emphasis"><em>one annotated constructor per-class</em></span>
        may be marked as <span class="emphasis"><em>required</em></span>, but multiple non-required
        constructors can be annotated. In that case, each will be considered
        among the candidates and Spring will use the <span class="emphasis"><em>greediest</em></span>
        constructor whose dependencies can be satisfied.</p><p>Prefer the use of <tt class="interfacename">@Autowired</tt>'s
        <span class="emphasis"><em>required</em></span> attribute over the <tt class="interfacename">@Required</tt>
        annotation. The <span class="emphasis"><em>required</em></span> attribute indicates that
        the property is not required for autowiring purposes, simply skipping
        it if it cannot be autowired. <tt class="interfacename">@Required</tt>,
        on the other hand, is stronger in that it enforces the property to
        have been set in any of the container's supported ways; if no value
        has been injected, a corresponding exception will be raised.</p></td></tr></table></div><p><tt class="interfacename">@Autowired</tt> may also be used for
      well-known "resolvable dependencies": the <tt class="interfacename">BeanFactory</tt>
      interface, the <tt class="interfacename">ApplicationContext</tt> interface,
      the <tt class="interfacename">ResourceLoader</tt> interface,
      the <tt class="interfacename">ApplicationEventPublisher</tt> interface
      and the <tt class="interfacename">MessageSource</tt> interface.
      These interfaces (and their extended interfaces such as
      <tt class="interfacename">ConfigurableApplicationContext</tt> or
      <tt class="interfacename">ResourcePatternResolver</tt>) will be
      automatically resolved, with no special setup necessary.</p><pre class="programlisting">public class MovieRecommender {

    @Autowired
    private ApplicationContext context;

    public MovieRecommender() {
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-autowired-annotation-qualifiers"></a>3.11.3.&nbsp;Fine-tuning annotation-based autowiring with qualifiers</h3></div></div><div></div></div><p>Since autowiring by type may lead to multiple candidates, it is
      often necessary to have more control over the selection process. One way
      to accomplish this is with Spring's
      <tt class="interfacename">@Qualifier</tt> annotation. This allows for
      associating qualifier values with specific arguments, narrowing the
      set of type matches so that a specific bean is chosen for each argument.
      In the simplest case, this can be a plain descriptive value:</p><pre class="programlisting">public class MovieRecommender {

    @Autowired
    <span class="bold"><b>@Qualifier("main")</b></span>
    private MovieCatalog movieCatalog;

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>The <tt class="interfacename">@Qualifier</tt> annotation can also
      be specified on individual constructor arguments or method
      parameters:</p><pre class="programlisting">public class MovieRecommender {

    private MovieCatalog movieCatalog;
    
    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(<span class="bold"><b>@Qualifier("main")</b></span> MovieCatalog movieCatalog, CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>The corresponding bean definitions would look like as follows.
      The bean with qualifier value "main" would be wired with the
      constructor argument that has been qualified with the same value.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        <span class="bold"><b>&lt;qualifier value="main"/&gt;</b></span>
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        <span class="bold"><b>&lt;qualifier value="action"/&gt;</b></span>
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;

    &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;

&lt;/beans&gt;
</pre><p>For a fallback match, the bean name is considered as a default qualifier
      value. This means that the bean may be defined with an id "main" instead of
      the nested qualifier element, leading to the same matching result. However,
      note that while this can be used to refer to specific beans by name,
      <tt class="interfacename">@Autowired</tt> is fundamentally about type-driven
      injection with optional semantic qualifiers. This means that qualifier values,
      even when using the bean name fallback, always have narrowing semantics within
      the set of type matches; they do not semantically express a reference to a
      unique bean id. Good qualifier values would be "main" or "EMEA" or "persistent",
      expressing characteristics of a specific component - independent from the bean
      id (which may be auto-generated in case of an anonymous bean definition like
      the one above).</p><p>Qualifiers also apply to typed collections (as discussed above):
      e.g. to <tt class="literal">Set&lt;MovieCatalog&gt;</tt>. In such a case,
      all matching beans according to the declared qualifiers are going to
      be injected as a collection. This implies that qualifiers do not have
      to be unique; they rather simply constitute filtering criteria.
      For example, there could be multiple <tt class="classname">MovieCatalog</tt>
      beans defined with the same qualifier value "action"; all of which
      would be injected into a <tt class="literal">Set&lt;MovieCatalog&gt;</tt>
      annotated with <tt class="literal">@Qualifier("action")</tt>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you intend to express annotation-driven injection by name,
        do not primarily use <tt class="interfacename">@Autowired</tt> -
        even if is technically capable of referring to a bean name through
        <tt class="interfacename">@Qualifier</tt> values. Instead,
        prefer the JSR-250 <tt class="interfacename">@Resource</tt>
        annotation which is semantically defined to identify a specific
        target component by its unique name, with the declared type
        being irrelevant for the matching process.</p><p>As a specific consequence of this semantic difference,
        beans which are themselves defined as a collection or map type
        cannot be injected via <tt class="interfacename">@Autowired</tt>
        since type matching is not properly applicable to them.
        Use <tt class="interfacename">@Resource</tt> for such beans,
        referring to the specific collection/map bean by unique name.</p><p><span class="emphasis"><em>Note:</em></span> In contrast to
        <tt class="interfacename">@Autowired</tt> which is applicable to
        fields, constructors and multi-argument methods (allowing for
        narrowing through qualifier annotations at the parameter level),
        <tt class="interfacename">@Resource</tt> is only supported for
        fields and bean property setter methods with a single argument.
        As a consequence, stick with qualifiers if your injection target
        is a constructor or a multi-argument method.</p></td></tr></table></div><p>You may create your own custom qualifier annotations as well.
      Simply define an annotation and provide the
      <tt class="interfacename">@Qualifier</tt> annotation within your
      definition:</p><pre class="programlisting">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
<span class="bold"><b>@Qualifier</b></span>
public @interface Genre {

    String value();
}</pre><p>Then you can provide the custom qualifier on autowired fields and
      parameters:</p><pre class="programlisting">public class MovieRecommender {

    @Autowired
    <span class="bold"><b>@Genre("Action")</b></span>
    private MovieCatalog actionCatalog;
    
    private MovieCatalog comedyCatalog;
    
    @Autowired
    public void setComedyCatalog(<span class="bold"><b>@Genre("Comedy")</b></span> MovieCatalog comedyCatalog) {
        this.comedyCatalog = comedyCatalog;
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>The next step is to provide the information on the candidate bean
      definitions. You can add <tt class="literal">&lt;qualifier/&gt;</tt> tags as
      sub-elements of the <tt class="literal">&lt;bean/&gt;</tt> tag and then
      specify the <tt class="literal">'type'</tt> and <tt class="literal">'value'</tt> to
      match your custom qualifier annotations. The type will be matched
      against the fully-qualified class name of the annotation, or as a
      convenience when there is no risk of conflicting names, you may use the
      'short' class name. Both are demonstrated in the following
      example.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        <span class="bold"><b>&lt;qualifier type="Genre" value="Action"/&gt;</b></span>
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        <span class="bold"><b>&lt;qualifier type="example.Genre" value="Comedy"/&gt;</b></span>
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;
    
    &lt;bean id="movieRecommender" class="example.MovieRecommender"/&gt;

&lt;/beans&gt;
</pre><p>In the next section, entitled <a href="#beans-classpath-scanning" title="3.12.&nbsp;Classpath scanning for managed components">Section&nbsp;3.12, &#8220;Classpath scanning for managed components&#8221;</a>,
      you will see an annotation-based alternative to providing the qualifier
      metadata in XML. Specifically, see: <a href="#beans-scanning-qualifiers" title="3.12.6.&nbsp;Providing qualifier metadata with annotations">Section&nbsp;3.12.6, &#8220;Providing qualifier metadata with annotations&#8221;</a>.
      </p><p>In some cases, it may be sufficient to use an annotation without a
      value. This may be useful when the annotation serves a more generic
      purpose and could be applied across several different types of
      dependencies. For example, you may provide an
      <span class="emphasis"><em>offline</em></span> catalog that would be searched when no
      Internet connection is available. First define the simple
      annotation:</p><pre class="programlisting">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface Offline {

}</pre><p>Then add the annotation to the field or property to be
      autowired:</p><pre class="programlisting">public class MovieRecommender {

    @Autowired
    <span class="bold"><b>@Offline</b></span>
    private MovieCatalog offlineCatalog;

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>Now the bean definition only needs a qualifier
      <tt class="literal">'type'</tt>:</p><pre class="programlisting">&lt;bean class="example.SimpleMovieCatalog"&gt;
    <span class="bold"><b>&lt;qualifier type="Offline"/&gt;</b></span>
    <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
&lt;/bean&gt;</pre><p>It is also possible to define custom qualifier annotations that
      accept named attributes in addition to or instead of the simple
      <tt class="literal">'value'</tt> attribute. If multiple attribute values are
      then specified on a field or parameter to be autowired, a bean
      definition must match <span class="emphasis"><em>all</em></span> such attribute values to
      be considered an autowire candidate. As an example, consider the
      following annotation definition:</p><pre class="programlisting">@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Qualifier
public @interface MovieQualifier {

    String genre();
    
    Format format();
}</pre><p>In this case <tt class="literal">Format</tt> is an enum:</p><pre class="programlisting">public enum Format {
    
    VHS, DVD, BLURAY
}</pre><p>The fields to be autowired are annotated with the custom qualifier
      and include values for both attributes: <tt class="literal">'genre'</tt> and
      <tt class="literal">'format'</tt>.</p><pre class="programlisting">public class MovieRecommender {

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Action")
    private MovieCatalog actionVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.VHS, genre="Comedy")
    private MovieCatalog comedyVhsCatalog;

    @Autowired
    @MovieQualifier(format=Format.DVD, genre="Action")
    private MovieCatalog actionDvdCatalog;

    @Autowired
    @MovieQualifier(format=Format.BLURAY, genre="Comedy")
    private MovieCatalog comedyBluRayCatalog;
   
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>Finally, the bean definitions should contain matching qualifier
      values. This example also demonstrates that bean
      <span class="emphasis"><em>meta</em></span> attributes may be used instead of the
      <tt class="literal">&lt;qualifier/&gt;</tt> sub-elements. If available, the
      <tt class="literal">&lt;qualifier/&gt;</tt> and its attributes would take
      precedence, but the autowiring mechanism will fallback on the values
      provided within the <tt class="literal">&lt;meta/&gt;</tt> tags if no such
      qualifier is present (see the last 2 bean definitions below).</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    &lt;context:annotation-config/&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier type="MovieQualifier"&gt;
            &lt;attribute key="format" value="VHS"/&gt;
            &lt;attribute key="genre" value="Action"/&gt;
        &lt;/qualifier&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;qualifier type="MovieQualifier"&gt;
            &lt;attribute key="format" value="VHS"/&gt;
            &lt;attribute key="genre" value="Comedy"/&gt;
        &lt;/qualifier&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;

    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;meta key="format" value="DVD"/&gt;
        &lt;meta key="genre" value="Action"/&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;
    
    &lt;bean class="example.SimpleMovieCatalog"&gt;
        &lt;meta key="format" value="BLURAY"/&gt;
        &lt;meta key="genre" value="Comedy"/&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject any dependencies required by this bean --&gt;</span></i>
    &lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-custom-autowire-configurer"></a>3.11.4.&nbsp;<tt class="classname">CustomAutowireConfigurer</tt></h3></div></div><div></div></div><p>The <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/annotation/CustomAutowireConfigurer.html" target="_top"><tt class="classname">CustomAutowireConfigurer</tt></a>
      is a <tt class="interfacename">BeanFactoryPostProcessor</tt> that
      enables further customization of the autowiring process. Specifically,
      it allows you to register your own custom qualifier annotation types
      even if they are not themselves annotated with Spring's
      <tt class="interfacename">@Qualifier</tt> annotation.</p><pre class="programlisting">&lt;bean id="customAutowireConfigurer" class="org.springframework.beans.factory.annotation.CustomAutowireConfigurer"&gt;
    &lt;property name="customQualifierTypes"&gt;
        &lt;set&gt;
            &lt;value&gt;example.CustomQualifier&lt;/value&gt;
        &lt;/set&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that the particular implementation of
      <tt class="interfacename">AutowireCandidateResolver</tt> that will be
      activated for the application context depends upon the Java version. If
      running on less than Java 5, the qualifier annotations are not
      supported, and therefore autowire candidates are solely determined by
      the <tt class="literal">'autowire-candidate'</tt> value of each bean
      definition as well as any
      <tt class="literal">'default-autowire-candidates'</tt> pattern(s) available on
      the <tt class="literal">&lt;beans/&gt;</tt> element. If running on Java 5 or
      greater, the presence of <tt class="interfacename">@Qualifier</tt>
      annotations or any custom annotations registered with the
      <tt class="classname">CustomAutowireConfigurer</tt> will also play a
      role.</p><p>Regardless of the Java version, the determination of a "primary"
      candidate (when multiple beans qualify as autowire candidates) is the
      same: if exactly one bean definition among the candidates has a
      <tt class="literal">'primary'</tt> attribute set to <tt class="literal">'true'</tt>,
      it will be selected.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-resource-annotation"></a>3.11.5.&nbsp;<tt class="interfacename">@Resource</tt></h3></div></div><div></div></div><p>Spring also supports injection using the JSR-250
      <tt class="interfacename">@Resource</tt> annotation on fields or
      bean property setter methods. This is a common pattern found in
      Java EE 5 and Java 6 (e.g. in JSF 1.2 managed beans or JAX-WS 2.0
      endpoints), which Spring supports for Spring-managed objects as well.</p><p><tt class="interfacename">@Resource</tt> takes a 'name' attribute,
      and by default Spring will interpret that value as the bean name to be
      injected. In other words, it follows <span class="emphasis"><em>by-name</em></span>
      semantics as demonstrated in this example:</p><pre class="programlisting">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    <span class="bold"><b>@Resource(name="myMovieFinder")</b></span>
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}</pre><p>If no name is specified explicitly, then the default name
      will be derived from the name of the field or setter method:
      In case of a field, it will simply be equivalent to the field name;
      in case of a setter method, it will be equivalent to the bean
      property name. So the following example is going to have the bean
      with name "movieFinder" injected into its setter method:</p><pre class="programlisting">public class SimpleMovieLister {

    private MovieFinder movieFinder;

    <span class="bold"><b>@Resource</b></span>
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The name provided with the annotation will be resolved as a bean
        name by the <tt class="interfacename">BeanFactory</tt> of which the
        <tt class="classname">CommonAnnotationBeanPostProcessor</tt> is aware.
        Note that the names may be resolved via JNDI if Spring's <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/jndi/support/SimpleJndiBeanFactory.html" target="_top"><tt class="classname">SimpleJndiBeanFactory</tt></a>
        is configured explicitly. However, it is recommended to rely on the
        default behavior and simply use Spring's JNDI lookup capabilities to
        preserve the level of indirection.</p></td></tr></table></div><p>Similar to <tt class="interfacename">@Autowired</tt>,
      <tt class="interfacename">@Resource</tt> may fall back to standard bean type
      matches (i.e. find a primary type match instead of a specific named bean)
      as well as resolve well-known "resolvable dependencies":
      the <tt class="interfacename">BeanFactory</tt> interface,
      the <tt class="interfacename">ApplicationContext</tt> interface,
      the <tt class="interfacename">ResourceLoader</tt> interface,
      the <tt class="interfacename">ApplicationEventPublisher</tt> interface
      and the <tt class="interfacename">MessageSource</tt> interface.
      Note that this only applies to <tt class="interfacename">@Resource</tt>
      usage with no explicit name specified!</p><p>So the following example will have its <tt class="literal">customerPreferenceDao</tt>
      field looking for a bean with name "customerPreferenceDao" first, then falling
      back to a primary type match for the type <tt class="classname">CustomerPreferenceDao</tt>.
      The "context" field will simply be injected based on the known resolvable dependency
      type <tt class="interfacename">ApplicationContext</tt>.</p><pre class="programlisting">public class MovieRecommender {

    @Resource
    private CustomerPreferenceDao customerPreferenceDao;

    @Resource
    private ApplicationContext context;

    public MovieRecommender() {
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-postconstruct-and-predestroy-annotations"></a>3.11.6.&nbsp;<tt class="interfacename">@PostConstruct</tt> and
      <tt class="interfacename">@PreDestroy</tt></h3></div></div><div></div></div><p>The <tt class="classname">CommonAnnotationBeanPostProcessor</tt> not
      only recognizes the <tt class="interfacename">@Resource</tt> annotation
      but also the JSR-250 <span class="emphasis"><em>lifecycle</em></span> annotations.
      Introduced in Spring 2.5, the support for these annotations offers yet
      another alternative to those described in the sections on <a href="#beans-factory-lifecycle-initializingbean" title="3.5.1.1.&nbsp;Initialization callbacks">initialization
      callbacks</a> and <a href="#beans-factory-lifecycle-disposablebean" title="3.5.1.2.&nbsp;Destruction callbacks">destruction
      callbacks</a>. Provided that the
      <tt class="classname">CommonAnnotationBeanPostProcessor</tt> is registered
      within the Spring <tt class="interfacename">ApplicationContext</tt>, a
      method carrying one of these annotations will be invoked at the same
      point in the lifecycle as the corresponding Spring lifecycle interface's
      method or explicitly declared callback method. In the example below, the
      cache will be pre-populated upon initialization and cleared upon
      destruction.</p><pre class="programlisting">public class CachingMovieLister {

    @PostConstruct
    public void populateMovieCache() {
        <i class="lineannotation"><span class="lineannotation">// populates the movie cache upon initialization...</span></i>
    }
    
    @PreDestroy
    public void clearMovieCache() {
        <i class="lineannotation"><span class="lineannotation">// clears the movie cache upon destruction...</span></i>
    }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>For details regarding the effects of combining various lifecycle
        mechanisms, see <a href="#beans-factory-lifecycle-combined-effects" title="3.5.1.4.&nbsp;Combining lifecycle mechanisms">Section&nbsp;3.5.1.4, &#8220;Combining lifecycle mechanisms&#8221;</a>.</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-classpath-scanning"></a>3.12.&nbsp;Classpath scanning for managed components</h2></div></div><div></div></div><p>Thus far most of the examples within this chapter have used XML for
    specifying the configuration metadata that produces each
    <tt class="interfacename">BeanDefinition</tt> within the Spring container.
    The previous section (<a href="#beans-annotation-config" title="3.11.&nbsp;Annotation-based configuration">Section&nbsp;3.11, &#8220;Annotation-based configuration&#8221;</a>)
    demonstrated the possibility of providing a considerable amount of the
    configuration metadata using source-level annotations. Even in those
    examples however, the "base" bean definitions were explicitly defined in
    the XML file while the annotations were driving the dependency injection
    only. The current section introduces an option for implicitly detecting the 
    <span class="emphasis"><em>candidate components</em></span> by scanning the classpath and 
    matching against <span class="emphasis"><em>filters</em></span>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-stereotype-annotations"></a>3.12.1.&nbsp;<tt class="interfacename">@Component</tt> and further stereotype
      annotations</h3></div></div><div></div></div><p>Beginning with Spring 2.0, the
      <tt class="interfacename">@Repository</tt> annotation was introduced as
      a marker for any class that fulfills the role or
      <span class="emphasis"><em>stereotype</em></span> of a repository (a.k.a. Data Access
      Object or DAO). Among the possibilities for leveraging such a marker is
      the automatic translation of exceptions as described in <a href="#orm-jpa-exceptions" title="12.6.4.&nbsp;Exception Translation">Section&nbsp;12.6.4, &#8220;Exception Translation&#8221;</a>.</p><p>Spring 2.5 introduces further stereotype annotations:
      <tt class="interfacename">@Component</tt>,
      <tt class="interfacename">@Service</tt> and
      <tt class="interfacename">@Controller</tt>.
      <tt class="interfacename">@Component</tt> serves as a generic stereotype
      for any Spring-managed component; whereas,
      <tt class="interfacename">@Repository</tt>,
      <tt class="interfacename">@Service</tt>, and
      <tt class="interfacename">@Controller</tt> serve as specializations of
      <tt class="interfacename">@Component</tt> for more specific use cases
      (e.g., in the persistence, service, and presentation layers,
      respectively). What this means is that you can annotate your component
      classes with <tt class="interfacename">@Component</tt>, but by
      annotating them with <tt class="interfacename">@Repository</tt>,
      <tt class="interfacename">@Service</tt>, or
      <tt class="interfacename">@Controller</tt> instead, your classes are
      more properly suited for processing by tools or associating with aspects.
      For example, these stereotype annotations make ideal targets for 
      pointcuts. Of course, it is also possible that
      <tt class="interfacename">@Repository</tt>,
      <tt class="interfacename">@Service</tt>, and
      <tt class="interfacename">@Controller</tt> may carry additional
      semantics in future releases of the Spring Framework. Thus, if you are 
      making a decision between using <tt class="interfacename">@Component</tt> 
      or <tt class="interfacename">@Service</tt> for your service layer,
      <tt class="interfacename">@Service</tt> is clearly the better choice.
      Similarly, as stated above, <tt class="interfacename">@Repository</tt>
      is already supported as a marker for automatic exception translation in
      your persistence layer.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-scanning-autodetection"></a>3.12.2.&nbsp;Auto-detecting components</h3></div></div><div></div></div><p>Spring provides the capability of automatically detecting
      'stereotyped' classes and registering corresponding
      <tt class="interfacename">BeanDefinition</tt>s with the
      <tt class="interfacename">ApplicationContext</tt>. For example, the
      following two classes are eligible for such autodetection:</p><pre class="programlisting">@Service
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
}</pre><pre class="programlisting">@Repository
public class JpaMovieFinder implements MovieFinder {
    <i class="lineannotation"><span class="lineannotation">// implementation elided for clarity</span></i>
}</pre><p>To autodetect these classes and register the corresponding beans
      requires the inclusion of the following element in XML where
      'basePackage' would be a common parent package for the two classes (or
      alternatively a comma-separated list could be specified that included
      the parent package of each class).</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
           http://www.springframework.org/schema/context
           http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;
               
     &lt;context:component-scan base-package="org.example"/&gt;
     
&lt;/beans&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Note that the scanning of classpath packages requires
        the presence of corresponding directory entries in the classpath.
        When building jars with Ant, make sure to <span class="emphasis"><em>not</em></span>
        activate the files-only switch of the jar task!</p></td></tr></table></div><p>Furthermore, the
      <tt class="interfacename">AutowiredAnnotationBeanPostProcessor</tt> and
      <tt class="interfacename">CommonAnnotationBeanPostProcessor</tt> are
      both included implicitly when using the component-scan element. That
      means that the two components are autodetected <span class="emphasis"><em>and</em></span>
      wired together - all without any bean configuration metadata provided in
      XML.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The registration of those post-processors can be disabled by
        including the <span class="emphasis"><em>annotation-config</em></span> attribute with a
        value of 'false'.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-scanning-filters"></a>3.12.3.&nbsp;Using filters to customize scanning</h3></div></div><div></div></div><p>By default, classes annotated with
      <tt class="interfacename">@Component</tt>,
      <tt class="interfacename">@Repository</tt>,
      <tt class="interfacename">@Service</tt>, or
      <tt class="interfacename">@Controller</tt> (or classes annotated with a
      custom annotation that itself is annotated with 
      <tt class="interfacename">@Component</tt>) are the only detected
      candidate components. However it is simple to modify and extend this
      behavior by applying custom filters. These can be added as either
      <span class="emphasis"><em>include-filter</em></span> or
      <span class="emphasis"><em>exclude-filter</em></span> sub-elements of the 
      '<tt class="literal">component-scan</tt>' element. Each filter element requires 
      the '<tt class="literal">type</tt>' and '<tt class="literal">expression</tt>'
      attributes. Five filtering options exist as described below.</p><div class="table"><a name="beans-scanning-filters-tbl"></a><p class="title"><b>Table&nbsp;3.7.&nbsp;Filter Types</b></p><table summary="Filter Types" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Filter Type</th><th>Example Expression</th><th>Description</th></tr></thead><tbody><tr><td>annotation</td><td><tt class="literal">org.example.SomeAnnotation</tt></td><td>An annotation to be present at the type level in target components.</td></tr><tr><td>assignable</td><td><tt class="literal">org.example.SomeClass</tt></td><td>A class (or interface) that the target components are assignable to (extend/implement).</td></tr><tr><td>aspectj</td><td><tt class="literal">org.example..*Service+</tt></td><td>An AspectJ type expression to be matched by the target components.</td></tr><tr><td>regex</td><td><tt class="literal">org\.example\.Default.*</tt></td><td>A regex expression to be matched by the target components' class names.</td></tr><tr><td>custom</td><td><tt class="literal">org.example.MyCustomTypeFilter</tt></td><td>A custom implementation of the <tt class="interfacename">org.springframework.core.type.TypeFilter</tt> interface.</td></tr></tbody></table></div><p>Find below an example of the XML configuration for ignoring all
      <tt class="interfacename">@Repository</tt> annotations and using "stub"
      repositories instead.</p><pre class="programlisting">&lt;beans ...&gt;

     &lt;context:component-scan base-package="org.example"&gt;
        &lt;context:include-filter type="regex" expression=".*Stub.*Repository"/&gt;
        &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Repository"/&gt;
     &lt;/context:component-scan&gt;

&lt;/beans&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>It is also possible to disable the default filters by providing
        <span class="emphasis"><em>use-default-filters="false"</em></span> as an attribute of
        the &lt;component-scan/&gt; element. This will in effect disable
        automatic detection of classes annotated with
        <tt class="interfacename">@Component</tt>,
        <tt class="interfacename">@Repository</tt>,
        <tt class="interfacename">@Service</tt>, or
        <tt class="interfacename">@Controller</tt>.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-scanning-name-generator"></a>3.12.4.&nbsp;Naming autodetected components</h3></div></div><div></div></div><p>When a component is autodetected as part of the scanning process,
      its bean name will be generated by the
      <tt class="interfacename">BeanNameGenerator</tt> strategy known to that
      scanner. By default, any Spring 'stereotype' annotation
      (<tt class="interfacename">@Component</tt>,
      <tt class="interfacename">@Repository</tt>,
      <tt class="interfacename">@Service</tt>, and
      <tt class="interfacename">@Controller</tt>) that contains a
      <tt class="literal">name</tt> value will thereby provide that name to the
      corresponding bean definition. If such an annotation contains no
      <tt class="literal">name</tt> value or for any other detected component (such as
      those discovered due to custom filters), the default bean name generator
      will return the uncapitalized non-qualified class name. For example, if
      the following two components were detected, the names would be
      'myMovieLister' and 'movieFinderImpl':</p><pre class="programlisting">@Service("myMovieLister")
public class SimpleMovieLister {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><pre class="programlisting">@Repository
public class MovieFinderImpl implements MovieFinder {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you don't want to rely on the default bean-naming strategy,
        you may provide a custom bean-naming strategy. First, implement the
        <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/support/BeanNameGenerator.html" target="_top"><tt class="interfacename">BeanNameGenerator</tt></a>
        interface, and be sure to include a default no-arg constructor. Then,
        provide the fully-qualified class name when configuring the
        scanner:</p></td></tr></table></div><pre class="programlisting">&lt;beans ...&gt;
               
     &lt;context:component-scan base-package="org.example"
                             name-generator="org.example.MyNameGenerator" /&gt;

&lt;/beans&gt;</pre><p>As a general rule, consider specifying the name with the
      annotation whenever other components may be making explicit references
      to it. On the other hand, the auto-generated names are adequate whenever
      the container is responsible for wiring.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-scanning-scope-resolver"></a>3.12.5.&nbsp;Providing a scope for autodetected components</h3></div></div><div></div></div><p>As with Spring-managed components in general, the default and by
      far most common scope is 'singleton'. However, there are times when
      other scopes are needed. Therefore Spring 2.5 introduces a new
      <tt class="interfacename">@Scope</tt> annotation as well. Simply provide
      the name of the scope within the annotation, such as:</p><pre class="programlisting">@Scope("prototype")
@Repository
public class MovieFinderImpl implements MovieFinder {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you would like to provide a custom strategy for scope
        resolution rather than relying on the annotation-based approach,
        implement the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/context/annotation/ScopeMetadataResolver.html" target="_top"><tt class="interfacename">ScopeMetadataResolver</tt></a>
        interface, and be sure to include a default no-arg constructor. Then,
        provide the fully-qualified class name when configuring the
        scanner:</p></td></tr></table></div><pre class="programlisting">&lt;beans ...&gt;
               
     &lt;context:component-scan base-package="org.example"
                             scope-resolver="org.example.MyScopeResolver" /&gt;
     
&lt;/beans&gt;</pre><p>When using certain non-singleton scopes, it may be necessary to
      generate proxies for the scoped objects. The reasoning is described in
      detail within the section entitled <a href="#beans-factory-scopes-other-injection" title="3.4.4.5.&nbsp;Scoped beans as dependencies">Section&nbsp;3.4.4.5, &#8220;Scoped beans as dependencies&#8221;</a>. For this purpose, a
      <span class="emphasis"><em>scoped-proxy</em></span> attribute is available on the
      'component-scan' element. The three possible values are: 'no',
      'interfaces', and 'targetClass'. For example, the following
      configuration will result in standard JDK dynamic proxies:</p><pre class="programlisting">&lt;beans ...&gt;
               
     &lt;context:component-scan base-package="org.example"
                             scoped-proxy="interfaces" /&gt;
     
&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-scanning-qualifiers"></a>3.12.6.&nbsp;Providing qualifier metadata with annotations</h3></div></div><div></div></div><p>The <tt class="interfacename">@Qualifier</tt> annotation was
      introduced in the section above entitled
      <a href="#beans-autowired-annotation-qualifiers" title="3.11.3.&nbsp;Fine-tuning annotation-based autowiring with qualifiers">Section&nbsp;3.11.3, &#8220;Fine-tuning annotation-based autowiring with qualifiers&#8221;</a>. The
      examples in that section demonstrated use of the
      <tt class="interfacename">@Qualifier</tt> annotation as well
      as custom qualifier annotations to provide fine-grained control
      when resolving autowire candidates. Since those examples were
      based on XML bean definitions, the qualifier metadata was provided
      on the candidate bean definitions using the '<tt class="literal">qualifier</tt>'
      or '<tt class="literal">meta</tt>' sub-elements of the '<tt class="literal">bean</tt>'
      element in the XML. When relying upon classpath scanning for 
      autodetection of components, then the qualifier metadata may
      be provided with type-level annotations on the candidate class.
      The following three examples demonstrate this technique.</p><pre class="programlisting">@Component
<span class="bold"><b>@Qualifier("Action")</b></span>
public class ActionMovieCatalog implements MovieCatalog {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><pre class="programlisting">@Component
<span class="bold"><b>@Genre("Action")</b></span>
public class ActionMovieCatalog implements MovieCatalog {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><pre class="programlisting">@Component
<span class="bold"><b>@Offline</b></span>
public class CachingMovieCatalog implements MovieCatalog {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top">As with most of the annotation-based alternatives, keep
      in mind that the annotation metadata is bound to the class
      definition itself, while the use of XML allows for multiple
      beans <span class="emphasis"><em>of the same type</em></span> to provide variations
      in their qualifier metadata since that metadata is provided
      per-instance rather than per-class.</td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="context-load-time-weaver"></a>3.13.&nbsp;Registering a <tt class="interfacename">LoadTimeWeaver</tt></h2></div></div><div></div></div><p>The <tt class="literal">context</tt> namespace introduced in Spring 2.5
    provides a <tt class="literal">load-time-weaver</tt> element.</p><pre class="programlisting">&lt;beans ...&gt;
     
     &lt;context:load-time-weaver/&gt;
     
&lt;/beans&gt;</pre><p>Adding this element to an XML-based Spring configuration file
    activates a Spring <tt class="interfacename">LoadTimeWeaver</tt> for the
    <tt class="interfacename">ApplicationContext</tt>. Any bean within that
    <tt class="interfacename">ApplicationContext</tt> may implement
    <tt class="interfacename">LoadTimeWeaverAware</tt> thereby receiving a
    reference to the load-time weaver instance. This is particularly useful in
    combination with <a href="#orm-jpa" title="12.6.&nbsp;JPA">Spring's JPA support</a> where
    load-time weaving may be necessary for JPA class transformation. Consult
    the <tt class="classname">LocalContainerEntityManagerFactoryBean</tt> Javadoc
    for more detail. For more on AspectJ load-time weaving, see <a href="#aop-aj-ltw" title="6.8.4.&nbsp;Load-time weaving with AspectJ in the Spring Framework">Section&nbsp;6.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221;</a>.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.d0e1168" href="#d0e1168">1</a>] </sup>See the section entitled <a href="#background-ioc" title="Background">Background</a></p></div><div class="footnote"><p><sup>[<a name="ftn.d0e3240" href="#d0e3240">2</a>] </sup>See the section entitled <a href="#beans-factory-collaborators" title="3.3.1.&nbsp;Injecting dependencies">Section&nbsp;3.3.1, &#8220;Injecting dependencies&#8221;</a></p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="resources"></a>Chapter&nbsp;4.&nbsp;Resources</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="resources-introduction"></a>4.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Java's standard <tt class="classname">java.net.URL</tt> class and
    standard handlers for various URL prefixes unfortunately are not quite
    adequate enough for all access to low-level resources. For example,
	there is no standardized <tt class="classname">URL</tt> implementation
	that may be used to access a resource that needs to be obtained from
	the classpath, or relative to a
	<tt class="interfacename">ServletContext</tt>. While it is possible
    to register new handlers for specialized <tt class="classname">URL</tt>
	prefixes (similar to existing handlers for prefixes such as
	<tt class="literal">http:</tt>), this is generally quite complicated, and the
	<tt class="classname">URL</tt> interface still lacks some desirable
    functionality, such as a method to check for the existence of the
	resource being pointed to.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="resources-resource"></a>4.2.&nbsp;The <tt class="interfacename">Resource</tt> interface</h2></div></div><div></div></div><p>Spring's <tt class="interfacename">Resource</tt> interface is meant
    to be a more capable interface for abstracting access to low-level
    resources.</p><pre class="programlisting">public interface Resource extends InputStreamSource {

    boolean exists();

    boolean isOpen();

    URL getURL() throws IOException;

    File getFile() throws IOException;

    Resource createRelative(String relativePath) throws IOException;

    String getFilename();

    String getDescription();
}</pre><pre class="programlisting">public interface InputStreamSource {

    InputStream getInputStream() throws IOException;
}</pre><p>Some of the most important methods from the
    <tt class="interfacename">Resource</tt> interface are:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">getInputStream()</tt>: locates and opens the
        resource, returning an <tt class="classname">InputStream</tt> for reading
        from the resource. It is expected that each invocation returns a
        fresh <tt class="classname">InputStream</tt>. It is the responsibility of
        the caller to close the stream.</p></li><li><p><tt class="methodname">exists()</tt>: returns a
        <tt class="literal">boolean</tt> indicating whether this resource actually
        exists in physical form.</p></li><li><p><tt class="methodname">isOpen()</tt>: returns a
        <tt class="literal">boolean</tt> indicating whether this resource represents
        a handle with an open stream. If <tt class="literal">true</tt>, the
        <tt class="classname">InputStream</tt> cannot be read multiple times, and
        must be read once only and then closed to avoid resource leaks. Will
        be <tt class="literal">false</tt> for all usual resource implementations,
        with the exception of
        <tt class="classname">InputStreamResource</tt>.</p></li><li><p><tt class="methodname">getDescription()</tt>: returns a description
        for this resource, to be used for error output when working with the
        resource. This is often the fully qualified file name or the actual
        URL of the resource.</p></li></ul></div><p>Other methods allow you to obtain an actual
    <tt class="classname">URL</tt> or <tt class="classname">File</tt> object
    representing the resource (if the underlying implementation is compatible,
    and supports that functionality).</p><p>The <tt class="interfacename">Resource</tt> abstraction is used
    extensively in Spring itself, as an argument type in many method
    signatures when a resource is needed. Other methods in some Spring APIs
    (such as the constructors to various
    <tt class="interfacename">ApplicationContext</tt> implementations), take a
    <tt class="classname">String</tt> which in unadorned or simple form is used to
    create a <tt class="interfacename">Resource</tt> appropriate to that
    context implementation, or via special prefixes on the
    <tt class="classname">String</tt> path, allow the caller to specify that a
    specific <tt class="interfacename">Resource</tt> implementation must be
    created and used.</p><p>While the <tt class="interfacename">Resource</tt> interface is used
    a lot with Spring and by Spring, it's actually very useful to use as a
    general utility class by itself in your own code, for access to resources,
    even when your code doesn't know or care about any other parts of Spring.
    While this couples your code to Spring, it really only couples it to this
    small set of utility classes, which are serving as a more capable
    replacement for <tt class="classname">URL</tt>, and can be considered
    equivalent to any other library you would use for this purpose.</p><p>It is important to note that the
    <tt class="interfacename">Resource</tt> abstraction does not replace
    functionality: it wraps it where possible. For example, a
    <tt class="classname">UrlResource</tt> wraps a URL, and uses the wrapped
    <tt class="classname">URL</tt> to do its work.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="resources-implementations"></a>4.3.&nbsp;Built-in <tt class="interfacename">Resource</tt> implementations</h2></div></div><div></div></div><p>There are a number of <tt class="interfacename">Resource</tt>
    implementations that come supplied straight out of the box in
    Spring:</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="resources-implementations-urlresource"></a>4.3.1.&nbsp;<tt class="classname">UrlResource</tt></h3></div></div><div></div></div><p>The <tt class="classname">UrlResource</tt> wraps a
      <tt class="classname">java.net.URL</tt>, and may be used to access any
      object that is normally accessible via a URL, such as files, an HTTP
      target, an FTP target, etc. All URLs have a standardized
      <tt class="classname">String</tt> representation, such that appropriate
      standardized prefixes are used to indicate one URL type from another.
      This includes <tt class="literal">file:</tt> for accessing filesystem paths,
      <tt class="literal">http:</tt> for accessing resources via the HTTP protocol,
      <tt class="literal">ftp:</tt> for accessing resources via FTP, etc.</p><p>A <tt class="classname">UrlResource</tt> is created by Java code
      explicitly using the <tt class="classname">UrlResource</tt> constructor, but
      will often be created implicitly when you call an API method which takes
      a <tt class="classname">String</tt> argument which is meant to represent a
      path. For the latter case, a JavaBeans
      <tt class="interfacename">PropertyEditor</tt> will ultimately decide
      which type of <tt class="interfacename">Resource</tt> to create. If the
      path string contains a few well-known (to it, that is) prefixes such as
      <tt class="literal">classpath:</tt>, it will create an appropriate specialized
      <tt class="interfacename">Resource</tt> for that prefix. However, if it
      doesn't recognize the prefix, it will assume the this is just a standard
      URL string, and will create a <tt class="classname">UrlResource</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="resources-implementations-classpathresource"></a>4.3.2.&nbsp;<tt class="classname">ClassPathResource</tt></h3></div></div><div></div></div><p>This class represents a resource which should be obtained from the
      classpath. This uses either the thread context class loader, a given
      class loader, or a given class for loading resources.</p><p>This <tt class="interfacename">Resource</tt> implementation
      supports resolution as <tt class="classname">java.io.File</tt> if the class
      path resource resides in the file system, but not for classpath
      resources which reside in a jar and have not been expanded (by the
      servlet engine, or whatever the environment is) to the filesystem. To
      address this the various <tt class="interfacename">Resource</tt>
      implementations always support resolution as a
      <tt class="classname">java.net.URL</tt>.</p><p>A <tt class="classname">ClassPathResource</tt> is created by Java code
      explicitly using the <tt class="classname">ClassPathResource</tt>
      constructor, but will often be created implicitly when you call an API
      method which takes a <tt class="classname">String</tt> argument which is
      meant to represent a path. For the latter case, a JavaBeans
      <tt class="interfacename">PropertyEditor</tt> will recognize the special
      prefix <tt class="literal">classpath:</tt>on the string path, and create a
      <tt class="classname">ClassPathResource</tt> in that case.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="resources-implementations-filesystemresource"></a>4.3.3.&nbsp;<tt class="classname">FileSystemResource</tt></h3></div></div><div></div></div><p>This is a <tt class="interfacename">Resource</tt> implementation
      for <tt class="classname">java.io.File</tt> handles. It obviously supports
      resolution as a <tt class="classname">File</tt>, and as a
      <tt class="classname">URL</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="resources-implementations-servletcontextresource"></a>4.3.4.&nbsp;<tt class="classname">ServletContextResource</tt></h3></div></div><div></div></div><p>This is a <tt class="interfacename">Resource</tt> implementation
      for <tt class="interfacename">ServletContext</tt> resources,
      interpreting relative paths within the relevant web application's root
      directory.</p><p>This always supports stream access and URL access, but only allows
      <tt class="classname">java.io.File</tt> access when the web application
      archive is expanded and the resource is physically on the filesystem.
      Whether or not it's expanded and on the filesystem like this, or
      accessed directly from the JAR or somewhere else like a DB (it's
      conceivable) is actually dependent on the Servlet container.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="resources-implementations-inputstreamresource"></a>4.3.5.&nbsp;<tt class="classname">InputStreamResource</tt></h3></div></div><div></div></div><p>A <tt class="interfacename">Resource</tt> implementation for a
      given <tt class="interfacename">InputStream</tt>. This should only be
      used if no specific <tt class="interfacename">Resource</tt>
      implementation is applicable. In particular, prefer
      <tt class="classname">ByteArrayResource</tt> or any of the file-based
      <tt class="interfacename">Resource</tt> implementations where
      possible.</p><p>In contrast to other <tt class="interfacename">Resource</tt>
      implementations, this is a descriptor for an
      <span class="emphasis"><em>already</em></span> opened resource - therefore returning
      <tt class="literal">true</tt> from <tt class="methodname">isOpen()</tt>. Do not
      use it if you need to keep the resource descriptor somewhere, or if you
      need to read a stream multiple times.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="resources-implementations-bytearrayresource"></a>4.3.6.&nbsp;<tt class="classname">ByteArrayResource</tt></h3></div></div><div></div></div><p>This is a <tt class="interfacename">Resource</tt> implementation
      for a given byte array. It creates a
      <tt class="classname">ByteArrayInputStream</tt> for the given byte
      array.</p><p>It's useful for loading content from any given byte array, without
      having to resort to a single-use
      <tt class="classname">InputStreamResource</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="resources-resourceloader"></a>4.4.&nbsp;The <tt class="interfacename">ResourceLoader</tt></h2></div></div><div></div></div><p>The <tt class="interfacename">ResourceLoader</tt> interface is meant
    to be implemented by objects that can return (i.e. load)
    <tt class="interfacename">Resource</tt> instances.</p><pre class="programlisting">public interface ResourceLoader {
    Resource getResource(String location);
}</pre><p>All application contexts implement the
    <tt class="interfacename">ResourceLoader</tt> interface, and therefore all
    application contexts may be used to obtain
    <tt class="interfacename">Resource</tt> instances.</p><p>When you call <tt class="methodname">getResource()</tt> on a specific
    application context, and the location path specified doesn't have a
    specific prefix, you will get back a
    <tt class="interfacename">Resource</tt> type that is appropriate to that
    particular application context. For example, assume the following snippet
    of code was executed against a
    <tt class="classname">ClassPathXmlApplicationContext</tt> instance:</p><pre class="programlisting">Resource template = ctx.getResource("some/resource/path/myTemplate.txt);</pre><p>What would be returned would be a
    <tt class="classname">ClassPathResource</tt>; if the same method was executed
    against a <tt class="classname">FileSystemXmlApplicationContext</tt> instance,
    you'd get back a <tt class="classname">FileSystemResource</tt>. For a
    <tt class="classname">WebApplicationContext</tt>, you'd get back a
    <tt class="classname">ServletContextResource</tt>, and so on.</p><p>As such, you can load resources in a fashion appropriate to the
    particular application context.</p><p>On the other hand, you may also force
    <tt class="classname">ClassPathResource</tt> to be used, regardless of the
    application context type, by specifying the special
    <tt class="literal">classpath:</tt> prefix:</p><pre class="programlisting">Resource template = ctx.getResource("classpath:some/resource/path/myTemplate.txt);</pre><p>Similarly, one can force a <tt class="classname">UrlResource</tt> to be
    used by specifying any of the standard <tt class="classname">java.net.URL</tt>
    prefixes:</p><pre class="programlisting">Resource template = ctx.getResource("file:/some/resource/path/myTemplate.txt);</pre><pre class="programlisting">Resource template = ctx.getResource("http://myhost.com/resource/path/myTemplate.txt);</pre><p>The following table summarizes the strategy for converting
    <tt class="classname">String</tt>s to
    <tt class="interfacename">Resource</tt>s:</p><div class="table"><a name="resources-resource-strings"></a><p class="title"><b>Table&nbsp;4.1.&nbsp;Resource strings</b></p><table summary="Resource strings" width="100%" border="1"><colgroup><col align="left"><col><col></colgroup><thead><tr><th align="center">Prefix</th><th align="center">Example</th><th align="center">Explanation</th></tr></thead><tbody><tr><td align="left"><p>classpath:</p></td><td><p> <tt class="literal">classpath:com/myapp/config.xml</tt>
            </p></td><td><p>Loaded from the classpath.</p></td></tr><tr><td align="left"><p>file:</p></td><td><p> <tt class="literal">file:/data/config.xml</tt>
            </p></td><td><p> Loaded as a <tt class="classname">URL</tt>, from the
            filesystem. <sup>[<a name="d0e8268" href="#ftn.d0e8268">a</a>]</sup> </p></td></tr><tr><td align="left"><p>http:</p></td><td><p> <tt class="literal">http://myserver/logo.png</tt>
            </p></td><td><p>Loaded as a
            <tt class="classname">URL</tt>.</p></td></tr><tr><td align="left"><p>(none)</p></td><td><p> <tt class="literal">/data/config.xml</tt> </p></td><td><p> Depends on the underlying
            <tt class="interfacename">ApplicationContext</tt>. </p></td></tr></tbody><tbody class="footnotes"><tr><td colspan="3"><div class="footnote"><p><sup>[<a name="ftn.d0e8268" href="#d0e8268">a</a>] </sup>But see also the section entitled <a href="#resources-filesystemresource-caveats" title="4.7.3.&nbsp;FileSystemResource caveats">Section&nbsp;4.7.3, &#8220;FileSystemResource caveats&#8221;</a>.</p></div></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="resources-resourceloaderaware"></a>4.5.&nbsp;The <tt class="interfacename">ResourceLoaderAware</tt> interface</h2></div></div><div></div></div><p>The <tt class="interfacename">ResourceLoaderAware</tt> interface is
    a special marker interface, identifying objects that expect to be provided
    with a <tt class="interfacename">ResourceLoader</tt> reference.</p><pre class="programlisting">public interface ResourceLoaderAware {

   void setResourceLoader(ResourceLoader resourceLoader);
}</pre><p>When a class implements
    <tt class="interfacename">ResourceLoaderAware</tt> and is deployed into an
    application context (as a Spring-managed bean), it is recognized as
    <tt class="interfacename">ResourceLoaderAware</tt> by the application
    context. The application context will then invoke the
    <tt class="methodname">setResourceLoader(ResourceLoader)</tt>, supplying
    itself as the argument (remember, all application contexts in Spring
    implement the <tt class="interfacename">ResourceLoader</tt>
    interface).</p><p>Of course, since an
    <tt class="interfacename">ApplicationContext</tt> is a
    <tt class="interfacename">ResourceLoader</tt>, the bean could also
    implement the <tt class="interfacename">ApplicationContextAware</tt>
    interface and use the supplied application context directly to load
    resources, but in general, it's better to use the specialized
    <tt class="interfacename">ResourceLoader</tt> interface if that's all
    that's needed. The code would just be coupled to the resource loading
    interface, which can be considered a utility interface, and not the whole
    Spring <tt class="interfacename">ApplicationContext</tt> interface.</p><p>As of Spring 2.5, you can rely upon autowiring of the
    <tt class="interfacename">ResourceLoader</tt> as an alternative to
    implementing the <tt class="interfacename">ResourceLoaderAware</tt> interface.
    The "traditional" <tt class="literal">constructor</tt> and <tt class="literal">byType</tt>
    autowiring modes (as described in the section entitled
    <a href="#beans-factory-autowire" title="3.3.5.&nbsp;Autowiring collaborators">Section&nbsp;3.3.5, &#8220;Autowiring collaborators&#8221;</a>) are now capable of providing a
    dependency of type <tt class="interfacename">ResourceLoader</tt> for either a
    constructor argument or setter method parameter respectively. For more flexibility
    (including the ability to autowire fields and multiple parameter methods), consider
    using the new annotation-based autowiring features. In that case, the
    <tt class="interfacename">ResourceLoader</tt> will be autowired into a field,
    constructor argument, or method parameter that is expecting the
    <tt class="interfacename">ResourceLoader</tt> type as long as the field,
    constructor, or method in question carries the
    <tt class="interfacename">@Autowired</tt> annotation. For more information,
    see the section entitled <a href="#beans-autowired-annotation" title="3.11.2.&nbsp;@Autowired">Section&nbsp;3.11.2, &#8220;@Autowired&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="resources-as-dependencies"></a>4.6.&nbsp;<tt class="literal">Resources</tt> as dependencies</h2></div></div><div></div></div><p>If the bean itself is going to determine and supply the resource
    path through some sort of dynamic process, it probably makes sense for the
    bean to use the <tt class="interfacename">ResourceLoader</tt> interface to
    load resources. Consider as an example the loading of a template of some
    sort, where the specific resource that is needed depends on the role of
    the user. If the resources are static, it makes sense to eliminate the use
    of the <tt class="interfacename">ResourceLoader</tt> interface completely,
    and just have the bean expose the <tt class="interfacename">Resource</tt>
    properties it needs, and expect that they will be injected into it.</p><p>What makes it trivial to then inject these properties, is that all
    application contexts register and use a special JavaBeans
    <tt class="interfacename">PropertyEditor</tt> which can convert
    <tt class="classname">String</tt> paths to
    <tt class="interfacename">Resource</tt> objects. So if
    <tt class="literal">myBean</tt> has a template property of type
    <tt class="interfacename">Resource</tt>, it can be configured with a
    simple string for that resource, as follows:</p><pre class="programlisting">&lt;bean id="myBean" class="..."&gt;
  &lt;property name="template" value="some/resource/path/myTemplate.txt"/&gt;
&lt;/bean&gt;</pre><p>Note that the resource path has no prefix, so because the
    application context itself is going to be used as the
    <tt class="interfacename">ResourceLoader</tt>, the resource itself will be
    loaded via a <tt class="classname">ClassPathResource</tt>,
    <tt class="literal">FileSystemResource</tt>, or
    <tt class="classname">ServletContextResource</tt> (as appropriate)
    depending on the exact type of the context.</p><p>If there is a need to force a specific
    <tt class="interfacename">Resource</tt> type to be used, then a prefix may
    be used. The following two examples show how to force a
    <tt class="classname">ClassPathResource</tt> and a
    <tt class="classname">UrlResource</tt> (the latter being used to access a
    filesystem file).</p><pre class="programlisting">&lt;property name="template" value="classpath:some/resource/path/myTemplate.txt"&gt;</pre><pre class="programlisting">&lt;property name="template" value="file:/some/resource/path/myTemplate.txt"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="resources-app-ctx"></a>4.7.&nbsp;Application contexts and <tt class="interfacename">Resource</tt> paths</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="resources-app-ctx-construction"></a>4.7.1.&nbsp;Constructing application contexts</h3></div></div><div></div></div><p>An application context constructor (for a specific application
      context type) generally takes a string or array of strings as the
      location path(s) of the resource(s) such as XML files that make up the
      definition of the context.</p><p>When such a location path doesn't have a prefix, the specific
      <tt class="interfacename">Resource</tt> type built from that path and
      used to load the bean definitions, depends on and is appropriate to the
      specific application context. For example, if you create a
      <tt class="classname">ClassPathXmlApplicationContext</tt> as follows:</p><pre class="programlisting">ApplicationContext ctx = new ClassPathXmlApplicationContext("conf/appContext.xml");</pre><p>The bean definitions will be loaded from the classpath, as a
      <tt class="classname"></tt><tt class="classname">ClassPathResource</tt> will be
      used. But if you create a
      <tt class="classname">FileSystemXmlApplicationContext</tt> as
      follows:</p><pre class="programlisting">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf/appContext.xml");</pre><p>The bean definition will be loaded from a filesystem location, in
      this case relative to the current working directory.</p><p>Note that the use of the special classpath prefix or a standard
      URL prefix on the location path will override the default type of
      <tt class="interfacename">Resource</tt> created to load the definition.
      So this <tt class="classname">FileSystemXmlApplicationContext</tt>...</p><pre class="programlisting">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("classpath:conf/appContext.xml");</pre><p>... will actually load its bean definitions from the classpath.
      However, it is still a <tt class="classname">FileSystemXmlApplicationContext</tt>. If it is
      subsequently used as a <tt class="interfacename">ResourceLoader</tt>,
      any unprefixed paths will still be treated as filesystem paths.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="resources-app-ctx-classpathxml"></a>4.7.1.1.&nbsp;Constructing <tt class="classname">ClassPathXmlApplicationContext</tt> instances - shortcuts</h4></div></div><div></div></div><p>The <tt class="classname">ClassPathXmlApplicationContext</tt>
        exposes a number of constructors to enable convenient instantiation.
        The basic idea is that one supplies merely a string array containing
        just the filenames of the XML files themselves (without the leading
        path information), and one <span class="emphasis"><em>also</em></span> supplies a
        <tt class="classname">Class</tt>; the
        <tt class="classname">ClassPathXmlApplicationContext</tt> will derive the
        path information from the supplied class.</p><p>An example will hopefully make this clear. Consider a directory
        layout that looks like this:</p><pre class="programlisting">com/
  foo/
    services.xml
    daos.xml
    MessengerService.class</pre><p>A <tt class="classname">ClassPathXmlApplicationContext</tt> instance
        composed of the beans defined in the <tt class="literal">'services.xml'</tt>
        and <tt class="literal">'daos.xml'</tt> could be instantiated like
        so...</p><pre class="programlisting">ApplicationContext ctx = new ClassPathXmlApplicationContext(
    new String[] {"services.xml", "daos.xml"}, MessengerService.class);</pre><p>Please do consult the Javadocs for the
        <tt class="classname">ClassPathXmlApplicationContext</tt> class for
        details of the various constructors.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="resources-app-ctx-wildcards-in-resource-paths"></a>4.7.2.&nbsp;Wildcards in application context constructor resource paths</h3></div></div><div></div></div><p>The resource paths in application context constructor values may
      be a simple path (as shown above) which has a one-to-one mapping to a
      target Resource, or alternately may contain the special "classpath*:"
      prefix and/or internal Ant-style regular expressions (matched using
      Spring's <tt class="classname">PathMatcher</tt> utility). Both of the latter
      are effectively wildcards</p><p>One use for this mechanism is when doing component-style
      application assembly. All components can 'publish' context definition
      fragments to a well-known location path, and when the final application
      context is created using the same path prefixed via
      <tt class="literal">classpath*:</tt>, all component fragments will be picked
      up automatically.</p><p>Note that this wildcarding is specific to use of resource paths in
      application context constructors (or when using the
      <tt class="classname">PathMatcher</tt> utility class hierarchy directly),
      and is resolved at construction time. It has nothing to do with the
      <tt class="interfacename">Resource</tt> type itself. It's not possible
      to use the <tt class="literal">classpath*:</tt> prefix to construct an actual
      <tt class="interfacename">Resource</tt>, as a resource points to just
      one resource at a time.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="resources-app-ctx-ant-patterns-in-paths"></a>4.7.2.1.&nbsp;Ant-style Patterns</h4></div></div><div></div></div><p>When the path location contains an Ant-style pattern, for example:</p><pre class="programlisting">     /WEB-INF/*-context.xml
     com/mycompany/**/applicationContext.xml
     file:C:/some/path/*-context.xml
     classpath:com/mycompany/**/applicationContext.xml</pre><p>... the resolver follows a more complex but defined procedure to
        try to resolve the wildcard. It produces a Resource for the path up to
        the last non-wildcard segment and obtains a URL from it. If this URL
        is not a "jar:" URL or container-specific variant (e.g.
        "<tt class="literal">zip:</tt>" in WebLogic, "<tt class="literal">wsjar</tt>" in
        WebSphere, etc.), then a <tt class="classname">java.io.File</tt> is
        obtained from it and used to resolve the wildcard by traversing the
        filesystem. In the case of a jar URL, the resolver either gets a
        <tt class="classname">java.net.JarURLConnection</tt> from it or manually
        parses the jar URL and then traverses the contents of the jar file
        to resolve the wildcards.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="resources-app-ctx-portability"></a>4.7.2.1.1.&nbsp;Implications on portability</h5></div></div><div></div></div><p>If the specified path is already a file URL (either
          explicitly, or implicitly because the base
		  <tt class="interfacename">ResourceLoader</tt> is a
          filesystem one, then wildcarding is guaranteed to work in a
          completely portable fashion.</p><p>If the specified path is a classpath location, then the
          resolver must obtain the last non-wildcard path segment URL via a
          <tt class="methodname">Classloader.getResource()</tt> call. Since this
          is just a node of the path (not the file at the end) it is actually
          undefined (in the <tt class="classname">ClassLoader</tt> Javadocs)
          exactly what sort of a URL is returned in this case. In practice, it
          is always a <tt class="classname">java.io.File</tt> representing the
          directory, where the classpath resource resolves to a filesystem
          location, or a jar URL of some sort, where the classpath resource
          resolves to a jar location. Still, there is a portability concern on
          this operation.</p><p>If a jar URL is obtained for the last non-wildcard segment,
          the resolver must be able to get a
          <tt class="classname">java.net.JarURLConnection</tt> from it, or
          manually parse the jar URL, to be able to walk the contents of the
          jar, and resolve the wildcard. This will work in most environments,
          but will fail in others, and it is strongly recommended that the
          wildcard resolution of resources coming from jars be thoroughly
          tested in your specific environment before you rely on it.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="resources-classpath-wildcards"></a>4.7.2.2.&nbsp;The <tt class="literal">classpath*:</tt> prefix</h4></div></div><div></div></div><p>When constructing an XML-based application context, a location
        string may use the special <tt class="literal">classpath*:</tt>
        prefix:</p><pre class="programlisting">ApplicationContext ctx =
    new ClassPathXmlApplicationContext("classpath*:conf/appContext.xml");</pre><p>This special prefix specifies that all classpath resources that
        match the given name must be obtained (internally, this essentially
        happens via a <tt class="methodname">ClassLoader.getResources(...)</tt>
        call), and then merged to form the final application context
        definition.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Classpath*: portability"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Classpath*: portability</th></tr><tr><td colspan="2" align="left" valign="top"><p>The wildcard classpath relies on the <tt class="literal">getResources()</tt> method of the
          underlying classloader. As most application servers nowadays supply
          their own classloader implementation, the behavior might differ
          especially when dealing with jar files. A simple test to check if
          <tt class="literal">classpath*</tt> works is to use the classloader to load a file from
          within a jar on the classpath:
          <tt class="literal">getClass().getClassLoader().getResources("&lt;someFileInsideTheJar&gt;")</tt>.
          Try this test with files that have the same name but are placed
          inside two different locations. In case an inappropriate result is
          returned, check the application server documentation for settings
          that might affect the classloader behavior.</p></td></tr></table></div><p>The "<tt class="literal">classpath*:</tt>" prefix can also be combined
        with a <tt class="literal">PathMatcher</tt> pattern in the rest of the location path, for
        example "<tt class="literal">classpath*:META-INF/*-beans.xml</tt>". In this
        case, the resolution strategy is fairly simple: a
        ClassLoader.getResources() call is used on the last non-wildcard path
        segment to get all the matching resources in the class loader
        hierarchy, and then off each resource the same PathMatcher resoltion
        strategy described above is used for the wildcard subpath.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="resources-wildcards-in-path-other-stuff"></a>4.7.2.3.&nbsp;Other notes relating to wildcards</h4></div></div><div></div></div><p>Please note that "<tt class="literal">classpath*:</tt>" when
        combined with Ant-style patterns will only work reliably with at least
        one root directory before the pattern starts, unless the actual target
        files reside in the file system. This means that a pattern like
        "<tt class="literal">classpath*:*.xml</tt>" will not retrieve files from the
        root of jar files but rather only from the root of expanded
        directories. This originates from a limitation in the JDK's
        <tt class="methodname">ClassLoader.getResources()</tt> method which only
        returns file system locations for a passed-in empty string (indicating
        potential roots to search).</p><p>Ant-style patterns with "<tt class="literal">classpath:</tt>"
		resources are not guaranteed to find matching resources if the root
		package to search is available in multiple class path locations. This
		is because a resource such as</p><pre class="programlisting">    com/mycompany/package1/service-context.xml</pre><p>may be in only one location, but when a path such as</p><pre class="programlisting">    classpath:com/mycompany/**/service-context.xml</pre><p>is used to try to resolve it, the resolver will work off the (first) URL
        returned by <tt class="methodname">getResource("com/mycompany")</tt>;. If
        this base package node exists in multiple classloader locations, the
        actual end resource may not be underneath. Therefore, preferably, use
        "<tt class="literal">classpath*:</tt>" with the same Ant-style pattern in
        such a case, which will search all class path locations that contain
        the root package.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="resources-filesystemresource-caveats"></a>4.7.3.&nbsp;<tt class="classname">FileSystemResource</tt> caveats</h3></div></div><div></div></div><p>A <tt class="classname">FileSystemResource</tt> that is not attached
      to a <tt class="classname">FileSystemApplicationContext</tt> (that is, a
      <tt class="classname">FileSystemApplicationContext</tt> is not the actual
      <tt class="interfacename">ResourceLoader</tt>) will treat absolute vs.
      relative paths as you would expect. Relative paths are relative to the
      current working directory, while absolute paths are relative to the root
      of the filesystem.</p><p>For backwards compatibility (historical) reasons however, this
      changes when the <tt class="classname">FileSystemApplicationContext</tt> is
      the <tt class="literal">ResourceLoader</tt>. The
      <tt class="classname">FileSystemApplicationContext</tt> simply forces all
      attached <tt class="classname">FileSystemResource</tt> instances to treat
      all location paths as relative, whether they start with a leading slash
      or not. In practice, this means the following are equivalent:</p><pre class="programlisting">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("conf/context.xml");</pre><pre class="programlisting">ApplicationContext ctx =
    new FileSystemXmlApplicationContext("/conf/context.xml");</pre><p>As are the following: (Even though it would make sense for them to
      be different, as one case is relative and the other absolute.)</p><pre class="programlisting">FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("some/resource/path/myTemplate.txt");</pre><pre class="programlisting">FileSystemXmlApplicationContext ctx = ...;
ctx.getResource("/some/resource/path/myTemplate.txt");</pre><p>In practice, if true absolute filesystem paths are needed, it is
      better to forgo the use of absolute paths with
      <tt class="classname">FileSystemResource</tt> /
      <tt class="classname">FileSystemXmlApplicationContext</tt>, and just force
      the use of a <tt class="classname">UrlResource</tt>, by using the
      <tt class="literal">file:</tt> URL prefix.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// actual context type doesn't matter, the <tt class="interfacename">Resource</tt> will always be <tt class="classname">UrlResource</tt></span></i>
ctx.getResource("file:/some/resource/path/myTemplate.txt");</pre><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// force this FileSystemXmlApplicationContext to load its definition via a <tt class="classname">UrlResource</tt></span></i>
ApplicationContext ctx =
    new FileSystemXmlApplicationContext("file:/conf/context.xml");</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="validation"></a>Chapter&nbsp;5.&nbsp;Validation, Data-binding, the <tt class="interfacename">BeanWrapper</tt>, and <tt class="literal">PropertyEditors</tt></h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-introduction"></a>5.1.&nbsp;Introduction</h2></div></div><div></div></div><p>There are pros and cons for considering validation as business logic,
    and Spring offers a design for validation (and data binding) that
    does not exclude either one of them. Specifically validation should not be
    tied to the web tier, should be easy to localize and it should be
    possible to plug in any validator available. Considering the above, Spring
    has come up with a <tt class="interfacename">Validator</tt> interface that
    is both basic and eminently usable in every layer of an application.</p><p>Data binding is useful for allowing user input to be dynamically
    bound to the domain model of an application (or whatever objects you use
    to process user input). Spring provides the so-called
    <tt class="interfacename">DataBinder</tt> to do exactly that. The
    <tt class="interfacename">Validator</tt> and the
    <tt class="interfacename">DataBinder</tt> make up the <tt class="literal">validation</tt> package,
    which is primarily used in but not limited to the MVC framework.</p><p>The <tt class="interfacename">BeanWrapper</tt> is a fundamental concept in the
    Spring Framework and is used in a lot of places. However, you probably
    will not ever have the need to use the <tt class="interfacename">BeanWrapper</tt> directly. Because this
    is reference documentation however, we felt that some explanation might be
    in order. We're explaining the <tt class="interfacename">BeanWrapper</tt> in this chapter since if you were
    going to use it at all, you would probably do so when trying to bind
    data to objects, which is strongly related to the <tt class="interfacename">BeanWrapper</tt>.</p><p>Spring uses PropertyEditors all over the place. The concept of a
    <tt class="interfacename">PropertyEditor</tt> is part of the JavaBeans specification. Just as the
    <tt class="interfacename">BeanWrapper</tt>, it's best to explain the use of PropertyEditors in this
    chapter as well, since it's closely related to the <tt class="interfacename">BeanWrapper</tt> and the
    <tt class="interfacename">DataBinder</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validator"></a>5.2.&nbsp;Validation using Spring's <tt class="interfacename">Validator</tt> interface</h2></div></div><div></div></div><p>Spring's features a <tt class="interfacename">Validator</tt> interface that you can
        use to validate objects. The <tt class="interfacename">Validator</tt> interface works using
        an <tt class="interfacename">Errors</tt> object so that while validating, validators can report
        validation failures to the <tt class="interfacename">Errors</tt> object.</p><p>Let's consider a small data object:</p><pre class="programlisting">
public class Person {

  private String name;
  private int age;

  <i class="lineannotation"><span class="lineannotation">// the usual getters and setters...</span></i>
}</pre><p>We're going to provide validation behavior for the <tt class="classname">Person</tt>
			class by implementing the following two methods of the
			<tt class="interfacename">org.springframework.validation.Validator</tt> interface:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="methodname">supports(Class)</tt> - Can this
					<tt class="interfacename">Validator</tt> validate instances of the supplied
					<tt class="classname">Class</tt>?</p></li><li><p><tt class="methodname">validate(Object, org.springframework.validation.Errors)</tt> -
					validates the given object and in case of validation errors, registers
					those with the given <tt class="interfacename">Errors</tt> object</p></li></ul></div><p>
		</p><p>
		Implementing a <tt class="interfacename">Validator</tt> is fairly straightforward,
		especially when you know of the <tt class="classname">ValidationUtils</tt> helper class
		that the Spring Framework also provides.</p><pre class="programlisting">public class PersonValidator implements Validator {
    
    <i class="lineannotation"><span class="lineannotation">/**
    * This <tt class="interfacename">Validator</tt> validates <span class="bold"><b>just</b></span> <tt class="classname">Person</tt> instances
    */</span></i>
    public boolean supports(Class clazz) {
        return Person.class.equals(clazz);
    }
    
    public void validate(Object obj, Errors e) {
        ValidationUtils.rejectIfEmpty(e, "name", "name.empty");
        Person p = (Person) obj;
        if (p.getAge() &lt; 0) {
            e.rejectValue("age", "negativevalue");
        } else if (p.getAge() &gt; 110) {
            e.rejectValue("age", "too.darn.old");
        }
    }
}</pre><p>As you can see, the <tt class="literal">static</tt> <tt class="methodname">rejectIfEmpty(..)</tt>
		method on the <tt class="classname">ValidationUtils</tt> class is used to reject the
		<tt class="literal">'name'</tt> property if it is <tt class="literal">null</tt> or the empty string.
		Have a look at the Javadoc for the <tt class="classname">ValidationUtils</tt> class to see
		what functionality it provides besides the example shown previously.</p><p>While it is certainly possible to implement a single
		<tt class="interfacename">Validator</tt> class to validate each of the nested objects
		in a rich object, it may be better to encapsulate the validation logic for each nested
		class of object in its own <tt class="interfacename">Validator</tt> implementation. A
		simple example of a <span class="emphasis"><em>'rich'</em></span> object would be a
		<tt class="classname">Customer</tt> that is composed of two <tt class="classname">String</tt>
		properties (a first and second name) and a complex <tt class="classname">Address</tt> object.
        <tt class="classname">Address</tt> objects may be used independently of
        <tt class="classname">Customer</tt> objects, and so a distinct
        <tt class="classname">AddressValidator</tt> has been implemented. If you want your
        <tt class="classname">CustomerValidator</tt> to reuse the logic contained within the
        <tt class="classname">AddressValidator</tt> class without recourse to copy-n-paste you can
        dependency-inject or instantiate an <tt class="classname">AddressValidator</tt> within your
        <tt class="classname">CustomerValidator</tt>, and use it like so:</p><pre class="programlisting">public class CustomerValidator implements Validator {

   private final Validator addressValidator;

   public CustomerValidator(Validator addressValidator) {
      if (addressValidator == null) {
          throw new IllegalArgumentException("The supplied [Validator] is required and must not be null.");
      }
      if (!addressValidator.supports(Address.class)) {
          throw new IllegalArgumentException(
            "The supplied [Validator] must support the validation of [Address] instances.");
      }
      this.addressValidator = addressValidator;
   }

    <i class="lineannotation"><span class="lineannotation">/**
    * This <tt class="interfacename">Validator</tt> validates <tt class="classname">Customer</tt> instances, and any subclasses of <tt class="classname">Customer</tt> too
    */</span></i>
   public boolean supports(Class clazz) {
      return Customer.class.isAssignableFrom(clazz);
   }

   public void validate(Object target, Errors errors) {
      ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "field.required");
      ValidationUtils.rejectIfEmptyOrWhitespace(errors, "surname", "field.required");
      Customer customer = (Customer) target;
      try {
          errors.pushNestedPath("address");
          ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors);
      } finally {
          errors.popNestedPath();
      }
   }
}</pre><p>Validation errors are reported to the <tt class="interfacename">Errors</tt>
		object passed to the validator. In case of Spring Web MVC you can use
		<tt class="literal">&lt;spring:bind/&gt;</tt> tag to inspect the error messages, but
		of course you can also inspect the errors object yourself. More information about
		the methods it offers can be found from the Javadoc.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="validation-conversion"></a>5.3.&nbsp;Resolving codes to error messages</h2></div></div><div></div></div><p>We've talked about databinding and validation. Outputting messages corresponding to
		validation errors is the last thing we need to discuss. In the example we've shown
		above, we rejected the <tt class="literal">name</tt> and the <tt class="literal">age</tt> field.
		If we're going to output the error messages by using a <tt class="interfacename">MessageSource</tt>,
		we will do so using the error code we've given when rejecting the field ('name' and 'age'
		in this case). When you call (either directly, or indirectly, using for example the
		<tt class="classname">ValidationUtils</tt> class) <tt class="literal">rejectValue</tt> or one of
		the other <tt class="literal">reject</tt> methods from the <tt class="interfacename">Errors</tt>
		interface, the underlying implementation will not only register the code you've
		passed in, but also a number of additional error codes. What error codes it registers
		is determined by the <tt class="interfacename">MessageCodesResolver</tt> that is used.
		By default, the <tt class="classname">DefaultMessageCodesResolver</tt> is used, which for example
		not only registers a message with the code you gave, but also messages that include the
		field name you passed to the reject method. So in case you reject a field using
		<tt class="literal">rejectValue("age", "too.darn.old")</tt>, apart from the
		<tt class="literal">too.darn.old</tt> code, Spring will also register
		<tt class="literal">too.darn.old.age</tt> and <tt class="literal">too.darn.old.age.int</tt>
		(so the first will include the field name and the second will include the type of the
		field); this is done as a convenience to aid developers in targeting error
		messages and suchlike.</p><p>More information on the <tt class="interfacename">MessageCodesResolver</tt> and the default
		strategy can be found online with the Javadocs for
		<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/validation/MessageCodesResolver.html" target="_top">MessageCodesResolver</a>
		and
		<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/validation/DefaultMessageCodesResolver.html" target="_top">DefaultMessageCodesResolver</a>
		respectively.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="beans-beans"></a>5.4.&nbsp;Bean manipulation and the <tt class="interfacename">BeanWrapper</tt></h2></div></div><div></div></div><p>The <tt class="literal">org.springframework.beans</tt> package adheres to
    the JavaBeans standard provided by Sun. A JavaBean is simply a class with
    a default no-argument constructor, which follows a naming convention
    where (by way of an example) a property named <tt class="literal">bingoMadness</tt> would have a setter
    method <tt class="methodname">setBingoMadness(..)</tt> and a getter method <tt class="methodname">getBingoMadness()</tt>.
    For more information about JavaBeans and the specification, please refer
    to Sun's website ( <a href="http://java.sun.com/products/javabeans/" target="_top">java.sun.com/products/javabeans</a>).</p><p>One quite important class in the beans package is the
    <tt class="interfacename">BeanWrapper</tt> interface and its corresponding
    implementation (<tt class="classname">BeanWrapperImpl</tt>). As quoted from the
    Javadoc, the <tt class="interfacename">BeanWrapper</tt> offers functionality to set and get property
    values (individually or in bulk), get property descriptors, and to query
    properties to determine if they are readable or writable. Also, the
    <tt class="interfacename">BeanWrapper</tt> offers support for nested properties, enabling the setting of
    properties on sub-properties to an unlimited depth. Then, the <tt class="interfacename">BeanWrapper</tt>
    supports the ability to add standard JavaBeans
    <tt class="interfacename">PropertyChangeListeners</tt> and
    <tt class="interfacename">VetoableChangeListeners</tt>, without the need for
    supporting code in the target class. Last but not least, the <tt class="interfacename">BeanWrapper</tt>
    provides support for the setting of indexed properties. The <tt class="interfacename">BeanWrapper</tt>
    usually isn't used by application code directly, but by the
    <tt class="interfacename">DataBinder</tt> and the
    <tt class="interfacename">BeanFactory</tt>.</p><p>The way the <tt class="interfacename">BeanWrapper</tt> works is partly indicated by its name:
    <span class="emphasis"><em>it wraps a bean</em></span> to perform actions on that bean, like
    setting and retrieving properties.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beans-conventions"></a>5.4.1.&nbsp;Setting and getting basic and nested properties</h3></div></div><div></div></div><p>Setting and getting properties is done using the
      <tt class="literal">setPropertyValue(s)</tt> and
      <tt class="literal">getPropertyValue(s)</tt> methods that both come with a
      couple of overloaded variants. They're all described in more detail in
      the Javadoc Spring comes with. What's important to know is that there
      are a couple of conventions for indicating properties of an object. A
      couple of examples:</p><div class="table"><a name="beans-beans-conventions-properties-tbl"></a><p class="title"><b>Table&nbsp;5.1.&nbsp;Examples of properties</b></p><table summary="Examples of properties" border="1"><colgroup><col><col></colgroup><thead><tr><th>Expression</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="literal">name</tt></td><td>Indicates the property <tt class="literal">name</tt>
                corresponding to the methods <tt class="methodname">getName()</tt> or
                <tt class="methodname">isName()</tt> and
                <tt class="methodname">setName(..)</tt></td></tr><tr><td><tt class="literal">account.name</tt></td><td>Indicates the nested property <tt class="literal">name</tt>
                of the property <tt class="literal">account</tt> corresponding e.g.
                to the methods <tt class="literal">getAccount().setName()</tt> or
                <tt class="literal">getAccount().getName()</tt></td></tr><tr><td><tt class="literal">account[2]</tt></td><td>Indicates the <span class="emphasis"><em>third</em></span> element of the
                indexed property <tt class="literal">account</tt>. Indexed
                properties can be of type <tt class="literal">array</tt>,
                <tt class="literal">list</tt> or other <span class="emphasis"><em>naturally
                ordered</em></span> collection</td></tr><tr><td><tt class="literal">account[COMPANYNAME]</tt></td><td>Indicates the value of the map entry indexed by the key
                <span class="emphasis"><em>COMPANYNAME</em></span> of the Map property
                <tt class="literal">account</tt></td></tr></tbody></table></div><p>Below you'll find some examples of working with the <tt class="interfacename">BeanWrapper</tt> to
      get and set properties.</p><p><span class="emphasis"><em>(This next section is not vitally important to you if you're not
      planning to work with the <tt class="interfacename">BeanWrapper</tt> directly. If you're
      just using the <tt class="interfacename">DataBinder</tt> and the
      <tt class="interfacename">BeanFactory</tt> and their out-of-the-box implementation, you
      should skip ahead to the section about
      <tt class="interfacename">PropertyEditors</tt>.)</em></span></p><p>Consider the following two classes:</p><pre class="programlisting">public class Company {
    private String name;
    private Employee managingDirector;

    public String getName()	{ 
        return this.name; 
    }
    public void setName(String name) { 
        this.name = name; 
    } 
    public Employee getManagingDirector() { 
        return this.managingDirector; 
    }
    public void setManagingDirector(Employee managingDirector) {
        this.managingDirector = managingDirector;
    }
}</pre><pre class="programlisting">public class Employee {
    private String name;
    private float salary;

    public String getName()	{
        return this.name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public float getSalary() {
        return salary;
    }
    public void setSalary(float salary) {
        this.salary = salary;
    }
}</pre><p>The following code snippets show some examples of how to retrieve
      and manipulate some of the properties of instantiated
      <tt class="literal">Companies</tt> and <tt class="literal">Employees</tt>:</p><pre class="programlisting">BeanWrapper company = BeanWrapperImpl(new Company());
<i class="lineannotation"><span class="lineannotation">// setting the company name..</span></i>
company.setPropertyValue("name", "Some Company Inc.");
<i class="lineannotation"><span class="lineannotation">// ... can also be done like this:</span></i>
PropertyValue value = new PropertyValue("name", "Some Company Inc.");
company.setPropertyValue(value);

<i class="lineannotation"><span class="lineannotation">// ok, let's create the director and tie it to the company:</span></i>
BeanWrapper jim = BeanWrapperImpl(new Employee());
jim.setPropertyValue("name", "Jim Stravinsky");
company.setPropertyValue("managingDirector", jim.getWrappedInstance());

<i class="lineannotation"><span class="lineannotation">// retrieving the salary of the managingDirector through the company</span></i>
Float salary = (Float) company.getPropertyValue("managingDirector.salary");</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="beans-beans-conversion"></a>5.4.2.&nbsp;Built-in <span class="interface">PropertyEditor</span> implementations</h3></div></div><div></div></div><p>Spring heavily uses the concept of <tt class="literal">PropertyEditors</tt> to effect the conversion
		between an <tt class="classname">Object</tt> and a <tt class="classname">String</tt>. If you think about it,
		it sometimes might be handy to be able to represent properties in a different way than the object itself.
		For example, a <tt class="classname">Date</tt> can be represented in a human readable way (as the
		<tt class="classname">String</tt> '<tt class="literal">2007-14-09</tt>'), while we're still able to convert the
		human readable form back to the original date (or even better: convert any date entered in a human readable
		form, back to <tt class="classname">Date</tt> objects). This behavior can be achieved by
		<span class="emphasis"><em>registering custom editors</em></span>, of type <tt class="interfacename">java.beans.PropertyEditor</tt>.
		Registering custom editors on a <tt class="interfacename">BeanWrapper</tt> or alternately in a specific IoC
		container as mentioned in the previous chapter, gives it the knowledge of how to convert properties to the
		desired type. Read more about <tt class="interfacename">PropertyEditors</tt> in the Javadoc of the
		<tt class="literal">java.beans</tt> package provided by Sun.</p><p>A couple of examples where property editing is used in Spring:
			</p><div class="itemizedlist"><ul type="disc" compact><li><p><span class="emphasis"><em>setting properties on beans</em></span> is done
					using <tt class="literal">PropertyEditors</tt>. When mentioning
					<tt class="literal">java.lang.String</tt> as the value of a property of
					some bean you're declaring in XML file, Spring will (if the setter
					of the corresponding property has a <tt class="classname">Class</tt>-parameter) use the
					<tt class="classname">ClassEditor</tt> to try to resolve the parameter to
					a <tt class="classname">Class</tt> object.</p></li><li><p><span class="emphasis"><em>parsing HTTP request parameters</em></span> in
					Spring's MVC framework is done using all kinds of <tt class="literal">PropertyEditors</tt>
					that you can manually bind in all subclasses of the
					<tt class="classname">CommandController</tt>.</p></li></ul></div><p>
		</p><p>Spring has a number of built-in <tt class="literal">PropertyEditors</tt> to make life easy.
		Each of those is listed below and they are all located in the
		<tt class="literal">org.springframework.beans.propertyeditors</tt> package. Most, but not all (as indicated below),
		are registered by default by <tt class="classname">BeanWrapperImpl</tt>. Where the property editor is configurable
		in some fashion, you can of course still register your own variant to override the default one:</p><div class="table"><a name="beans-beans-property-editors-tbl"></a><p class="title"><b>Table&nbsp;5.2.&nbsp;Built-in <tt class="literal">PropertyEditors</tt></b></p><table summary="Built-in PropertyEditors" border="1"><colgroup><col><col></colgroup><thead><tr><th>Class</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="classname">ByteArrayPropertyEditor</tt></td><td>Editor for byte arrays. Strings will simply be
                converted to their corresponding byte representations.
                Registered by default by <tt class="classname">BeanWrapperImpl</tt>.</td></tr><tr><td><tt class="classname">ClassEditor</tt></td><td>Parses Strings representing classes to actual classes
                and the other way around. When a class is not found, an
                <tt class="classname">IllegalArgumentException</tt> is thrown. Registered by default by
                <tt class="classname">BeanWrapperImpl</tt>.</td></tr><tr><td><tt class="classname">CustomBooleanEditor</tt></td><td>Customizable property editor for <tt class="classname">Boolean</tt> properties.
                Registered by default by <tt class="classname">BeanWrapperImpl</tt>, but, can be
                overridden by registering custom instance of it as custom
                editor.</td></tr><tr><td><tt class="classname">CustomCollectionEditor</tt></td><td>Property editor for Collections, converting any source
                <tt class="interfacename">Collection</tt> to a given target <tt class="interfacename">Collection</tt> type.</td></tr><tr><td><tt class="classname">CustomDateEditor</tt></td><td>Customizable property editor for java.util.Date,
                supporting a custom DateFormat. NOT registered by default. Must
                be user registered as needed with appropriate format.</td></tr><tr><td><tt class="classname">CustomNumberEditor</tt></td><td>Customizable property editor for any Number subclass
                like <tt class="classname">Integer</tt>, <tt class="classname">Long</tt>,
                <tt class="classname">Float</tt>, <tt class="classname">Double</tt>. Registered
                by default by <tt class="classname">BeanWrapperImpl</tt>, but can be
                overridden by registering custom instance of it as a custom editor.</td></tr><tr><td><tt class="classname">FileEditor</tt></td><td>Capable of resolving Strings to
                <tt class="classname">java.io.File</tt> objects. Registered by default by
                <tt class="classname">BeanWrapperImpl</tt>. </td></tr><tr><td><tt class="classname">InputStreamEditor</tt></td><td>One-way property editor, capable of taking a text
                string and producing (via an intermediate <tt class="classname">ResourceEditor</tt> and
                <tt class="interfacename">Resource</tt>) an
                <tt class="interfacename">InputStream</tt>, so <tt class="interfacename">InputStream</tt>
                properties may be directly set as Strings. Note that the default usage
                will not close the <tt class="interfacename">InputStream</tt> for
                you! Registered by default by <tt class="classname">BeanWrapperImpl</tt>.</td></tr><tr><td><tt class="classname">LocaleEditor</tt></td><td>Capable of resolving Strings to
                <tt class="classname">Locale</tt> objects and vice versa (the String
                format is [language]_[country]_[variant], which is the same
                thing the toString() method of Locale provides). Registered by
                default by <tt class="classname">BeanWrapperImpl</tt>.</td></tr><tr><td><tt class="classname">PatternEditor</tt></td><td>Capable of resolving Strings to JDK 1.5
                <tt class="classname">Pattern</tt> objects and vice versa.</td></tr><tr><td><tt class="classname">PropertiesEditor</tt></td><td>Capable of converting Strings (formatted using the
                format as defined in the Javadoc for the java.lang.Properties
                class) to <tt class="classname">Properties</tt> objects. Registered by
                default by <tt class="classname">BeanWrapperImpl</tt>.</td></tr><tr><td><tt class="classname">StringTrimmerEditor</tt></td><td>Property editor that trims Strings. Optionally allows
                transforming an empty string into a <tt class="literal">null</tt> value. NOT
                registered by default; must be user registered as needed.</td></tr><tr><td><tt class="classname">URLEditor</tt></td><td>Capable of resolving a String representation of a URL
                to an actual <tt class="classname">URL</tt> object. Registered by
                default by <tt class="classname">BeanWrapperImpl</tt>.</td></tr></tbody></table></div><p>
		Spring uses the <tt class="interfacename">java.beans.PropertyEditorManager</tt> to set
		the search path for property editors that might be needed. The search path also includes
		<tt class="literal">sun.bean.editors</tt>, which includes
		<tt class="interfacename">PropertyEditor</tt> implementations for types such as
		<tt class="classname">Font</tt>, <tt class="classname">Color</tt>, and most of the primitive types.
		Note also that the standard JavaBeans infrastructure will automatically discover
		<tt class="interfacename">PropertyEditor</tt> classes (without you having to register them
		explicitly) if they are in the same package as the class they handle, and have the same name
		as that class, with <tt class="literal">'Editor'</tt> appended; for example, one could have the
		following class and package structure, which would be sufficient for the
		<tt class="classname">FooEditor</tt> class to be recognized and used as the
		<tt class="interfacename">PropertyEditor</tt> for <tt class="classname">Foo</tt>-typed
		properties.
	  </p><pre class="programlisting">com
  chank
    pop
      Foo
      FooEditor   <i class="lineannotation"><span class="lineannotation">// the <tt class="interfacename">PropertyEditor</tt> for the <tt class="classname">Foo</tt> class</span></i></pre><p>Note that you can also use the standard <tt class="interfacename">BeanInfo</tt> JavaBeans
		mechanism here as well (described
		<a href="http://java.sun.com/docs/books/tutorial/javabeans/customization/index.html" target="_top">in not-amazing-detail here</a>).
		Find below an example of using the <tt class="interfacename">BeanInfo</tt> mechanism for
		explicitly registering one or more <tt class="interfacename">PropertyEditor</tt> instances
		with the properties of an associated class.</p><pre class="programlisting">com
  chank
    pop
      Foo
      FooBeanInfo   <i class="lineannotation"><span class="lineannotation">// the <tt class="interfacename">BeanInfo</tt> for the <tt class="classname">Foo</tt> class</span></i></pre><p>
		Here is the Java source code for the referenced <tt class="classname">FooBeanInfo</tt> class. This
		would associate a <tt class="classname">CustomNumberEditor</tt> with the <tt class="literal">age</tt>
		property of the <tt class="classname">Foo</tt> class.
	  </p><pre class="programlisting">public class FooBeanInfo extends SimpleBeanInfo {
      
    public PropertyDescriptor[] getPropertyDescriptors() {
        try {
            final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true);
            PropertyDescriptor ageDescriptor = new PropertyDescriptor("age", Foo.class) {
                public PropertyEditor createPropertyEditor(Object bean) {
                    return numberPE;
                };
            };
            return new PropertyDescriptor[] { ageDescriptor };
        }
        catch (IntrospectionException ex) {
            throw new Error(ex.toString());
        }
    }
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="beans-beans-conversion-customeditor-registration"></a>5.4.2.1.&nbsp;Registering additional custom <tt class="interfacename">PropertyEditors</tt></h4></div></div><div></div></div><p>When setting bean properties as a string value, a Spring IoC container
            ultimately uses standard JavaBeans <tt class="literal">PropertyEditors</tt> to convert these
            Strings to the complex type of the property. Spring pre-registers a number
            of custom <tt class="literal">PropertyEditors</tt> (for example, to convert a classname expressed
            as a string into a real <tt class="classname">Class</tt> object). Additionally, Java's standard
            JavaBeans <tt class="interfacename">PropertyEditor</tt> lookup mechanism allows a
            <tt class="classname">PropertyEditor</tt> for a class simply to be named appropriately and
            placed in the same package as the class it provides support for, to be found automatically.</p><p>If there is a need to register other custom <tt class="literal">PropertyEditors</tt>, there
            are several mechanisms available. The most manual approach, which is not normally convenient or
            recommended, is to simply use the <tt class="methodname">registerCustomEditor()</tt> method of the
            <tt class="interfacename">ConfigurableBeanFactory</tt> interface, assuming you have a
            <tt class="interfacename">BeanFactory</tt> reference. Another, slightly more convenient, mechanism is to use
            a special bean factory post-processor called <tt class="classname">CustomEditorConfigurer</tt>.
            Although bean factory post-processors can be used with <tt class="interfacename">BeanFactory</tt>
			implementations, the <tt class="classname">CustomEditorConfigurer</tt> has a nested property setup, so it is
			strongly recommended that it is used with the <tt class="interfacename">ApplicationContext</tt>, where
			it may be deployed in similar fashion to any other bean, and automatically detected and applied.</p><p>Note that all bean factories and application contexts automatically use a number of built-in property
			editors, through their use of something called a <tt class="interfacename">BeanWrapper</tt> to handle
			property conversions. The standard property editors that the <tt class="interfacename">BeanWrapper</tt>
			registers are listed in <a href="#beans-beans-conversion" title="5.4.2.&nbsp;Built-in PropertyEditor implementations">the previous section</a>. Additionally,
            <tt class="literal">ApplicationContexts</tt> also override or add an additional number of editors
            to handle resource lookups in a manner appropriate to the specific application context type.</p><p>Standard JavaBeans <tt class="interfacename">PropertyEditor</tt> instances are used to convert
			property values expressed as strings to the actual complex type of the property.
			<tt class="classname">CustomEditorConfigurer</tt>, a bean factory post-processor, may be used to conveniently
			add support for additional <tt class="interfacename">PropertyEditor</tt> instances to an
			<tt class="interfacename">ApplicationContext</tt>.</p><p>Consider a user class <tt class="classname">ExoticType</tt>, and another class
			<tt class="classname">DependsOnExoticType</tt> which needs <tt class="classname">ExoticType</tt> set as a property:</p><pre class="programlisting">package example;
		
public class ExoticType {

    private String name;

    public ExoticType(String name) {
        this.name = name;
    }
}

public class DependsOnExoticType { 
   
    private ExoticType type;

    public void setType(ExoticType type) {
        this.type = type;
    }
}</pre><p>When things are properly set up, we want to be able to assign the type property as a string, which a
			<tt class="interfacename">PropertyEditor</tt> will behind the scenes convert into an actual
			<tt class="classname">ExoticType</tt> instance:</p><pre class="programlisting">&lt;bean id="sample" class="example.DependsOnExoticType"&gt;
    &lt;property name="type" value="aNameForExoticType"/&gt;
&lt;/bean&gt;</pre><p>The <tt class="interfacename">PropertyEditor</tt> implementation could look similar to this:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// converts string representation to <tt class="classname">ExoticType</tt> object</span></i>
package example;

public class ExoticTypeEditor extends PropertyEditorSupport {

    private String format;

    public void setFormat(String format) {
        this.format = format;
    }
    
    public void setAsText(String text) {
        if (format != null &amp;&amp; format.equals("upperCase")) {
            text = text.toUpperCase();
        }
        ExoticType type = new ExoticType(text);
        setValue(type);
    }
}</pre><p>Finally, we use <tt class="classname">CustomEditorConfigurer</tt> to register the new
			<tt class="interfacename">PropertyEditor</tt> with the <tt class="interfacename">ApplicationContext</tt>,
			which will then be able to use it as needed:</p><pre class="programlisting">&lt;bean class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt;
  &lt;property name="customEditors"&gt;
    &lt;map&gt;
      &lt;entry key="example.ExoticType"&gt;
        &lt;bean class="example.ExoticTypeEditor"&gt;
          &lt;property name="format" value="upperCase"/&gt;
        &lt;/bean&gt;
      &lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="beans-beans-conversion-customeditor-registration-per"></a>5.4.2.1.1.&nbsp;Using <tt class="interfacename">PropertyEditorRegistrars</tt></h5></div></div><div></div></div><p>Another mechanism for registering property editors with the Spring container is to create and use
			a <tt class="interfacename">PropertyEditorRegistrar</tt>. This interface is particularly useful when you
			need to use the same set of property editors in several different situations: write a corresponding
			registrar and reuse that in each case. <tt class="literal">PropertyEditorRegistrars</tt> work in conjunction
			with an interface called <tt class="interfacename">PropertyEditorRegistry</tt>, an interface
			that is implemented by the Spring <tt class="interfacename">BeanWrapper</tt> (and
			<tt class="interfacename">DataBinder</tt>). <tt class="literal">PropertyEditorRegistrars</tt> are particularly
			convenient when used in conjunction with the <tt class="classname">CustomEditorConfigurer</tt>
			(introduced <a href="#beans-beans-conversion-customeditor-registration" title="5.4.2.1.&nbsp;Registering additional custom PropertyEditors">here</a>), which exposes a
			property called <tt class="methodname">setPropertyEditorRegistrars(..)</tt>:
			<tt class="literal">PropertyEditorRegistrars</tt> added to a <tt class="classname">CustomEditorConfigurer</tt> in this
			fashion can easily be shared with <tt class="interfacename">DataBinder</tt> and Spring MVC
			<tt class="interfacename">Controllers</tt>. Furthermore, it avoids the need for synchronization on custom
			editors: a <tt class="interfacename">PropertyEditorRegistrar</tt> is expected to create fresh
			<tt class="interfacename">PropertyEditor</tt> instances for each bean creation attempt.</p><p>Using a <tt class="interfacename">PropertyEditorRegistrar</tt> is perhaps best illustrated with an
			example. First off, you need to create your own <tt class="interfacename">PropertyEditorRegistrar</tt>
			implementation:</p><pre class="programlisting">package com.foo.editors.spring;

public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar {

    public void registerCustomEditors(PropertyEditorRegistry registry) {

        <i class="lineannotation"><span class="lineannotation">// it is expected that new <tt class="interfacename">PropertyEditor</tt> instances are created</span></i>
        registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor());

        <i class="lineannotation"><span class="lineannotation">// you could register as many custom property editors as are required here...</span></i>
    }
}</pre><p>See also the <tt class="classname">org.springframework.beans.support.ResourceEditorRegistrar</tt> for an
			example <tt class="interfacename">PropertyEditorRegistrar</tt> implementation. Notice how in its
			implementation of the <tt class="methodname">registerCustomEditors(..)</tt> method it creates new instances
			of each property editor.</p><p>Next we configure a <tt class="classname">CustomEditorConfigurer</tt> and inject an
			instance of our <tt class="classname">CustomPropertyEditorRegistrar</tt> into it:</p><pre class="programlisting">&lt;bean class="org.springframework.beans.factory.config.CustomEditorConfigurer"&gt;
    &lt;property name="propertyEditorRegistrars"&gt;
        &lt;list&gt;
            &lt;ref bean="customPropertyEditorRegistrar"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="customPropertyEditorRegistrar" class="com.foo.editors.spring.CustomPropertyEditorRegistrar"/&gt;</pre><p>Finally, and in a bit of a departure from the focus of this chapter, for those of you using
			<a href="#mvc" title="Chapter&nbsp;13.&nbsp;Web MVC framework">Spring's MVC web framework</a>, using <tt class="interfacename">PropertyEditorRegistrars</tt>
			in conjunction with data-binding <tt class="interfacename">Controllers</tt> (such as
			<tt class="classname">SimpleFormController</tt>) can be very convenient. Find below an example of using a
			<tt class="interfacename">PropertyEditorRegistrar</tt> in the implementation of an <tt class="methodname">initBinder(..)</tt>
			method:</p><pre class="programlisting">public final class RegisterUserController extends SimpleFormController {

    private final PropertyEditorRegistrar customPropertyEditorRegistrar;

    public RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) {
        this.customPropertyEditorRegistrar = propertyEditorRegistrar;
    }

    protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws Exception {
        <span class="bold"><b>this.customPropertyEditorRegistrar.registerCustomEditors(binder);</b></span>
    }

    <i class="lineannotation"><span class="lineannotation">// other methods to do with registering a <tt class="classname">User</tt></span></i>
}</pre><p>This style of <tt class="interfacename">PropertyEditor</tt> registration can lead to concise code (the
			implementation of <tt class="methodname">initBinder(..)</tt> is just one line long!), and allows common
			<tt class="interfacename">PropertyEditor</tt> registration code to be encapsulated in a class and then
			shared amongst as many <tt class="interfacename">Controllers</tt> as needed.</p></div></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="aop"></a>Chapter&nbsp;6.&nbsp;Aspect Oriented Programming with Spring</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-introduction"></a>6.1.&nbsp;Introduction</h2></div></div><div></div></div><p><span class="emphasis"><em>Aspect-Oriented Programming</em></span> (AOP) complements
    Object-Oriented Programming (OOP) by providing another way of thinking
    about program structure. The key unit of modularity in OOP is the class,
    whereas in AOP the unit of modularity is the <span class="emphasis"><em>aspect</em></span>.
    Aspects enable the modularization of concerns such as transaction
    management that cut across multiple types and objects. (Such concerns are
    often termed <span class="emphasis"><em>crosscutting</em></span> concerns in AOP
    literature.)</p><p>One of the key components of Spring is the <span class="emphasis"><em>AOP
    framework</em></span>. While the Spring IoC container does not depend on
    AOP, meaning you do not need to use AOP if you don't want to, AOP
    complements Spring IoC to provide a very capable middleware
    solution.</p><div class="sidebar"><p class="title"><b>Spring 2.0 AOP</b></p><p>Spring 2.0 introduces a simpler and more powerful way of writing
      custom aspects using either a <a href="#aop-schema" title="6.3.&nbsp;Schema-based AOP support">schema-based
      approach</a> or the <a href="#aop-ataspectj" title="6.2.&nbsp;@AspectJ support">@AspectJ annotation
      style</a>. Both of these styles offer fully typed advice and use of
      the AspectJ pointcut language, while still using Spring AOP for
      weaving.</p><p>The Spring 2.0 schema- and @AspectJ-based AOP support is discussed
      in this chapter. Spring 2.0 AOP remains fully backwards compatible with
      Spring 1.2 AOP, and the lower-level AOP support offered by the Spring
      1.2 APIs is discussed in <a href="#aop-api" title="Chapter&nbsp;7.&nbsp;Spring AOP APIs">the following
      chapter</a>.</p></div><p>AOP is used in the Spring Framework to...</p><div class="itemizedlist"><ul type="disc"><li><p>... provide declarative enterprise services, especially as a
        replacement for EJB declarative services. The most important such
        service is <a href="#transaction-declarative" title="9.5.&nbsp;Declarative transaction management"><span class="emphasis"><em>declarative transaction
        management</em></span></a>.</p></li><li><p>... allow users to implement custom aspects, complementing their
        use of OOP with AOP.</p></li></ul></div><i><span class="remark"><p>If you are interested only in generic declarative services
    or other pre-packaged declarative middleware services such as pooling, you
    do not need to work directly with Spring AOP, and can skip most of this
    chapter. </p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-defn"></a>6.1.1.&nbsp;AOP concepts</h3></div></div><div></div></div><p>Let us begin by defining some central AOP concepts and
      terminology. These terms are not Spring-specific... unfortunately, AOP
      terminology is not particularly intuitive; however, it would be even
      more confusing if Spring used its own terminology.</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Aspect</em></span>: a modularization of a concern
          that cuts across multiple classes. Transaction management is a good
          example of a crosscutting concern in J2EE applications. In Spring
          AOP, aspects are implemented using regular classes (the <a href="#aop-schema" title="6.3.&nbsp;Schema-based AOP support">schema-based approach</a>) or regular
          classes annotated with the <tt class="interfacename">@Aspect</tt>
          annotation (the <a href="#aop-ataspectj" title="6.2.&nbsp;@AspectJ support"><tt class="interfacename">@AspectJ</tt>
          style</a>).</p></li><li><p><span class="emphasis"><em>Join point</em></span>: a point during the execution
          of a program, such as the execution of a method or the handling of
          an exception. In Spring AOP, a join point
          <span class="emphasis"><em>always</em></span> represents a method execution.</p></li><li><p><span class="emphasis"><em>Advice</em></span>: action taken by an aspect at a
          particular join point. Different types of advice include "around,"
          "before" and "after" advice. (Advice types are discussed below.)
          Many AOP frameworks, including Spring, model an advice as an
          <span class="emphasis"><em>interceptor</em></span>, maintaining a chain of
          interceptors <span class="emphasis"><em>around</em></span> the join point.</p></li><li><p><span class="emphasis"><em>Pointcut</em></span>: a predicate that matches join
          points. Advice is associated with a pointcut expression and runs at
          any join point matched by the pointcut (for example, the execution
          of a method with a certain name). The concept of join points as
          matched by pointcut expressions is central to AOP, and Spring uses
          the AspectJ pointcut expression language by default.</p></li><li><p><span class="emphasis"><em>Introduction</em></span>: declaring additional
          methods or fields on behalf of a type. Spring AOP allows you to
          introduce new interfaces (and a corresponding implementation) to any
          advised object. For example, you could use an introduction to make a
          bean implement an <tt class="interfacename">IsModified</tt>
          interface, to simplify caching. (An introduction is known as an
          inter-type declaration in the AspectJ community.)</p></li><li><p><span class="emphasis"><em>Target object</em></span>: object being advised by
          one or more aspects. Also referred to as the
          <span class="emphasis"><em>advised</em></span> object. Since Spring AOP is implemented
          using runtime proxies, this object will always be a
          <span class="emphasis"><em>proxied</em></span> object.</p></li><li><p><span class="emphasis"><em>AOP proxy</em></span>: an object created by the AOP
          framework in order to implement the aspect contracts (advise method
          executions and so on). In the Spring Framework, an AOP proxy will be
          a JDK dynamic proxy or a CGLIB proxy.</p></li><li><p><span class="emphasis"><em>Weaving</em></span>: linking aspects with other
          application types or objects to create an advised object. This can
          be done at compile time (using the AspectJ compiler, for example),
          load time, or at runtime. Spring AOP, like other pure Java AOP
          frameworks, performs weaving at runtime.</p></li></ul></div><p>Types of advice:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Before advice</em></span>: Advice that executes
          before a join point, but which does not have the ability to prevent
          execution flow proceeding to the join point (unless it throws an
          exception).</p></li><li><p><span class="emphasis"><em>After returning advice</em></span>: Advice to be
          executed after a join point completes normally: for example, if a
          method returns without throwing an exception.</p></li><li><p><span class="emphasis"><em>After throwing advice</em></span>: Advice to be
          executed if a method exits by throwing an exception.</p></li><li><p><span class="emphasis"><em>After (finally) advice</em></span>: Advice to be
          executed regardless of the means by which a join point exits (normal
          or exceptional return).</p></li><li><p><span class="emphasis"><em>Around advice</em></span>: Advice that surrounds a
          join point such as a method invocation. This is the most powerful
          kind of advice. Around advice can perform custom behavior before and
          after the method invocation. It is also responsible for choosing
          whether to proceed to the join point or to shortcut the advised
          method execution by returning its own return value or throwing an
          exception.</p></li></ul></div><p>Around advice is the most general kind of advice. Since Spring
      AOP, like AspectJ, provides a full range of advice types, we recommend
      that you use the least powerful advice type that can implement the
      required behavior. For example, if you need only to update a cache with
      the return value of a method, you are better off implementing an after
      returning advice than an around advice, although an around advice can
      accomplish the same thing. Using the most specific advice type provides
      a simpler programming model with less potential for errors. For example,
      you do not need to invoke the <tt class="methodname">proceed()</tt> method
      on the <tt class="interfacename">JoinPoint</tt> used for around advice,
      and hence cannot fail to invoke it.</p><p>In Spring 2.0, all advice parameters are statically typed, so that
      you work with advice parameters of the appropriate type (the type of the
      return value from a method execution for example) rather than
      <tt class="classname">Object</tt> arrays.</p><p>The concept of join points, matched by pointcuts, is the key to
      AOP which distinguishes it from older technologies offering only
      interception. Pointcuts enable advice to be targeted independently of
      the Object-Oriented hierarchy. For example, an around advice providing
      declarative transaction management can be applied to a set of methods
      spanning multiple objects (such as all business operations in the
      service layer).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-spring-defn"></a>6.1.2.&nbsp;Spring AOP capabilities and goals</h3></div></div><div></div></div><p>Spring AOP is implemented in pure Java. There is no need for a
      special compilation process. Spring AOP does not need to control the
      class loader hierarchy, and is thus suitable for use in a J2EE web
      container or application server.</p><p>Spring AOP currently supports only method execution join points
      (advising the execution of methods on Spring beans). Field interception
      is not implemented, although support for field interception could be
      added without breaking the core Spring AOP APIs. If you need to advise
      field access and update join points, consider a language such as
      AspectJ.</p><p>Spring AOP's approach to AOP differs from that of most other AOP
      frameworks. The aim is not to provide the most complete AOP
      implementation (although Spring AOP is quite capable); it is rather to
      provide a close integration between AOP implementation and Spring IoC to
      help solve common problems in enterprise applications.</p><p>Thus, for example, the Spring Framework's AOP functionality is
      normally used in conjunction with the Spring IoC container. Aspects are
      configured using normal bean definition syntax (although this allows
      powerful "autoproxying" capabilities): this is a crucial difference from
      other AOP implementations. There are some things you cannot do easily or
      efficiently with Spring AOP, such as advise very fine-grained objects
      (such as domain objects typically): AspectJ is the best choice in such
      cases. However, our experience is that Spring AOP provides an excellent
      solution to most problems in J2EE applications that are amenable to
      AOP.</p><p>Spring AOP will never strive to compete with AspectJ to provide a
      comprehensive AOP solution. We believe that both proxy-based frameworks
      like Spring AOP and full-blown frameworks such as AspectJ are valuable,
      and that they are complementary, rather than in competition. Spring 2.0
      seamlessly integrates Spring AOP and IoC with AspectJ, to enable all
      uses of AOP to be catered for within a consistent Spring-based
      application architecture. This integration does not affect the Spring
      AOP API or the AOP Alliance API: Spring AOP remains backward-compatible.
      See <a href="#aop-api" title="Chapter&nbsp;7.&nbsp;Spring AOP APIs">the following chapter</a> for a
      discussion of the Spring AOP APIs.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>One of the central tenets of the Spring Framework is that of
        <span class="emphasis"><em>non-invasiveness</em></span>; this is the idea that you
        should not be forced to introduce framework-specific classes and
        interfaces into your business/domain model. However, in some places
        the Spring Framework does give you the option to introduce Spring
        Framework-specific dependencies into your codebase: the rationale in
        giving you such options is because in certain scenarios it might be
        just plain easier to read or code some specific piece of functionality
        in such a way. The Spring Framework (almost) always offers you the
        choice though: you have the freedom to make an informed decision as to
        which option best suits your particular use case or scenario.</p><p>One such choice that is relevant to this chapter is that of
        which AOP framework (and which AOP style) to choose. You have the
        choice of AspectJ and/or Spring AOP, and you also have the choice of
        either the @AspectJ annotation-style approach or the Spring XML
        configuration-style approach. The fact that this chapter chooses to
        introduce the @AspectJ-style approach first should not be taken as an
        indication that the Spring team favors the @AspectJ annotation-style
        approach over the Spring XML configuration-style.</p><p>See the section entitled <a href="#aop-choosing" title="6.4.&nbsp;Choosing which AOP declaration style to use">Section&nbsp;6.4, &#8220;Choosing which AOP declaration style to use&#8221;</a> for a
        fuller discussion of the whys and wherefores of each style.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introduction-proxies"></a>6.1.3.&nbsp;AOP Proxies</h3></div></div><div></div></div><p>Spring AOP defaults to using standard J2SE <span class="emphasis"><em>dynamic
      proxies</em></span> for AOP proxies. This enables any interface (or set
      of interfaces) to be proxied.</p><p>Spring AOP can also use CGLIB proxies. This is necessary to proxy
      classes, rather than interfaces. CGLIB is used by default if a business
      object does not implement an interface. As it is good practice to
      program to interfaces rather than classes, business classes normally
      will implement one or more business interfaces. It is possible to <a href="#aop-autoproxy-force-CGLIB">force the use of CGLIB</a>, in
      those (hopefully rare) cases where you need to advise a method that is
      not declared on an interface, or where you need to pass a proxied object
      to a method as a concrete type.</p><p>It is important to grasp the fact that Spring AOP is
      <span class="emphasis"><em>proxy-based</em></span>. See the section entitled <a href="#aop-understanding-aop-proxies" title="6.6.1.&nbsp;Understanding AOP proxies">Section&nbsp;6.6.1, &#8220;Understanding AOP proxies&#8221;</a> for a thorough examination of
      exactly what this implementation detail actually means.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-ataspectj"></a>6.2.&nbsp;@AspectJ support</h2></div></div><div></div></div><p>@AspectJ refers to a style of declaring aspects as regular Java
    classes annotated with Java 5 annotations. The @AspectJ style was
    introduced by the <a href="http://www.eclipse.org/aspectj" target="_top">AspectJ
    project</a> as part of the AspectJ 5 release. Spring 2.0 interprets
    the same annotations as AspectJ 5, using a library supplied by AspectJ for
    pointcut parsing and matching. The AOP runtime is still pure Spring AOP
    though, and there is no dependency on the AspectJ compiler or
    weaver.</p><i><span class="remark"><p>Using the AspectJ compiler and weaver enables use of the
    full AspectJ language, and is discussed in <a href="#aop-using-aspectj" title="6.8.&nbsp;Using AspectJ with Spring applications">Section&nbsp;6.8, &#8220;Using AspectJ with Spring applications&#8221;</a>.</p></span></i><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-aspectj-support"></a>6.2.1.&nbsp;Enabling @AspectJ Support</h3></div></div><div></div></div><p>To use @AspectJ aspects in a Spring configuration you need to
      enable Spring support for configuring Spring AOP based on @AspectJ
      aspects, and <span class="emphasis"><em>autoproxying</em></span> beans based on whether or
      not they are advised by those aspects. By autoproxying we mean that if
      Spring determines that a bean is advised by one or more aspects, it will
      automatically generate a proxy for that bean to intercept method
      invocations and ensure that advice is executed as needed.</p><p>The @AspectJ support is enabled by including the following element
      inside your spring configuration:</p><pre class="programlisting">&lt;aop:aspectj-autoproxy/&gt;</pre><p>This assumes that you are using schema support as described in
      <a href="#xsd-config" title="Appendix&nbsp;A.&nbsp;XML Schema-based configuration">Appendix&nbsp;A, <i>XML Schema-based configuration</i></a>. See <a href="#xsd-config-body-schemas-aop" title="A.2.7.&nbsp;The aop schema">Section&nbsp;A.2.7, &#8220;The aop schema&#8221;</a> for how to import the tags in
      the aop namespace.</p><p>If you are using the DTD, it is still possible to enable @AspectJ
      support by adding the following definition to your application
      context:</p><pre class="programlisting">&lt;bean class="org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator" /&gt;</pre><p>You will also need two AspectJ libraries on the classpath of your
      application: <tt class="filename">aspectjweaver.jar</tt>
      and <tt class="filename">aspectjrt.jar</tt>. These
      libraries are available in the <tt class="filename">'lib'</tt> directory of an AspectJ installation
      (version 1.5.1 or later required), or in the <tt class="filename">'lib/aspectj'</tt> directory of the
      Spring-with-dependencies distribution.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-at-aspectj"></a>6.2.2.&nbsp;Declaring an aspect</h3></div></div><div></div></div><p>With the @AspectJ support enabled, any bean defined in your
      application context with a class that is an @AspectJ aspect (has the
      <tt class="interfacename">@Aspect</tt> annotation) will be automatically
      detected by Spring and used to configure Spring AOP. The following
      example shows the minimal definition required for a not-very-useful
      aspect:</p><p>A regular bean definition in the application context, pointing to
      a bean class that has the <tt class="interfacename">@Aspect</tt>
      annotation:</p><pre class="programlisting">&lt;bean id="myAspect" class="org.xyz.NotVeryUsefulAspect"&gt;
   <i class="lineannotation"><span class="lineannotation">&lt;!-- configure properties of aspect here as normal --&gt;</span></i>
&lt;/bean&gt;
</pre><p>And the <tt class="classname">NotVeryUsefulAspect</tt> class
      definition, annotated with
      <tt class="interfacename">org.aspectj.lang.annotation.Aspect</tt>
      annotation;</p><pre class="programlisting">package org.xyz;
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class NotVeryUsefulAspect {

}</pre><p>Aspects (classes annotated with
      <tt class="interfacename">@Aspect</tt>) may have methods and fields just
      like any other class. They may also contain pointcut, advice, and
      introduction (inter-type) declarations.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Advising aspects"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Advising aspects</th></tr><tr><td colspan="2" align="left" valign="top"><p>In Spring AOP, it is <span class="emphasis"><em>not</em></span> possible to have
        aspects themselves be the target of advice from other aspects. The
        <span class="emphasis"><em>@Aspect</em></span> annotation on a class marks it as an
        aspect, and hence excludes it from auto-proxying.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-pointcuts"></a>6.2.3.&nbsp;Declaring a pointcut</h3></div></div><div></div></div><p>Recall that pointcuts determine join points of interest, and thus
      enable us to control when advice executes. <span class="emphasis"><em>Spring AOP only
      supports method execution join points for Spring beans</em></span>, so
      you can think of a pointcut as matching the execution of methods on
      Spring beans. A pointcut declaration has two parts: a signature
      comprising a name and any parameters, and a pointcut expression that
      determines <span class="emphasis"><em>exactly</em></span> which method executions we are
      interested in. In the @AspectJ annotation-style of AOP, a pointcut
      signature is provided by a regular method definition, and the pointcut
      expression is indicated using the
      <tt class="interfacename">@Pointcut</tt> annotation (the method serving
      as the pointcut signature <span class="emphasis"><em>must</em></span> have a
      <tt class="literal">void</tt> return type).</p><p>An example will help make this distinction between a pointcut
      signature and a pointcut expression clear. The following example defines
      a pointcut named <tt class="literal">'anyOldTransfer'</tt> that will match the
      execution of any method named <tt class="literal">'transfer'</tt>:</p><pre class="programlisting">@Pointcut("execution(* transfer(..))")<i class="lineannotation"><span class="lineannotation">// the pointcut expression</span></i>
private void anyOldTransfer() {}<i class="lineannotation"><span class="lineannotation">// the pointcut signature</span></i></pre><p>The pointcut expression that forms the value of the
      <tt class="interfacename">@Pointcut</tt> annotation is a regular AspectJ
      5 pointcut expression. For a full discussion of AspectJ's pointcut
      language, see the <a href="http://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_top">AspectJ
      Programming Guide</a> (and for Java 5 based extensions, the <a href="http://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html" target="_top">AspectJ
      5 Developers Notebook</a>) or one of the books on AspectJ such as
      &#8220;<span class="quote">Eclipse AspectJ</span>&#8221; by Colyer et. al. or &#8220;<span class="quote">AspectJ in
      Action</span>&#8221; by Ramnivas Laddad.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-pointcuts-designators"></a>6.2.3.1.&nbsp;Supported Pointcut Designators</h4></div></div><div></div></div><p>Spring AOP supports the following AspectJ pointcut designators
        (PCD) for use in pointcut expressions:</p><div class="sidebar"><p class="title"><b>Other pointcut types</b></p><p>The full AspectJ pointcut language supports additional
          pointcut designators that are not supported in Spring. These are:
          <tt class="literal">call, get, set, preinitialization, staticinitialization,
          initialization, handler, adviceexecution, withincode, cflow,
          cflowbelow, if, @this</tt>, and <tt class="literal">@withincode</tt>.
          Use of these pointcut designators in pointcut expressions
          interpreted by Spring AOP will result in an
          <tt class="classname">IllegalArgumentException</tt> being thrown.</p><p>The set of pointcut designators supported by Spring AOP may be
          extended in future releases both to support more of the AspectJ
          pointcut designators.</p></div><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>execution</em></span> - for matching method
            execution join points, this is the primary pointcut designator you
            will use when working with Spring AOP</p></li><li><p><span class="emphasis"><em>within</em></span> - limits matching to join points
            within certain types (simply the execution of a method declared
            within a matching type when using Spring AOP)</p></li><li><p><span class="emphasis"><em>this</em></span> - limits matching to join points
            (the execution of methods when using Spring AOP) where the bean
            reference (Spring AOP proxy) is an instance of the given
            type</p></li><li><p><span class="emphasis"><em>target</em></span> - limits matching to join points
            (the execution of methods when using Spring AOP) where the target
            object (application object being proxied) is an instance of the
            given type</p></li><li><p><span class="emphasis"><em>args</em></span> - limits matching to join points
            (the execution of methods when using Spring AOP) where the
            arguments are instances of the given types</p></li><li><p><span class="emphasis"><em><tt class="interfacename">@target</tt></em></span>
            - limits matching to join points (the execution of methods when
            using Spring AOP) where the class of the executing object has an
            annotation of the given type</p></li><li><p><span class="emphasis"><em><tt class="interfacename">@args</tt></em></span> -
            limits matching to join points (the execution of methods when
            using Spring AOP) where the runtime type of the actual arguments
            passed have annotations of the given type(s)</p></li><li><p><span class="emphasis"><em><tt class="interfacename">@within</tt></em></span>
            - limits matching to join points within types that have the given
            annotation (the execution of methods declared in types with the
            given annotation when using Spring AOP)</p></li><li><p><span class="emphasis"><em>@annotation</em></span> - limits matching to join
            points where the subject of the join point (method being executed
            in Spring AOP) has the given annotation</p></li></ul></div><p>Because Spring AOP limits matching to only method execution
        join points, the discussion of the pointcut designators above gives a
        narrower definition than you will find in the AspectJ programming
        guide. In addition, AspectJ itself has type-based semantics and at an
        execution join point both '<tt class="literal">this</tt>' and
        '<tt class="literal">target</tt>' refer to the same object - the object
        executing the method. Spring AOP is a proxy-based system and
        differentiates between the proxy object itself (bound to
        '<tt class="literal">this</tt>') and the target object behind the proxy
        (bound to '<tt class="literal">target</tt>').</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Due to the proxy-based nature of Spring's AOP framework,
          protected methods are by definition <span class="emphasis"><em>not</em></span>
          intercepted, neither for JDK proxies (where this isn't applicable)
          nor for CGLIB proxies (where this is technically possible but not
          recommendable for AOP purposes). As a consequence, any given pointcut
          will be matched against <span class="emphasis"><em>public methods only</em></span>!</p><p>If your interception needs include protected/private methods
          or even constructors, consider the use of Spring-driven
          <a href="#aop-aj-ltw" title="6.8.4.&nbsp;Load-time weaving with AspectJ in the Spring Framework">native AspectJ weaving</a> instead
          of Spring's proxy-based AOP framework. This constitutes a different
          mode of AOP usage with different characteristics, so be sure to make
          yourself familiar with weaving first before making a decision.</p></td></tr></table></div><p>Spring AOP also supports an additional PCD named
        '<tt class="literal">bean</tt>'. This PCD allows you to limit the matching
        of join points to a particular named Spring bean, or to a set of named
        Spring beans (when using wildcards). The '<tt class="literal">bean</tt>' PCD
        has the following form:</p><pre class="programlisting">bean(idOrNameOfBean)</pre><p>The '<tt class="literal">idOrNameOfBean</tt>' token can be the name of
        any Spring bean: limited wildcard support using the
        '<tt class="literal">*</tt>' character is provided, so if you establish
        some naming conventions for your Spring beans you can quite easily
        write a '<tt class="literal">bean</tt>' PCD expression to pick them out. As
        is the case with other pointcut designators, the
        '<tt class="literal">bean</tt>' PCD can be &amp;&amp;'ed, ||'ed, and !
        (negated) too.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Please note that the '<tt class="literal">bean</tt>' PCD is
          <span class="emphasis"><em>only</em></span> supported in Spring AOP - and
          <span class="emphasis"><em>not</em></span> in native AspectJ weaving. It is a
          Spring-specific extension to the standard PCDs that AspectJ
          defines.</p><p>The '<tt class="literal">bean</tt>' PCD operates at the
          <span class="emphasis"><em>instance</em></span> level (building on the Spring
          bean name concept) rather than at the type level only
          (which is what weaving-based AOP is limited to).
          Instance-based pointcut designators are a special capability
          of Spring's proxy-based AOP framework and its close integration
          with the Spring bean factory, where it is natural and
          straightforward to identify specific beans by name.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-pointcuts-combining"></a>6.2.3.2.&nbsp;Combining pointcut expressions</h4></div></div><div></div></div><p>Pointcut expressions can be combined using '&amp;&amp;', '||'
        and '!'. It is also possible to refer to pointcut expressions by name.
        The following example shows three pointcut expressions:
        <tt class="literal">anyPublicOperation</tt> (which matches if a method
        execution join point represents the execution of any public method);
        <tt class="literal">inTrading</tt> (which matches if a method execution is
        in the trading module), and <tt class="literal">tradingOperation</tt> (which
        matches if a method execution represents any public method in the
        trading module).</p><pre class="programlisting">    @Pointcut("execution(public * *(..))")
    private void anyPublicOperation() {}
    
    @Pointcut("within(com.xyz.someapp.trading..*)")
    private void inTrading() {}
    
    @Pointcut("anyPublicOperation() &amp;&amp; inTrading()")
    private void tradingOperation() {}</pre><p>It is a best practice to build more complex pointcut expressions
        out of smaller named components as shown above. When referring to
        pointcuts by name, normal Java visibility rules apply (you can see
        private pointcuts in the same type, protected pointcuts in the
        hierarchy, public pointcuts anywhere and so on). Visibility does not
        affect pointcut <span class="emphasis"><em>matching</em></span>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-common-pointcuts"></a>6.2.3.3.&nbsp;Sharing common pointcut definitions</h4></div></div><div></div></div><p>When working with enterprise applications, you often want to
        refer to modules of the application and particular sets of operations
        from within several aspects. We recommend defining a
        "SystemArchitecture" aspect that captures common pointcut expressions
        for this purpose. A typical such aspect would look as follows:</p><pre class="programlisting">package com.xyz.someapp;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;

@Aspect
public class SystemArchitecture {

  <i class="lineannotation"><span class="lineannotation">/**
   * A join point is in the web layer if the method is defined
   * in a type in the com.xyz.someapp.web package or any sub-package
   * under that.
   */</span></i>
  @Pointcut("within(com.xyz.someapp.web..*)")
  public void inWebLayer() {}

  <i class="lineannotation"><span class="lineannotation">/**
   * A join point is in the service layer if the method is defined
   * in a type in the <tt class="literal">com.xyz.someapp.service</tt> package or any sub-package
   * under that.
   */</span></i>
  @Pointcut("within(com.xyz.someapp.service..*)")
  public void inServiceLayer() {}

  <i class="lineannotation"><span class="lineannotation">/**
   * A join point is in the data access layer if the method is defined
   * in a type in the <tt class="literal">com.xyz.someapp.dao</tt> package or any sub-package
   * under that.
   */</span></i>
  @Pointcut("within(com.xyz.someapp.dao..*)")
  public void inDataAccessLayer() {}

  <i class="lineannotation"><span class="lineannotation">/**
   * A business service is the execution of any method defined on a service
   * interface. This definition assumes that interfaces are placed in the
   * "service" package, and that implementation types are in sub-packages.
   * 
   * If you group service interfaces by functional area (for example, 
   * in packages <tt class="literal">com.xyz.someapp.abc.service</tt> and <tt class="literal">com.xyz.def.service</tt>) then
   * the pointcut expression "<tt class="literal">execution(* com.xyz.someapp..service.*.*(..))</tt>"
   * could be used instead.
   *
   * Alternatively, you can write the expression using the '<tt class="literal">bean</tt>'
   * PCD, like so "<tt class="literal">bean(*Service)</tt>". (This assumes that you have
   * named your Spring service beans in a consistent fashion.)
   */</span></i>
  @Pointcut("execution(* com.xyz.someapp.service.*.*(..))")
  public void businessService() {}
  
  <i class="lineannotation"><span class="lineannotation">/**
   * A data access operation is the execution of any method defined on a 
   * dao interface. This definition assumes that interfaces are placed in the
   * "<tt class="literal">dao</tt>" package, and that implementation types are in sub-packages.
   */</span></i>
  @Pointcut("execution(* com.xyz.someapp.dao.*.*(..))")
  public void dataAccessOperation() {}

}</pre><p>The pointcuts defined in such an aspect can be referred to
        anywhere that you need a pointcut expression. For example, to make the
        service layer transactional, you could write:</p><pre class="programlisting">&lt;aop:config&gt;
  &lt;aop:advisor 
      pointcut="com.xyz.someapp.SystemArchitecture.businessService()"
      advice-ref="tx-advice"/&gt;
&lt;/aop:config&gt;

&lt;tx:advice id="tx-advice"&gt;
  &lt;tx:attributes&gt;
    &lt;tx:method name="*" propagation="REQUIRED"/&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</pre><p>The <tt class="literal">&lt;aop:config&gt;</tt> and
        <tt class="literal">&lt;aop:advisor&gt;</tt> elements are discussed in <a href="#aop-schema" title="6.3.&nbsp;Schema-based AOP support">Section&nbsp;6.3, &#8220;Schema-based AOP support&#8221;</a>. The transaction elements are discussed in
        <a href="#transaction" title="Chapter&nbsp;9.&nbsp;Transaction management">Chapter&nbsp;9, <i>Transaction management</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-pointcuts-examples"></a>6.2.3.4.&nbsp;Examples</h4></div></div><div></div></div><p>Spring AOP users are likely to use the
        <tt class="literal">execution</tt> pointcut designator the most often. The
        format of an execution expression is:</p><pre class="programlisting">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern)
          throws-pattern?)</pre><p>All parts except the returning type pattern (ret-type-pattern in
        the snippet above), name pattern, and parameters pattern are optional.
        The returning type pattern determines what the return type of the
        method must be in order for a join point to be matched. Most
        frequently you will use <tt class="literal">*</tt> as the returning type
        pattern, which matches any return type. A fully-qualified type name
        will match only when the method returns the given type. The name
        pattern matches the method name. You can use the <tt class="literal">*</tt>
        wildcard as all or part of a name pattern. The parameters pattern is
        slightly more complex: <tt class="literal">()</tt> matches a method that
        takes no parameters, whereas <tt class="literal">(..)</tt> matches any
        number of parameters (zero or more). The pattern
        <tt class="literal">(*)</tt> matches a method taking one parameter of any
        type, <tt class="literal">(*,String)</tt> matches a method taking two
        parameters, the first can be of any type, the second must be a String.
        Consult the <a href="http://www.eclipse.org/aspectj/doc/released/progguide/semantics-pointcuts.html" target="_top">
        Language Semantics</a> section of the AspectJ Programming Guide
        for more information.</p><p>Some examples of common pointcut expressions are given
        below.</p><div class="itemizedlist"><ul type="disc"><li><p>the execution of any public method:</p><pre class="programlisting">execution(public * *(..))</pre></li><li><p>the execution of any method with a name beginning with
            "set":</p><pre class="programlisting">execution(* set*(..))</pre></li><li><p>the execution of any method defined by the
            <tt class="interfacename">AccountService</tt> interface:</p><pre class="programlisting">execution(* com.xyz.service.AccountService.*(..))</pre></li><li><p>the execution of any method defined in the service
            package:</p><pre class="programlisting">execution(* com.xyz.service.*.*(..))</pre></li><li><p>the execution of any method defined in the service package
            or a sub-package:</p><pre class="programlisting">execution(* com.xyz.service..*.*(..))</pre></li><li><p>any join point (method execution only in Spring AOP) within
            the service package:</p><pre class="programlisting">within(com.xyz.service.*)</pre></li><li><p>any join point (method execution only in Spring AOP) within
            the service package or a sub-package:</p><pre class="programlisting">within(com.xyz.service..*)</pre></li><li><p>any join point (method execution only in Spring AOP) where
            the proxy implements the
            <tt class="interfacename">AccountService</tt> interface:</p><pre class="programlisting">this(com.xyz.service.AccountService)</pre><i><span class="remark"><p>'this' is more commonly used in a binding form :-
            see the following section on advice for how to make the proxy
            object available in the advice body.</p></span></i></li><li><p>any join point (method execution only in Spring AOP) where
            the target object implements the
            <tt class="interfacename">AccountService</tt> interface:</p><pre class="programlisting">target(com.xyz.service.AccountService)</pre><i><span class="remark"><p>'target' is more commonly used in a binding form :-
            see the following section on advice for how to make the target
            object available in the advice body.</p></span></i></li><li><p>any join point (method execution only in Spring AOP) which
            takes a single parameter, and where the argument passed at runtime
            is <tt class="interfacename">Serializable</tt>:</p><pre class="programlisting">args(java.io.Serializable)</pre><i><span class="remark">'args' is more commonly used in a binding form :- see the
            following section on advice for how to make the method arguments
            available in the advice body.</span></i><p>Note that the pointcut given in this example is different to
            <tt class="literal">execution(* *(java.io.Serializable))</tt>: the args
            version matches if the argument passed at runtime is Serializable,
            the execution version matches if the method signature declares a
            single parameter of type
            <tt class="interfacename">Serializable</tt>.</p></li><li><p>any join point (method execution only in Spring AOP) where
            the target object has an
            <tt class="interfacename">@Transactional</tt> annotation:</p><pre class="programlisting">@target(org.springframework.transaction.annotation.Transactional)</pre><i><span class="remark"><p>'@target' can also be used in a binding form :- see
            the following section on advice for how to make the annotation
            object available in the advice body.</p></span></i></li><li><p>any join point (method execution only in Spring AOP) where
            the declared type of the target object has an
            <tt class="interfacename">@Transactional</tt> annotation:</p><pre class="programlisting">@within(org.springframework.transaction.annotation.Transactional)</pre><i><span class="remark"><p>'@within' can also be used in a binding form :- see
            the following section on advice for how to make the annotation
            object available in the advice body.</p></span></i></li><li><p>any join point (method execution only in Spring AOP) where
            the executing method has an
            <tt class="interfacename">@Transactional</tt> annotation:</p><pre class="programlisting">@annotation(org.springframework.transaction.annotation.Transactional)</pre><i><span class="remark"><p>'@annotation' can also be used in a binding form :-
            see the following section on advice for how to make the annotation
            object available in the advice body.</p></span></i></li><li><p>any join point (method execution only in Spring AOP) which
            takes a single parameter, and where the runtime type of the
            argument passed has the <tt class="interfacename">@Classified</tt>
            annotation:</p><pre class="programlisting">@args(com.xyz.security.Classified)</pre><i><span class="remark"><p>'@args' can also be used in a binding form :- see
            the following section on advice for how to make the annotation
            object(s) available in the advice body.</p></span></i></li><li><p>any join point (method execution only in Spring AOP) on a
            Spring bean named '<tt class="literal">tradeService</tt>':</p><pre class="programlisting">bean(tradeService)</pre></li><li><p>any join point (method execution only in Spring AOP) on
            Spring beans having names that match the wildcard expression
            '<tt class="literal">*Service</tt>':</p><pre class="programlisting">bean(*Service)</pre></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-advice"></a>6.2.4.&nbsp;Declaring advice</h3></div></div><div></div></div><p>Advice is associated with a pointcut expression, and runs before,
      after, or around method executions matched by the pointcut. The pointcut
      expression may be either a simple reference to a named pointcut, or a
      pointcut expression declared in place.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-advice-before"></a>6.2.4.1.&nbsp;Before advice</h4></div></div><div></div></div><p>Before advice is declared in an aspect using the
        <tt class="interfacename">@Before</tt> annotation:</p><pre class="programlisting">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample {

  @Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
  public void doAccessCheck() {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
  }

}</pre><p>If using an in-place pointcut expression we could rewrite the
        above example as:</p><pre class="programlisting">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;

@Aspect
public class BeforeExample {

  @Before("execution(* com.xyz.myapp.dao.*.*(..))")
  public void doAccessCheck() {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
  }

}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-advice-after-returning"></a>6.2.4.2.&nbsp;After returning advice</h4></div></div><div></div></div><p>After returning advice runs when a matched method execution
        returns normally. It is declared using the
        <tt class="interfacename">@AfterReturning</tt> annotation:</p><pre class="programlisting">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterReturning;

@Aspect
public class AfterReturningExample {

  @AfterReturning("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
  public void doAccessCheck() {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
  }

}</pre><i><span class="remark">Note: it is of course possible to have multiple advice
        declarations, and other members as well, all inside the same aspect.
        We're just showing a single advice declaration in these examples to
        focus on the issue under discussion at the time.</span></i><p>Sometimes you need access in the advice body to the actual value
        that was returned. You can use the form of
        <tt class="interfacename">@AfterReturning</tt> that binds the return
        value for this:</p><pre class="programlisting">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterReturning;

@Aspect
public class AfterReturningExample {

  @AfterReturning(
    pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
    returning="retVal")
  public void doAccessCheck(Object retVal) {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
  }
  
}</pre><p>The name used in the <tt class="literal">returning</tt> attribute must
        correspond to the name of a parameter in the advice method. When a
        method execution returns, the return value will be passed to the
        advice method as the corresponding argument value. A
        <tt class="literal">returning</tt> clause also restricts matching to only
        those method executions that return a value of the specified type
        (<tt class="classname">Object</tt> in this case, which will match any
        return value).</p><p>Please note that it is <span class="emphasis"><em>not</em></span> possible to
        return a totally different reference when using after-returning
        advice.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-advice-after-throwing"></a>6.2.4.3.&nbsp;After throwing advice</h4></div></div><div></div></div><p>After throwing advice runs when a matched method execution exits
        by throwing an exception. It is declared using the
        <tt class="interfacename">@AfterThrowing</tt> annotation:</p><pre class="programlisting">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;

@Aspect
public class AfterThrowingExample {

  @AfterThrowing("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
  public void doRecoveryActions() {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
  }

}</pre><p>Often you want the advice to run only when exceptions of a given
        type are thrown, and you also often need access to the thrown
        exception in the advice body. Use the <tt class="literal">throwing</tt>
        attribute to both restrict matching (if desired, use
        <tt class="interfacename">Throwable</tt> as the exception type
        otherwise) and bind the thrown exception to an advice
        parameter.</p><pre class="programlisting">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.AfterThrowing;

@Aspect
public class AfterThrowingExample {

  @AfterThrowing(
    pointcut="com.xyz.myapp.SystemArchitecture.dataAccessOperation()",
    throwing="ex")
  public void doRecoveryActions(DataAccessException ex) {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
  }

}</pre><p>The name used in the <tt class="literal">throwing</tt> attribute must
        correspond to the name of a parameter in the advice method. When a
        method execution exits by throwing an exception, the exception will be
        passed to the advice method as the corresponding argument value. A
        <tt class="literal">throwing</tt> clause also restricts matching to only
        those method executions that throw an exception of the specified type
        (<tt class="classname">DataAccessException</tt> in this case).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-advice-after-finally"></a>6.2.4.4.&nbsp;After (finally) advice</h4></div></div><div></div></div><p>After (finally) advice runs however a matched method execution
        exits. It is declared using the <tt class="interfacename">@After</tt>
        annotation. After advice must be prepared to handle both normal and
        exception return conditions. It is typically used for releasing
        resources, etc.</p><pre class="programlisting">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.After;

@Aspect
public class AfterFinallyExample {

  @After("com.xyz.myapp.SystemArchitecture.dataAccessOperation()")
  public void doReleaseLock() {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
  }

}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-ataspectj-around-advice"></a>6.2.4.5.&nbsp;Around advice</h4></div></div><div></div></div><p>The final kind of advice is around advice. Around advice runs
        "around" a matched method execution. It has the opportunity to do work
        both before and after the method executes, and to determine when, how,
        and even if, the method actually gets to execute at all. Around advice
        is often used if you need to share state before and after a method
        execution in a thread-safe manner (starting and stopping a timer for
        example). Always use the least powerful form of advice that meets your
        requirements (i.e. don't use around advice if simple before advice
        would do).</p><p>Around advice is declared using the
        <tt class="interfacename">@Around</tt> annotation. The first parameter
        of the advice method must be of type
        <tt class="interfacename">ProceedingJoinPoint</tt>. Within the body of
        the advice, calling <tt class="literal">proceed()</tt> on the
        <tt class="interfacename">ProceedingJoinPoint</tt> causes the
        underlying method to execute. The <tt class="literal">proceed</tt> method
        may also be called passing in an <tt class="classname">Object[]</tt> - the
        values in the array will be used as the arguments to the method
        execution when it proceeds.</p><i><span class="remark">The behavior of proceed when called with an
        <tt class="classname">Object[]</tt> is a little different than the
        behavior of proceed for around advice compiled by the AspectJ
        compiler. For around advice written using the traditional AspectJ
        language, the number of arguments passed to proceed must match the
        number of arguments passed to the around advice (not the number of
        arguments taken by the underlying join point), and the value passed to
        proceed in a given argument position supplants the original value at
        the join point for the entity the value was bound to (Don't worry if
        this doesn't make sense right now!). The approach taken by Spring is
        simpler and a better match to its proxy-based, execution only
        semantics. You only need to be aware of this difference if you are
        compiling @AspectJ aspects written for Spring and using proceed with
        arguments with the AspectJ compiler and weaver. There is a way to
        write such aspects that is 100% compatible across both Spring AOP and
        AspectJ, and this is discussed in the following section on advice
        parameters.</span></i><pre class="programlisting">import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.ProceedingJoinPoint;

@Aspect
public class AroundExample {

  @Around("com.xyz.myapp.SystemArchitecture.businessService()")
  public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
    // start stopwatch
    Object retVal = pjp.proceed();
    // stop stopwatch
    return retVal;
  }

}</pre><p>The value returned by the around advice will be the return value
        seen by the caller of the method. A simple caching aspect for example
        could return a value from a cache if it has one, and invoke proceed()
        if it does not. Note that proceed may be invoked once, many times, or
        not at all within the body of the around advice, all of these are
        quite legal.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-ataspectj-advice-params"></a>6.2.4.6.&nbsp;Advice parameters</h4></div></div><div></div></div><p>Spring 2.0 offers fully typed advice - meaning that you declare
        the parameters you need in the advice signature (as we saw for the
        returning and throwing examples above) rather than work with
        <tt class="classname">Object[]</tt> arrays all the time. We'll see how to
        make argument and other contextual values available to the advice body
        in a moment. First let's take a look at how to write generic advice
        that can find out about the method the advice is currently
        advising.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="aop-ataspectj-advice-params-the-joinpoint"></a>6.2.4.6.1.&nbsp;Access to the current
          <tt class="interfacename">JoinPoint</tt></h5></div></div><div></div></div><p>Any advice method may declare as its first parameter, a
          parameter of type
          <tt class="interfacename">org.aspectj.lang.JoinPoint</tt> (please
          note that around advice is <span class="emphasis"><em>required</em></span> to declare
          a first parameter of type
          <tt class="interfacename">ProceedingJoinPoint</tt>, which is a
          subclass of <tt class="interfacename">JoinPoint</tt>. The
          <tt class="interfacename">JoinPoint</tt> interface provides a number
          of useful methods such as <tt class="literal">getArgs()</tt> (returns the
          method arguments), <tt class="methodname">getThis()</tt> (returns the
          proxy object), <tt class="methodname">getTarget()</tt> (returns the
          target object), <tt class="methodname">getSignature()</tt> (returns a
          description of the method that is being advised) and
          <tt class="methodname">toString()</tt> (prints a useful description of
          the method being advised). Please do consult the Javadocs for full
          details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="aop-ataspectj-advice-params-passing"></a>6.2.4.6.2.&nbsp;Passing parameters to advice</h5></div></div><div></div></div><p>We've already seen how to bind the returned value or exception
          value (using after returning and after throwing advice). To make
          argument values available to the advice body, you can use the
          binding form of <tt class="literal">args</tt>. If a parameter name is used
          in place of a type name in an args expression, then the value of the
          corresponding argument will be passed as the parameter value when
          the advice is invoked. An example should make this clearer. Suppose
          you want to advise the execution of dao operations that take an
          Account object as the first parameter, and you need access to the
          account in the advice body. You could write the following:</p><pre class="programlisting">@Before("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp;" + 
        "args(account,..)")
public void validateAccount(Account account) {
  <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>The <tt class="literal">args(account,..)</tt> part of the pointcut
          expression serves two purposes: firstly, it restricts matching to
          only those method executions where the method takes at least one
          parameter, and the argument passed to that parameter is an instance
          of <tt class="classname">Account</tt>; secondly, it makes the actual
          <tt class="classname">Account</tt> object available to the advice via
          the <tt class="literal">account</tt> parameter.</p><p>Another way of writing this is to declare a pointcut that
          "provides" the <tt class="classname">Account</tt> object value when it
          matches a join point, and then just refer to the named pointcut from
          the advice. This would look as follows:</p><pre class="programlisting">@Pointcut("com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp;" + 
          "args(account,..)")
private void accountDataAccessOperation(Account account) {}

@Before("accountDataAccessOperation(account)")
public void validateAccount(Account account) {
  <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>The interested reader is once more referred to the AspectJ
          programming guide for more details.</p><p>The proxy object (<tt class="literal">this</tt>), target object
          (<tt class="literal">target</tt>), and annotations (<tt class="literal">@within,
          @target, @annotation, @args</tt>) can all be bound in a similar
          fashion. The following example shows how you could match the
          execution of methods annotated with an
          <tt class="interfacename">@Auditable</tt> annotation, and extract
          the audit code.</p><p>First the definition of the
          <tt class="interfacename">@Auditable</tt> annotation:</p><pre class="programlisting">@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Auditable {
	AuditCode value();
}</pre><p>And then the advice that matches the execution of
          <tt class="interfacename">@Auditable</tt> methods:</p><pre class="programlisting">@Before("com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; " + 
        "@annotation(auditable)")
public void audit(Auditable auditable) {
  AuditCode code = auditable.value();
  <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="aop-ataspectj-advice-params-names"></a>6.2.4.6.3.&nbsp;Determining argument names</h5></div></div><div></div></div><p>The parameter binding in advice invocations relies on matching
          names used in pointcut expressions to declared parameter names in
          (advice and pointcut) method signatures. Parameter names are
          <span class="emphasis"><em>not</em></span> available through Java reflection, so
          Spring AOP uses the following strategies to determine parameter
          names:</p><div class="orderedlist"><ol type="1"><li><p>If the parameter names have been specified by the user
              explicitly, then the specified parameter names are used: both
              the advice and the pointcut annotations have an optional
              "argNames" attribute which can be used to specify the argument
              names of the annotated method - these argument names
              <span class="emphasis"><em>are</em></span> available at runtime. For
              example:</p><pre class="programlisting">@Before(
   value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)",
   argNames="bean,auditable")
public void audit(Object bean, Auditable auditable) {
  AuditCode code = auditable.value();
  <i class="lineannotation"><span class="lineannotation">// ... use code and bean</span></i>
}</pre><p>If the first parameter is of the
              <tt class="interfacename">JoinPoint</tt>,
              <tt class="interfacename">ProceedingJoinPoint</tt>, or
              <tt class="interfacename">JoinPoint.StaticPart</tt> type, you
              may leave out the name of the parameter from the value of the
              "argNames" attribute. For example, if you modify the preceding
              advice to receive the join point object, the "argNames"
              attribute need not include it:</p><pre class="programlisting">@Before(
   value="com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)",
   argNames="bean,auditable")
public void audit(JoinPoint jp, Object bean, Auditable auditable) {
  AuditCode code = auditable.value();
  <i class="lineannotation"><span class="lineannotation">// ... use code, bean, and jp</span></i>
}</pre><p>The special treatment given to the first parameter of the
              <tt class="interfacename">JoinPoint</tt>,
              <tt class="interfacename">ProceedingJoinPoint</tt>, and
              <tt class="interfacename">JoinPoint.StaticPart</tt> types is
              particularly convenient for advice that do not collect any other
              join point context. In such situations, you may simply omit the
              "argNames" attribute. For example, the following advice need not
              declare the "argNames" attribute:</p><pre class="programlisting">@Before(
   "com.xyz.lib.Pointcuts.anyPublicMethod()")
public void audit(JoinPoint jp) {
  <i class="lineannotation"><span class="lineannotation">// ... use jp</span></i>
}</pre></li><li><p>Using the <tt class="literal">'argNames'</tt> attribute is a
              little clumsy, so if the <tt class="literal">'argNames'</tt> attribute
              has not been specified, then Spring AOP will look at the debug
              information for the class and try to determine the parameter
              names from the local variable table. This information will be
              present as long as the classes have been compiled with debug
              information (<tt class="literal">'-g:vars'</tt> at a minimum). The
              consequences of compiling with this flag on are: (1) your code
              will be slightly easier to understand (reverse engineer), (2)
              the class file sizes will be very slightly bigger (typically
              inconsequential), (3) the optimization to remove unused local
              variables will not be applied by your compiler. In other words,
              you should encounter no difficulties building with this flag
              on.</p><i><span class="remark">If an @AspectJ aspect has been compiled by the AspectJ
              compiler (ajc) even without the debug information then there is
              no need to add the <tt class="literal">argNames</tt> attribute as the
              compiler will retain the needed information.</span></i></li><li><p>If the code has been compiled without the necessary debug
              information, then Spring AOP will attempt to deduce the pairing
              of binding variables to parameters (for example, if only one
              variable is bound in the pointcut expression, and the advice
              method only takes one parameter, the pairing is obvious!). If
              the binding of variables is ambiguous given the available
              information, then an
              <tt class="exceptionname">AmbiguousBindingException</tt> will be
              thrown.</p></li><li><p>If all of the above strategies fail then an
              <tt class="exceptionname">IllegalArgumentException</tt> will be
              thrown.</p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="aop-ataspectj-advice-proceeding-with-the-call"></a>6.2.4.6.4.&nbsp;Proceeding with arguments</h5></div></div><div></div></div><p>We remarked earlier that we would describe how to write a
          proceed call <span class="emphasis"><em>with arguments</em></span> that works
          consistently across Spring AOP and AspectJ. The solution is simply
          to ensure that the advice signature binds each of the method
          parameters in order. For example:</p><pre class="programlisting">@Around("execution(List&lt;Account&gt; find*(..)) &amp;&amp;" +
        "com.xyz.myapp.SystemArchitecture.inDataAccessLayer() &amp;&amp; " +
        "args(accountHolderNamePattern)")		
public Object preProcessQueryPattern(ProceedingJoinPoint pjp, String accountHolderNamePattern)
throws Throwable {
  String newPattern = preProcess(accountHolderNamePattern);
  return pjp.proceed(new Object[] {newPattern});
}        
</pre><p>In many cases you will be doing this binding anyway (as in the
          example above).</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-ataspectj-advice-ordering"></a>6.2.4.7.&nbsp;Advice ordering</h4></div></div><div></div></div><p>What happens when multiple pieces of advice all want to run at
        the same join point? Spring AOP follows the same precedence rules as
        AspectJ to determine the order of advice execution. The highest
        precedence advice runs first "on the way in" (so given two pieces of
        before advice, the one with highest precedence runs first). "On the
        way out" from a join point, the highest precedence advice runs last
        (so given two pieces of after advice, the one with the highest
        precedence will run second).</p><p>When two pieces of advice defined in
        <span class="emphasis"><em>different</em></span> aspects both need to run at the same
        join point, unless you specify otherwise the order of execution is
        undefined. You can control the order of execution by specifying
        precedence. This is done in the normal Spring way by either
        implementing the
        <tt class="interfacename">org.springframework.core.Ordered</tt>
        interface in the aspect class or annotating it with the
        <tt class="interfacename">Order</tt> annotation. Given two aspects,
        the aspect returning the lower value from
        <tt class="literal">Ordered.getValue()</tt> (or the annotation value) has
        the higher precedence.</p><p>When two pieces of advice defined in <span class="emphasis"><em>the
        same</em></span> aspect both need to run at the same join point, the
        ordering is undefined (since there is no way to retrieve the
        declaration order via reflection for javac-compiled classes). Consider
        collapsing such advice methods into one advice method per join point
        in each aspect class, or refactor the pieces of advice into separate
        aspect classes - which can be ordered at the aspect level.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-introductions"></a>6.2.5.&nbsp;Introductions</h3></div></div><div></div></div><p>Introductions (known as inter-type declarations in AspectJ) enable
      an aspect to declare that advised objects implement a given interface,
      and to provide an implementation of that interface on behalf of those
      objects.</p><p>An introduction is made using the
      <tt class="interfacename">@DeclareParents</tt> annotation. This
      annotation is used to declare that matching types have a new parent
      (hence the name). For example, given an interface
      <tt class="interfacename">UsageTracked</tt>, and an implementation of
      that interface <tt class="classname">DefaultUsageTracked</tt>, the following
      aspect declares that all implementors of service interfaces also
      implement the <tt class="interfacename">UsageTracked</tt> interface. (In
      order to expose statistics via JMX for example.)</p><pre class="programlisting">@Aspect
public class UsageTracking {

  @DeclareParents(value="com.xzy.myapp.service.*+",
                  defaultImpl=DefaultUsageTracked.class)
  public static UsageTracked mixin;
  
  @Before("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp;" +
          "this(usageTracked)")
  public void recordUsage(UsageTracked usageTracked) {
    usageTracked.incrementUseCount();
  }
  
}</pre><p>The interface to be implemented is determined by the type of the
      annotated field. The <tt class="literal">value</tt> attribute of the
      <tt class="interfacename">@DeclareParents</tt> annotation is an AspectJ
      type pattern :- any bean of a matching type will implement the
      UsageTracked interface. Note that in the before advice of the above
      example, service beans can be directly used as implementations of the
      <tt class="interfacename">UsageTracked</tt> interface. If accessing a
      bean programmatically you would write the following:</p><pre class="programlisting">UsageTracked usageTracked = (UsageTracked) context.getBean("myService");</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-instantiation-models"></a>6.2.6.&nbsp;Aspect instantiation models</h3></div></div><div></div></div><i><span class="remark">(This is an advanced topic, so if you are just starting out with
      AOP you can safely skip it until later.)</span></i><p>By default there will be a single instance of each aspect within
      the application context. AspectJ calls this the singleton instantiation
      model. It is possible to define aspects with alternate lifecycles :-
      Spring supports AspectJ's <tt class="literal">perthis</tt> and
      <tt class="literal">pertarget</tt> instantiation models (<tt class="literal">percflow,
      percflowbelow,</tt> and <tt class="literal">pertypewithin</tt> are not
      currently supported).</p><p>A "perthis" aspect is declared by specifying a
      <tt class="literal">perthis</tt> clause in the
      <tt class="interfacename">@Aspect</tt> annotation. Let's look at an
      example, and then we'll explain how it works.</p><pre class="programlisting">@Aspect("perthis(com.xyz.myapp.SystemArchitecture.businessService())")
public class MyAspect {

  private int someState;
	
  @Before(com.xyz.myapp.SystemArchitecture.businessService())
  public void recordServiceUsage() {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
  }
  	
}</pre><p>The effect of the <tt class="literal">'perthis'</tt> clause is that one
      aspect instance will be created for each unique service object executing
      a business service (each unique object bound to 'this' at join points
      matched by the pointcut expression). The aspect instance is created the
      first time that a method is invoked on the service object. The aspect
      goes out of scope when the service object goes out of scope. Before the
      aspect instance is created, none of the advice within it executes. As
      soon as the aspect instance has been created, the advice declared within
      it will execute at matched join points, but only when the service object
      is the one this aspect is associated with. See the AspectJ programming
      guide for more information on per-clauses.</p><p>The <tt class="literal">'pertarget'</tt> instantiation model works in
      exactly the same way as perthis, but creates one aspect instance for
      each unique target object at matched join points.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ataspectj-example"></a>6.2.7.&nbsp;Example</h3></div></div><div></div></div><p>Now that you have seen how all the constituent parts work, let's
      put them together to do something useful!</p><p>The execution of business services can sometimes fail due to
      concurrency issues (for example, deadlock loser). If the operation is
      retried, it is quite likely to succeed next time round. For business
      services where it is appropriate to retry in such conditions (idempotent
      operations that don't need to go back to the user for conflict
      resolution), we'd like to transparently retry the operation to avoid the
      client seeing a
      <tt class="classname">PessimisticLockingFailureException</tt>. This is a
      requirement that clearly cuts across multiple services in the service
      layer, and hence is ideal for implementing via an aspect.</p><p>Because we want to retry the operation, we will need to use around
      advice so that we can call proceed multiple times. Here's how the basic
      aspect implementation looks:</p><pre class="programlisting">@Aspect
public class ConcurrentOperationExecutor implements Ordered {
   
   private static final int DEFAULT_MAX_RETRIES = 2;

   private int maxRetries = DEFAULT_MAX_RETRIES;
   private int order = 1;

   public void setMaxRetries(int maxRetries) {
      this.maxRetries = maxRetries;
   }
   
   public int getOrder() {
      return this.order;
   }
   
   public void setOrder(int order) {
      this.order = order;
   }
   
   @Around("com.xyz.myapp.SystemArchitecture.businessService()")
   public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable { 
      int numAttempts = 0;
      PessimisticLockingFailureException lockFailureException;
      do {
         numAttempts++;
         try { 
            return pjp.proceed();
         }
         catch(PessimisticLockingFailureException ex) {
            lockFailureException = ex;
         }
      }
      while(numAttempts &lt;= this.maxRetries);
      throw lockFailureException;
   }

}</pre><p>Note that the aspect implements the
      <tt class="interfacename">Ordered</tt> interface so we can set the
      precedence of the aspect higher than the transaction advice (we want a
      fresh transaction each time we retry). The <tt class="literal">maxRetries</tt>
      and <tt class="literal">order</tt> properties will both be configured by
      Spring. The main action happens in the
      <tt class="literal">doConcurrentOperation</tt> around advice. Notice that for
      the moment we're applying the retry logic to all
      <tt class="literal">businessService()s</tt>. We try to proceed, and if we fail
      with an <tt class="classname">PessimisticLockingFailureException</tt> we
      simply try again unless we have exhausted all of our retry
      attempts.</p><p>The corresponding Spring configuration is:</p><pre class="programlisting">&lt;aop:aspectj-autoproxy/&gt;

&lt;bean id="concurrentOperationExecutor"
  class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor"&gt;
     &lt;property name="maxRetries" value="3"/&gt;
     &lt;property name="order" value="100"/&gt;  
&lt;/bean&gt;</pre><p>To refine the aspect so that it only retries idempotent
      operations, we might define an <tt class="interfacename">Idempotent</tt>
      annotation:</p><pre class="programlisting">@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
  <i class="lineannotation"><span class="lineannotation">// marker annotation</span></i>
}</pre><p>and use the annotation to annotate the implementation of service
      operations. The change to the aspect to only retry idempotent operations
      simply involves refining the pointcut expression so that only
      <tt class="interfacename">@Idempotent</tt> operations match:</p><pre class="programlisting">@Around("com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; " + 
        "@annotation(com.xyz.myapp.service.Idempotent)")
public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable { 
  ...	
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-schema"></a>6.3.&nbsp;Schema-based AOP support</h2></div></div><div></div></div><p>If you are unable to use Java 5, or simply prefer an XML-based
    format, then Spring 2.0 also offers support for defining aspects using the
    new "aop" namespace tags. The exact same pointcut expressions and advice
    kinds are supported as when using the @AspectJ style, hence in this
    section we will focus on the new <span class="emphasis"><em>syntax</em></span> and refer the
    reader to the discussion in the previous section (<a href="#aop-ataspectj" title="6.2.&nbsp;@AspectJ support">Section&nbsp;6.2, &#8220;@AspectJ support&#8221;</a>) for an understanding of writing pointcut
    expressions and the binding of advice parameters.</p><p>To use the aop namespace tags described in this section, you need to
    import the spring-aop schema as described in <a href="#xsd-config" title="Appendix&nbsp;A.&nbsp;XML Schema-based configuration">Appendix&nbsp;A, <i>XML Schema-based configuration</i></a>. See <a href="#xsd-config-body-schemas-aop" title="A.2.7.&nbsp;The aop schema">Section&nbsp;A.2.7, &#8220;The aop schema&#8221;</a> for how to import the tags in the
    aop namespace.</p><p>Within your Spring configurations, all aspect and advisor elements
    must be placed within an <tt class="literal">&lt;aop:config&gt;</tt> element
    (you can have more than one <tt class="literal">&lt;aop:config&gt;</tt> element
    in an application context configuration). An
    <tt class="literal">&lt;aop:config&gt;</tt> element can contain pointcut,
    advisor, and aspect elements (note these must be declared in that
    order).</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../images/admons/warning.png"></td><th align="left">Warning</th></tr><tr><td colspan="2" align="left" valign="top"><p>The <tt class="literal">&lt;aop:config&gt;</tt> style of configuration
      makes heavy use of Spring's <a href="#aop-autoproxy" title="7.9.&nbsp;Using the &#34;autoproxy&#34; facility">auto-proxying</a> mechanism. This can cause
      issues (such as advice not being woven) if you are already using
      explicit auto-proxying via the use of
      <tt class="classname">BeanNameAutoProxyCreator</tt> or suchlike. The
      recommended usage pattern is to use either just the
      <tt class="literal">&lt;aop:config&gt;</tt> style, or just the
      <tt class="interfacename">AutoProxyCreator</tt> style.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-declaring-an-aspect"></a>6.3.1.&nbsp;Declaring an aspect</h3></div></div><div></div></div><p>Using the schema support, an aspect is simply a regular Java
      object defined as a bean in your Spring application context. The state
      and behavior is captured in the fields and methods of the object, and
      the pointcut and advice information is captured in the XML.</p><p>An aspect is declared using the &lt;aop:aspect&gt; element, and
      the backing bean is referenced using the <tt class="literal">ref</tt>
      attribute:</p><pre class="programlisting">&lt;aop:config&gt;
  &lt;aop:aspect id="myAspect" ref="aBean"&gt;
    ...
  &lt;/aop:aspect&gt;
&lt;/aop:config&gt;

&lt;bean id="aBean" class="..."&gt;
  ...
&lt;/bean&gt;</pre><p>The bean backing the aspect ("<tt class="literal">aBean</tt>" in this
      case) can of course be configured and dependency injected just like any
      other Spring bean.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-pointcuts"></a>6.3.2.&nbsp;Declaring a pointcut</h3></div></div><div></div></div><p>A named pointcut can be declared inside an &lt;aop:config&gt;
      element, enabling the pointcut definition to be shared across several
      aspects and advisors.</p><p>A pointcut representing the execution of any business service in
      the service layer could be defined as follows:</p><pre class="programlisting">&lt;aop:config&gt;

  &lt;aop:pointcut id="businessService" 
        expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

&lt;/aop:config&gt;</pre><p>Note that the pointcut expression itself is using the same AspectJ
      pointcut expression language as described in <a href="#aop-ataspectj" title="6.2.&nbsp;@AspectJ support">Section&nbsp;6.2, &#8220;@AspectJ support&#8221;</a>. If you are using the schema based
      declaration style with Java 5, you can refer to named pointcuts defined
      in types (@Aspects) within the pointcut expression, but this feature is
      not available on JDK 1.4 and below (it relies on the Java 5 specific
      AspectJ reflection APIs). On JDK 1.5 therefore, another way of defining
      the above pointcut would be:</p><pre class="programlisting">&lt;aop:config&gt;

  &lt;aop:pointcut id="businessService" 
        expression="com.xyz.myapp.SystemArchitecture.businessService()"/&gt;

&lt;/aop:config&gt;</pre><p>Assuming you have a <tt class="literal">SystemArchitecture</tt> aspect
      as described in <a href="#aop-common-pointcuts" title="6.2.3.3.&nbsp;Sharing common pointcut definitions">Section&nbsp;6.2.3.3, &#8220;Sharing common pointcut definitions&#8221;</a>.</p><p>Declaring a pointcut inside an aspect is very similar to declaring
      a top-level pointcut:</p><pre class="programlisting">&lt;aop:config&gt;

  &lt;aop:aspect id="myAspect" ref="aBean"&gt;

    &lt;aop:pointcut id="businessService" 
          expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;
          
    ...
    
  &lt;/aop:aspect&gt;

&lt;/aop:config&gt;</pre><p>Much the same way in an @AspectJ aspect, pointcuts declared using
      the schema based definition style may collect join point context. For
      example, the following pointcut collects the 'this' object as the join
      point context and passes it to advice:</p><pre class="programlisting">&lt;aop:config&gt;

  &lt;aop:aspect id="myAspect" ref="aBean"&gt;

    &lt;aop:pointcut id="businessService" 
          expression="execution(* com.xyz.myapp.service.*.*(..)) &amp;amp;&amp;amp; this(service)"/&gt;
    &lt;aop:before pointcut-ref="businessService" method="monitor"/&gt;
    ...
    
  &lt;/aop:aspect&gt;

&lt;/aop:config&gt;</pre><p>The advice must be declared to receive the collected join point
      context by including parameters of the matching names:</p><pre class="programlisting">public void monitor(Object service) {
    ...
}</pre><p>When combining pointcut sub-expressions, '&amp;&amp;' is awkward
      within an XML document, and so the keywords 'and', 'or' and 'not' can be
      used in place of '&amp;&amp;', '||' and '!' respectively. For example,
      the previous pointcut may be better written as:</p><pre class="programlisting">&lt;aop:config&gt;

  &lt;aop:aspect id="myAspect" ref="aBean"&gt;

    &lt;aop:pointcut id="businessService" 
          expression="execution(* com.xyz.myapp.service.*.*(..)) <span class="bold"><b>and</b></span> this(service)"/&gt;
    &lt;aop:before pointcut-ref="businessService" method="monitor"/&gt;
    ...
    
  &lt;/aop:aspect&gt;

&lt;/aop:config&gt;</pre><p>Note that pointcuts defined in this way are referred to by their
      XML id and cannot be used as named pointcuts to form composite
      pointcuts. The named pointcut support in the schema based definition
      style is thus more limited than that offered by the @AspectJ
      style.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-advice"></a>6.3.3.&nbsp;Declaring advice</h3></div></div><div></div></div><p>The same five advice kinds are supported as for the @AspectJ
      style, and they have exactly the same semantics.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-before"></a>6.3.3.1.&nbsp;Before advice</h4></div></div><div></div></div><p>Before advice runs before a matched method execution. It is
        declared inside an <tt class="literal">&lt;aop:aspect&gt;</tt> using the
        &lt;aop:before&gt; element.</p><pre class="programlisting">&lt;aop:aspect id="beforeExample" ref="aBean"&gt;

    &lt;aop:before 
      pointcut-ref="dataAccessOperation" 
      method="doAccessCheck"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</pre><p>Here <tt class="literal">dataAccessOperation</tt> is the id of a
        pointcut defined at the top (<tt class="literal">&lt;aop:config&gt;</tt>)
        level. To define the pointcut inline instead, replace the
        <tt class="literal">pointcut-ref</tt> attribute with a
        <tt class="literal">pointcut</tt> attribute:</p><pre class="programlisting">&lt;aop:aspect id="beforeExample" ref="aBean"&gt;

    &lt;aop:before 
      pointcut="execution(* com.xyz.myapp.dao.*.*(..))" 
      method="doAccessCheck"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</pre><p>As we noted in the discussion of the @AspectJ style, using named
        pointcuts can significantly improve the readability of your
        code.</p><p>The method attribute identifies a method
        (<tt class="literal">doAccessCheck</tt>) that provides the body of the
        advice. This method must be defined for the bean referenced by the
        aspect element containing the advice. Before a data access operation
        is executed (a method execution join point matched by the pointcut
        expression), the "doAccessCheck" method on the aspect bean will be
        invoked.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-after-returning"></a>6.3.3.2.&nbsp;After returning advice</h4></div></div><div></div></div><p>After returning advice runs when a matched method execution
        completes normally. It is declared inside an
        <tt class="literal">&lt;aop:aspect&gt;</tt> in the same way as before
        advice. For example:</p><pre class="programlisting">&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt;

    &lt;aop:after-returning 
      pointcut-ref="dataAccessOperation" 
      method="doAccessCheck"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</pre><p>Just as in the @AspectJ style, it is possible to get hold of the
        return value within the advice body. Use the returning attribute to
        specify the name of the parameter to which the return value should be
        passed:</p><pre class="programlisting">&lt;aop:aspect id="afterReturningExample" ref="aBean"&gt;

    &lt;aop:after-returning 
      pointcut-ref="dataAccessOperation"
      returning="retVal" 
      method="doAccessCheck"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</pre><p>The doAccessCheck method must declare a parameter named
        <tt class="literal">retVal</tt>. The type of this parameter constrains
        matching in the same way as described for @AfterReturning. For
        example, the method signature may be declared as:</p><pre class="programlisting">public void doAccessCheck(Object retVal) {...</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-after-throwing"></a>6.3.3.3.&nbsp;After throwing advice</h4></div></div><div></div></div><p>After throwing advice executes when a matched method execution
        exits by throwing an exception. It is declared inside an
        <tt class="literal">&lt;aop:aspect&gt;</tt> using the after-throwing
        element:</p><pre class="programlisting">&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt;

    &lt;aop:after-throwing
      pointcut-ref="dataAccessOperation" 
      method="doRecoveryActions"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</pre><p>Just as in the @AspectJ style, it is possible to get hold of the
        thrown exception within the advice body. Use the throwing attribute to
        specify the name of the parameter to which the exception should be
        passed:</p><pre class="programlisting">&lt;aop:aspect id="afterThrowingExample" ref="aBean"&gt;

    &lt;aop:after-throwing 
      pointcut-ref="dataAccessOperation"
      throwing="dataAccessEx" 
      method="doRecoveryActions"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</pre><p>The doRecoveryActions method must declare a parameter named
        <tt class="literal">dataAccessEx</tt>. The type of this parameter constrains
        matching in the same way as described for @AfterThrowing. For example,
        the method signature may be declared as:</p><pre class="programlisting">public void doRecoveryActions(DataAccessException dataAccessEx) {...</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-after-finally"></a>6.3.3.4.&nbsp;After (finally) advice</h4></div></div><div></div></div><p>After (finally) advice runs however a matched method execution
        exits. It is declared using the <tt class="literal">after</tt>
        element:</p><pre class="programlisting">&lt;aop:aspect id="afterFinallyExample" ref="aBean"&gt;

    &lt;aop:after
      pointcut-ref="dataAccessOperation" 
      method="doReleaseLock"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-advice-around"></a>6.3.3.5.&nbsp;Around advice</h4></div></div><div></div></div><p>The final kind of advice is around advice. Around advice runs
        "around" a matched method execution. It has the opportunity to do work
        both before and after the method executes, and to determine when, how,
        and even if, the method actually gets to execute at all. Around advice
        is often used if you need to share state before and after a method
        execution in a thread-safe manner (starting and stopping a timer for
        example). Always use the least powerful form of advice that meets your
        requirements; don't use around advice if simple before advice would
        do.</p><p>Around advice is declared using the
        <tt class="literal">aop:around</tt> element. The first parameter of the
        advice method must be of type
        <tt class="interfacename">ProceedingJoinPoint</tt>. Within the body of
        the advice, calling <tt class="literal">proceed()</tt> on the
        <tt class="interfacename">ProceedingJoinPoint</tt> causes the
        underlying method to execute. The <tt class="literal">proceed</tt> method
        may also be calling passing in an <tt class="classname">Object[]</tt> -
        the values in the array will be used as the arguments to the method
        execution when it proceeds. See <a href="#aop-ataspectj-around-advice" title="6.2.4.5.&nbsp;Around advice">Section&nbsp;6.2.4.5, &#8220;Around advice&#8221;</a> for notes on calling proceed
        with an <tt class="classname">Object[]</tt>.</p><pre class="programlisting">&lt;aop:aspect id="aroundExample" ref="aBean"&gt;

    &lt;aop:around
      pointcut-ref="businessService" 
      method="doBasicProfiling"/&gt;
          
    ...
    
&lt;/aop:aspect&gt;</pre><p>The implementation of the <tt class="literal">doBasicProfiling</tt>
        advice would be exactly the same as in the @AspectJ example (minus the
        annotation of course):</p><pre class="programlisting">public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable {
    <i class="lineannotation"><span class="lineannotation">// start stopwatch</span></i>
    Object retVal = pjp.proceed();
    <i class="lineannotation"><span class="lineannotation">// stop stopwatch</span></i>
    return retVal;
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-schema-params"></a>6.3.3.6.&nbsp;Advice parameters</h4></div></div><div></div></div><p>The schema based declaration style supports fully typed advice
        in the same way as described for the @AspectJ support - by matching
        pointcut parameters by name against advice method parameters. See
        <a href="#aop-ataspectj-advice-params" title="6.2.4.6.&nbsp;Advice parameters">Section&nbsp;6.2.4.6, &#8220;Advice parameters&#8221;</a> for details. If you
        wish to explicitly specify argument names for the advice methods (not
        relying on the detection strategies previously described) then this is
        done using the <tt class="literal">arg-names</tt> attribute of the advice
        element, which is treated in the same manner to the "argNames"
        attribute in an advice annotation as described in <a href="#aop-ataspectj-advice-params-names" title="6.2.4.6.3.&nbsp;Determining argument names">Section&nbsp;6.2.4.6.3, &#8220;Determining argument names&#8221;</a>. For example:</p><pre class="programlisting">&lt;aop:before
  pointcut="com.xyz.lib.Pointcuts.anyPublicMethod() and @annotation(auditable)"
  method="audit"
  arg-names="auditable"/&gt;</pre><p>The <tt class="literal">arg-names</tt> attribute accepts a
        comma-delimited list of parameter names.</p><p>Find below a slightly more involved example of the XSD-based
        approach that illustrates some around advice used in conjunction with
        a number of strongly typed parameters.</p><pre class="programlisting">package x.y.service;

public interface FooService {

   Foo getFoo(String fooName, int age);
}

public class DefaultFooService implements FooService {

   public Foo getFoo(String name, int age) {
      return new Foo(name, age);
   }
}</pre><p>Next up is the aspect. Notice the fact that the
        <tt class="methodname">profile(..)</tt> method accepts a number of
        strongly-typed parameters, the first of which happens to be the join
        point used to proceed with the method call: the presence of this
        parameter is an indication that the
        <tt class="methodname">profile(..)</tt> is to be used as
        <tt class="literal">around</tt> advice:</p><pre class="programlisting">package x.y;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.util.StopWatch;

public class SimpleProfiler {

   public Object profile(ProceedingJoinPoint call, String name, int age) throws Throwable {
      StopWatch clock = new StopWatch(
            "Profiling for '" + name + "' and '" + age + "'");
      try {
         clock.start(call.toShortString());
         return call.proceed();
      } finally {
         clock.stop();
         System.out.println(clock.prettyPrint());
      }
   }
}</pre><p>Finally, here is the XML configuration that is required to
        effect the execution of the above advice for a particular join
        point:</p><pre class="programlisting">&lt;beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:aop="http://www.springframework.org/schema/aop"
      xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

   <i class="lineannotation"><span class="lineannotation">&lt;!-- this is the object that will be proxied by Spring's AOP infrastructure --&gt;</span></i>
   &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

   <i class="lineannotation"><span class="lineannotation">&lt;!-- this is the actual advice itself --&gt;</span></i>
   &lt;bean id="profiler" class="x.y.SimpleProfiler"/&gt;

   &lt;aop:config&gt;
      &lt;aop:aspect ref="profiler"&gt;

         &lt;aop:pointcut id="theExecutionOfSomeFooServiceMethod"
                    expression="execution(* x.y.service.FooService.getFoo(String,int))
                    and args(name, age)"/&gt;

         &lt;aop:around pointcut-ref="theExecutionOfSomeFooServiceMethod"
                  method="profile"/&gt;

      &lt;/aop:aspect&gt;
   &lt;/aop:config&gt;

&lt;/beans&gt;</pre><p>If we had the following driver script, we would get output
        something like this on standard output:</p><pre class="programlisting">import org.springframework.beans.factory.BeanFactory;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import x.y.service.FooService;

public final class Boot {

   public static void main(final String[] args) throws Exception {
      BeanFactory ctx = new ClassPathXmlApplicationContext("x/y/plain.xml");
      FooService foo = (FooService) ctx.getBean("fooService");
      foo.getFoo("Pengo", 12);
   }
}</pre><pre class="programlisting">StopWatch 'Profiling for 'Pengo' and '12'': running time (millis) = 0
-----------------------------------------
ms     %     Task name
-----------------------------------------
00000  ?  execution(getFoo)</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-ordering"></a>6.3.3.7.&nbsp;Advice ordering</h4></div></div><div></div></div><p>When multiple advice needs to execute at the same join point
        (executing method) the ordering rules are as described in <a href="#aop-ataspectj-advice-ordering" title="6.2.4.7.&nbsp;Advice ordering">Section&nbsp;6.2.4.7, &#8220;Advice ordering&#8221;</a>. The precedence between
        aspects is determined by either adding the
        <tt class="interfacename">Order</tt> annotation to the bean backing
        the aspect or by having the bean implement the
        <tt class="interfacename">Ordered</tt> interface.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-introductions"></a>6.3.4.&nbsp;Introductions</h3></div></div><div></div></div><p>Introductions (known as inter-type declarations in AspectJ) enable
      an aspect to declare that advised objects implement a given interface,
      and to provide an implementation of that interface on behalf of those
      objects.</p><p>An introduction is made using the
      <tt class="literal">aop:declare-parents</tt> element inside an
      <tt class="literal">aop:aspect</tt> This element is used to declare that
      matching types have a new parent (hence the name). For example, given an
      interface <tt class="interfacename">UsageTracked</tt>, and an
      implementation of that interface
      <tt class="classname">DefaultUsageTracked</tt>, the following aspect
      declares that all implementors of service interfaces also implement the
      <tt class="interfacename">UsageTracked</tt> interface. (In order to
      expose statistics via JMX for example.)</p><pre class="programlisting">&lt;aop:aspect id="usageTrackerAspect" ref="usageTracking"&gt;

  &lt;aop:declare-parents
      types-matching="com.xzy.myapp.service.*+"
      implement-interface="com.xyz.myapp.service.tracking.UsageTracked"
      default-impl="com.xyz.myapp.service.tracking.DefaultUsageTracked"/&gt;
  
  &lt;aop:before
    pointcut="com.xyz.myapp.SystemArchitecture.businessService()
              and this(usageTracked)"
    method="recordUsage"/&gt;
  
&lt;/aop:aspect&gt;</pre><p>The class backing the <tt class="literal">usageTracking</tt> bean would
      contain the method:</p><pre class="programlisting">public void recordUsage(UsageTracked usageTracked) {
    usageTracked.incrementUseCount();
}</pre><p>The interface to be implemented is determined by
      <tt class="literal">implement-interface</tt> attribute. The value of the
      <tt class="literal">types-matching</tt> attribute is an AspectJ type pattern
      :- any bean of a matching type will implement the
      <tt class="interfacename">UsageTracked</tt> interface. Note that in the
      before advice of the above example, service beans can be directly used
      as implementations of the <tt class="interfacename">UsageTracked</tt>
      interface. If accessing a bean programmatically you would write the
      following:</p><pre class="programlisting">UsageTracked usageTracked = (UsageTracked) context.getBean("myService");</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-instatiation-models"></a>6.3.5.&nbsp;Aspect instantiation models</h3></div></div><div></div></div><p>The only supported instantiation model for schema-defined aspects
      is the singleton model. Other instantiation models may be supported in
      future releases.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-advisors"></a>6.3.6.&nbsp;Advisors</h3></div></div><div></div></div><p>The concept of "advisors" is brought forward from the AOP support
      defined in Spring 1.2 and does not have a direct equivalent in AspectJ.
      An advisor is like a small self-contained aspect that has a single piece
      of advice. The advice itself is represented by a bean, and must
      implement one of the advice interfaces described in <a href="#aop-api-advice-types" title="7.3.2.&nbsp;Advice types in Spring">Section&nbsp;7.3.2, &#8220;Advice types in Spring&#8221;</a>. Advisors can take advantage of
      AspectJ pointcut expressions though.</p><p>Spring 2.0 supports the advisor concept with the
      <tt class="literal">&lt;aop:advisor&gt;</tt> element. You will most commonly
      see it used in conjunction with transactional advice, which also has its
      own namespace support in Spring 2.0. Here's how it looks:</p><pre class="programlisting">&lt;aop:config&gt;

  &lt;aop:pointcut id="businessService"
        expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;

  &lt;aop:advisor 
      pointcut-ref="businessService"
      advice-ref="tx-advice"/&gt;
      
&lt;/aop:config&gt;

&lt;tx:advice id="tx-advice"&gt;
  &lt;tx:attributes&gt;
    &lt;tx:method name="*" propagation="REQUIRED"/&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</pre></div><p>As well as the <tt class="literal">pointcut-ref</tt> attribute used in the
    above example, you can also use the <tt class="literal">pointcut</tt> attribute
    to define a pointcut expression inline.</p><p>To define the precedence of an advisor so that the advice can
    participate in ordering, use the <tt class="literal">order</tt> attribute to
    define the <tt class="literal">Ordered</tt> value of the advisor.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-schema-example"></a>6.3.7.&nbsp;Example</h3></div></div><div></div></div><p>Let's see how the concurrent locking failure retry example from
      <a href="#aop-ataspectj-example" title="6.2.7.&nbsp;Example">Section&nbsp;6.2.7, &#8220;Example&#8221;</a> looks when rewritten using the
      schema support.</p><p>The execution of business services can sometimes fail due to
      concurrency issues (for example, deadlock loser). If the operation is
      retried, it is quite likely it will succeed next time round. For
      business services where it is appropriate to retry in such conditions
      (idempotent operations that don't need to go back to the user for
      conflict resolution), we'd like to transparently retry the operation to
      avoid the client seeing a
      <tt class="classname">PessimisticLockingFailureException</tt>. This is a
      requirement that clearly cuts across multiple services in the service
      layer, and hence is ideal for implementing via an aspect.</p><p>Because we want to retry the operation, we'll need to use around
      advice so that we can call proceed multiple times. Here's how the basic
      aspect implementation looks (it's just a regular Java class using the
      schema support):</p><pre class="programlisting">public class ConcurrentOperationExecutor implements Ordered {
   
   private static final int DEFAULT_MAX_RETRIES = 2;

   private int maxRetries = DEFAULT_MAX_RETRIES;
   private int order = 1;

   public void setMaxRetries(int maxRetries) {
      this.maxRetries = maxRetries;
   }
   
   public int getOrder() {
      return this.order;
   }
   
   public void setOrder(int order) {
      this.order = order;
   }
   
   public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable { 
      int numAttempts = 0;
      PessimisticLockingFailureException lockFailureException;
      do {
         numAttempts++;
         try { 
            return pjp.proceed();
         }
         catch(PessimisticLockingFailureException ex) {
            lockFailureException = ex;
         }
      }
      while(numAttempts &lt;= this.maxRetries);
      throw lockFailureException;
   }

}</pre><p>Note that the aspect implements the
      <tt class="interfacename">Ordered</tt> interface so we can set the
      precedence of the aspect higher than the transaction advice (we want a
      fresh transaction each time we retry). The <tt class="literal">maxRetries</tt>
      and <tt class="literal">order</tt> properties will both be configured by
      Spring. The main action happens in the
      <tt class="literal">doConcurrentOperation</tt> around advice method. We try to
      proceed, and if we fail with a
      <tt class="classname">PessimisticLockingFailureException</tt> we simply try
      again unless we have exhausted all of our retry attempts.</p><i><span class="remark">This class is identical to the one used in the @AspectJ example,
      but with the annotations removed.</span></i><p>The corresponding Spring configuration is:</p><pre class="programlisting">&lt;aop:config&gt;

  &lt;aop:aspect id="concurrentOperationRetry" ref="concurrentOperationExecutor"&gt;

    &lt;aop:pointcut id="idempotentOperation"
        expression="execution(* com.xyz.myapp.service.*.*(..))"/&gt;
       
    &lt;aop:around
       pointcut-ref="idempotentOperation"
       method="doConcurrentOperation"/&gt;
  
  &lt;/aop:aspect&gt;

&lt;/aop:config&gt;

&lt;bean id="concurrentOperationExecutor"
  class="com.xyz.myapp.service.impl.ConcurrentOperationExecutor"&gt;
     &lt;property name="maxRetries" value="3"/&gt;
     &lt;property name="order" value="100"/&gt;  
&lt;/bean&gt;</pre><p>Notice that for the time being we assume that all business
      services are idempotent. If this is not the case we can refine the
      aspect so that it only retries genuinely idempotent operations, by
      introducing an <tt class="interfacename">Idempotent</tt>
      annotation:</p><pre class="programlisting">@Retention(RetentionPolicy.RUNTIME)
public @interface Idempotent {
  <i class="lineannotation"><span class="lineannotation">// marker annotation</span></i>
}</pre><p>and using the annotation to annotate the implementation of service
      operations. The change to the aspect to retry only idempotent operations
      simply involves refining the pointcut expression so that only
      <tt class="interfacename">@Idempotent</tt> operations match:</p><pre class="programlisting">  &lt;aop:pointcut id="idempotentOperation"
        expression="execution(* com.xyz.myapp.service.*.*(..)) and
                    @annotation(com.xyz.myapp.service.Idempotent)"/&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-choosing"></a>6.4.&nbsp;Choosing which AOP declaration style to use</h2></div></div><div></div></div><p>Once you have decided that an aspect is the best approach for
    implementing a given requirement, how do you decide between using Spring
    AOP or AspectJ, and between the Aspect language (code) style, @AspectJ
    annotation style, or the Spring XML style? These decisions are influenced
    by a number of factors including application requirements, development
    tools, and team familiarity with AOP.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-spring-or-aspectj"></a>6.4.1.&nbsp;Spring AOP or full AspectJ?</h3></div></div><div></div></div><p>Use the simplest thing that can work. Spring AOP is simpler than
      using full AspectJ as there is no requirement to introduce the AspectJ
      compiler / weaver into your development and build processes. If you only
      need to advise the execution of operations on Spring beans, then Spring
      AOP is the right choice. If you need to advise objects not managed by
      the Spring container (such as domain objects typically), then you will
      need to use AspectJ. You will also need to use AspectJ if you wish to
      advise join points other than simple method executions (for example,
      field get or set join points, and so on).</p><p>When using AspectJ, you have the choice of the AspectJ language
      syntax (also known as the "code style") or the @AspectJ annotation
      style. Clearly, if you are not using Java 5+ then the choice has been
      made for you... use the code style. If aspects play a large role in your
      design, and you are able to use the <a href="http://www.eclipse.org/ajdt/" target="_top">AspectJ Development Tools
      (AJDT)</a> plugin for Eclipse, then the AspectJ language syntax is
      the preferred option: it is cleaner and simpler because the language was
      purposefully designed for writing aspects. If you are not using Eclipse,
      or have only a few aspects that do not play a major role in your
      application, then you may want to consider using the @AspectJ style and
      sticking with a regular Java compilation in your IDE, and adding an
      aspect weaving phase to your build script.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ataspectj-or-xml"></a>6.4.2.&nbsp;@AspectJ or XML for Spring AOP?</h3></div></div><div></div></div><p>If you have chosen to use Spring AOP, then you have a choice of
      @AspectJ or XML style. Clearly if you are not running on Java 5+, then
      the XML style is the appropriate choice; for Java 5 projects there are
      various tradeoffs to consider.</p><p>The XML style will be most familiar to existing Spring users. It
      can be used with any JDK level (referring to named pointcuts from within
      pointcut expressions does still require Java 5+ though) and is backed by
      genuine POJOs. When using AOP as a tool to configure enterprise services
      then XML can be a good choice (a good test is whether you consider the
      pointcut expression to be a part of your configuration you might want to
      change independently). With the XML style arguably it is clearer from
      your configuration what aspects are present in the system.</p><p>The XML style has two disadvantages. Firstly it does not fully
      encapsulate the implementation of the requirement it addresses in a
      single place. The DRY principle says that there should be a single,
      unambiguous, authoritative representation of any piece of knowledge
      within a system. When using the XML style, the knowledge of
      <span class="emphasis"><em>how</em></span> a requirement is implemented is split across
      the declaration of the backing bean class, and the XML in the
      configuration file. When using the @AspectJ style there is a single
      module - the aspect - in which this information is encapsulated.
      Secondly, the XML style is slightly more limited in what it can express
      than the @AspectJ style: only the "singleton" aspect instantiation model
      is supported, and it is not possible to combine named pointcuts declared
      in XML. For example, in the @AspectJ style you can write something
      like:</p><pre class="programlisting">  @Pointcut(execution(* get*()))
  public void propertyAccess() {}

  @Pointcut(execution(org.xyz.Account+ *(..))
  public void operationReturningAnAccount() {}

  @Pointcut(propertyAccess() &amp;&amp; operationReturningAnAccount())
  public void accountPropertyAccess() {}</pre><p>In the XML style I can declare the first two pointcuts:</p><pre class="programlisting">  &lt;aop:pointcut id="propertyAccess"
      expression="execution(* get*())"/&gt;

  &lt;aop:pointcut id="operationReturningAnAccount"
      expression="execution(org.xyz.Account+ *(..))"/&gt;</pre><p>The downside of the XML approach is that you cannot define the
      '<tt class="literal">accountPropertyAccess</tt>' pointcut by combining these
      definitions.</p><p>The @AspectJ style supports additional instantiation models, and
      richer pointcut composition. It has the advantage of keeping the aspect
      as a modular unit. It also has the advantage the @AspectJ aspects can be
      understood (and thus consumed) both by Spring AOP and by AspectJ - so if
      you later decide you need the capabilities of AspectJ to implement
      additional requirements then it is very easy to migrate to an
      AspectJ-based approach. On balance the Spring team prefer the @AspectJ
      style whenever you have aspects that do more than simple "configuration"
      of enterprise services.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-mixing-styles"></a>6.5.&nbsp;Mixing aspect types</h2></div></div><div></div></div><p>It is perfectly possible to mix @AspectJ style aspects using the
    autoproxying support, schema-defined <tt class="literal">&lt;aop:aspect&gt;</tt>
    aspects, <tt class="literal">&lt;aop:advisor&gt;</tt> declared advisors and even
    proxies and interceptors defined using the Spring 1.2 style in the same
    configuration. All of these are implemented using the same underlying
    support mechanism and will co-exist without any difficulty.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-proxying"></a>6.6.&nbsp;Proxying mechanisms</h2></div></div><div></div></div><p>Spring AOP uses either JDK dynamic proxies or CGLIB to create the
    proxy for a given target object. (JDK dynamic proxies are preferred
    whenever you have a choice).</p><p>If the target object to be proxied implements at least one interface
    then a JDK dynamic proxy will be used. All of the interfaces implemented
    by the target type will be proxied. If the target object does not
    implement any interfaces then a CGLIB proxy will be created.</p><p>If you want to force the use of CGLIB proxying (for example, to
    proxy every method defined for the target object, not just those
    implemented by its interfaces) you can do so. However, there are some
    issues to consider:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">final</tt> methods cannot be advised, as they
        cannot be overriden.</p></li><li><p>You will need the CGLIB 2 binaries on your classpath, whereas
        dynamic proxies are available with the JDK. Spring will automatically
        warn you when it needs CGLIB and the CGLIB library classes are not
        found on the classpath.</p></li><li><p>The constructor of your proxied object will be called twice.
        This is a natural consequence of the CGLIB proxy model whereby a
        subclass is generated for each proxied object. For each proxied
        instance, two objects are created: the actual proxied object and an
        instance of the subclass that implements the advice. This behavior is
        not exhibited when using JDK proxies. Usually, calling the constructor
        of the proxied type twice, is not an issue, as there are usually only
        assignments taking place and no real logic is implemented in the
        constructor.</p></li></ul></div><p><a name="aop-autoproxy-force-CGLIB"></a>To force the use of CGLIB proxies set
    the value of the <tt class="literal">proxy-target-class</tt> attribute of the
    <tt class="literal">&lt;aop:config&gt;</tt> element to true:</p><pre class="programlisting">&lt;aop:config <span class="bold"><b>proxy-target-class="true"</b></span>&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- other beans defined here... --&gt;</span></i>
&lt;/aop:config&gt;</pre><p>To force CGLIB proxying when using the @AspectJ autoproxy support,
    set the <tt class="literal">'proxy-target-class'</tt> attribute of the
    <tt class="literal">&lt;aop:aspectj-autoproxy&gt;</tt> element to
    <tt class="literal">true</tt>:</p><pre class="programlisting">&lt;aop:aspectj-autoproxy <span class="bold"><b>proxy-target-class="true"</b></span>/&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Multiple <tt class="literal">&lt;aop:config/&gt;</tt> sections are
      collapsed into a single unified auto-proxy creator at runtime, which
      applies the <span class="emphasis"><em>strongest</em></span> proxy settings that any of
      the <tt class="literal">&lt;aop:config/&gt;</tt> sections (typically from
      different XML bean definition files) specified. This also applies to the
      <tt class="literal">&lt;tx:annotation-driven/&gt;</tt> and
      <tt class="literal">&lt;aop:aspectj-autoproxy/&gt;</tt> elements.</p><p>To be clear: using '<tt class="literal">proxy-target-class="true"</tt>'
      on <tt class="literal">&lt;tx:annotation-driven/&gt;</tt>,
      <tt class="literal">&lt;aop:aspectj-autoproxy/&gt;</tt> or
      <tt class="literal">&lt;aop:config/&gt;</tt> elements will force the use of
      CGLIB proxies <span class="emphasis"><em>for all three of them</em></span>.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-understanding-aop-proxies"></a>6.6.1.&nbsp;Understanding AOP proxies</h3></div></div><div></div></div><p>Spring AOP is <span class="emphasis"><em>proxy-based</em></span>. It is vitally
      important that you grasp the semantics of what that last statement
      actually means before you write your own aspects or use any of the
      Spring AOP-based aspects supplied with the Spring Framework.</p><p>Consider first the scenario where you have a plain-vanilla,
      un-proxied, nothing-special-about-it, straight object reference, as
      illustrated by the following code snippet.</p><pre class="programlisting">public class SimplePojo implements Pojo {

   public void foo() {
      <i class="lineannotation"><span class="lineannotation">// this next method invocation is a <span class="bold"><b>direct</b></span> call on the 'this' reference</span></i>
      this.bar();
   }
   
   public void bar() {
      <i class="lineannotation"><span class="lineannotation">// some logic...</span></i>
   }
}</pre><p>If you invoke a method on an object reference, the method is
      invoked <span class="emphasis"><em>directly</em></span> on that object reference, as can
      be seen below.</p><div class="mediaobject" align="center"><img src="images/aop-proxy-plain-pojo-call.png" align="middle"></div><pre class="programlisting">public class Main {

   public static void main(String[] args) {
   
      Pojo pojo = new SimplePojo();
      
      <i class="lineannotation"><span class="lineannotation">// this is a <span class="bold"><b>direct</b></span> method call on the 'pojo' reference</span></i>
      pojo.foo();
   }
}</pre><p>Things change slightly when the reference that client code has is
      a proxy. Consider the following diagram and code snippet.</p><div class="mediaobject" align="center"><img src="images/aop-proxy-call.png" align="middle"></div><pre class="programlisting">public class Main {

   public static void main(String[] args) {
   
      ProxyFactory factory = new ProxyFactory(new SimplePojo());
      factory.addInterface(Pojo.class);
      factory.addAdvice(new RetryAdvice());

      Pojo pojo = (Pojo) factory.getProxy();
      
      <i class="lineannotation"><span class="lineannotation">// this is a method call <span class="bold"><b>on the proxy!</b></span></span></i>
      pojo.foo();
   }
}</pre><p>The key thing to understand here is that the client code inside
      the <tt class="methodname">main(..)</tt> of the <tt class="classname">Main</tt>
      class <span class="emphasis"><em>has a reference to the proxy</em></span>. This means that
      method calls on that object reference will be calls on the proxy, and as
      such the proxy will be able to delegate to all of the interceptors
      (advice) that are relevant to that particular method call. However, once
      the call has finally reached the target object, the
      <tt class="classname">SimplePojo</tt> reference in this case, any method
      calls that it may make on itself, such as
      <tt class="methodname">this.bar()</tt> or
      <tt class="methodname">this.foo()</tt>, are going to be invoked against the
      <span class="emphasis"><em><tt class="literal">this</tt></em></span> reference, and
      <span class="emphasis"><em>not</em></span> the proxy. This has important implications. It
      means that self-invocation is <span class="emphasis"><em>not</em></span> going to result
      in the advice associated with a method invocation getting a chance to
      execute.</p><p>Okay, so what is to be done about this? The best approach (the
      term best is used loosely here) is to refactor your code such that the
      self-invocation does not happen. For sure, this does entail some work on
      your part, but it is the best, least-invasive approach. The next
      approach is absolutely horrendous, and I am almost reticent to point it
      out precisely because it is so horrendous. You can (choke!) totally tie
      the logic within your class to Spring AOP by doing this:</p><pre class="programlisting">public class SimplePojo implements Pojo {

   public void foo() {
      <i class="lineannotation"><span class="lineannotation">// this works, but... gah!</span></i>
      ((Pojo) AopContext.currentProxy()).bar();
   }
   
   public void bar() {
      <i class="lineannotation"><span class="lineannotation">// some logic...</span></i>
   }
}</pre><p>This totally couples your code to Spring AOP,
      <span class="emphasis"><em>and</em></span> it makes the class itself aware of the fact
      that it is being used in an AOP context, which flies in the face of AOP.
      It also requires some additional configuration when the proxy is being
      created:</p><pre class="programlisting">public class Main {

   public static void main(String[] args) {
   
      ProxyFactory factory = new ProxyFactory(new SimplePojo());
      factory.adddInterface(Pojo.class);
      factory.addAdvice(new RetryAdvice());
      <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>factory.setExposeProxy(true);</b></span></span></i>

      Pojo pojo = (Pojo) factory.getProxy();

      <i class="lineannotation"><span class="lineannotation">// this is a method call <span class="bold"><b>on the proxy!</b></span></span></i>
      pojo.foo();
   }
}</pre><p>Finally, it must be noted that AspectJ does not have this
      self-invocation issue because it is not a proxy-based AOP
      framework.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-aspectj-programmatic"></a>6.7.&nbsp;Programmatic creation of @AspectJ Proxies</h2></div></div><div></div></div><p>In addition to declaring aspects in your configuration using either
    <tt class="literal">&lt;aop:config&gt;</tt> or
    <tt class="literal">&lt;aop:aspectj-autoproxy&gt;</tt>, it is also possible
    programmatically to create proxies that advise target objects. For the
    full details of Spring's AOP API, see the next chapter. Here we want to
    focus on the ability to automatically create proxies using @AspectJ
    aspects.</p><p>The class
    <tt class="classname">org.springframework.aop.aspectj.annotation.AspectJProxyFactory</tt>
    can be used to create a proxy for a target object that is advised by one
    or more @AspectJ aspects. Basic usage for this class is very simple, as
    illustrated below. See the Javadocs for full information.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// create a factory that can generate a proxy for the given target object</span></i>
AspectJProxyFactory factory = new AspectJProxyFactory(targetObject); 

<i class="lineannotation"><span class="lineannotation">// add an aspect, the class must be an @AspectJ aspect
// you can call this as many times as you need with different aspects</span></i>
factory.addAspect(SecurityManager.class);

<i class="lineannotation"><span class="lineannotation">// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect</span></i>
factory.addAspect(usageTracker);	

<i class="lineannotation"><span class="lineannotation">// now get the proxy object...</span></i>
MyInterfaceType proxy = factory.getProxy();</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-using-aspectj"></a>6.8.&nbsp;Using AspectJ with Spring applications</h2></div></div><div></div></div><p>Everything we've covered so far in this chapter is pure Spring AOP.
    In this section, we're going to look at how you can use the AspectJ
    compiler/weaver instead of, or in addition to, Spring AOP if your needs go
    beyond the facilities offered by Spring AOP alone.</p><p>Spring ships with a small AspectJ aspect library, which is available
    standalone in your distribution as <tt class="filename">spring-aspects.jar</tt>; you'll need to add this
    to your classpath in order to use the aspects in it. <a href="#aop-atconfigurable" title="6.8.1.&nbsp;Using AspectJ to dependency inject domain objects with&#xA;      Spring">Section&nbsp;6.8.1, &#8220;Using AspectJ to dependency inject domain objects with
      Spring&#8221;</a> and <a href="#aop-ajlib-other" title="6.8.2.&nbsp;Other Spring aspects for AspectJ">Section&nbsp;6.8.2, &#8220;Other Spring aspects for AspectJ&#8221;</a>
    discuss the content of this library and how you can use it. <a href="#aop-aj-configure" title="6.8.3.&nbsp;Configuring AspectJ aspects using Spring IoC">Section&nbsp;6.8.3, &#8220;Configuring AspectJ aspects using Spring IoC&#8221;</a> discusses how to dependency inject AspectJ
    aspects that are woven using the AspectJ compiler. Finally, <a href="#aop-aj-ltw" title="6.8.4.&nbsp;Load-time weaving with AspectJ in the Spring Framework">Section&nbsp;6.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221;</a> provides an introduction to load-time weaving for
    Spring applications using AspectJ.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-atconfigurable"></a>6.8.1.&nbsp;Using AspectJ to dependency inject domain objects with
      Spring</h3></div></div><div></div></div><p>The Spring container instantiates and configures beans defined in
      your application context. It is also possible to ask a bean factory to
      configure a <span class="emphasis"><em>pre-existing</em></span> object given the name of a
      bean definition containing the configuration to be applied. The
      <tt class="filename">spring-aspects.jar</tt> contains an
      annotation-driven aspect that exploits this capability to allow
      dependency injection of <span class="emphasis"><em>any object</em></span>. The support is
      intended to be used for objects created <span class="emphasis"><em>outside of the control
      of any container</em></span>. Domain objects often fall into this
      category because they are often created programmatically using the
      <tt class="literal">new</tt> operator, or by an ORM tool as a result of a
      database query.</p><p>The <tt class="interfacename">@Configurable</tt> annotation marks
      a class as eligible for Spring-driven configuration. In the simplest
      case it can be used just as a marker annotation:</p><pre class="programlisting">package com.xyz.myapp.domain;

import org.springframework.beans.factory.annotation.Configurable;

@Configurable
public class Account {
   <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>When used as a marker interface in this way, Spring will configure
      new instances of the annotated type (<tt class="classname">Account</tt> in
      this case) using a prototype-scoped bean definition with the same name
      as the fully-qualified type name
      (<tt class="classname">com.xyz.myapp.domain.Account</tt>). Since the default
      name for a bean is the fully-qualified name of its type, a convenient
      way to declare the prototype definition is simply to omit the
      <tt class="literal">id</tt> attribute:</p><pre class="programlisting">&lt;bean class="com.xyz.myapp.domain.Account" scope="prototype"&gt;
  &lt;property name="fundsTransferService" ref="fundsTransferService"/&gt;
&lt;/bean&gt;</pre><p>If you want to explicitly specify the name of the prototype bean
      definition to use, you can do so directly in the annotation:</p><pre class="programlisting">package com.xyz.myapp.domain;

import org.springframework.beans.factory.annotation.Configurable;

@Configurable("account")
public class Account {
   <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>Spring will now look for a bean definition named
      "<tt class="literal">account</tt>" and use that as the definition to configure
      new <tt class="classname">Account</tt> instances.</p><p>You can also use autowiring to avoid having to specify a
      prototype-scoped bean definition at all. To have Spring apply autowiring
      use the '<tt class="literal">autowire</tt>' property of the
      <tt class="interfacename">@Configurable</tt> annotation: specify either
      <tt class="literal">@Configurable(autowire=Autowire.BY_TYPE)</tt> or
      <tt class="literal">@Configurable(autowire=Autowire.BY_NAME</tt> for
      autowiring by type or by name respectively. As an alternative, as of
      Spring 2.5 it is preferable to specify explicit, annotation-driven 
      dependency injection for your <tt class="interfacename">@Configurable</tt> 
      beans by using <tt class="interfacename">@Autowired</tt> and
      <tt class="interfacename">@Resource</tt> at the field or method level (see 
      <a href="#beans-annotation-config" title="3.11.&nbsp;Annotation-based configuration">Section&nbsp;3.11, &#8220;Annotation-based configuration&#8221;</a> for further details).</p><p>Finally you can enable Spring dependency checking for the object
      references in the newly created and configured object by using the
      <tt class="literal">dependencyCheck</tt> attribute (for example:
      <tt class="literal">@Configurable(autowire=Autowire.BY_NAME,dependencyCheck=true)</tt>).
      If this attribute is set to true, then Spring will validate after
      configuration that all properties (<span class="emphasis"><em>which are not primitives or
      collections</em></span>) have been set.</p><p>Using the annotation on its own does nothing of course. It is the
      <tt class="classname">AnnotationBeanConfigurerAspect</tt> in <tt class="filename">spring-aspects.jar</tt> that acts on the
      presence of the annotation. In essence the aspect says "after returning
      from the initialization of a new object of a type annotated with
      <tt class="interfacename">@Configurable</tt>, configure the newly
      created object using Spring in accordance with the properties of the
      annotation". In this context, <span class="emphasis"><em>initialization</em></span> refers
      to newly instantiated objects (e.g., objects instantiated with the
      '<tt class="literal">new</tt>' operator) as well as to
      <tt class="interfacename">Serializable</tt> objects that are undergoing
      deserialization (e.g., via <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/io/Serializable.html" target="_top">readResolve()</a>).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>One of the key phrases in the above paragraph is '<span class="emphasis"><em>in
        essence</em></span>'. For most cases, the exact semantics of
        '<span class="emphasis"><em>after returning from the initialization of a new
        object</em></span>' will be fine... in this context, '<span class="emphasis"><em>after
        initialization</em></span>' means that the dependencies will be
        injected <span class="emphasis"><em>after</em></span> the object has been constructed -
        this means that the dependencies will not be available for use in the
        constructor bodies of the class. If you want the dependencies to be
        injected <span class="emphasis"><em>before</em></span> the constructor bodies execute,
        and thus be available for use in the body of the constructors, then
        you need to define this on the
        <tt class="interfacename">@Configurable</tt> declaration like
        so:</p><pre class="programlisting">@Configurable(preConstruction=true)</pre><p>You can find out more information about the language semantics
        of the various pointcut types in AspectJ <a href="http://www.eclipse.org/aspectj/doc/next/progguide/semantics-joinPoints.html" target="_top">in
        this appendix</a> of the <a href="http://www.eclipse.org/aspectj/doc/next/progguide/index.html" target="_top">AspectJ
        Programming Guide</a>.</p></td></tr></table></div><p>For this to work the annotated types must be woven with the
      AspectJ weaver - you can either use a build-time Ant or Maven task to do
      this (see for example the <a href="http://www.eclipse.org/aspectj/doc/released/devguide/antTasks.html" target="_top">AspectJ
      Development Environment Guide</a>) or load-time weaving (see <a href="#aop-aj-ltw" title="6.8.4.&nbsp;Load-time weaving with AspectJ in the Spring Framework">Section&nbsp;6.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221;</a>). The
      <tt class="classname">AnnotationBeanConfigurerAspect</tt> itself needs
      configuring by Spring (in order to obtain a reference to the bean
      factory that is to be used to configure new objects). The Spring <a href="#xsd-config-body-schemas-context" title="A.2.8.&nbsp;The context schema"><tt class="literal">context</tt>
      namespace</a> defines a convenient tag for doing this: just include
      the following in your application context configuration:</p><pre class="programlisting">&lt;context:spring-configured/&gt;</pre><p>If you are using the DTD instead of schema, the equivalent
      definition is:</p><pre class="programlisting">&lt;bean 
      class="org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"
      factory-method="aspectOf"/&gt;</pre><p>Instances of <tt class="interfacename">@Configurable</tt> objects
      created <span class="emphasis"><em>before</em></span> the aspect has been configured will
      result in a warning being issued to the log and no configuration of the
      object taking place. An example might be a bean in the Spring
      configuration that creates domain objects when it is initialized by
      Spring. In this case you can use the "depends-on" bean attribute to
      manually specify that the bean depends on the configuration
      aspect.</p><pre class="programlisting">&lt;bean id="myService"
  class="com.xzy.myapp.service.MyService"
  depends-on="org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- ... --&gt;</span></i>

&lt;/bean&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-configurable-testing"></a>6.8.1.1.&nbsp;Unit testing <tt class="interfacename">@Configurable</tt>
        objects</h4></div></div><div></div></div><p>One of the goals of the
        <tt class="interfacename">@Configurable</tt> support is to enable
        independent unit testing of domain objects without the difficulties
        associated with hard-coded lookups. If
        <tt class="interfacename">@Configurable</tt> types have not been woven
        by AspectJ then the annotation has no affect during unit testing, and
        you can simply set mock or stub property references in the object
        under test and proceed as normal. If
        <tt class="interfacename">@Configurable</tt> types
        <span class="emphasis"><em>have</em></span> been woven by AspectJ then you can still
        unit test outside of the container as normal, but you will see a
        warning message each time that you construct an
        <tt class="interfacename">@Configurable</tt> object indicating that it
        has not been configured by Spring.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-configurable-container"></a>6.8.1.2.&nbsp;Working with multiple application contexts</h4></div></div><div></div></div><p>The <tt class="classname">AnnotationBeanConfigurerAspect</tt> used
        to implement the <tt class="interfacename">@Configurable</tt> support
        is an AspectJ singleton aspect. The scope of a singleton aspect is the
        same as the scope of <tt class="literal">static</tt> members, that is to say
        there is one aspect instance per classloader that defines the type.
        This means that if you define multiple application contexts within the
        same classloader hierarchy you need to consider where to define the
        <tt class="literal">&lt;context:spring-configured/&gt;</tt> bean and where to
        place <tt class="filename">spring-aspects.jar</tt> on
        the classpath.</p><p>Consider a typical Spring web-app configuration with a shared
        parent application context defining common business services and
        everything needed to support them, and one child application context
        per servlet containing definitions particular to that servlet. All of
        these contexts will co-exist within the same classloader hierarchy,
        and so the <tt class="literal">AnnotationBeanConfigurerAspect</tt> can only
        hold a reference to one of them. In this case we recommend defining
        the <tt class="literal">&lt;context:spring-configured/&gt;</tt> bean in the
        shared (parent) application context: this defines the services that
        you are likely to want to inject into domain objects. A consequence is
        that you cannot configure domain objects with references to beans
        defined in the child (servlet-specific) contexts using the
        @Configurable mechanism (probably not something you want to do
        anyway!).</p><p>When deploying multiple web-apps within the same container,
        ensure that each web-application loads the types in <tt class="filename">spring-aspects.jar</tt> using its own
        classloader (for example, by placing <tt class="filename">spring-aspects.jar</tt> in <tt class="filename">'WEB-INF/lib'</tt>). If <tt class="filename">spring-aspects.jar</tt> is only added to the
        container wide classpath (and hence loaded by the shared parent
        classloader), all web applications will share the same aspect instance
        which is probably not what you want.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ajlib-other"></a>6.8.2.&nbsp;Other Spring aspects for AspectJ</h3></div></div><div></div></div><p>In addition to the <tt class="interfacename">@Configurable</tt>
      aspect, <tt class="filename">spring-aspects.jar</tt>
      contains an AspectJ aspect that can be used to drive Spring's
      transaction management for types and methods annotated with the
      <tt class="interfacename">@Transactional</tt> annotation. This is
      primarily intended for users who want to use the Spring Framework's
      transaction support outside of the Spring container.</p><p>The aspect that interprets
      <tt class="interfacename">@Transactional</tt> annotations is the
      <tt class="classname">AnnotationTransactionAspect</tt>. When using this
      aspect, you must annotate the <span class="emphasis"><em>implementation</em></span> class
      (and/or methods within that class), <span class="emphasis"><em>not</em></span> the
      interface (if any) that the class implements. AspectJ follows Java's
      rule that annotations on interfaces are <span class="emphasis"><em>not
      inherited</em></span>.</p><p>A <tt class="interfacename">@Transactional</tt> annotation on a
      class specifies the default transaction semantics for the execution of
      any <span class="emphasis"><em>public</em></span> operation in the class.</p><p>A <tt class="interfacename">@Transactional</tt> annotation on a
      method within the class overrides the default transaction semantics
      given by the class annotation (if present). Methods with
      <tt class="literal">public</tt>, <tt class="literal">protected</tt>, and default
      visibility may all be annotated. Annotating <tt class="literal">protected</tt>
      and default visibility methods directly is the only way to get
      transaction demarcation for the execution of such methods.</p><p>For AspectJ programmers that want to use the Spring configuration
      and transaction management support but don't want to (or cannot) use
      annotations, <tt class="filename">spring-aspects.jar</tt>
      also contains <tt class="literal">abstract</tt> aspects you can extend to
      provide your own pointcut definitions. See the sources for the
      <tt class="classname">AbstractBeanConfigurerAspect</tt> and
      <tt class="classname">AbstractTransactionAspect</tt> aspects for more
      information. As an example, the following excerpt shows how you could
      write an aspect to configure all instances of objects defined in the
      domain model using prototype bean definitions that match the
      fully-qualified class names:</p><pre class="programlisting">public aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect {

  public DomainObjectConfiguration() {
    setBeanWiringInfoResolver(new ClassNameBeanWiringInfoResolver());
  }

  <i class="lineannotation"><span class="lineannotation">// the creation of a new bean (any object in the domain model)</span></i>
  protected pointcut beanCreation(Object beanInstance) :
    initialization(new(..)) &amp;&amp;
    SystemArchitecture.inDomainModel() &amp;&amp; 
    this(beanInstance);
		   		   
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-aj-configure"></a>6.8.3.&nbsp;Configuring AspectJ aspects using Spring IoC</h3></div></div><div></div></div><p>When using AspectJ aspects with Spring applications, it is natural
      to both want and expect to be able to configure such aspects using
      Spring. The AspectJ runtime itself is responsible for aspect creation,
      and the means of configuring the AspectJ created aspects via Spring
      depends on the AspectJ instantiation model (the
      '<tt class="literal">per-xxx</tt>' clause) used by the aspect.</p><p>The majority of AspectJ aspects are <span class="emphasis"><em>singleton</em></span>
      aspects. Configuration of these aspects is very easy: simply create a
      bean definition referencing the aspect type as normal, and include the
      bean attribute <tt class="literal">'factory-method="aspectOf"'</tt>. This
      ensures that Spring obtains the aspect instance by asking AspectJ for it
      rather than trying to create an instance itself. For example:</p><pre class="programlisting">&lt;bean id="profiler" class="com.xyz.profiler.Profiler"
      <span class="bold"><b>factory-method="aspectOf"</b></span>&gt;
  &lt;property name="profilingStrategy" ref="jamonProfilingStrategy"/&gt;
&lt;/bean&gt;</pre><p>Non-singleton aspects are harder to configure: however it is
      possible to do so by creating prototype bean definitions and using the
      <tt class="interfacename">@Configurable</tt> support from <tt class="filename">spring-aspects.jar</tt> to configure the
      aspect instances once they have bean created by the AspectJ
      runtime.</p><p>If you have some @AspectJ aspects that you want to weave with
      AspectJ (for example, using load-time weaving for domain model types)
      and other @AspectJ aspects that you want to use with Spring AOP, and
      these aspects are all configured using Spring, then you will need to
      tell the Spring AOP @AspectJ autoproxying support which exact subset of
      the @AspectJ aspects defined in the configuration should be used for
      autoproxying. You can do this by using one or more
      <tt class="literal">&lt;include/&gt;</tt> elements inside the
      <tt class="literal">&lt;aop:aspectj-autoproxy/&gt;</tt> declaration. Each
      <tt class="literal">&lt;include/&gt;</tt> element specifies a name pattern,
      and only beans with names matched by at least one of the patterns will
      be used for Spring AOP autoproxy configuration:</p><pre class="programlisting">&lt;aop:aspectj-autoproxy&gt;
  &lt;aop:include name="thisBean"/&gt;
  &lt;aop:include name="thatBean"/&gt;
&lt;/aop:aspectj-autoproxy&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Do not be misled by the name of the
        <tt class="literal">&lt;aop:aspectj-autoproxy/&gt;</tt> element: using it
        will result in the creation of <span class="emphasis"><em>Spring AOP
        proxies</em></span>. The @AspectJ style of aspect declaration is just
        being used here, but the AspectJ runtime is <span class="emphasis"><em>not</em></span>
        involved.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-aj-ltw"></a>6.8.4.&nbsp;Load-time weaving with AspectJ in the Spring Framework</h3></div></div><div></div></div><p>Load-time weaving (LTW) refers to the process of weaving AspectJ
      aspects into an application's class files as they are being loaded into
      the Java virtual machine (JVM). The focus of this section is on
      configuring and using LTW in the specific context of the Spring
      Framework: this section is not an introduction to LTW though. For full
      details on the specifics of LTW and configuring LTW with just AspectJ
      (with Spring not being involved at all), see the <a href="http://www.eclipse.org/aspectj/doc/released/devguide/ltw.html" target="_top">LTW
      section of the AspectJ Development Environment Guide</a>.</p><p>The value-add that the Spring Framework brings to AspectJ LTW is
      in enabling much finer-grained control over the weaving process.
      'Vanilla' AspectJ LTW is effected using a Java (5+) agent, which is
      switched on by specifying a VM argument when starting up a JVM. It is
      thus a JVM-wide setting, which may be fine in some situations, but often
      is a little too coarse. Spring-enabled LTW enables you to switch on LTW
      on a <span class="emphasis"><em>per-<tt class="classname">ClassLoader</tt></em></span> basis,
      which obviously is more fine-grained and which can make more sense in a
      'single-JVM-multiple-application' environment (such as is found in a
      typical application server environment).</p><p>Further, <a href="#aop-aj-ltw-environments" title="6.8.4.6.&nbsp;Environment-specific configuration">in certain
      environments</a>, this support enables load-time weaving
      <span class="emphasis"><em>without making any modifications to the application server's
      launch script</em></span> that will be needed to add
      -javaagent:path/to/aspectjweaver.jar or (as we describe later in this
      section) -javaagent:path/to/spring-agent.jar. Developers simply modify
      one or more files that form the application context to enable load-time
      weaving instead of relying on administrators who typically are in charge
      of the deployment configuration such as the launch script.</p><p>Now that the sales pitch is over, let us first walk through a
      quick example of AspectJ LTW using Spring, followed by detailed
      specifics about elements introduced in the following example. For a
      complete example, please see the Petclinic sample application.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-first-example"></a>6.8.4.1.&nbsp;A first example</h4></div></div><div></div></div><p>Let us assume that you are an application developer who has been
        tasked with diagnosing the cause of some performance problems in a
        system. Rather than break out a profiling tool, what we are going to
        do is switch on a simple profiling aspect that will enable us to very
        quickly get some performance metrics, so that we can then apply a
        finer-grained profiling tool to that specific area immediately
        afterwards.</p><p>Here is the profiling aspect. Nothing too fancy, just a
        quick-and-dirty time-based profiler, using the @AspectJ-style of
        aspect declaration.</p><pre class="programlisting">package foo;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.util.StopWatch;
import org.springframework.core.annotation.Order;

@Aspect
public class ProfilingAspect {

    @Around("methodsToBeProfiled()")
    public Object profile(ProceedingJoinPoint pjp) throws Throwable {
        StopWatch sw = new StopWatch(getClass().getSimpleName());
        try {
            sw.start(pjp.getSignature().getName());
            return pjp.proceed();
        } finally {
            sw.stop();
            System.out.println(sw.prettyPrint());
        }
    }

    @Pointcut("execution(public * foo..*.*(..))")
    public void methodsToBeProfiled(){}
}
</pre><p>We will also need to create an
        '<tt class="filename">META-INF/aop.xml</tt>' file, to inform the AspectJ
        weaver that we want to weave our
        <tt class="classname">ProfilingAspect</tt> into our classes. This file
        convention, namely the presence of a file (or files) on the Java
        classpath called ' <tt class="filename">META-INF/aop.xml</tt>' is standard
        AspectJ.</p><pre class="programlisting">&lt;!DOCTYPE aspectj PUBLIC
        "-//AspectJ//DTD//EN" "http://www.eclipse.org/aspectj/dtd/aspectj.dtd"&gt;
&lt;aspectj&gt;

    &lt;weaver&gt;

        <i class="lineannotation"><span class="lineannotation">&lt;!-- only weave classes in our application-specific packages --&gt;</span></i>
        &lt;include within="foo.*"/&gt;

    &lt;/weaver&gt;

    &lt;aspects&gt;

        <i class="lineannotation"><span class="lineannotation">&lt;!-- weave in just this aspect --&gt;</span></i>        
        &lt;aspect name="foo.ProfilingAspect"/&gt;

    &lt;/aspects&gt;

  &lt;/aspectj&gt;</pre><p>Now to the Spring-specific portion of the configuration. We need
        to configure a <tt class="interfacename">LoadTimeWeaver</tt> (all
        explained later, just take it on trust for now). This load-time weaver
        is the essential component responsible for weaving the aspect
        configuration in one or more '<tt class="filename">META-INF/aop.xml</tt>'
        files into the classes in your application. The good thing is that it
        does not require a lot of configuration, as can be seen below (there
        are some more options that you can specify, but these are detailed
        later).</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- a service object; we will be profiling its methods --&gt;</span></i>
    &lt;bean id="entitlementCalculationService"
          class="foo.StubEntitlementCalculationService"/&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- this switches on the load-time weaving --&gt;</span></i>
    <span class="bold"><b>&lt;context:load-time-weaver/&gt;</b></span>

&lt;/beans&gt;</pre><p>Now that all the required artifacts are in place - the aspect,
        the '<tt class="filename">META-INF/aop.xml</tt>' file, and the Spring
        configuration -, let us create a simple driver class with a
        <tt class="methodname">main(..)</tt> method to demonstrate the LTW in
        action.</p><pre class="programlisting">package foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Main {

    public static void main(String[] args) {

        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml", Main.class);

        EntitlementCalculationService entitlementCalculationService
            = (EntitlementCalculationService) ctx.getBean("entitlementCalculationService");

        <i class="lineannotation"><span class="lineannotation">// the profiling aspect is 'woven' around this method execution</span></i>
        entitlementCalculationService.calculateEntitlement();
    }
}</pre><p>There is one last thing to do. The introduction to this section
        did say that one could switch on LTW selectively on a
        per-<tt class="classname">ClassLoader</tt> basis with Spring, and this is
        true. However, just for this example, we are going to use a Java agent
        (supplied with Spring) to switch on the LTW. This is the command line
        we will use to run the above <tt class="classname">Main</tt> class:</p><pre class="programlisting">java -javaagent:C:/projects/foo/lib/global/spring-agent.jar foo.Main</pre><p>The '<tt class="literal">-javaagent</tt>' is a Java 5+ flag for
        specifying and enabling <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/instrument/package-summary.html" target="_top">agents
        to instrument programs running on the JVM</a>. The Spring
        Framework ships with such an agent, the
        <tt class="classname">InstrumentationSavingAgent</tt>, which is packaged
        in the <tt class="filename">spring-agent.jar</tt> that
        was supplied as the value of the <tt class="literal">-javaagent</tt>
        argument in the above example.</p><p>The output from the execution of the <tt class="classname">Main</tt>
        program will look something like that below. (I have introduced a
        <tt class="methodname">Thread.sleep(..)</tt> statement into the
        <tt class="methodname">calculateEntitlement()</tt> implementation so that
        the profiler actually captures something other than 0 milliseconds -
        the <tt class="literal">01234</tt> milliseconds is <span class="emphasis"><em>not</em></span>
        an overhead introduced by the AOP :) )</p><pre class="programlisting">Calculating entitlement

StopWatch 'ProfilingAspect': running time (millis) = 1234
------ ----- ----------------------------
ms     %     Task name
------ ----- ----------------------------
01234  100%  calculateEntitlement</pre><p>Since this LTW is effected using full-blown AspectJ, we are not
        just limited to advising Spring beans; the following slight variation
        on the <tt class="classname">Main</tt> program will yield the same
        result.</p><pre class="programlisting">package foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public final class Main {

    public static void main(String[] args) {

        new ClassPathXmlApplicationContext("beans.xml", Main.class);

        EntitlementCalculationService entitlementCalculationService =
            new StubEntitlementCalculationService();

        <i class="lineannotation"><span class="lineannotation">// the profiling aspect will be 'woven' around this method execution</span></i>
        entitlementCalculationService.calculateEntitlement();
    }
}</pre><p>Notice how in the above program we are simply bootstrapping the
        Spring container, and then creating a new instance of the
        <tt class="classname">StubEntitlementCalculationService</tt> totally
        outside the context of Spring... the profiling advice still gets woven
        in.</p><p>The example admittedly is simplistic... however the basics of
        the LTW support in Spring have all been introduced in the above
        example, and the rest of this section will explain the 'why' behind
        each bit of configuration and usage in detail.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The <tt class="classname">ProfilingAspect</tt> used in this
          example may be basic, but it is quite useful. It is a nice example
          of a development-time aspect that developers can use during
          development (of course), and then quite easily exclude from builds
          of the application being deployed into UAT or production.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-the-aspects"></a>6.8.4.2.&nbsp;Aspects</h4></div></div><div></div></div><p>The aspects that you use in LTW have to be AspectJ aspects. They
        can be written in either the AspectJ language itself or you can write
        your aspects in the @AspectJ-style. The latter option is of course
        only an option if you are using Java 5+, but it does mean that your
        aspects are then both valid AspectJ <span class="emphasis"><em>and</em></span> Spring
        AOP aspects. Furthermore, the compiled aspect classes need to be
        available on the classpath.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-aop_dot_xml"></a>6.8.4.3.&nbsp;'<tt class="filename">META-INF/aop.xml</tt>'</h4></div></div><div></div></div><p>The AspectJ LTW infrastructure is configured using one or more
        '<tt class="filename">META-INF/aop.xml</tt>' files, that are on the Java
        classpath (either directly, or more typically in jar files).</p><p>The structure and contents of this file is detailed in the main
        AspectJ reference documentation, and the interested reader is <a href="http://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html" target="_top">referred
        to that resource</a>. (I appreciate that this section is brief,
        but the '<tt class="filename">aop.xml</tt>' file is 100% AspectJ - there is
        no Spring-specific information or semantics that apply to it, and so
        there is no extra value that I can contribute either as a result), so
        rather than rehash the quite satisfactory section that the AspectJ
        developers wrote, I am just directing you there.)</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-libraries"></a>6.8.4.4.&nbsp;Required libraries (JARS)</h4></div></div><div></div></div><p>At a minimum you will need the following libraries to use the
        Spring Framework's support for AspectJ LTW:</p><div class="orderedlist"><ol type="1"><li><p><tt class="filename">spring.jar</tt> (version
            2.5 or later)</p></li><li><p><tt class="filename">aspectjrt.jar</tt>
            (version 1.5 or later)</p></li><li><p><tt class="filename">aspectjweaver.jar</tt>
            (version 1.5 or later)</p></li></ol></div><p>If you are using the <a href="#aop-aj-ltw-environment-generic" title="6.8.4.6.1.&nbsp;Generic Java applications">Spring-provided agent to
        enable instrumentation</a>, you will also need:</p><div class="orderedlist"><ol type="1"><li><p><tt class="filename">spring-agent.jar</tt></p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-spring"></a>6.8.4.5.&nbsp;Spring configuration</h4></div></div><div></div></div><p>The key component in Spring's LTW support is the
        <tt class="interfacename">LoadTimeWeaver</tt> interface (in the
        <tt class="literal">org.springframework.instrument.classloading</tt>
        package), and the numerous implementations of it that ship with the
        Spring distribution. A <tt class="interfacename">LoadTimeWeaver</tt>
        is responsible for adding one or more
        <tt class="classname">java.lang.instrument.ClassFileTransformers</tt> to a
        <tt class="classname">ClassLoader</tt> at runtime, which opens the door to
        all manner of interesting applications, one of which happens to be the
        LTW of aspects.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you are unfamiliar with the idea of runtime class file
          transformation, you are encouraged to read the Javadoc API
          documentation for the <tt class="literal">java.lang.instrument</tt>
          package before continuing. This is not a huge chore because there is
          - rather annoyingly - precious little documentation there... the key
          interfaces and classes will at least be laid out in front of you for
          reference as you read through this section.</p></td></tr></table></div><p>Configuring a <tt class="interfacename">LoadTimeWeaver</tt>
        using XML for a particular
        <tt class="interfacename">ApplicationContext</tt> can be as easy as
        adding one line. (Please note that you almost certainly will need to
        be using an <tt class="interfacename">ApplicationContext</tt> as your
        Spring container - typically a
        <tt class="interfacename">BeanFactory</tt> will not be enough because
        the LTW support makes use of
        <tt class="interfacename">BeanFactoryPostProcessors</tt>.)</p><p>To enable the Spring Framework's LTW support, you need to
        configure a <tt class="interfacename">LoadTimeWeaver</tt>, which
        typically is done using the
        <tt class="literal">&lt;context:load-time-weaver/&gt;</tt> element. Find
        below a valid <tt class="literal">&lt;context:load-time-weaver/&gt;</tt>
        definition that uses default settings.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    &lt;context:load-time-weaver/&gt;

&lt;/beans&gt;</pre><p>The above <tt class="literal">&lt;context:load-time-weaver/&gt;</tt>
        bean definition will define and register a number of LTW-specific
        infrastructure beans for you automatically, such as a
        <tt class="interfacename">LoadTimeWeaver</tt> and an
        <tt class="classname">AspectJWeavingEnabler</tt>. Notice how the
        <tt class="literal">&lt;context:load-time-weaver/&gt;</tt> is defined in the
        '<tt class="literal">context</tt>' namespace; note also that the referenced
        XML Schema file is only available in versions of Spring 2.5 and
        later.</p><p>What the above configuration does is define and register a
        default <tt class="interfacename">LoadTimeWeaver</tt> bean for you.
        The default <tt class="interfacename">LoadTimeWeaver</tt> is the
        <tt class="classname">DefaultContextLoadTimeWeaver</tt> class, which
        attempts to decorate an automatically detected
        <tt class="interfacename">LoadTimeWeaver</tt>: the exact type of
        <tt class="interfacename">LoadTimeWeaver</tt> that will be
        'automatically detected' is dependent upon your runtime environment
        (summarised in the following table).</p><div class="table"><a name="aop-aj-ltw-spring-env-impls"></a><p class="title"><b>Table&nbsp;6.1.&nbsp;<tt class="classname">DefaultContextLoadTimeWeaver</tt>
          <tt class="interfacename">LoadTimeWeavers</tt></b></p><table summary="DefaultContextLoadTimeWeaver&#xA;          LoadTimeWeavers" width="100%" border="1"><colgroup><col align="left"><col></colgroup><thead><tr><th align="left">Runtime Environment</th><th><tt class="interfacename">LoadTimeWeaver</tt> implementation</th></tr></thead><tbody><tr><td align="left"><p>Running in <a href="http://www.bea.com/framework.jsp?CNT=index.htm&amp;FP=/content/products/weblogic/server" target="_top">BEA's
                Weblogic 10</a></p></td><td><p><tt class="classname">WebLogicLoadTimeWeaver</tt></p></td></tr><tr><td align="left"><p>Running in <a href="http://www.oracle.com/technology/products/oc4j/index.html" target="_top">Oracle's
                OC4J</a></p></td><td><p><tt class="classname">OC4JLoadTimeWeaver</tt></p></td></tr><tr><td align="left"><p>Running in <a href="http://glassfish.dev.java.net/" target="_top">GlassFish</a></p></td><td><p><tt class="classname">GlassFishLoadTimeWeaver</tt></p></td></tr><tr><td align="left"><p>JVM started with Spring
                <tt class="classname">InstrumentationSavingAgent</tt></p><p><span class="emphasis"><em><tt class="literal">(java
                -javaagent:path/to/spring-agent.jar)</tt></em></span></p></td><td><p><tt class="classname">InstrumentationLoadTimeWeaver</tt></p></td></tr><tr><td align="left"><p>Fallback, expecting the underlying ClassLoader to follow common conventions
                (e.g. applicable to <tt class="classname">TomcatInstrumentableClassLoader</tt> and to Resin)</p></td><td><p><tt class="classname">ReflectiveLoadTimeWeaver</tt></p></td></tr></tbody></table></div><p>Note that these are just the
        <tt class="interfacename">LoadTimeWeavers</tt> that are autodetected
        when using the <tt class="classname">DefaultContextLoadTimeWeaver</tt>: it
        is of course possible to specify exactly which
        <tt class="interfacename">LoadTimeWeaver</tt> implementation that you
        wish to use by specifying the fully-qualified classname as the value
        of the '<tt class="literal">weaver-class</tt>' attribute of the
        <tt class="literal">&lt;context:load-time-weaver/&gt;</tt> element. Find
        below an example of doing just that:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    &lt;context:load-time-weaver
            <span class="bold"><b>weaver-class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"</b></span>/&gt;

&lt;/beans&gt;</pre><p>The <tt class="interfacename">LoadTimeWeaver</tt> that is
        defined and registered by the
        <tt class="literal">&lt;context:load-time-weaver/&gt;</tt> element can be
        later retrieved from the Spring container using the well-known name
        '<tt class="literal">loadTimeWeaver</tt>'. Remember that the
        <tt class="interfacename">LoadTimeWeaver</tt> exists just as a
        mechanism for Spring's LTW infrastructure to add one or more
        <tt class="interfacename">ClassFileTransformers</tt>. The actual
        <tt class="classname">ClassFileTransformer</tt> that does the LTW is the
        <tt class="classname">ClassPreProcessorAgentAdapter</tt> (from the
        <tt class="literal">org.aspectj.weaver.loadtime</tt> package) class. See the
        class-level Javadoc for the
        <tt class="classname">ClassPreProcessorAgentAdapter</tt> class for further
        details, because the specifics of how the weaving is actually effected
        is beyond the scope of this section.</p><p>There is one final attribute of the
        <tt class="literal">&lt;context:load-time-weaver/&gt;</tt> left to discuss:
        the '<tt class="literal">aspectj-weaving</tt>' attribute. This is a simple
        attribute that controls whether LTW is enabled or not, it is as simple
        as that. It accepts one of three possible values, summarised below,
        with the default value if the attribute is not present being '
        <tt class="literal">autodetect</tt>'</p><div class="table"><a name="aop-aj-ltw-ltw-tag-attrs"></a><p class="title"><b>Table&nbsp;6.2.&nbsp;'<tt class="literal">aspectj-weaving</tt>' attribute values</b></p><table summary="'aspectj-weaving' attribute values" width="100%" border="1"><colgroup><col align="left"><col></colgroup><thead><tr><th align="left">Attribute Value</th><th>Explanation</th></tr></thead><tbody><tr><td align="left"><p><tt class="literal">on</tt></p></td><td><p>AspectJ weaving is on, and aspects will be woven
                at load-time as appropriate.</p></td></tr><tr><td align="left"><p><tt class="literal">off</tt></p></td><td><p>LTW is off... no aspect will be woven at
                load-time.</p></td></tr><tr><td align="left"><p><tt class="literal">autodetect</tt></p></td><td><p>If the Spring LTW infrastructure can find at
                least one '<tt class="filename">META-INF/aop.xml</tt>' file, then
                AspectJ weaving is on, else it is off. This is the default
                value.</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-aj-ltw-environments"></a>6.8.4.6.&nbsp;Environment-specific configuration</h4></div></div><div></div></div><p>This last section contains any additional settings and
        configuration that you will need when using Spring's LTW support in
        environments such as application servers and web containers.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="aop-aj-ltw-environment-generic"></a>6.8.4.6.1.&nbsp;Generic Java applications</h5></div></div><div></div></div><p>You may enable Spring's support for LTW in any Java application
          (standalone as well as application server based) through the use of
          the Spring-provided instrumentation agent. To do so, start
          the VM by by specifying the
          <tt class="literal">-javaagent:path/to/spring-agent.jar</tt> option.
          Note that this requires modification of the VM launch script
          which may prevent you from using this in application server
          environments (depending on your operation policies).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="aop-aj-ltw-environment-tomcat"></a>6.8.4.6.2.&nbsp;Tomcat</h5></div></div><div></div></div><p>For web applications deployed onto Apache Tomcat 5.0 and above,
          Spring provides a <tt class="classname">TomcatInstrumentableClassLoader</tt>
          to be registered as the web app class loader. The required Tomcat setup
          looks as follows, to be included either in Tomcat's central
          <tt class="literal">server.xml</tt> file or in an application-specific
          <tt class="literal">META-INF/context.xml</tt> file within the WAR root.
          Spring's <tt class="literal">spring-tomcat-weaver.jar</tt> needs to be
          included in Tomcat's common lib directory in order to make this
          setup work.</p><pre class="programlisting">&lt;Context path="/myWebApp" docBase="/my/webApp/location"&gt;
    &lt;Loader loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"
            useSystemClassLoaderAsParent="false"/&gt;
&lt;/Context&gt;
</pre><p><span class="emphasis"><em>Note: We generally recommend Tomcat 5.5.20 or above
          when enabling load-time weaving.</em></span> Prior versions have known
          issues with custom <tt class="classname">ClassLoader</tt> setup.</p><p>Alternatively, consider the use of the Spring-provided generic
          VM agent, to be specified in Tomcat's launch script (see above).
          This will make instrumentation available to all deployed web
          applications, no matter which ClassLoader they happen to run on.</p><p>For a more detailed discussion of Tomcat-based weaving setup,
          check out the <a href="#orm-jpa-setup-lcemfb-tomcat" title="12.6.1.3.1.&nbsp;Tomcat load-time weaving setup (5.0+)">Section&nbsp;12.6.1.3.1, &#8220;Tomcat load-time weaving setup (5.0+)&#8221;</a> section
          which discusses specifics of various Tomcat versions. While the primary
          focus of that section is on JPA persistence provider setup, the Tomcat
          setup characteristics apply to general load-time weaving as well.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="aop-aj-ltw-environments-weblogic-oc4j-resin-glassfish"></a>6.8.4.6.3.&nbsp;WebLogic, OC4J, Resin, GlassFish</h5></div></div><div></div></div><p>Recent versions of BEA WebLogic (version 10 and above), Oracle
          Containers for Java EE (OC4J 10.1.3.1 and above) and Resin (3.1 and above)
          provide a ClassLoader that is capable of local instrumentation.
          Spring's native LTW leverages such ClassLoaders to enable AspectJ weaving.
          You can enable LTW by simply activating <tt class="literal">context:load-time-weaver</tt>
          as described earlier. Specifically, you do <span class="emphasis"><em>not</em></span>
          need to modify the launch script to add
          <tt class="literal">-javaagent:path/to/spring-agent.jar</tt>.</p><p>GlassFish provides an instrumentation-capable ClassLoader as well,
          but only in its EAR environment. For GlassFish web applications,
          follow the Tomcat setup instructions as outlined above.</p></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-resources"></a>6.9.&nbsp;Further Resources</h2></div></div><div></div></div><p>More information on AspectJ can be found on the <a href="http://www.eclipse.org/aspectj" target="_top">AspectJ website</a>.</p><p>The book <span class="emphasis"><em>Eclipse AspectJ</em></span> by Adrian Colyer et.
    al. (Addison-Wesley, 2005) provides a comprehensive introduction and
    reference for the AspectJ language.</p><p>The book <span class="emphasis"><em>AspectJ in Action</em></span> by Ramnivas Laddad
    (Manning, 2003) comes highly recommended; the focus of the book is on
    AspectJ, but a lot of general AOP themes are explored (in some depth).</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="aop-api"></a>Chapter&nbsp;7.&nbsp;Spring AOP APIs</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-api-introduction"></a>7.1.&nbsp;Introduction</h2></div></div><div></div></div><p>The previous chapter described the Spring 2.0 support for AOP using
	@AspectJ and schema-based aspect definitions. In this chapter we discuss 
	the lower-level Spring AOP APIs and the AOP support used in Spring 1.2 applications.
	For new applications, we recommend the use of the Spring 2.0 AOP support 
	described in the previous chapter, but when working with existing applications,
	or when reading books and articles, you may come across Spring 1.2 style examples.
	Spring 2.0 is fully backwards compatible with Spring 1.2 and everything described
	in this chapter is fully supported in Spring 2.0.
	</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-api-pointcuts"></a>7.2.&nbsp;Pointcut API in Spring</h2></div></div><div></div></div><p>Let's look at how Spring handles the crucial pointcut concept.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-concepts"></a>7.2.1.&nbsp;Concepts</h3></div></div><div></div></div><p>Spring's pointcut model enables pointcut reuse independent of
      advice types. It's possible to target different advice using the same
      pointcut.</p><p>The <tt class="literal">org.springframework.aop.Pointcut</tt> interface
      is the central interface, used to target advices to particular classes
      and methods. The complete interface is shown below:</p><pre class="programlisting">public interface Pointcut {

    ClassFilter getClassFilter();

    MethodMatcher getMethodMatcher();

}</pre><p>Splitting the <tt class="interfacename">Pointcut</tt> interface into two parts
      allows reuse of class and method matching parts, and fine-grained
      composition operations (such as performing a "union" with another method
      matcher).</p><p>The <tt class="interfacename">ClassFilter</tt> interface is used to restrict
      the pointcut to a given set of target classes. If the
      <tt class="literal">matches()</tt> method always returns true, all target
      classes will be matched:</p><pre class="programlisting">public interface ClassFilter {

    boolean matches(Class clazz);
}</pre><p>The <tt class="interfacename">MethodMatcher</tt> interface is normally more
      important. The complete interface is shown below:</p><pre class="programlisting">public interface MethodMatcher {

    boolean matches(Method m, Class targetClass);

    boolean isRuntime();

    boolean matches(Method m, Class targetClass, Object[] args);
}</pre><p>The <tt class="literal">matches(Method, Class) </tt>method is used to
      test whether this pointcut will ever match a given method on a target
      class. This evaluation can be performed when an AOP proxy is created, to
      avoid the need for a test on every method invocation. If the 2-argument
      matches method returns true for a given method, and the
      <tt class="literal">isRuntime()</tt> method for the MethodMatcher returns
      true, the 3-argument matches method will be invoked on every method
      invocation. This enables a pointcut to look at the arguments passed to
      the method invocation immediately before the target advice is to
      execute.</p><p>Most MethodMatchers are static, meaning that their
      <tt class="literal">isRuntime()</tt> method returns false. In this case, the
      3-argument matches method will never be invoked.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>If possible, try to make pointcuts static, allowing the AOP
				framework to cache the results of pointcut evaluation when an AOP proxy
				is created.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-pointcut-ops"></a>7.2.2.&nbsp;Operations on pointcuts</h3></div></div><div></div></div><p>Spring supports operations on pointcuts: notably,
      <span class="emphasis"><em>union</em></span> and <span class="emphasis"><em>intersection</em></span>.</p><div class="itemizedlist"><ul type="disc"><li><p>Union means the methods that either pointcut matches.</p></li><li><p>Intersection means the methods that both pointcuts match.</p></li><li><p>Union is usually more useful.</p></li><li><p>Pointcuts can be composed using the static methods in the
					<span class="emphasis"><em>org.springframework.aop.support.Pointcuts</em></span> class, or
					using the <span class="emphasis"><em>ComposablePointcut</em></span> class in the same
					package. However, using AspectJ pointcut expressions is usually a
					simpler approach.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-pointcuts-aspectj"></a>7.2.3.&nbsp;AspectJ expression pointcuts</h3></div></div><div></div></div><p>Since 2.0, the most important type of pointcut used by Spring is
      <tt class="literal">org.springframework.aop.aspectj.AspectJExpressionPointcut</tt>.
      This is a pointcut that uses an AspectJ supplied library to parse an AspectJ
      pointcut expression string.</p><p>See the previous chapter for a discussion of supported AspectJ pointcut
      primitives.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-pointcuts-impls"></a>7.2.4.&nbsp;Convenience pointcut implementations</h3></div></div><div></div></div><p>Spring provides several convenient pointcut implementations. Some
      can be used out of the box; others are intended to be subclassed in
      application-specific pointcuts.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-pointcuts-static"></a>7.2.4.1.&nbsp;Static pointcuts</h4></div></div><div></div></div><p>Static pointcuts are based on method and target class, and
        cannot take into account the method's arguments. Static pointcuts are
        sufficient - <span class="emphasis"><em>and best</em></span> - for most usages. It's possible for Spring to
        evaluate a static pointcut only once, when a method is first invoked:
        after that, there is no need to evaluate the pointcut again with each
        method invocation.</p><p>Let's consider some static pointcut implementations included
        with Spring.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="aop-api-pointcuts-regex"></a>7.2.4.1.1.&nbsp;Regular expression pointcuts</h5></div></div><div></div></div><p>One obvious way to specify static pointcuts is regular
          expressions. Several AOP frameworks besides Spring make this
          possible.
          <tt class="literal">org.springframework.aop.support.Perl5RegexpMethodPointcut</tt>
          is a generic regular expression pointcut, using Perl 5 regular
          expression syntax. The <tt class="literal">Perl5RegexpMethodPointcut</tt>
          class depends on Jakarta ORO for regular expression matching. Spring
          also provides the <tt class="literal">JdkRegexpMethodPointcut</tt> class
          that uses the regular expression support in JDK 1.4+.</p><p>Using the <tt class="literal">Perl5RegexpMethodPointcut</tt> class,
          you can provide a list of pattern Strings. If any of these is a
          match, the pointcut will evaluate to true. (So the result is
          effectively the union of these pointcuts.)</p><p>The usage is shown below:</p><pre class="programlisting">&lt;bean id="settersAndAbsquatulatePointcut" 
    class="org.springframework.aop.support.Perl5RegexpMethodPointcut"&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;.*set.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Spring provides a convenience class,
          <tt class="literal">RegexpMethodPointcutAdvisor</tt>, that allows us to
          also reference an Advice (remember that an Advice can be an
          interceptor, before advice, throws advice etc.). Behind the scenes,
          Spring will use a <tt class="literal">JdkRegexpMethodPointcut</tt>. Using
          <tt class="literal">RegexpMethodPointcutAdvisor</tt> simplifies wiring,
          as the one bean encapsulates both pointcut and advice, as shown
          below:</p><pre class="programlisting">&lt;bean id="settersAndAbsquatulateAdvisor" 
    class="org.springframework.aop.support.RegexpMethodPointcutAdvisor"&gt;
    &lt;property name="advice"&gt;
        &lt;ref local="beanNameOfAopAllianceInterceptor"/&gt;
    &lt;/property&gt;
    &lt;property name="patterns"&gt;
        &lt;list&gt;
            &lt;value&gt;.*set.*&lt;/value&gt;
            &lt;value&gt;.*absquatulate&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p><span class="emphasis"><em>RegexpMethodPointcutAdvisor</em></span> can be used
          with any Advice type.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="aop-api-pointcuts-attribute-driven"></a>7.2.4.1.2.&nbsp;Attribute-driven pointcuts</h5></div></div><div></div></div><p>An important type of static pointcut is a
          <span class="emphasis"><em>metadata-driven</em></span> pointcut. This uses the values
          of metadata attributes: typically, source-level metadata.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-pointcuts-dynamic"></a>7.2.4.2.&nbsp;Dynamic pointcuts</h4></div></div><div></div></div><p>Dynamic pointcuts are costlier to evaluate than static
        pointcuts. They take into account method
        <span class="emphasis"><em>arguments</em></span>, as well as static information. This
        means that they must be evaluated with every method invocation; the
        result cannot be cached, as arguments will vary.</p><p>The main example is the <tt class="literal">control flow</tt>
        pointcut.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="aop-api-pointcuts-cflow"></a>7.2.4.2.1.&nbsp;Control flow pointcuts</h5></div></div><div></div></div><p>Spring control flow pointcuts are conceptually similar to
          AspectJ <span class="emphasis"><em>cflow</em></span> pointcuts, although less
          powerful. (There is currently no way to specify that a pointcut
          executes below a join point matched by another pointcut.) 
          A control flow pointcut matches
          the current call stack. For example, it might fire if the join point
          was invoked by a method in the <tt class="literal">com.mycompany.web</tt>
          package, or by the <tt class="literal">SomeCaller</tt> class. Control flow
          pointcuts are specified using the
          <tt class="literal">org.springframework.aop.support.ControlFlowPointcut
          </tt>class.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Control flow pointcuts are significantly more expensive to
              evaluate at runtime than even other dynamic pointcuts. In Java 1.4,
              the cost is about 5 times that of other dynamic pointcuts.</p></td></tr></table></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-pointcuts-superclasses"></a>7.2.5.&nbsp;Pointcut superclasses</h3></div></div><div></div></div><p>Spring provides useful pointcut superclasses to help you to
      implement your own pointcuts.</p><p>Because static pointcuts are most useful, you'll probably subclass
      StaticMethodMatcherPointcut, as shown below. This requires implementing
      just one abstract method (although it's possible to override other
      methods to customize behavior):</p><pre class="programlisting">class TestStaticPointcut extends StaticMethodMatcherPointcut {

    public boolean matches(Method m, Class targetClass) {
        // return true if custom criteria match
    }
}</pre><p>There are also superclasses for dynamic pointcuts.</p><p>You can use custom pointcuts with any advice type in Spring 1.0
      RC2 and above.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-pointcuts-custom"></a>7.2.6.&nbsp;Custom pointcuts</h3></div></div><div></div></div><p>Because pointcuts in Spring AOP are Java classes, rather than
      language features (as in AspectJ) it's possible to declare custom
      pointcuts, whether static or dynamic. Custom pointcuts in Spring can be
      arbitrarily complex. However, using the AspectJ pointcut expression
      language is recommended if possible.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Later versions of Spring may offer support for "semantic
				pointcuts" as offered by JAC: for example, "all methods that change
				instance variables in the target object."</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-api-advice"></a>7.3.&nbsp;Advice API in Spring</h2></div></div><div></div></div><p>Let's now look at how Spring AOP handles advice.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-advice-lifecycle"></a>7.3.1.&nbsp;Advice lifecycles</h3></div></div><div></div></div><p>Each advice is a Spring bean. An advice instance can be shared across all 
      advised objects, or unique
      to each advised object. This corresponds to
      <span class="emphasis"><em>per-class</em></span> or <span class="emphasis"><em>per-instance</em></span>
      advice.</p><p>Per-class advice is used most often. It is appropriate for generic
      advice such as transaction advisors. These do not depend on the state of
      the proxied object or add new state; they merely act on the method and
      arguments.</p><p>Per-instance advice is appropriate for introductions, to support
      mixins. In this case, the advice adds state to the proxied
      object.</p><p>It's possible to use a mix of shared and per-instance advice in
      the same AOP proxy.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-advice-types"></a>7.3.2.&nbsp;Advice types in Spring</h3></div></div><div></div></div><p>Spring provides several advice types out of the box, and is
      extensible to support arbitrary advice types. Let us look at the basic
      concepts and standard advice types.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-advice-around"></a>7.3.2.1.&nbsp;Interception around advice</h4></div></div><div></div></div><p>The most fundamental advice type in Spring is
        <span class="emphasis"><em>interception around advice</em></span>.</p><p>Spring is compliant with the AOP Alliance interface for around
        advice using method interception. MethodInterceptors implementing
        around advice should implement the following interface:</p><pre class="programlisting">public interface MethodInterceptor extends Interceptor {
  
    Object invoke(MethodInvocation invocation) throws Throwable;
}</pre><p>The <tt class="classname">MethodInvocation</tt> argument to the
        <tt class="methodname">invoke()</tt> method exposes the method being invoked;
        the target join point; the AOP proxy; and the arguments to the method.
        The <tt class="methodname">invoke()</tt> method should return the
        invocation's result: the return value of the join point.</p><p>A simple <tt class="classname">MethodInterceptor</tt> implementation
        looks as follows:</p><pre class="programlisting">public class DebugInterceptor implements MethodInterceptor {

    public Object invoke(MethodInvocation invocation) throws Throwable {
        System.out.println("Before: invocation=[" + invocation + "]");
        Object rval = invocation.proceed();
        System.out.println("Invocation returned");
        return rval;
    }
}</pre><p>Note the call to the MethodInvocation's
        <tt class="methodname">proceed()</tt> method. This proceeds down the
        interceptor chain towards the join point. Most interceptors will invoke
        this method, and return its return value. However, a
        MethodInterceptor, like any around advice, can return a different
        value or throw an exception rather than invoke the proceed method.
        However, you don't want to do this without good reason!</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>MethodInterceptors offer interoperability with other AOP
        Alliance-compliant AOP implementations. The other advice types
        discussed in the remainder of this section implement common AOP
        concepts, but in a Spring-specific way. While there is an advantage in
        using the most specific advice type, stick with MethodInterceptor
        around advice if you are likely to want to run the aspect in another
        AOP framework. Note that pointcuts are not currently interoperable
        between frameworks, and the AOP Alliance does not currently define
        pointcut interfaces.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-advice-before"></a>7.3.2.2.&nbsp;Before advice</h4></div></div><div></div></div><p>A simpler advice type is a <span class="bold"><b>before
        advice</b></span>. This does not need a
        <tt class="literal">MethodInvocation</tt> object, since it will only be
        called before entering the method.</p><p>The main advantage of a before advice is that there is no need
        to invoke the <tt class="literal">proceed() </tt>method, and therefore no
        possibility of inadvertently failing to proceed down the interceptor
        chain.</p><p>The <tt class="literal">MethodBeforeAdvice</tt> interface is shown
        below. (Spring's API design would allow for field before advice,
        although the usual objects apply to field interception and it's
        unlikely that Spring will ever implement it).</p><pre class="programlisting">public interface MethodBeforeAdvice extends BeforeAdvice {

    void before(Method m, Object[] args, Object target) throws Throwable;
}</pre><p>Note the return type is <tt class="literal">void</tt>. Before
        advice can insert custom behavior before the join point executes, but
        cannot change the return value. If a before advice throws an
        exception, this will abort further execution of the interceptor chain.
        The exception will propagate back up the interceptor chain. If it is
        unchecked, or on the signature of the invoked method, it will be
        passed directly to the client; otherwise it will be wrapped in an
        unchecked exception by the AOP proxy.</p><p>An example of a before advice in Spring, which counts all method
        invocations:</p><pre class="programlisting">public class CountingBeforeAdvice implements MethodBeforeAdvice {

    private int count;

    public void before(Method m, Object[] args, Object target) throws Throwable {
        ++count;
    }

    public int getCount() { 
        return count; 
    }
}</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>Before advice can be used with any pointcut.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-advice-throws"></a>7.3.2.3.&nbsp;Throws advice</h4></div></div><div></div></div><p><span class="bold"><b>Throws advice</b></span> is invoked after
        the return of the join point if the join point threw an exception.
        Spring offers typed throws advice. Note that this means that the
        <tt class="literal">org.springframework.aop.ThrowsAdvice</tt> interface does
        not contain any methods: It is a tag interface identifying that the
        given object implements one or more typed throws advice methods. These
        should be in the form of:</p><pre class="programlisting">afterThrowing([Method, args, target], subclassOfThrowable) </pre><p>Only the last argument is required. The method signatures may
        have either one or four arguments, depending on whether the advice
        method is interested in the method and arguments. The following
        classes are examples of throws advice.</p><p>The advice below is invoked if a <tt class="exceptionname">RemoteException</tt>
    		is thrown (including subclasses):</p><pre class="programlisting">public class RemoteThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        <i class="lineannotation"><span class="lineannotation">// Do something with remote exception</span></i>
    }
}</pre><p>The following advice is invoked if a
        <tt class="exceptionname">ServletException</tt> is thrown. Unlike the above
        advice, it declares 4 arguments, so that it has access to the invoked
        method, method arguments and target object:</p><pre class="programlisting">public class ServletThrowsAdviceWithArguments implements ThrowsAdvice {

    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        <i class="lineannotation"><span class="lineannotation">// Do something with all arguments</span></i>
    }
}</pre><p>The final example illustrates how these two methods could be
        used in a single class, which handles both
        <tt class="literal">RemoteException</tt> and
        <tt class="literal">ServletException</tt>. Any number of throws advice
        methods can be combined in a single class.</p><pre class="programlisting">public static class CombinedThrowsAdvice implements ThrowsAdvice {

    public void afterThrowing(RemoteException ex) throws Throwable {
        // Do something with remote exception
    }
 
    public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) {
        // Do something with all arguments
    }
}</pre><p><span class="emphasis"><em>Note:</em></span> If a throws-advice method throws an exception itself,
        it will override the original exception (i.e. change the exception thrown to the user).
        The overriding exception will typically be a RuntimeException; this is compatible with
        any method signature. However, if a throws-advice method throws a checked exception,
        it will have to match the declared exceptions of the target method and is hence to some
        degree coupled to specific target method signatures. <span class="emphasis"><em>Do not throw an undeclared
        checked exception that is incompatible with the target method's signature!</em></span></p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>Throws advice can be used with any pointcut.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-advice-after-returning"></a>7.3.2.4.&nbsp;After Returning advice</h4></div></div><div></div></div><p>An after returning advice in Spring must implement the
        <span class="emphasis"><em>org.springframework.aop.AfterReturningAdvice</em></span>
        interface, shown below:</p><pre class="programlisting">public interface AfterReturningAdvice extends Advice {

    void afterReturning(Object returnValue, Method m, Object[] args, Object target) 
            throws Throwable;
}</pre><p>An after returning advice has access to the return value (which
        it cannot modify), invoked method, methods arguments and
        target.</p><p>The following after returning advice counts all successful
        method invocations that have not thrown exceptions:</p><pre class="programlisting">public class CountingAfterReturningAdvice implements AfterReturningAdvice {

    private int count;

    public void afterReturning(Object returnValue, Method m, Object[] args, Object target)
            throws Throwable {
        ++count;
    }

    public int getCount() {
        return count;
    }
}</pre><p>This advice doesn't change the execution path. If it throws an
        exception, this will be thrown up the interceptor chain instead of the
        return value.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>After returning advice can be used with any pointcut.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-advice-introduction"></a>7.3.2.5.&nbsp;Introduction advice</h4></div></div><div></div></div><p>Spring treats introduction advice as a special kind of
        interception advice.</p><p>Introduction requires an <tt class="literal">IntroductionAdvisor</tt>,
        and an <tt class="literal">IntroductionInterceptor</tt>, implementing the
        following interface:</p><pre class="programlisting">public interface IntroductionInterceptor extends MethodInterceptor {

    boolean implementsInterface(Class intf);
}</pre><p>The <tt class="literal">invoke() </tt>method inherited from the AOP
        Alliance <tt class="literal">MethodInterceptor</tt> interface must implement
        the introduction: that is, if the invoked method is on an introduced
        interface, the introduction interceptor is responsible for handling
        the method call - it cannot invoke <tt class="literal">proceed()</tt>.</p><p>Introduction advice cannot be used with any pointcut, as it
        applies only at class, rather than method, level. You can only use
        introduction advice with the <tt class="literal">IntroductionAdvisor</tt>,
        which has the following methods:</p><pre class="programlisting">public interface IntroductionAdvisor extends Advisor, IntroductionInfo {

	ClassFilter getClassFilter();

	void validateInterfaces() throws IllegalArgumentException;
}

public interface IntroductionInfo {

	Class[] getInterfaces();
}</pre><p>There is no <tt class="interfacename">MethodMatcher</tt>, and hence no
        <tt class="interfacename">Pointcut</tt>, associated with introduction advice. Only
        class filtering is logical.</p><p>The <tt class="literal">getInterfaces()</tt> method returns the
        interfaces introduced by this advisor.</p>

         The 

        <tt class="literal">validateInterfaces()</tt>

         method is used internally to see whether or not the introduced interfaces can be implemented by the configured 

        <tt class="literal">IntroductionInterceptor</tt>

         . 

        <p>Let's look at a simple example from the Spring test suite. Let's
        suppose we want to introduce the following interface to one or more
        objects:</p><p>
          </p><pre class="programlisting">public interface Lockable {
    void lock();
    void unlock();
    boolean locked();
}</pre><p>
        </p><p>This illustrates a <span class="bold"><b>mixin</b></span>. We
        want to be able to cast advised objects to Lockable, whatever their
        type, and call lock and unlock methods. If we call the lock() method,
        we want all setter methods to throw a
        <tt class="literal">LockedException</tt>. Thus we can add an aspect that
        provides the ability to make objects immutable, without them having
        any knowledge of it: a good example of AOP.</p><p>Firstly, we'll need an
        <tt class="literal">IntroductionInterceptor</tt> that does the heavy
        lifting. In this case, we extend the
        <tt class="literal">org.springframework.aop.support.DelegatingIntroductionInterceptor</tt>
        convenience class. We could implement IntroductionInterceptor
        directly, but using
        <tt class="literal">DelegatingIntroductionInterceptor</tt> is best for most
        cases.</p><p>The <tt class="literal">DelegatingIntroductionInterceptor</tt> is
        designed to delegate an introduction to an actual implementation of
        the introduced interface(s), concealing the use of interception to do
        so. The delegate can be set to any object using a constructor
        argument; the default delegate (when the no-arg constructor is used)
        is this. Thus in the example below, the delegate is the
        <tt class="literal">LockMixin</tt> subclass of
        <tt class="literal">DelegatingIntroductionInterceptor</tt>. Given a delegate
        (by default itself), a
        <tt class="literal">DelegatingIntroductionInterceptor</tt> instance looks
        for all interfaces implemented by the delegate (other than
        IntroductionInterceptor), and will support introductions against any
        of them. It's possible for subclasses such as
        <tt class="literal">LockMixin</tt> to call the
        <tt class="literal">suppressInterface(Class intf) </tt>method to suppress
        interfaces that should not be exposed. However, no matter how many
        interfaces an <tt class="literal">IntroductionInterceptor</tt> is prepared
        to support, the <tt class="literal">IntroductionAdvisor</tt> used will
        control which interfaces are actually exposed. An introduced interface
        will conceal any implementation of the same interface by the
        target.</p><p>Thus LockMixin subclasses
        <tt class="literal">DelegatingIntroductionInterceptor</tt> and implements
        Lockable itself. The superclass automatically picks up that Lockable
        can be supported for introduction, so we don't need to specify that.
        We could introduce any number of interfaces in this way.</p><p>Note the use of the <tt class="literal">locked</tt> instance variable.
        This effectively adds additional state to that held in the target
        object.</p><p>
          </p><pre class="programlisting">public class LockMixin extends DelegatingIntroductionInterceptor 
    implements Lockable {

    private boolean locked;

    public void lock() {
        this.locked = true;
    }

    public void unlock() {
        this.locked = false;
    }

    public boolean locked() {
        return this.locked;
    }

    public Object invoke(MethodInvocation invocation) throws Throwable {
        if (locked() &amp;&amp; invocation.getMethod().getName().indexOf("set") == 0)
            throw new LockedException();
        return super.invoke(invocation);
    }

}</pre><p>
        </p><p>Often it isn't necessary to override the <tt class="literal">invoke()
        </tt>method: the
        <tt class="literal">DelegatingIntroductionInterceptor</tt>
        implementation - which calls the delegate method if the method is
        introduced, otherwise proceeds towards the join point - is usually
        sufficient. In the present case, we need to add a check: no setter
        method can be invoked if in locked mode.</p><p>The introduction advisor required is simple. All it needs to do
        is hold a distinct <tt class="literal">LockMixin</tt> instance, and specify
        the introduced interfaces - in this case, just
        <tt class="literal">Lockable</tt>. A more complex example might take a
        reference to the introduction interceptor (which would be defined as a
        prototype): in this case, there's no configuration relevant for a
        <tt class="literal">LockMixin</tt>, so we simply create it using
        <tt class="literal">new</tt>.</p><p>
          </p><pre class="programlisting">public class LockMixinAdvisor extends DefaultIntroductionAdvisor {

    public LockMixinAdvisor() {
        super(new LockMixin(), Lockable.class);
    }
}</pre><p>
        </p><p>We can apply this advisor very simply: it requires no
        configuration. (However, it <span class="emphasis"><em>is</em></span> necessary: It's
        impossible to use an <tt class="literal">IntroductionInterceptor</tt>
        without an <span class="emphasis"><em>IntroductionAdvisor</em></span>.) As usual with
        introductions, the advisor must be per-instance, as it is stateful. We
        need a different instance of <tt class="literal">LockMixinAdvisor</tt>, and
        hence <tt class="literal">LockMixin</tt>, for each advised object. The
        advisor comprises part of the advised object's state.</p><p>We can apply this advisor programmatically, using the
        <tt class="literal">Advised.addAdvisor() </tt>method, or (the recommended
        way) in XML configuration, like any other advisor. All proxy creation
        choices discussed below, including "auto proxy creators," correctly
        handle introductions and stateful mixins.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-api-advisor"></a>7.4.&nbsp;Advisor API in Spring</h2></div></div><div></div></div><p>In Spring, an Advisor is an aspect that contains just a single advice
    object associated with a pointcut expression.</p><p>Apart from the special case of introductions, any advisor can be
    used with any advice.
    <tt class="literal">org.springframework.aop.support.DefaultPointcutAdvisor</tt>
    is the most commonly used advisor class. For example, it can be used with
    a <tt class="literal">MethodInterceptor</tt>, <tt class="literal">BeforeAdvice</tt> or
    <tt class="literal">ThrowsAdvice</tt>.</p><p>It is possible to mix advisor and advice types in Spring in the same
    AOP proxy. For example, you could use a interception around advice, throws
    advice and before advice in one proxy configuration: Spring will
    automatically create the necessary interceptor chain.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-pfb"></a>7.5.&nbsp;Using the ProxyFactoryBean to create AOP proxies</h2></div></div><div></div></div><p>If you're using the Spring IoC container (an ApplicationContext or
    BeanFactory) for your business objects - and you should be! - you will want
    to use one of Spring's AOP FactoryBeans. (Remember that a factory bean
    introduces a layer of indirection, enabling it to create objects of a
    different type.)</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The Spring 2.0 AOP support also uses factory beans under the covers.</p></td></tr></table></div><p>The basic way to create an AOP proxy in Spring is to use the
    <span class="emphasis"><em>org.springframework.aop.framework.ProxyFactoryBean</em></span>.
    This gives complete control over the pointcuts and advice that will apply,
    and their ordering. However, there are simpler options that are preferable
    if you don't need such control.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-pfb-1"></a>7.5.1.&nbsp;Basics</h3></div></div><div></div></div><p>The <tt class="literal">ProxyFactoryBean</tt>, like other Spring
      <tt class="literal">FactoryBean</tt> implementations, introduces a level of
      indirection. If you define a <tt class="literal">ProxyFactoryBean</tt> with
      name <tt class="literal">foo</tt>, what objects referencing
      <tt class="literal">foo</tt> see is not the
      <tt class="literal">ProxyFactoryBean</tt> instance itself, but an object
      created by the <tt class="literal">ProxyFactoryBean</tt>'s implementation of
      the <tt class="literal">getObject() </tt>method. This method will create an
      AOP proxy wrapping a target object.</p><p>One of the most important benefits of using a
      <tt class="literal">ProxyFactoryBean</tt> or another IoC-aware class to create
      AOP proxies, is that it means that advices and pointcuts can also be
      managed by IoC. This is a powerful feature, enabling certain approaches
      that are hard to achieve with other AOP frameworks. For example, an
      advice may itself reference application objects (besides the target,
      which should be available in any AOP framework), benefiting from all the
      pluggability provided by Dependency Injection.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-pfb-2"></a>7.5.2.&nbsp;JavaBean properties</h3></div></div><div></div></div><p>
		In common with most <tt class="interfacename">FactoryBean</tt> implementations
		provided with Spring, the <tt class="classname">ProxyFactoryBean</tt> class is
		itself a JavaBean. Its properties are used to:
	  </p><div class="itemizedlist"><ul type="disc"><li><p>Specify the target you want to proxy.</p></li><li><p>Specify whether to use CGLIB (see below and also the section entitled
			<a href="#aop-pfb-proxy-types" title="7.5.3.&nbsp;JDK- and CGLIB-based proxies">Section&nbsp;7.5.3, &#8220;JDK- and CGLIB-based proxies&#8221;</a>).</p></li></ul></div><p>
		Some key properties are inherited from
		<tt class="classname">org.springframework.aop.framework.ProxyConfig</tt> (the
		superclass for all AOP proxy factories in Spring). These key properties include:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
			<tt class="literal">proxyTargetClass</tt>: <tt class="literal">true</tt> if the
			target class is to be proxied, rather than the target class' interfaces.
			If this property value is set to <tt class="literal">true</tt>, then CGLIB proxies
			will be created (but see also below the section entitled
			<a href="#aop-pfb-proxy-types" title="7.5.3.&nbsp;JDK- and CGLIB-based proxies">Section&nbsp;7.5.3, &#8220;JDK- and CGLIB-based proxies&#8221;</a>).
		  </p></li><li><p>
			<tt class="literal">optimize</tt>: controls whether or not aggressive
			optimizations are applied to proxies <span class="emphasis"><em>created via CGLIB</em></span>.
			One should not blithely use this setting unless one fully understands
			how the relevant AOP proxy handles optimization. This is currently used only
			for CGLIB proxies; it has no effect with JDK dynamic proxies.
          </p></li><li><p><tt class="literal">frozen</tt>: if a proxy configuration is <tt class="literal">frozen</tt>,
			then changes to the configuration are no longer allowed. This is useful both as
			a slight optimization and for those cases when you don't want callers to be able
			to manipulate the proxy (via the <tt class="interfacename">Advised</tt> interface)
			after the proxy has been created. The default value of this property is
			<tt class="literal">false</tt>, so changes such as adding additional advice are allowed.</p></li><li><p>
			<tt class="literal">exposeProxy</tt>: determines whether or not the current
			proxy should be exposed in a <tt class="classname">ThreadLocal</tt> so that
			it can be accessed by the target. If a target needs to obtain
			the proxy and the <tt class="literal">exposeProxy</tt> property is set to
			<tt class="literal">true</tt>, the target can use the
			<tt class="methodname">AopContext.currentProxy()</tt> method.
          </p></li><li><p>
			<tt class="literal">aopProxyFactory</tt>: the implementation of
			<tt class="interfacename">AopProxyFactory</tt> to use. Offers a way of
			customizing whether to use dynamic proxies, CGLIB or any other proxy
			strategy. The default implementation will choose dynamic proxies or
			CGLIB appropriately. There should be no need to use this property;
			it is intended to allow the addition of new proxy types in Spring 1.1.
          </p></li></ul></div><p>
		Other properties specific to <tt class="classname">ProxyFactoryBean</tt> include:
	  </p><div class="itemizedlist"><ul type="disc"><li><p>
			<tt class="literal">proxyInterfaces</tt>: array of String interface
			names. If this isn't supplied, a CGLIB proxy for the target class
			will be used (but see also below the section entitled
			<a href="#aop-pfb-proxy-types" title="7.5.3.&nbsp;JDK- and CGLIB-based proxies">Section&nbsp;7.5.3, &#8220;JDK- and CGLIB-based proxies&#8221;</a>).
          </p></li><li><p>
			<tt class="literal">interceptorNames</tt>: String array of
			<tt class="interfacename">Advisor</tt>, interceptor or other advice
			names to apply. Ordering is significant, on a first come-first served
			basis. That is to say that the first interceptor in the list
			will be the first to be able to intercept the invocation.
          </p><p>
			The names are bean names in the current factory, including
			bean names from ancestor factories. You can't mention bean
			references here since doing so would result in the
			<tt class="classname">ProxyFactoryBean</tt> ignoring the singleton
			setting of the advice.
          </p><p>
			You can append an interceptor name with an asterisk
			(<tt class="literal">*</tt>). This will result in the application of all
			advisor beans with names starting with the part before the asterisk
			to be applied. An example of using this feature can be found in
			<a href="#aop-global-advisors" title="7.5.6.&nbsp;Using 'global' advisors">Section&nbsp;7.5.6, &#8220;Using 'global' advisors&#8221;</a>.
          </p></li><li><p>
			singleton: whether or not the factory should return a single
			object, no matter how often the <tt class="literal">getObject()</tt>
			method is called. Several <tt class="interfacename">FactoryBean</tt>
			implementations offer such a method. The default value is
			<tt class="literal">true</tt>. If you	want to use stateful advice - 
			for example, for stateful mixins - use	prototype advices along
			with a singleton value of <tt class="literal">false</tt>.
          </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-pfb-proxy-types"></a>7.5.3.&nbsp;JDK- and CGLIB-based proxies</h3></div></div><div></div></div><p>
			This section serves as the definitive documentation on how the
			<tt class="classname">ProxyFactoryBean</tt> chooses to create one of
			either a JDK- and CGLIB-based proxy for a particular target object
			(that is to be proxied).
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
				The behavior of the <tt class="classname">ProxyFactoryBean</tt> with regard
				to creating JDK- or CGLIB-based proxies changed between versions 1.2.x and
				2.0 of Spring. The <tt class="classname">ProxyFactoryBean</tt> now
				exhibits similar semantics with regard to auto-detecting interfaces
				as those of the <tt class="classname">TransactionProxyFactoryBean</tt> class.		
			</p></td></tr></table></div><p>
			If the class of a target object that is to be proxied (hereafter simply
			referred to as the target class) doesn't implement any interfaces, then
			a CGLIB-based proxy will be created. This is the easiest scenario, because
			JDK proxies are interface based, and no interfaces means JDK proxying
			isn't even possible. One simply plugs in the target bean, and specifies the
			list of interceptors via the <tt class="literal">interceptorNames</tt> property.
			Note that a CGLIB-based proxy will be created even if the
			<tt class="literal">proxyTargetClass</tt> property of the
			<tt class="classname">ProxyFactoryBean</tt> has been set to <tt class="literal">false</tt>.
			(Obviously this makes no sense, and is best removed from the bean
			definition because it is at best redundant, and at worst confusing.)
		</p><p>
			If the target class implements one (or more) interfaces, then the type of
			proxy that is created depends on the configuration of the
			<tt class="classname">ProxyFactoryBean</tt>.
		</p><p>
			If the <tt class="literal">proxyTargetClass</tt> property of the
			<tt class="classname">ProxyFactoryBean</tt> has been set to <tt class="literal">true</tt>,
			then a CGLIB-based proxy will be created. This makes sense, and is in
			keeping with the principle of least surprise. Even if the
			<tt class="literal">proxyInterfaces</tt> property of the
			<tt class="classname">ProxyFactoryBean</tt> has been set to one or more
			fully qualified interface names, the fact that the
			<tt class="literal">proxyTargetClass</tt> property is set to 
			<tt class="literal">true</tt> <span class="emphasis"><em>will</em></span> cause
			CGLIB-based proxying to be in effect.
		</p><p>
			If the <tt class="literal">proxyInterfaces</tt> property of the
			<tt class="classname">ProxyFactoryBean</tt> has been set to one or more
			fully qualified interface names, then a JDK-based proxy will be created.
			The created proxy will implement all of the interfaces that were specified
			in the <tt class="literal">proxyInterfaces</tt> property; if the target class
			happens to implement a whole lot more interfaces than those specified in
			the <tt class="literal">proxyInterfaces</tt> property, that is all well and
			good but those additional interfaces will not be implemented by the
			returned proxy.
		</p><p>
			If the <tt class="literal">proxyInterfaces</tt> property of the
			<tt class="classname">ProxyFactoryBean</tt> has <span class="emphasis"><em>not</em></span> been
			set, but the target class <span class="emphasis"><em>does implement one (or more)</em></span>
			interfaces, then the <tt class="classname">ProxyFactoryBean</tt> will auto-detect
			the fact that the target class does actually implement at least one interface,
			and a JDK-based proxy will be created. The interfaces that are actually
			proxied will be <span class="emphasis"><em>all</em></span> of the interfaces that the target
			class implements; in effect, this is the same as simply supplying a list
			of each and every interface that the target class implements to the
			<tt class="literal">proxyInterfaces</tt> property. However, it is significantly less
			work, and less prone to typos.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-proxying-intf"></a>7.5.4.&nbsp;Proxying interfaces</h3></div></div><div></div></div><p>
		Let's look at a simple example of <tt class="classname">ProxyFactoryBean</tt>
		in action. This example involves:
      </p><div class="itemizedlist"><ul type="disc"><li><p>A <span class="emphasis"><em>target bean</em></span> that will be proxied. This
          is the "personTarget" bean definition in the example below.</p></li><li><p>An Advisor and an Interceptor used to provide advice.</p></li><li><p>An AOP proxy bean definition specifying the target object (the
          personTarget bean) and the interfaces to proxy, along with the
          advices to apply.</p></li></ul></div><pre class="programlisting">&lt;bean id="personTarget" class="com.mycompany.PersonImpl"&gt;
    &lt;property name="name"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;
    &lt;property name="age"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
    &lt;property name="someProperty"&gt;&lt;value&gt;Custom string property value&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"&gt;
&lt;/bean&gt;

&lt;bean id="person" 
    class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces"&gt;&lt;value&gt;com.mycompany.Person&lt;/value&gt;&lt;/property&gt;

    &lt;property name="target"&gt;&lt;ref local="personTarget"/&gt;&lt;/property&gt;
    &lt;property name="interceptorNames"&gt;
        &lt;list&gt;
            &lt;value&gt;myAdvisor&lt;/value&gt;
            &lt;value&gt;debugInterceptor&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that the <tt class="literal">interceptorNames</tt> property takes a
      list of String: the bean names of the interceptor or advisors in the
      current factory. Advisors, interceptors, before, after returning and
      throws advice objects can be used. The ordering of advisors is
      significant.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>You might be wondering why the list doesn't hold bean
				references. The reason for this is that if the ProxyFactoryBean's
				singleton property is set to false, it must be able to return
				independent proxy instances. If any of the advisors is itself a
				prototype, an independent instance would need to be returned, so it's
				necessary to be able to obtain an instance of the prototype from the
				factory; holding a reference isn't sufficient.</p></td></tr></table></div><p>The "person" bean definition above can be used in place of a
      Person implementation, as follows:</p><pre class="programlisting">Person person = (Person) factory.getBean("person");</pre><p>Other beans in the same IoC context can express a strongly typed
      dependency on it, as with an ordinary Java object:</p><pre class="programlisting">&lt;bean id="personUser" class="com.mycompany.PersonUser"&gt;
  &lt;property name="person"&gt;&lt;ref local="person" /&gt;&lt;/property&gt;
&lt;/bean&gt;</pre><p>The <tt class="literal">PersonUser</tt> class in this example would
      expose a property of type Person. As far as it's concerned, the AOP
      proxy can be used transparently in place of a "real" person
      implementation. However, its class would be a dynamic proxy class. It
      would be possible to cast it to the <tt class="literal">Advised</tt> interface
      (discussed below).</p><p>It's possible to conceal the distinction between target and proxy
      using an anonymous <span class="emphasis"><em>inner bean</em></span>, as follows. Only the
      <tt class="literal">ProxyFactoryBean</tt> definition is different; the advice
      is included only for completeness:</p><pre class="programlisting">&lt;bean id="myAdvisor" class="com.mycompany.MyAdvisor"&gt;
  &lt;property name="someProperty"&gt;&lt;value&gt;Custom string property value&lt;/value&gt;&lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="debugInterceptor" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;

&lt;bean id="person" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="proxyInterfaces"&gt;&lt;value&gt;com.mycompany.Person&lt;/value&gt;&lt;/property&gt;
  &lt;!-- Use inner bean, not local reference to target --&gt;
  &lt;property name="target"&gt;
    &lt;bean class="com.mycompany.PersonImpl"&gt;
      &lt;property name="name"&gt;&lt;value&gt;Tony&lt;/value&gt;&lt;/property&gt;
      &lt;property name="age"&gt;&lt;value&gt;51&lt;/value&gt;&lt;/property&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
  &lt;property name="interceptorNames"&gt;
    &lt;list&gt;
      &lt;value&gt;myAdvisor&lt;/value&gt;
      &lt;value&gt;debugInterceptor&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>This has the advantage that there's only one object of type
      <tt class="literal">Person</tt>: useful if we want to prevent users of the
      application context from obtaining a reference to the un-advised object, or
      need to avoid any ambiguity with Spring IoC
      <span class="emphasis"><em>autowiring</em></span>. There's also arguably an advantage in
      that the ProxyFactoryBean definition is self-contained. However, there
      are times when being able to obtain the un-advised target from the
      factory might actually be an <span class="emphasis"><em>advantage</em></span>: for
      example, in certain test scenarios.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-api-proxying-class"></a>7.5.5.&nbsp;Proxying classes</h3></div></div><div></div></div><p>What if you need to proxy a class, rather than one or more
      interfaces?</p><p>Imagine that in our example above, there was no
      <tt class="literal">Person</tt> interface: we needed to advise a class called
      <tt class="literal">Person</tt> that didn't implement any business interface.
      In this case, you can configure Spring to use CGLIB proxying, rather
      than dynamic proxies. Simply set the <tt class="literal">proxyTargetClass</tt>
      property on the ProxyFactoryBean above to true. While it's best to
      program to interfaces, rather than classes, the ability to advise
      classes that don't implement interfaces can be useful when working with
      legacy code. (In general, Spring isn't prescriptive. While it makes it
      easy to apply good practices, it avoids forcing a particular
      approach.)</p><p>If you want to, you can force the use of CGLIB in any case, even if
      you do have interfaces.</p><p>CGLIB proxying works by generating a subclass of the target class
      at runtime. Spring configures this generated subclass to delegate method
      calls to the original target: the subclass is used to implement the
      <span class="emphasis"><em>Decorator</em></span> pattern, weaving in the advice.</p><p>CGLIB proxying should generally be transparent to users. However,
      there are some issues to consider:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">Final</tt> methods can't be advised, as they
          can't be overridden.</p></li><li><p>You'll need the CGLIB 2 binaries on your classpath; dynamic
          proxies are available with the JDK.</p></li></ul></div><p>There's little performance difference between CGLIB proxying and
      dynamic proxies. As of Spring 1.0, dynamic proxies are slightly faster.
      However, this may change in the future. Performance should not be a
      decisive consideration in this case.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-global-advisors"></a>7.5.6.&nbsp;Using 'global' advisors</h3></div></div><div></div></div><p>By appending an asterisk to an interceptor name, all advisors with
      bean names matching the part before the asterisk, will be added to the
      advisor chain. This can come in handy if you need to add a standard set
      of 'global' advisors: </p><pre class="programlisting">
&lt;bean id="proxy" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="target" ref="service"/&gt;
  &lt;property name="interceptorNames"&gt;
    &lt;list&gt;
      &lt;value&gt;global*&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="global_debug" class="org.springframework.aop.interceptor.DebugInterceptor"/&gt;
&lt;bean id="global_performance" class="org.springframework.aop.interceptor.PerformanceMonitorInterceptor"/&gt;
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-concise-proxy"></a>7.6.&nbsp;Concise proxy definitions</h2></div></div><div></div></div><p>Especially when defining transactional proxies, you may end up with
    many similar proxy definitions. The use of parent and child bean
    definitions, along with inner bean definitions, can result in much cleaner
    and more concise proxy definitions.</p><p>First a parent, <span class="emphasis"><em>template</em></span>, bean definition is
    created for the proxy:</p><pre class="programlisting">&lt;bean id="txProxyTemplate" abstract="true"
        class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="transactionAttributes"&gt;
    &lt;props&gt;
      &lt;prop key="*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>This will never be instantiated itself, so may actually be
    incomplete. Then each proxy which needs to be created is just a child bean
    definition, which wraps the target of the proxy as an inner bean
    definition, since the target will never be used on its own
    anyway.</p><pre class="programlisting">&lt;bean id="myService" parent="txProxyTemplate"&gt;
  &lt;property name="target"&gt;
    &lt;bean class="org.springframework.samples.MyServiceImpl"&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>It is of course possible to override properties from the parent
    template, such as in this case, the transaction propagation
    settings:</p><pre class="programlisting">&lt;bean id="mySpecialService" parent="txProxyTemplate"&gt;
  &lt;property name="target"&gt;
    &lt;bean class="org.springframework.samples.MySpecialServiceImpl"&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
  &lt;property name="transactionAttributes"&gt;
    &lt;props&gt;
      &lt;prop key="get*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
      &lt;prop key="find*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
      &lt;prop key="load*"&gt;PROPAGATION_REQUIRED,readOnly&lt;/prop&gt;
      &lt;prop key="store*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that in the example above, we have explicitly marked the parent
    bean definition as <span class="emphasis"><em>abstract</em></span> by using the
    <span class="emphasis"><em>abstract</em></span> attribute, as described <a href="#beans-child-bean-definitions" title="3.6.&nbsp;Bean definition inheritance">previously</a>, so that it may
    not actually ever be instantiated. Application contexts (but not simple
    bean factories) will by default pre-instantiate all singletons. It is therefore
    important (at least for singleton beans) that if you have a (parent)
    bean definition which you intend to use only as a template, and this
    definition specifies a class, you must make sure to set the
    <span class="emphasis"><em>abstract</em></span> attribute to <span class="emphasis"><em>true</em></span>,
    otherwise the application context will actually try to pre-instantiate
    it.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-prog"></a>7.7.&nbsp;Creating AOP proxies programmatically with the ProxyFactory</h2></div></div><div></div></div><p>It's easy to create AOP proxies programmatically using Spring. This
    enables you to use Spring AOP without dependency on Spring IoC.</p><p>The following listing shows creation of a proxy for a target object,
    with one interceptor and one advisor. The interfaces implemented by the
    target object will automatically be proxied:</p><pre class="programlisting">ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl);
factory.addInterceptor(myMethodInterceptor);
factory.addAdvisor(myAdvisor);
MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy();</pre><p>The first step is to construct an object of type
    <tt class="literal">org.springframework.aop.framework.ProxyFactory</tt>. You can
    create this with a target object, as in the above example, or specify the
    interfaces to be proxied in an alternate constructor.</p><p>You can add interceptors or advisors, and manipulate them for the
    life of the ProxyFactory. If you add an
    IntroductionInterceptionAroundAdvisor you can cause the proxy to implement
    additional interfaces.</p><p>There are also convenience methods on ProxyFactory (inherited from
    <tt class="classname">AdvisedSupport</tt>) which allow you to add other advice types 
		such as before and throws advice. AdvisedSupport is the superclass of both 
    ProxyFactory and ProxyFactoryBean.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>Integrating AOP proxy creation with the IoC framework is best
			practice in most applications. We recommend that you externalize
			configuration from Java code with AOP, as in general.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-api-advised"></a>7.8.&nbsp;Manipulating advised objects</h2></div></div><div></div></div><p>However you create AOP proxies, you can manipulate them using the
    <tt class="literal">org.springframework.aop.framework.Advised</tt> interface.
    Any AOP proxy can be cast to this interface, whichever other interfaces it
    implements. This interface includes the following methods:</p><pre class="programlisting">Advisor[] getAdvisors();

void addAdvice(Advice advice) throws AopConfigException;

void addAdvice(int pos, Advice advice) 
        throws AopConfigException;

void addAdvisor(Advisor advisor) throws AopConfigException;

void addAdvisor(int pos, Advisor advisor) throws AopConfigException;

int indexOf(Advisor advisor);

boolean removeAdvisor(Advisor advisor) throws AopConfigException;

void removeAdvisor(int index) throws AopConfigException;

boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException;

boolean isFrozen();</pre><p>The <tt class="literal">getAdvisors()</tt> method will return an Advisor
    for every advisor, interceptor or other advice type that has been added to
    the factory. If you added an Advisor, the returned advisor at this index
    will be the object that you added. If you added an interceptor or other
    advice type, Spring will have wrapped this in an advisor with a pointcut
    that always returns true. Thus if you added a
    <tt class="literal">MethodInterceptor</tt>, the advisor returned for this index
    will be an <tt class="literal">DefaultPointcutAdvisor</tt> returning your
    <tt class="literal">MethodInterceptor</tt> and a pointcut that matches all
    classes and methods.</p><p>The <tt class="literal">addAdvisor()</tt> methods can be used to add any
    Advisor. Usually the advisor holding pointcut and advice will be the
    generic <tt class="literal">DefaultPointcutAdvisor</tt>, which can be used with
    any advice or pointcut (but not for introductions).</p><p>By default, it's possible to add or remove advisors or interceptors
    even once a proxy has been created. The only restriction is that it's
    impossible to add or remove an introduction advisor, as existing proxies
    from the factory will not show the interface change. (You can obtain a new
    proxy from the factory to avoid this problem.)</p><p>A simple example of casting an AOP proxy to the
    <tt class="literal">Advised</tt> interface and examining and manipulating its
    advice:</p><pre class="programlisting">Advised advised = (Advised) myObject;
Advisor[] advisors = advised.getAdvisors();
int oldAdvisorCount = advisors.length;
System.out.println(oldAdvisorCount + " advisors");

// Add an advice like an interceptor without a pointcut
// Will match all proxied methods
// Can use for interceptors, before, after returning or throws advice
advised.addAdvice(new DebugInterceptor());

// Add selective advice using a pointcut
advised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice));

assertEquals("Added two advisors",
     oldAdvisorCount + 2, advised.getAdvisors().length);</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>It's questionable whether it's advisable (no pun intended) to
			modify advice on a business object in production, although there are no
			doubt legitimate usage cases. However, it can be very useful in
			development: for example, in tests. I have sometimes found it very useful
			to be able to add test code in the form of an interceptor or other advice,
			getting inside a method invocation I want to test. (For example, the
			advice can get inside a transaction created for that method: for example,
			to run SQL to check that a database was correctly updated, before marking
			the transaction for roll back.)</p></td></tr></table></div><p>Depending on how you created the proxy, you can usually set a
    <tt class="literal">frozen</tt> flag, in which case the
    <tt class="literal">Advised</tt> <tt class="literal">isFrozen()</tt> method will
    return true, and any attempts to modify advice through addition or removal
    will result in an <tt class="literal">AopConfigException</tt>. The ability to
    freeze the state of an advised object is useful in some cases, for
    example, to prevent calling code removing a security interceptor. It may
    also be used in Spring 1.1 to allow aggressive optimization if runtime
    advice modification is known not to be required.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-autoproxy"></a>7.9.&nbsp;Using the "autoproxy" facility</h2></div></div><div></div></div><p>So far we've considered explicit creation of AOP proxies using a
    <tt class="literal">ProxyFactoryBean</tt> or similar factory bean.</p><p>Spring also allows us to use "autoproxy" bean definitions, which can
    automatically proxy selected bean definitions. This is built on Spring
    "bean post processor" infrastructure, which enables modification of any
    bean definition as the container loads.</p><p>In this model, you set up some special bean definitions in your XML
    bean definition file to configure the auto proxy infrastructure. This
    allows you just to declare the targets eligible for autoproxying: you
    don't need to use <tt class="literal">ProxyFactoryBean</tt>.</p><p>There are two ways to do this:</p><div class="itemizedlist"><ul type="disc"><li><p>Using an autoproxy creator that refers to specific beans in the
        current context.</p></li><li><p>A special case of autoproxy creation that deserves to be
        considered separately; autoproxy creation driven by source-level
        metadata attributes.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-autoproxy-choices"></a>7.9.1.&nbsp;Autoproxy bean definitions</h3></div></div><div></div></div><p>The <tt class="literal">org.springframework.aop.framework.autoproxy</tt>
      package provides the following standard autoproxy creators.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-autoproxy"></a>7.9.1.1.&nbsp;BeanNameAutoProxyCreator</h4></div></div><div></div></div><p>The <tt class="literal">BeanNameAutoProxyCreator</tt> class is a
        <tt class="literal">BeanPostProcessor</tt> that automatically creates AOP proxies
        for beans with names matching literal values or wildcards.</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator"&gt;
  &lt;property name="beanNames"&gt;&lt;value&gt;jdk*,onlyJdk&lt;/value&gt;&lt;/property&gt;
  &lt;property name="interceptorNames"&gt;
    &lt;list&gt;
      &lt;value&gt;myInterceptor&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>As with <tt class="literal">ProxyFactoryBean</tt>, there is an
        <tt class="literal">interceptorNames</tt> property rather than a list of interceptors, to allow
        correct behavior for prototype advisors. Named "interceptors" can be
        advisors or any advice type.</p><p>As with auto proxying in general, the main point of using
        <tt class="literal">BeanNameAutoProxyCreator</tt> is to apply the same
        configuration consistently to multiple objects, with minimal
        volume of configuration. It is a popular choice for applying
        declarative transactions to multiple objects.</p><p>Bean definitions whose names match, such as "jdkMyBean" and
        "onlyJdk" in the above example, are plain old bean definitions with
        the target class. An AOP proxy will be created automatically by the
        <tt class="literal">BeanNameAutoProxyCreator</tt>. The same advice will be
        applied to all matching beans. Note that if advisors are used (rather
        than the interceptor in the above example), the pointcuts may apply
        differently to different beans.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-autoproxy-default"></a>7.9.1.2.&nbsp;DefaultAdvisorAutoProxyCreator</h4></div></div><div></div></div><p>A more general and extremely powerful auto proxy creator is
        <tt class="literal">DefaultAdvisorAutoProxyCreator</tt>. This will
        automagically apply eligible advisors in the current context, without
        the need to include specific bean names in the autoproxy advisor's
        bean definition. It offers the same merit of consistent configuration
        and avoidance of duplication as
        <tt class="literal">BeanNameAutoProxyCreator</tt>.</p><p>Using this mechanism involves:</p><div class="itemizedlist"><ul type="disc"><li><p>Specifying a
            <tt class="literal">DefaultAdvisorAutoProxyCreator</tt> bean
            definition.</p></li><li><p>Specifying any number of Advisors in the same or related
            contexts. Note that these <span class="emphasis"><em>must</em></span> be Advisors,
            not just interceptors or other advices. This is necessary because
            there must be a pointcut to evaluate, to check the eligibility of
            each advice to candidate bean definitions.</p></li></ul></div><p>The <tt class="literal">DefaultAdvisorAutoProxyCreator</tt> will
        automatically evaluate the pointcut contained in each advisor, to see
        what (if any) advice it should apply to each business object (such as
        "businessObject1" and "businessObject2" in the example).</p><p>This means that any number of advisors can be applied
        automatically to each business object. If no pointcut in any of the
        advisors matches any method in a business object, the object will not
        be proxied. As bean definitions are added for new business objects,
        they will automatically be proxied if necessary.</p><p>Autoproxying in general has the advantage of making it
        impossible for callers or dependencies to obtain an un-advised object.
        Calling getBean("businessObject1") on this ApplicationContext will
        return an AOP proxy, not the target business object. (The "inner bean"
        idiom shown earlier also offers this benefit.)</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="customAdvisor" class="com.mycompany.MyAdvisor"/&gt;

&lt;bean id="businessObject1" class="com.mycompany.BusinessObject1"&gt;
  &lt;!-- Properties omitted --&gt;
&lt;/bean&gt;

&lt;bean id="businessObject2" class="com.mycompany.BusinessObject2"/&gt;
</pre><p>The <tt class="literal">DefaultAdvisorAutoProxyCreator</tt> is very
        useful if you want to apply the same advice consistently to many
        business objects. Once the infrastructure definitions are in place,
        you can simply add new business objects without including specific
        proxy configuration. You can also drop in additional aspects very
        easily - for example, tracing or performance monitoring aspects - with
        minimal change to configuration.</p><p>The DefaultAdvisorAutoProxyCreator offers support for filtering
        (using a naming convention so that only certain advisors are
        evaluated, allowing use of multiple, differently configured,
        AdvisorAutoProxyCreators in the same factory) and ordering. Advisors
        can implement the <tt class="literal">org.springframework.core.Ordered</tt>
        interface to ensure correct ordering if this is an issue. The
        TransactionAttributeSourceAdvisor used in the above example has a
        configurable order value; the default setting is unordered.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="aop-api-autoproxy-abstract"></a>7.9.1.3.&nbsp;AbstractAdvisorAutoProxyCreator</h4></div></div><div></div></div><p>This is the superclass of DefaultAdvisorAutoProxyCreator. You
        can create your own autoproxy creators by subclassing this class, in
        the unlikely event that advisor definitions offer insufficient
        customization to the behavior of the framework
        <tt class="literal">DefaultAdvisorAutoProxyCreator</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-autoproxy-metadata"></a>7.9.2.&nbsp;Using metadata-driven auto-proxying</h3></div></div><div></div></div><p>A particularly important type of autoproxying is driven by
      metadata. This produces a similar programming model to .NET
      <tt class="literal">ServicedComponents</tt>. Instead of using XML deployment
      descriptors as in EJB, configuration for transaction management and
      other enterprise services is held in source-level attributes.</p><p>In this case, you use the
      <tt class="literal">DefaultAdvisorAutoProxyCreator</tt>, in combination with
      Advisors that understand metadata attributes. The metadata specifics are
      held in the pointcut part of the candidate advisors, rather than in the
      autoproxy creation class itself.</p><p>This is really a special case of the
      <tt class="literal">DefaultAdvisorAutoProxyCreator</tt>, but deserves
      consideration on its own. (The metadata-aware code is in the pointcuts
      contained in the advisors, not the AOP framework itself.)</p><p>The <tt class="literal">/attributes</tt> directory of the JPetStore
      sample application shows the use of attribute-driven autoproxying. In
      this case, there's no need to use the
      <tt class="literal">TransactionProxyFactoryBean</tt>. Simply defining
      transactional attributes on business objects is sufficient, because of
      the use of metadata-aware pointcuts. The bean definitions include the
      following code, in <tt class="literal">/WEB-INF/declarativeServices.xml</tt>.
      Note that this is generic, and can be used outside the JPetStore:</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionInterceptor"
    class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="transactionAttributeSource"&gt;
    &lt;bean class="org.springframework.transaction.interceptor.AttributesTransactionAttributeSource"&gt;
      &lt;property name="attributes" ref="attributes"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="attributes" class="org.springframework.metadata.commons.CommonsAttributes"/&gt;</pre><p>The <tt class="literal">DefaultAdvisorAutoProxyCreator</tt> bean
      definition (the name is not significant, hence it can even be omitted)
      will pick up all eligible pointcuts in the current application context.
      In this case, the "transactionAdvisor" bean definition, of type
      <tt class="literal">TransactionAttributeSourceAdvisor</tt>, will apply to
      classes or methods carrying a transaction attribute. The
      TransactionAttributeSourceAdvisor depends on a TransactionInterceptor,
      via constructor dependency. The example resolves this via autowiring.
      The <tt class="literal">AttributesTransactionAttributeSource</tt> depends on
      an implementation of the
      <tt class="literal">org.springframework.metadata.Attributes</tt> interface. In
      this fragment, the "attributes" bean satisfies this, using the Jakarta
      Commons Attributes API to obtain attribute information. (The application
      code must have been compiled using the Commons Attributes compilation
      task.)</p><p>The <tt class="literal">/annotation</tt> directory of the JPetStore
      sample application contains an analogous example for auto-proxying
      driven by JDK 1.5+ annotations. The following configuration enables
      automatic detection of Spring's <tt class="literal">Transactional</tt>
      annotation, leading to implicit proxies for beans containing that
      annotation:</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="transactionInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="transactionInterceptor"
    class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
  &lt;property name="transactionManager" ref="transactionManager"/&gt;
  &lt;property name="transactionAttributeSource"&gt;
    &lt;bean class="org.springframework.transaction.annotation.AnnotationTransactionAttributeSource"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The <tt class="literal">TransactionInterceptor</tt> defined here depends
      on a <tt class="literal">PlatformTransactionManager</tt> definition, which is
      not included in this generic file (although it could be) because it will
      be specific to the application's transaction requirements (typically
      JTA, as in this example, or Hibernate, JDO or JDBC):</p><pre class="programlisting">&lt;bean id="transactionManager" 
    class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you require only declarative transaction management, using
				these generic XML definitions will result in Spring automatically
				proxying all classes or methods with transaction attributes. You won't
				need to work directly with AOP, and the programming model is similar to
				that of .NET ServicedComponents.</p></td></tr></table></div><p>This mechanism is extensible. It's possible to do autoproxying
      based on custom attributes. You need to:</p><div class="itemizedlist"><ul type="disc"><li><p>Define your custom attribute.</p></li><li><p>Specify an Advisor with the necessary advice, including a
          pointcut that is triggered by the presence of the custom attribute
          on a class or method. You may be able to use an existing advice,
          merely implementing a static pointcut that picks up the custom
          attribute.</p></li></ul></div><p>It's possible for such advisors to be unique to each advised class
      (for example, mixins): they simply need to be defined as prototype,
      rather than singleton, bean definitions. For example, the
      <tt class="literal">LockMixin</tt> introduction interceptor from the Spring
      test suite, shown above, could be used in conjunction with an
      attribute-driven pointcut to target a mixin, as shown here. We use the
      generic <tt class="literal">DefaultPointcutAdvisor</tt>, configured using
      JavaBean properties:</p><pre class="programlisting">&lt;bean id="lockMixin" class="org.springframework.aop.LockMixin"
    scope="prototype"/&gt;

&lt;bean id="lockableAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor"
    scope="prototype"&gt;
  &lt;property name="pointcut" ref="myAttributeAwarePointcut"/&gt;
  &lt;property name="advice" ref="lockMixin"/&gt;
&lt;/bean&gt;

&lt;bean id="anyBean" class="anyclass" ...</pre><p>If the attribute aware pointcut matches any methods in the
      <tt class="literal">anyBean</tt> or other bean definitions, the mixin will be
      applied. Note that both <tt class="literal">lockMixin</tt> and
      <tt class="literal">lockableAdvisor</tt> definitions are prototypes. The
      <tt class="literal">myAttributeAwarePointcut</tt> pointcut can be a singleton
      definition, as it doesn't hold state for individual advised
      objects.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-targetsource"></a>7.10.&nbsp;Using TargetSources</h2></div></div><div></div></div><p>Spring offers the concept of a <span class="emphasis"><em>TargetSource</em></span>,
    expressed in the <tt class="literal">org.springframework.aop.TargetSource</tt>
    interface. This interface is responsible for returning the "target object"
    implementing the join point. The <tt class="literal">TargetSource</tt>
    implementation is asked for a target instance each time the AOP proxy
    handles a method invocation.</p><p>Developers using Spring AOP don't normally need to work directly
    with TargetSources, but this provides a powerful means of supporting
    pooling, hot swappable and other sophisticated targets. For example, a
    pooling TargetSource can return a different target instance for each
    invocation, using a pool to manage instances.</p><p>If you do not specify a TargetSource, a default implementation is
    used that wraps a local object. The same target is returned for each
    invocation (as you would expect).</p><p>Let's look at the standard target sources provided with Spring, and
    how you can use them.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>When using a custom target source, your target will usually need
			to be a prototype rather than a singleton bean definition. This allows
			Spring to create a new target instance when required.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-swap"></a>7.10.1.&nbsp;Hot swappable target sources</h3></div></div><div></div></div><p>The
      <tt class="literal">org.springframework.aop.target.HotSwappableTargetSource</tt>
      exists to allow the target of an AOP proxy to be switched while allowing
      callers to keep their references to it.</p><p>Changing the target source's target takes effect immediately. The
      <tt class="literal">HotSwappableTargetSource</tt> is threadsafe.</p><p>You can change the target via the <tt class="literal">swap()</tt> method
      on HotSwappableTargetSource as follows:</p><pre class="programlisting">HotSwappableTargetSource swapper = 
    (HotSwappableTargetSource) beanFactory.getBean("swapper");
Object oldTarget = swapper.swap(newTarget);</pre><p>The XML definitions required look as follows:</p><pre class="programlisting">&lt;bean id="initialTarget" class="mycompany.OldTarget"/&gt;

&lt;bean id="swapper" class="org.springframework.aop.target.HotSwappableTargetSource"&gt;
  &lt;constructor-arg ref="initialTarget"/&gt;
&lt;/bean&gt;

&lt;bean id="swappable" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="targetSource" ref="swapper"/&gt;
&lt;/bean&gt;</pre><p>The above <tt class="literal">swap()</tt> call changes the target of the
      swappable bean. Clients who hold a reference to that bean will be
      unaware of the change, but will immediately start hitting the new
      target.</p><p>Although this example doesn't add any advice - and it's not
      necessary to add advice to use a <tt class="literal">TargetSource</tt> - of
      course any <tt class="literal">TargetSource</tt> can be used in conjunction
      with arbitrary advice.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-pool"></a>7.10.2.&nbsp;Pooling target sources</h3></div></div><div></div></div><p>Using a pooling target source provides a similar programming model
      to stateless session EJBs, in which a pool of identical instances is
      maintained, with method invocations going to free objects in the
      pool.</p><p>A crucial difference between Spring pooling and SLSB pooling is
      that Spring pooling can be applied to any POJO. As with Spring in
      general, this service can be applied in a non-invasive way.</p><p>Spring provides out-of-the-box support for Jakarta Commons Pool
      1.3, which provides a fairly efficient pooling implementation. You'll
      need the commons-pool Jar on your application's classpath to use this
      feature. It's also possible to subclass
      <tt class="literal">org.springframework.aop.target.AbstractPoolingTargetSource</tt>
      to support any other pooling API.</p><p>Sample configuration is shown below:</p><pre class="programlisting">&lt;bean id="businessObjectTarget" class="com.mycompany.MyBusinessObject" 
    scope="prototype"&gt;
  ... properties omitted
&lt;/bean&gt;

&lt;bean id="poolTargetSource" class="org.springframework.aop.target.CommonsPoolTargetSource"&gt;
  &lt;property name="targetBeanName" value="businessObjectTarget"/&gt;
  &lt;property name="maxSize" value="25"/&gt;
&lt;/bean&gt;

&lt;bean id="businessObject" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
  &lt;property name="targetSource" ref="poolTargetSource"/&gt;
  &lt;property name="interceptorNames" value="myInterceptor"/&gt;
&lt;/bean&gt;</pre><p>Note that the target object - "businessObjectTarget" in the
      example - <span class="emphasis"><em>must</em></span> be a prototype. This allows the
      <tt class="literal">PoolingTargetSource</tt> implementation to create new
      instances of the target to grow the pool as necessary. See the havadoc
      for <tt class="literal">AbstractPoolingTargetSource</tt> and the concrete
      subclass you wish to use for information about its properties: "maxSize"
      is the most basic, and always guaranteed to be present.</p><p>In this case, "myInterceptor" is the name of an interceptor that
      would need to be defined in the same IoC context. However, it isn't
      necessary to specify interceptors to use pooling. If you want only
      pooling, and no other advice, don't set the interceptorNames property at
      all.</p><p>It's possible to configure Spring so as to be able to cast any
      pooled object to the
      <tt class="literal">org.springframework.aop.target.PoolingConfig</tt>
      interface, which exposes information about the configuration and current
      size of the pool through an introduction. You'll need to define an
      advisor like this:</p><pre class="programlisting">&lt;bean id="poolConfigAdvisor" class="org.springframework.beans.factory.config.MethodInvokingFactoryBean"&gt;
  &lt;property name="targetObject" ref="poolTargetSource"/&gt;
  &lt;property name="targetMethod" value="getPoolingConfigMixin"/&gt;
&lt;/bean&gt;</pre><p>This advisor is obtained by calling a convenience method on the
      <tt class="literal">AbstractPoolingTargetSource</tt> class, hence the use of
      MethodInvokingFactoryBean. This advisor's name ("poolConfigAdvisor"
      here) must be in the list of interceptors names in the ProxyFactoryBean
      exposing the pooled object.</p><p>The cast will look as follows:</p><pre class="programlisting">PoolingConfig conf = (PoolingConfig) beanFactory.getBean("businessObject");
System.out.println("Max pool size is " + conf.getMaxSize());</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Pooling stateless service objects is not usually necessary. We
				don't believe it should be the default choice, as most stateless objects
				are naturally thread safe, and instance pooling is problematic if
				resources are cached.</p></td></tr></table></div><p>Simpler pooling is available using autoproxying. It's possible to
      set the TargetSources used by any autoproxy creator.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-prototype"></a>7.10.3.&nbsp;Prototype target sources</h3></div></div><div></div></div><p>Setting up a "prototype" target source is similar to a pooling
      TargetSource. In this case, a new instance of the target will be created
      on every method invocation. Although the cost of creating a new object
      isn't high in a modern JVM, the cost of wiring up the new object
      (satisfying its IoC dependencies) may be more expensive. Thus you
      shouldn't use this approach without very good reason.</p><p>To do this, you could modify the
      <tt class="literal">poolTargetSource</tt> definition shown above as follows.
      (I've also changed the name, for clarity.)</p><pre class="programlisting">&lt;bean id="prototypeTargetSource" class="org.springframework.aop.target.PrototypeTargetSource"&gt;
  &lt;property name="targetBeanName" ref="businessObjectTarget"/&gt;
&lt;/bean&gt;</pre><p>There's only one property: the name of the target bean.
      Inheritance is used in the TargetSource implementations to ensure
      consistent naming. As with the pooling target source, the target bean
      must be a prototype bean definition.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="aop-ts-threadlocal"></a>7.10.4.&nbsp;<tt class="classname">ThreadLocal</tt> target sources</h3></div></div><div></div></div><p><tt class="classname">ThreadLocal</tt> target sources are useful if you need an object to be
      created for each incoming request (per thread that is). The concept of a
      <tt class="classname">ThreadLocal</tt> provide a JDK-wide facility to
      transparently store resource alongside a thread. Setting up a
      <tt class="classname">ThreadLocalTargetSource</tt> is pretty much the same as was explained for the
      other types of target source:</p><pre class="programlisting">&lt;bean id="threadlocalTargetSource" class="org.springframework.aop.target.ThreadLocalTargetSource"&gt;
  &lt;property name="targetBeanName" value="businessObjectTarget"/&gt;
&lt;/bean&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>ThreadLocals come with serious issues (potentially
				resulting in memory leaks) when incorrectly using them in a
				multi-threaded and multi-classloader environments. One should always
				consider wrapping a threadlocal in some other class and never directly
				use the <tt class="classname">ThreadLocal</tt> itself (except of course in the wrapper class).
				Also, one should always remember to correctly set and unset (where the
				latter simply involved a call to <tt class="literal">ThreadLocal.set(null)</tt>) the resource
				local to the thread. Unsetting should be done in any case since not
				unsetting it might result in problematic behavior. Spring's ThreadLocal
				support does this for you and should always be considered in favor
				of using ThreadLocals without other proper handling
				code.</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-extensibility"></a>7.11.&nbsp;Defining new <tt class="interfacename">Advice</tt> types</h2></div></div><div></div></div><p>Spring AOP is designed to be extensible. While the interception
    implementation strategy is presently used internally, it is possible to
    support arbitrary advice types in addition to the out-of-the-box interception around advice,
    before, throws advice and after returning advice.</p><p>The <tt class="literal">org.springframework.aop.framework.adapter</tt>
    package is an SPI package allowing support for new custom advice types to
    be added without changing the core framework. The only constraint on a
    custom <tt class="interfacename">Advice</tt> type is that it must implement the
    <tt class="interfacename">org.aopalliance.aop.Advice</tt> tag interface.</p><p>Please refer to the
    <tt class="literal">org.springframework.aop.framework.adapter</tt> package's
    Javadocs for further information.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="aop-api-resources"></a>7.12.&nbsp;Further resources</h2></div></div><div></div></div><p>Please refer to the Spring sample applications for further examples
    of Spring AOP:</p><div class="itemizedlist"><ul type="disc"><li><p>The JPetStore's default configuration illustrates the use of the
        <tt class="classname">TransactionProxyFactoryBean</tt> for declarative transaction
        management.</p></li><li><p>The <tt class="literal">/attributes</tt> directory of the JPetStore
        illustrates the use of attribute-driven declarative transaction management.</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="testing"></a>Chapter&nbsp;8.&nbsp;Testing</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="testing-introduction"></a>8.1.&nbsp;Introduction</h2></div></div><div></div></div><p>The Spring team considers developer testing to be an absolutely
    integral part of enterprise software development. A thorough treatment of
    testing in the enterprise is beyond the scope of this chapter; rather, the
    focus here is on the value-add that the adoption of the IoC principle can
    bring to <a href="#unit-testing" title="8.2.&nbsp;Unit testing">unit testing</a> and on the
    benefits that the Spring Framework provides in <a href="#integration-testing" title="8.3.&nbsp;Integration testing">integration testing</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="unit-testing"></a>8.2.&nbsp;Unit testing</h2></div></div><div></div></div><p>One of the main benefits of Dependency Injection is that your code
    should really depend far less on the container than in traditional J2EE
    development. The POJOs that comprise your application should be testable
    in JUnit or TestNG tests, with objects simply instantiated using the
    <tt class="literal">new</tt> operator, <span class="emphasis"><em>without Spring or any other
    container</em></span>. You can use <a href="#mock-objects" title="8.2.1.&nbsp;Mock objects">mock
    objects</a> (in conjunction with many other valuable testing
    techniques) to test your code in isolation. If you follow the architecture
    recommendations around Spring you will find that the resulting clean
    layering and componentization of your codebase will naturally facilitate
    <span class="emphasis"><em>easier</em></span> unit testing. For example, you will be able to
    test service layer objects by stubbing or mocking DAO or Repository
    interfaces, without any need to access persistent data while running unit
    tests.</p><p>True unit tests typically will run extremely quickly, as there is no
    runtime infrastructure to set up, whether application server, database,
    ORM tool, or whatever. Thus emphasizing true unit tests as part of your
    development methodology will boost your productivity. The upshot of this
    is that you often do not need this section of the testing chapter to help
    you write effective <span class="emphasis"><em>unit</em></span> tests for your IoC-based
    applications. For certain unit testing scenarios, however, the Spring
    Framework provides the following mock objects and testing support
    classes.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mock-objects"></a>8.2.1.&nbsp;Mock objects</h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mock-objects-jndi"></a>8.2.1.1.&nbsp;JNDI</h4></div></div><div></div></div><p>The <tt class="literal">org.springframework.mock.jndi</tt> package
        contains an implementation of the JNDI SPI, which is useful for
        setting up a simple JNDI environment for test suites or stand-alone
        applications. If, for example, JDBC <tt class="classname">DataSource</tt>s
        get bound to the same JNDI names in test code as within a J2EE
        container, both application code and configuration can be reused in
        testing scenarios without modification.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mock-objects-servlet"></a>8.2.1.2.&nbsp;Servlet API</h4></div></div><div></div></div><p>The <tt class="literal">org.springframework.mock.web</tt> package
        contains a comprehensive set of Servlet API mock objects, targeted at
        usage with Spring's Web MVC framework, which are useful for testing
        web contexts and controllers. These mock objects are generally more
        convenient to use than dynamic mock objects (e.g., <a href="http://www.easymock.org" target="_top">EasyMock</a>) or existing Servlet
        API mock objects (e.g., <a href="http://www.mockobjects.com" target="_top">MockObjects</a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mock-objects-portlet"></a>8.2.1.3.&nbsp;Portlet API</h4></div></div><div></div></div><p>The <tt class="literal">org.springframework.mock.web.portlet</tt>
        package contains a set of Portlet API mock objects, targeted at usage
        with Spring's Portlet MVC framework.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="unit-testing-support-classes"></a>8.2.2.&nbsp;Unit testing support classes</h3></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="unit-testing-utilities"></a>8.2.2.1.&nbsp;General utilities</h4></div></div><div></div></div><p>The <tt class="literal">org.springframework.test.util</tt> package
        contains <tt class="classname">ReflectionTestUtils</tt>, which is a
        collection of reflection-based utility methods for use in unit and
        integration testing scenarios in which the developer would benefit
        from being able to set a non-<tt class="literal">public</tt> field or invoke
        a non-<tt class="literal">public</tt> setter method when testing application
        code involving, for example:</p><div class="itemizedlist"><ul type="disc"><li><p>ORM frameworks such as JPA and Hibernate which condone the
            usage of <tt class="literal">private</tt> or
            <tt class="literal">protected</tt> field access as opposed to
            <tt class="literal">public</tt> setter methods for properties in a
            domain entity</p></li><li><p>Spring's support for annotations such as
            <tt class="interfacename">@Autowired</tt> and
            <tt class="interfacename">@Resource</tt> which provides dependency
            injection for <tt class="literal">private</tt> or
            <tt class="literal">protected</tt> fields, setter methods, and
            configuration methods</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="unit-testing-spring-mvc"></a>8.2.2.2.&nbsp;Spring MVC</h4></div></div><div></div></div><p>The <tt class="literal">org.springframework.test.web</tt> package
        contains <tt class="classname">AbstractModelAndViewTests</tt>, which
        serves as a convenient base class for JUnit 3.8 based unit tests
        dealing with Spring MVC <tt class="classname">ModelAndView</tt> objects.
        When developing against Java 1.4 and higher (e.g., in combination with
        JUnit 4+, TestNG, etc.), you have the option of using the
        <tt class="classname">ModelAndViewAssert</tt> class (in the same package)
        to test your <tt class="classname">ModelAndView</tt> related
        functionality.</p><p>Tip: depending on your testing environment, either extend
        <tt class="classname">AbstractModelAndViewTests</tt> or use
        <tt class="classname">ModelAndViewAssert</tt> directly and then use
        <tt class="literal">MockHttpServletRequest</tt>,
        <tt class="literal">MockHttpSession</tt>, etc. from the <a href="#mock-objects-servlet" title="8.2.1.2.&nbsp;Servlet API"><tt class="literal">org.springframework.mock.web</tt></a>
        package to test your Spring MVC <tt class="literal">Controller</tt>s.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="integration-testing"></a>8.3.&nbsp;Integration testing</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="integration-testing-overview"></a>8.3.1.&nbsp;Overview</h3></div></div><div></div></div><p>It is important to be able to perform some integration testing
      without requiring deployment to your application server or connecting to
      other enterprise infrastructure. This will enable you to test things
      such as:</p><div class="itemizedlist"><ul type="disc"><li><p>The correct wiring of your Spring IoC container
          contexts.</p></li><li><p>Data access using JDBC or an ORM tool. This would include such
          things as the correctness of SQL statements, Hibernate queries, JPA
          entity mappings, etc.</p></li></ul></div><p>The Spring Framework provides first class support for integration
      testing in the form of the classes that are packaged in the <tt class="filename">spring-test.jar</tt> library. In this library,
      you will find the <tt class="literal">org.springframework.test</tt> package
      which contains valuable classes for integration testing using a Spring
      container, while at the same time not being reliant on an application
      server or other deployment environment. Such tests will be slower to run
      than unit tests but much faster to run than the equivalent Cactus tests
      or remote tests relying on deployment to an application server.</p><p>Prior to the 2.5 release of the framework, Spring provided <a href="#junit38-legacy-support" title="8.3.6.&nbsp;JUnit 3.8 legacy support">integration testing support specific to
      JUnit 3.8</a>. As of the 2.5 release, Spring offers support for unit
      and integration testing in the form of the <a href="#testcontext-framework" title="8.3.7.&nbsp;Spring TestContext Framework">Spring TestContext Framework</a>,
      which is agnostic of the actual testing framework in use, thus allowing
      instrumentation of tests in various environments including JUnit 3.8,
      JUnit 4.4, TestNG, etc. <span class="emphasis"><em>Note that the Spring TestContext
      Framework requires Java 5+.</em></span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="integration-testing-which-framework"></a>8.3.2.&nbsp;Which support framework to use</h3></div></div><div></div></div><p>The Spring team recommends using the <a href="#testcontext-framework" title="8.3.7.&nbsp;Spring TestContext Framework">Spring TestContext Framework</a> for
      all new unit testing or integration testing involving
      <tt class="classname">ApplicationContext</tt>s or requiring transactional
      test fixtures; however, if you are developing in a pre-Java 5
      environment, you will need to continue to use the <a href="#junit38-legacy-support" title="8.3.6.&nbsp;JUnit 3.8 legacy support">JUnit 3.8 legacy support</a>. In
      addition, explicit <a href="#junit38-legacy-jpa-tests" title="8.3.6.5.2.&nbsp;JPA support classes">integration
      testing support for JPA</a> which relies on <span class="emphasis"><em>shadow class
      loading</em></span> for JPA class instrumentation is currently only
      available with the JUnit 3.8 legacy support. If you are testing against
      a JPA provider which does not require class instrumentation, however, it
      is recommended that you use the TestContext framework.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="integration-testing-common-goals"></a>8.3.3.&nbsp;Common goals</h3></div></div><div></div></div><p>The Spring integration testing support frameworks share several
      common goals, including:</p><div class="itemizedlist"><ul type="disc"><li><p><a href="#testing-ctx-management" title="8.3.3.1.&nbsp;Context management and caching">Spring IoC container
          caching</a> between test execution.</p></li><li><p><a href="#testing-fixture-di" title="8.3.3.2.&nbsp;Dependency Injection of test fixtures">Dependency Injection of
          test fixture instances</a> (this is nice).</p></li><li><p><a href="#testing-tx" title="8.3.3.3.&nbsp;Transaction management">Transaction management</a>
          appropriate to integration testing (this is even nicer).</p></li><li><p><a href="#testing-support-classes" title="8.3.3.4.&nbsp;Integration testing support classes">Spring-specific
          support classes</a> that are really useful when writing
          integration tests.</p></li></ul></div><p>The following sections outline each of these goals and provide
      direct links to information specific to the particular support
      frameworks.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="testing-ctx-management"></a>8.3.3.1.&nbsp;Context management and caching</h4></div></div><div></div></div><p>Spring integration testing support frameworks provide consistent
        loading of Spring <tt class="classname">ApplicationContext</tt>s and
        caching of those contexts. Support for the caching of loaded contexts
        is important, because if you are working on a large project, startup
        time may become an issue - not because of the overhead of Spring
        itself, but because the objects instantiated by the Spring container
        will themselves take time to instantiate. For example, a project with
        50-100 Hibernate mapping files might take 10-20 seconds to load the
        mapping files, and incurring that cost before running every single
        test in every single test fixture will lead to slower overall test
        runs that could reduce productivity.</p><p>Test classes will generally provide an array containing the
        resource locations of XML configuration metadata - typically on the
        classpath - used to configure the application. This will be the same,
        or nearly the same, as the list of configuration locations specified
        in <tt class="literal">web.xml</tt> or other deployment
        configuration.</p><p>By default, once loaded, the configured
        <tt class="interfacename">ApplicationContext</tt> will be reused for
        each test. Thus the setup cost will be incurred only once (per test
        fixture), and subsequent test execution will be much faster. In the
        unlikely case that a test may 'dirty' the application context,
        requiring reloading - for example, by changing a bean definition or
        the state of an application object - Spring's testing support provides
        mechanisms to cause the test fixture to reload the configurations and
        rebuild the application context before executing the next test.</p><p>Context management and caching with:</p><div class="itemizedlist"><ul type="disc"><li><p><a href="#junit38-legacy-ctx-management" title="8.3.6.1.&nbsp;Context management and caching">JUnit 3.8
            legacy support</a></p></li><li><p><a href="#testcontext-ctx-management" title="8.3.7.2.&nbsp;Context management and caching">The TestContext
            Framework</a></p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="testing-fixture-di"></a>8.3.3.2.&nbsp;Dependency Injection of test fixtures</h4></div></div><div></div></div><p>When Spring integration testing support frameworks load your
        application context, they can optionally configure instances of your
        test classes via Dependency Injection. This provides a convenient
        mechanism for setting up test fixtures using pre-configured beans from
        your application context. A strong benefit here is that you can reuse
        application contexts across various testing scenarios (e.g., for
        configuring Spring-managed object graphs, transactional proxies,
        <tt class="classname">DataSource</tt>s, etc.), thus avoiding the need to
        duplicate complex test fixture set up for individual test
        cases.</p><p>As an example, consider the scenario where we have a class,
        <tt class="classname">HibernateTitleDao</tt>, that performs data access
        logic for say, the <tt class="classname">Title</tt> domain object. We want
        to write integration tests that test all of the following
        areas:</p><div class="itemizedlist"><ul type="disc"><li><p>The Spring configuration: basically, is everything related
            to the configuration of the
            <tt class="classname">HibernateTitleDao</tt> bean correct and
            present?</p></li><li><p>The Hibernate mapping file configuration: is everything
            mapped correctly and are the correct lazy-loading settings in
            place?</p></li><li><p>The logic of the <tt class="classname">HibernateTitleDao</tt>:
            does the configured instance of this class perform as
            anticipated?</p></li></ul></div><p>Dependency Injection of test fixtures with:</p><div class="itemizedlist"><ul type="disc"><li><p><a href="#junit38-legacy-fixture-di" title="8.3.6.2.&nbsp;Dependency Injection of test fixtures">JUnit 3.8 legacy
            support</a></p></li><li><p><a href="#testcontext-fixture-di" title="8.3.7.3.&nbsp;Dependency Injection of test fixtures">The TestContext
            Framework</a></p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="testing-tx"></a>8.3.3.3.&nbsp;Transaction management</h4></div></div><div></div></div><p>One common issue in tests that access a real database is their
        affect on the state of the persistence store. Even when you're using a
        development database, changes to the state may affect future tests.
        Also, many operations - such as inserting to or modifying persistent
        data - cannot be performed (or verified) outside a transaction.</p><p>The Spring integration testing support frameworks meet this
        need. By default, they create and roll back a transaction for each
        test. You simply write code that can assume the existence of a
        transaction. If you call transactionally proxied objects in your
        tests, they will behave correctly, according to their transactional
        semantics. In addition, if test methods delete the contents of
        selected tables while running within a transaction, the transaction
        will roll back by default, and the database will return to its state
        prior to execution of the test. Transactional support is provided to
        your test class via a
        <tt class="classname">PlatformTransactionManager</tt> bean defined in the
        test's application context.</p><p>If you want a transaction to commit - unusual, but occasionally
        useful when you want a particular test to populate or modify the
        database - the Spring integration testing support frameworks can be
        instructed to cause the transaction to commit instead of roll back
        either by calling an inherited hook-method or by declaring a specific
        annotation.</p><p>Transaction management with:</p><div class="itemizedlist"><ul type="disc"><li><p><a href="#junit38-legacy-tx" title="8.3.6.3.&nbsp;Transaction management">JUnit 3.8 legacy
            support</a></p></li><li><p><a href="#testcontext-tx" title="8.3.7.4.&nbsp;Transaction management">The TestContext
            Framework</a></p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="testing-support-classes"></a>8.3.3.4.&nbsp;Integration testing support classes</h4></div></div><div></div></div><p>The Spring integration testing support frameworks provide
        several <tt class="literal">abstract</tt> support classes that can simplify
        writing integration tests. These base test classes provide well
        defined hooks into the testing framework as well as convenient
        instance variables and methods, allowing access to such things
        as:</p><div class="itemizedlist"><ul type="disc"><li><p>The <tt class="literal">ApplicationContext</tt>: useful for
            performing explicit bean lookups or testing the state of the
            context as a whole.</p></li><li><p>A <tt class="classname">JdbcTemplate</tt> or
            <tt class="classname">SimpleJdbcTemplate</tt>: useful for querying to
            confirm state. For example, you might query before and after
            testing application code that creates an object and persists it
            using an ORM tool, to verify that the data appears in the
            database. (Spring will ensure that the query runs in the scope of
            the same transaction.) You will need to tell your ORM tool to
            'flush' its changes for this to work correctly, for example using
            the <tt class="methodname">flush()</tt> method on Hibernate's
            <tt class="interfacename">Session</tt> interface.</p></li></ul></div><p>Often you will provide an application-wide superclass for
        integration tests that provides further useful instance variables used
        in many tests.</p><p>Support classes for:</p><div class="itemizedlist"><ul type="disc"><li><p><a href="#junit38-legacy-support-classes" title="8.3.6.4.&nbsp;JUnit 3.8 legacy support classes">JUnit 3.8
            legacy support</a></p></li><li><p><a href="#testcontext-support-classes" title="8.3.7.5.&nbsp;TestContext support classes">The TestContext
            Framework</a></p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="integration-testing-support-jdbc"></a>8.3.4.&nbsp;JDBC testing support</h3></div></div><div></div></div><p>The <tt class="literal">org.springframework.test.jdbc</tt> package
      contains <tt class="classname">SimpleJdbcTestUtils</tt>, which is a
      Java-5-based collection of JDBC related utility functions intended to
      simplify standard database testing scenarios. <span class="emphasis"><em>Note that <a href="#testcontext-support-classes-junit38" title="8.3.7.5.1.&nbsp;JUnit 3.8 support classes"><tt class="classname">AbstractTransactionalJUnit38SpringContextTests</tt></a>,
      <a href="#testcontext-support-classes-junit44" title="8.3.7.5.2.&nbsp;JUnit 4.4 support classes"><tt class="classname">AbstractTransactionalJUnit4SpringContextTests</tt></a>,
      and <a href="#testcontext-support-classes-testng" title="8.3.7.5.4.&nbsp;TestNG support classes"><tt class="classname">AbstractTransactionalTestNGSpringContextTests</tt></a>
      provide convenience methods which delegate to
      <tt class="classname">SimpleJdbcTestUtils</tt> internally.</em></span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="integration-testing-common-annotations"></a>8.3.5.&nbsp;Common annotations</h3></div></div><div></div></div><p>The Spring Framework provides a common set of
      <span class="emphasis"><em>Spring-specific</em></span> annotations in the
      <tt class="literal">org.springframework.test.annotation</tt> package that you
      can use in your testing if you are developing against Java 5 or
      greater.</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><b><tt class="interfacename">@IfProfileValue</tt></b></span></p><p>Indicates that the annotated test is enabled for a specific
          testing environment. If the configured
          <tt class="classname">ProfileValueSource</tt> returns a matching
          <tt class="literal">value</tt> for the provided <tt class="literal">name</tt>,
          the test will be enabled. This annotation can be applied to an
          entire class or individual methods.</p><pre class="programlisting">@IfProfileValue(name="java.vendor", value="Sun Microsystems Inc.")
public void testProcessWhichRunsOnlyOnSunJvm() {
    <i class="lineannotation"><span class="lineannotation">// some logic that should run only on Java VMs from Sun Microsystems</span></i>
}</pre><p>Alternatively <tt class="interfacename">@IfProfileValue</tt>
          may be configured with a list of <tt class="literal">values</tt> (with
          <span class="emphasis"><em>OR</em></span> semantics) to achieve TestNG-like support
          for <span class="emphasis"><em>test groups</em></span> in a JUnit environment.
          Consider the following example:</p><pre class="programlisting">@IfProfileValue(name="test-groups", values={"unit-tests", "integration-tests"})
public void testProcessWhichRunsForUnitOrIntegrationTestGroups() {
    <i class="lineannotation"><span class="lineannotation">// some logic that should run only for unit and integration test groups</span></i>
}</pre></li><li><p><span class="bold"><b><tt class="interfacename">@ProfileValueSourceConfiguration</tt></b></span></p><p>Class-level annotation which is used to specify what type of
          <tt class="literal">ProfileValueSource</tt> to use when retrieving
          <span class="emphasis"><em>profile values</em></span> configured via the
          <tt class="interfacename">@IfProfileValue</tt> annotation. If
          <tt class="interfacename">@ProfileValueSourceConfiguration</tt> is
          not declared for a test,
          <tt class="classname">SystemProfileValueSource</tt> will be used by
          default.</p><pre class="programlisting">@ProfileValueSourceConfiguration(CustomProfileValueSource.class)
public class CustomProfileValueSourceTests {
    <i class="lineannotation"><span class="lineannotation">// class body...</span></i>
}</pre></li><li><p><span class="bold"><b><tt class="interfacename">@DirtiesContext</tt></b></span></p><p>The presence of this annotation on a test method indicates
          that the underlying Spring container is 'dirtied' during the
          execution of the test method, and thus must be rebuilt after the
          test method finishes execution (regardless of whether the test
          passed or not).</p><pre class="programlisting">@DirtiesContext
public void testProcessWhichDirtiesAppCtx() {
    <i class="lineannotation"><span class="lineannotation">// some logic that results in the Spring container being dirtied</span></i>
}</pre></li><li><p><span class="bold"><b><tt class="interfacename">@ExpectedException</tt></b></span></p><p>Indicates that the annotated test method is expected to throw
          an exception during execution. The type of the expected exception is
          provided in the annotation, and if an instance of the exception is
          thrown during the test method execution then the test passes.
          Likewise if an instance of the exception is <span class="emphasis"><em>not</em></span>
          thrown during the test method execution then the test fails.</p><pre class="programlisting">@ExpectedException(SomeBusinessException.class)
public void testProcessRainyDayScenario() {
    <i class="lineannotation"><span class="lineannotation">// some logic that should result in an <tt class="classname">Exception</tt> being thrown</span></i>
}</pre></li><li><p><span class="bold"><b><tt class="interfacename">@Timed</tt></b></span></p><p>Indicates that the annotated test method has to finish
          execution in a specified time period (in milliseconds). If the text
          execution time takes longer than the specified time period, the test
          fails.</p><p>Note that the time period includes execution of the test
          method itself, any repetitions of the test (see
          <tt class="interfacename">@Repeat</tt>), as well as any
          <span class="emphasis"><em>set up</em></span> or <span class="emphasis"><em>tear down</em></span> of the
          test fixture.</p><pre class="programlisting">@Timed(millis=1000)
public void testProcessWithOneSecondTimeout() {
    <i class="lineannotation"><span class="lineannotation">// some logic that should not take longer than 1 second to execute</span></i>
}</pre></li><li><p><span class="bold"><b><tt class="interfacename">@Repeat</tt></b></span></p><p>Indicates that the annotated test method must be executed
          repeatedly. The number of times that the test method is to be
          executed is specified in the annotation.</p><p>Note that the scope of execution to be repeated includes
          execution of the test method itself as well as any <span class="emphasis"><em>set
          up</em></span> or <span class="emphasis"><em>tear down</em></span> of the test
          fixture.</p><pre class="programlisting">@Repeat(10)
public void testProcessRepeatedly() {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre></li><li><p><span class="bold"><b><tt class="interfacename">@Rollback</tt></b></span></p><p>Indicates whether or not the transaction for the annotated
          test method should be <span class="emphasis"><em>rolled back</em></span> after the
          test method has completed. If <tt class="literal">true</tt>, the
          transaction will be rolled back; otherwise, the transaction will be
          committed. Use <tt class="interfacename">@Rollback</tt> to override
          the default rollback flag configured at the class level.</p><pre class="programlisting">@Rollback(false)
public void testProcessWithoutRollback() {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre></li><li><p><span class="bold"><b><tt class="interfacename">@NotTransactional</tt></b></span></p><p>The presence of this annotation indicates that the annotated
          test method must <span class="emphasis"><em>not</em></span> execute in a transactional
          context.</p><pre class="programlisting">@NotTransactional 
public void testProcessWithoutTransaction() {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre></li></ul></div><p>Annotation support for:</p><div class="itemizedlist"><ul type="disc"><li><p><a href="#junit38-legacy-java5-support" title="8.3.6.5.&nbsp;Java 5+ specific support">JUnit 3.8 legacy
          support</a>: all common annotations listed above are supported
          but <span class="emphasis"><em>must</em></span> be used in conjunction with
          <tt class="classname">AbstractAnnotationAwareTransactionalTests</tt> in
          order for the presence of these annotations to have any
          effect.</p></li><li><p><a href="#testcontext-annotations" title="8.3.7.6.&nbsp;TestContext framework annotation support">The TestContext
          Framework</a>: supports all of the common annotations listed
          above while providing additional TestContext-specific and
          transactional annotations (e.g.,
          <tt class="interfacename">@ContextConfiguration</tt>,
          <tt class="interfacename">@BeforeTransaction</tt>, etc.). Note,
          however, that some of the common annotations are only supported when
          used in conjunction with JUnit (e.g., with the <a href="#testcontext-junit4-runner" title="8.3.7.5.3.&nbsp;Custom JUnit 4.4 Runner">SpringJUnit4ClassRunner</a>
          or the <a href="#testcontext-support-classes-junit38" title="8.3.7.5.1.&nbsp;JUnit 3.8 support classes">JUnit
          3.8</a> and <a href="#testcontext-support-classes-junit44" title="8.3.7.5.2.&nbsp;JUnit 4.4 support classes">JUnit 4.4</a> base
          test classes). Refer to the documentation in the
          <span class="emphasis"><em>TestContext Framework</em></span> section for further
          details.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="junit38-legacy-support"></a>8.3.6.&nbsp;JUnit 3.8 legacy support</h3></div></div><div></div></div><p>Spring's JUnit 3.8 legacy support is comprised of the classes
      found in the <tt class="literal">org.springframework.test</tt> package. This
      package provides valuable JUnit <tt class="classname">TestCase</tt>
      superclasses which can be extended for out-of-container integration
      tests involving Spring <tt class="classname">ApplicationContext</tt>s or
      requiring transactional support at the test method level.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="junit38-legacy-ctx-management"></a>8.3.6.1.&nbsp;Context management and caching</h4></div></div><div></div></div><p><tt class="classname">AbstractSingleSpringContextTests</tt> provides
        context management and caching support for JUnit 3.8 based test cases
        and exposes a <tt class="literal">protected</tt> method that subclasses can
        override to provide the location of context definition files:</p><pre class="programlisting">protected String[] getConfigLocations()</pre><p>Implementations of this method must provide an array containing
        the resource locations of XML configuration metadata - typically on
        the classpath - used to configure the application. This will be the
        same, or nearly the same, as the list of configuration locations
        specified in <tt class="literal">web.xml</tt> or other deployment
        configuration. As an alternative you may choose to override one of the
        following. See the respective JavaDoc for further details.</p><pre class="programlisting">protected String[] getConfigPaths()</pre><pre class="programlisting">protected String getConfigPath()</pre><p>By default, once loaded, the configuration file set will be
        reused for each test case. Thus the setup cost will be incurred only
        once (per test fixture), and subsequent test execution will be much
        faster. In the unlikely case that a test may 'dirty' the application
        context, requiring reloading - for example, by changing a bean
        definition or the state of an application object - you can call the
        <tt class="methodname">setDirty()</tt> method on
        <tt class="classname">AbstractSingleSpringContextTests</tt> to cause the
        test fixture to reload the configurations and rebuild the application
        context before executing the next test case. As an alternative, if you
        are developing against Java 5 or greater and extending <a href="#junit38-legacy-annotation-aware-tests" title="8.3.6.5.1.&nbsp;Annotation aware transactional tests"><tt class="classname">AbstractAnnotationAwareTransactionalTests</tt></a>,
        you may annotate your test method with
        <tt class="interfacename">@DirtiesContext</tt> to achieve the same
        effect.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="junit38-legacy-fixture-di"></a>8.3.6.2.&nbsp;Dependency Injection of test fixtures</h4></div></div><div></div></div><p>When
        <tt class="classname">AbstractDependencyInjectionSpringContextTests</tt>
        (and subclasses) load your application context, they can optionally
        configure instances of your test classes by Setter Injection. All you
        need to do is to define instance variables and the corresponding
        setter methods.
        <tt class="classname">AbstractDependencyInjectionSpringContextTests</tt>
        will automatically locate the corresponding object in the set of
        configuration files specified in the
        <tt class="methodname">getConfigLocations()</tt> method.</p><p>Consider the scenario where we have a class,
        <tt class="classname">HibernateTitleDao</tt> (as outlined in the <a href="#testing-fixture-di" title="8.3.3.2.&nbsp;Dependency Injection of test fixtures">Common goals</a> section). Let's look
        at a JUnit 3.8 based implementation of the test class itself (we will
        look at the configuration immediately afterwards).</p><pre class="programlisting">public final class HibernateTitleDaoTests <span class="bold"><b>extends AbstractDependencyInjectionSpringContextTests</b></span>  {

    <i class="lineannotation"><span class="lineannotation">// this instance will be (automatically) dependency injected</span></i>    
    private HibernateTitleDao titleDao;

    <i class="lineannotation"><span class="lineannotation">// a setter method to enable DI of the 'titleDao' instance variable</span></i>
    public void setTitleDao(HibernateTitleDao titleDao) {
        this.titleDao = titleDao;
    }

    public void testLoadTitle() throws Exception {
        Title title = this.titleDao.loadTitle(new Long(10));
        assertNotNull(title);
    }

    <i class="lineannotation"><span class="lineannotation">// specifies the Spring configuration to load for this test fixture</span></i>
    protected String[] getConfigLocations() {
        return new String[] { "classpath:com/foo/daos.xml" };
    }

}</pre><p>The file referenced by the
        <tt class="methodname">getConfigLocations()</tt> method (i.e.,
        <tt class="literal">"classpath:com/foo/daos.xml"</tt>) looks like
        this:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" 
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- this bean will be injected into the <tt class="classname">HibernateTitleDaoTests</tt> class --&gt;</span></i>
    &lt;bean id="<span class="bold"><b>titleDao</b></span>" class="<span class="bold"><b>com.foo.dao.hibernate.HibernateTitleDao</b></span>"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- dependencies elided for clarity --&gt;</span></i>
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The
        <tt class="classname">AbstractDependencyInjectionSpringContextTests</tt>
        classes uses <a href="#beans-factory-autowire" title="3.3.5.&nbsp;Autowiring collaborators"><span class="emphasis"><em>autowire
        by type</em></span></a>. Thus if you have multiple bean definitions
        of the same type, you cannot rely on this approach for those
        particular beans. In that case, you can use the inherited
        <tt class="literal">applicationContext</tt> instance variable and perform
        explicit lookups using (for example) a call to
        <tt class="methodname">applicationContext.getBean("titleDao")</tt>.</p><p>If you don't want dependency injection applied to your test
        cases, simply don't declare any <tt class="literal">public</tt> setter
        methods. Alternatively, you can extend
        <tt class="classname">AbstractSpringContextTests</tt> - the root of the
        JUnit 3.8 integration testing support class hierarchy in the
        <tt class="literal">org.springframework.test</tt> package - which merely
        contains convenience methods to load Spring contexts and performs no
        Dependency Injection of the test fixture.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="junit38-legacy-fixture-di-field"></a>8.3.6.2.1.&nbsp;Field level injection</h5></div></div><div></div></div><p>If, for whatever reason, you don't fancy having setter methods
          in your test fixtures, Spring can inject dependencies into
          <tt class="literal">protected</tt> fields. Find below a reworking of the
          previous example to use field level injection (the Spring XML
          configuration does not need to change, merely the test
          fixture).</p><pre class="programlisting">public final class HibernateTitleDaoTests <span class="bold"><b>extends AbstractDependencyInjectionSpringContextTests</b></span>  {

    public HibernateTitleDaoTests() {
        <i class="lineannotation"><span class="lineannotation">// switch on field level injection</span></i>
        setPopulateProtectedVariables(true);
    }

    <i class="lineannotation"><span class="lineannotation">// this instance will be (automatically) dependency injected</span></i>
    <i class="lineannotation"><span class="lineannotation"><span class="emphasis"><em>protected</em></span></span></i> HibernateTitleDao <i class="lineannotation"><span class="lineannotation"><span class="emphasis"><em>titleDao</em></span></span></i>;

    public void testLoadTitle() throws Exception {
        Title title = this.titleDao.loadTitle(new Long(10));
        assertNotNull(title);
    }

    <i class="lineannotation"><span class="lineannotation">// specifies the Spring configuration to load for this test fixture</span></i>
    protected String[] getConfigLocations() {
        return new String[] { "classpath:com/foo/daos.xml" };
    }

}</pre><p>In the case of field injection, there is no autowiring going
          on: the name of a <tt class="literal">protected</tt> instance variable is
          used as the lookup bean name in the configured Spring
          container.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="junit38-legacy-tx"></a>8.3.6.3.&nbsp;Transaction management</h4></div></div><div></div></div><p><tt class="classname">AbstractTransactionalSpringContextTests</tt>
        depends on a <tt class="classname">PlatformTransactionManager</tt> bean
        being defined in the application context. The name doesn't matter due
        to the use of <a href="#beans-factory-autowire" title="3.3.5.&nbsp;Autowiring collaborators"><span class="emphasis"><em>autowire by
        type</em></span></a>.</p><p>Typically you will extend the subclass,
        <tt class="classname">AbstractTransactionalDataSourceSpringContextTests</tt>.
        This class also requires that a <tt class="classname">DataSource</tt> bean
        definition - again, with any name - be present in the application
        context. It creates a <tt class="classname">JdbcTemplate</tt> instance
        variable, that is useful for convenient querying, and provides handy
        methods to delete the contents of selected tables (remember that the
        transaction will roll back by default, so this is safe to do).</p><p>If you want a transaction to commit
        <span class="emphasis"><em>programmatically</em></span> - unusual, but occasionally
        useful when you want a particular test to populate the database - you
        can call the <tt class="methodname">setComplete()</tt> method inherited
        from <tt class="classname">AbstractTransactionalSpringContextTests</tt>.
        This will cause the transaction to commit instead of roll back. As an
        alternative, if you are developing against Java 5 or greater and
        extending <a href="#junit38-legacy-annotation-aware-tests" title="8.3.6.5.1.&nbsp;Annotation aware transactional tests"><tt class="classname">AbstractAnnotationAwareTransactionalTests</tt></a>,
        you may annotate your test method with
        <tt class="interfacename">@Rollback(false)</tt> to achieve the same
        effect through <span class="emphasis"><em>configuration</em></span>.</p><p>There is also the convenient ability to end a transaction before
        the test case ends, by calling the
        <tt class="methodname">endTransaction()</tt> method. This will roll back
        the transaction by default and commit it only if
        <tt class="methodname">setComplete()</tt> had previously been called.
        This functionality is useful if you want to test the behavior of
        'disconnected' data objects, such as Hibernate-mapped entities that
        will be used in a web or remoting tier outside a transaction. Often,
        lazy loading errors are discovered only through UI testing; if you
        call <tt class="methodname">endTransaction()</tt> you can ensure correct
        operation of the UI through your JUnit test suite.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="junit38-legacy-support-classes"></a>8.3.6.4.&nbsp;JUnit 3.8 legacy support classes</h4></div></div><div></div></div><p>When you extend the
        <tt class="classname">AbstractTransactionalDataSourceSpringContextTests</tt>
        class you will have access to the following
        <tt class="literal">protected</tt> instance variables:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">applicationContext</tt> (a
            <tt class="interfacename">ConfigurableApplicationContext</tt>):
            inherited from the
            <tt class="classname">AbstractSingleSpringContextTests</tt>
            superclass. Use this to perform explicit bean lookup or to test
            the state of the context as a whole.</p></li><li><p><tt class="literal">jdbcTemplate</tt>: inherited from
            <tt class="classname">AbstractTransactionalDataSourceSpringContextTests</tt>.
            Useful for querying to confirm state. For example, you might query
            before and after testing application code that creates an object
            and persists it using an ORM tool, to verify that the data appears
            in the database. (Spring will ensure that the query runs in the
            scope of the same transaction.) You will need to tell your ORM
            tool to 'flush' its changes for this to work correctly, for
            example using the <tt class="methodname">flush()</tt> method on
            Hibernate's <tt class="classname">Session</tt> interface.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="junit38-legacy-java5-support"></a>8.3.6.5.&nbsp;Java 5+ specific support</h4></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="junit38-legacy-annotation-aware-tests"></a>8.3.6.5.1.&nbsp;Annotation aware transactional tests</h5></div></div><div></div></div><p>In addition to the aforementioned <a href="#integration-testing-common-annotations" title="8.3.5.&nbsp;Common annotations">common
          annotations</a>, the
          <tt class="literal">org.springframework.test.annotation</tt> package also
          contains an <tt class="literal">abstract</tt> JUnit
          <tt class="classname">TestCase</tt> class which provides
          annotation-driven integration testing support.</p><p>The
          <tt class="classname">AbstractAnnotationAwareTransactionalTests</tt>
          class extends
          <tt class="classname">AbstractTransactionalDataSourceSpringContextTests</tt>
          and makes text fixtures, which extend it, aware of a number of
          (Spring-specific) annotations.
          <tt class="classname">AbstractAnnotationAwareTransactionalTests</tt>
          supports all annotations listed in the <a href="#integration-testing-common-annotations" title="8.3.5.&nbsp;Common annotations">common
          annotations</a> section as well as Spring's
          <tt class="interfacename">@Transactional</tt> annotation for
          configuring explicit transactional semantics.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="junit38-legacy-jpa-tests"></a>8.3.6.5.2.&nbsp;JPA support classes</h5></div></div><div></div></div><p>The <tt class="literal">org.springframework.test.jpa</tt> package
          provides support classes for tests based on the Java Persistence API
          (JPA).</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">AbstractJpaTests</tt> is a convenient
              support class for JPA-related tests, which offers the same
              contract as
              <tt class="classname">AbstractTransactionalDataSourceSpringContextTests</tt>
              and equally good performance, even when performing the
              instrumentation required by the JPA specification. Exposes an
              <tt class="interfacename">EntityManagerFactory</tt> and a shared
              <tt class="interfacename">EntityManager</tt>. Requires an
              <tt class="interfacename">EntityManagerFactory</tt> to be
              injected, plus the <tt class="interfacename">DataSource</tt> and
              <tt class="interfacename">JpaTransactionManager</tt> through the
              superclass.</p></li><li><p><tt class="classname">AbstractAspectjJpaTests</tt> is a
              subclass of <tt class="classname">AbstractJpaTests</tt> that
              activates AspectJ load-time weaving and allows the ability to
              specify a custom location for AspectJ's
              <tt class="literal">aop.xml</tt> file.</p></li></ul></div></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="testcontext-framework"></a>8.3.7.&nbsp;Spring TestContext Framework</h3></div></div><div></div></div><p>The <span class="emphasis"><em>Spring <tt class="classname">TestContext</tt>
      Framework</em></span> (located in the
      <tt class="literal">org.springframework.test.context</tt> package) provides
      generic, annotation-driven unit and integration testing support that is
      agnostic of the testing framework in use, for example JUnit 3.8, JUnit
      4.4, TestNG 5.5, etc. The TestContext framework also places a great deal
      of importance on <span class="emphasis"><em>convention over configuration</em></span> with
      reasonable defaults that can be overridden via annotation-based
      configuration.</p><p>In addition to generic testing infrastructure, the TestContext
      framework provides explicit support for JUnit 3.8, JUnit 4.4, and TestNG
      5.5 in the form of <tt class="literal">abstract</tt> support classes. For
      JUnit 4.4, the framework also provides a custom
      <tt class="interfacename">Runner</tt> which allows one to write test
      classes that are not required to extend a particular class
      hierarchy.</p><p>The following section provides an overview of the internals of the
      TestContext framework. If you are only interested in using the framework
      and not necessarily interested in extending it with your own custom
      listeners, feel free to skip ahead to the configuration (<a href="#testcontext-ctx-management" title="8.3.7.2.&nbsp;Context management and caching">context management</a>, <a href="#testcontext-fixture-di" title="8.3.7.3.&nbsp;Dependency Injection of test fixtures">dependency injection</a>, <a href="#testcontext-tx" title="8.3.7.4.&nbsp;Transaction management">transaction management</a>), <a href="#testcontext-support-classes" title="8.3.7.5.&nbsp;TestContext support classes">support classes</a>, and <a href="#testcontext-annotations" title="8.3.7.6.&nbsp;TestContext framework annotation support">annotation support</a>
      sections.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-key-abstractions"></a>8.3.7.1.&nbsp;Key abstractions</h4></div></div><div></div></div><p>The core of the framework consists of the
        <tt class="classname">TestContext</tt> and
        <tt class="classname">TestContextManager</tt> classes and the
        <tt class="interfacename">TestExecutionListener</tt> interface. A
        <tt class="classname">TestContextManager</tt> is created on a per-test
        basis. The <tt class="classname">TestContextManager</tt> in turn manages a
        <tt class="classname">TestContext</tt> which is responsible for holding
        the context of the current test. The
        <tt class="classname">TestContextManager</tt> is also responsible for
        updating the state of the <tt class="classname">TestContext</tt> as the
        test progresses and delegating to
        <tt class="interfacename">TestExecutionListener</tt>s, which
        instrument the actual test execution (e.g., providing dependency
        injection, managing transactions, etc.). Consult the JavaDoc and the
        Spring test suite for further information and examples of various
        configurations.</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">TestContext</tt>: encapsulates the context
            in which a test is executed, agnostic of the actual testing
            framework in use.</p></li><li><p><tt class="classname">TestContextManager</tt>: the main entry
            point into the <span class="emphasis"><em>Spring TestContext Framework</em></span>,
            which is responsible for managing a single
            <tt class="classname">TestContext</tt> and signaling events to all
            registered <tt class="interfacename">TestExecutionListener</tt>s
            at well defined test execution points: test instance preparation,
            prior to any <span class="emphasis"><em>before methods</em></span> of a particular
            testing framework, and after any <span class="emphasis"><em>after
            methods</em></span> of a particular testing framework.</p></li><li><p><tt class="interfacename">TestExecutionListener</tt>:
            defines a <span class="emphasis"><em>listener</em></span> API for reacting to test
            execution events published by the
            <tt class="classname">TestContextManager</tt> with which the listener
            is registered.</p><p>Spring provides three
            <tt class="interfacename">TestExecutionListener</tt>
            implementations which are configured by default (via the
            <tt class="interfacename">@TestExecutionListeners</tt>
            annotation):
            <tt class="classname">DependencyInjectionTestExecutionListener</tt>,
            <tt class="classname">DirtiesContextTestExecutionListener</tt>, and
            <tt class="classname">TransactionalTestExecutionListener</tt>, which
            provide support for dependency injection of the test instance,
            handling of the <tt class="interfacename">@DirtiesContext</tt>
            annotation, and transactional test execution support with default
            rollback semantics, respectively.</p></li></ul></div><p>The following three sections explain how to configure the
        <tt class="classname">TestContext</tt> framework via annotations and
        provide working examples of how to actually write unit and integration
        tests with the framework.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-ctx-management"></a>8.3.7.2.&nbsp;Context management and caching</h4></div></div><div></div></div><p>Each <tt class="classname">TestContext</tt> provides context
        management and caching support for the test instance for which it is
        responsible. Test instances do not automatically receive access to the
        configured <tt class="classname">ApplicationContext</tt>; however, if a
        test class implements the
        <tt class="interfacename">ApplicationContextAware</tt> interface, a
        reference to the <tt class="classname">ApplicationContext</tt> will be
        supplied to the test instance (provided the
        <tt class="classname">DependencyInjectionTestExecutionListener</tt> has
        been configured, which is the default). Note that
        <tt class="classname">AbstractJUnit38SpringContextTests</tt>,
        <tt class="classname">AbstractJUnit4SpringContextTests</tt>, and
        <tt class="classname">AbstractTestNGSpringContextTests</tt> already
        implement <tt class="interfacename">ApplicationContextAware</tt> and
        therefore provide this functionality out-of-the-box.</p><p>In contrast to the JUnit 3.8 legacy support, test classes which
        use the TestContext framework do not need to override any
        <tt class="literal">protected</tt> instance methods to configure their
        application context. Rather, configuration is achieved merely by
        declaring the <tt class="interfacename">@ContextConfiguration</tt>
        annotation at the class level. If your test class does not explicitly
        declare any application context resource <tt class="literal">locations</tt>,
        the configured <tt class="interfacename">ContextLoader</tt> will
        determine how and whether or not to load a context from a default set
        of locations. For example,
        <tt class="classname">GenericXmlContextLoader</tt> - which is the default
        <tt class="interfacename">ContextLoader</tt> - will generate a default
        location based on the name of the test class. If your class is named
        <tt class="literal">com.example.MyTest</tt>,
        <tt class="classname">GenericXmlContextLoader</tt> will load your
        application context from
        <tt class="literal">"classpath:/com/example/MyTest-context.xml"</tt>.</p><pre class="programlisting">package com.example;

@RunWith(SpringJUnit4ClassRunner.class)
<i class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from <tt class="literal">"classpath:/com/example/MyTest-context.xml"</tt></span></i>
<span class="bold"><b>@ContextConfiguration</b></span>
public class MyTest {
    <i class="lineannotation"><span class="lineannotation">// class body...</span></i>
}</pre><p>If the default location does not suit your needs, you are free
        to explicitly configure the <tt class="literal">locations</tt> attribute of
        <tt class="interfacename">@ContextConfiguration</tt> (see code listing
        below) with an array containing the resource locations of XML
        configuration metadata (assuming an XML-capable
        <tt class="interfacename">ContextLoader</tt> has been configured) -
        typically on the classpath - used to configure the application. This
        will be the same, or nearly the same, as the list of configuration
        locations specified in <tt class="literal">web.xml</tt> or other deployment
        configuration. As an alternative you may choose to implement and
        configure your own custom
        <tt class="interfacename">ContextLoader</tt>.</p><pre class="programlisting">@RunWith(SpringJUnit4ClassRunner.class)
<i class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from <tt class="literal">"/applicationContext.xml"</tt> and <tt class="literal">"/applicationContext-test.xml"</tt></span></i>
<i class="lineannotation"><span class="lineannotation">// in the root of the classpath</span></i>
<span class="bold"><b>@ContextConfiguration(locations={"/applicationContext.xml", "/applicationContext-test.xml"})</b></span>
public class MyTest {
    <i class="lineannotation"><span class="lineannotation">// class body...</span></i>
}</pre><p><tt class="interfacename">@ContextConfiguration</tt> also
        supports a boolean <tt class="literal">inheritLocations</tt> attribute which
        denotes whether or not resource locations from superclasses should be
        <span class="emphasis"><em>inherited</em></span>. The default value is
        <tt class="literal">true</tt>, which means that an annotated class will
        <span class="emphasis"><em>inherit</em></span> the resource locations defined by an
        annotated superclass. Specifically, the resource locations for an
        annotated class will be appended to the list of resource locations
        defined by an annotated superclass. Thus, subclasses have the option
        of <span class="emphasis"><em>extending</em></span> the list of resource locations. In
        the following example, the
        <tt class="interfacename">ApplicationContext</tt> for
        <tt class="classname">ExtendedTest</tt> will be loaded from
        "/base-context.xml" <span class="bold"><b>and</b></span>
        "/extended-context.xml", in that order. Beans defined in
        "/extended-context.xml" may therefore override those defined in
        "/base-context.xml".</p><pre class="programlisting">@RunWith(SpringJUnit4ClassRunner.class)
<i class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from <tt class="literal">"/base-context.xml"</tt> in the root of the classpath</span></i>
<span class="bold"><b>@ContextConfiguration(locations={"/base-context.xml"})</b></span>
public class BaseTest {
    <i class="lineannotation"><span class="lineannotation">// class body...</span></i>
}

<i class="lineannotation"><span class="lineannotation">// ApplicationContext will be loaded from <tt class="literal">"/base-context.xml"</tt> and <tt class="literal">"/extended-context.xml"</tt></span></i>
<i class="lineannotation"><span class="lineannotation">// in the root of the classpath</span></i>
<span class="bold"><b>@ContextConfiguration(locations={"/extended-context.xml"})</b></span>
public class ExtendedTest extends BaseTest {
    <i class="lineannotation"><span class="lineannotation">// class body...</span></i>
}</pre><p>If <tt class="literal">inheritLocations</tt> is set to
        <tt class="literal">false</tt>, the resource locations for the annotated
        class will <span class="emphasis"><em>shadow</em></span> and effectively replace any
        resource locations defined by a superclass.</p><p>By default, once loaded, the configured
        <tt class="interfacename">ApplicationContext</tt> will be reused for
        each test. Thus the setup cost will be incurred only once (per test
        fixture), and subsequent test execution will be much faster. In the
        unlikely case that a test may <span class="emphasis"><em>dirty</em></span> the
        application context, requiring reloading - for example, by changing a
        bean definition or the state of an application object - you may
        annotate your test method with
        <tt class="interfacename">@DirtiesContext</tt> (assuming
        <tt class="classname">DirtiesContextTestExecutionListener</tt> has been
        configured, which is the default) to cause the test fixture to reload
        the configurations and rebuild the application context before
        executing the next test.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-fixture-di"></a>8.3.7.3.&nbsp;Dependency Injection of test fixtures</h4></div></div><div></div></div><p>When you configure the
        <tt class="classname">DependencyInjectionTestExecutionListener</tt> -
        which is configured by default - via the
        <tt class="interfacename">@TestExecutionListeners</tt> annotation, the
        dependencies of your test instances will be
        <span class="emphasis"><em>injected</em></span> from beans in the application context
        you configured via
        <tt class="interfacename">@ContextConfiguration</tt> by Setter
        Injection, Field Injection, or both, depending on which annotations
        you choose and whether you place them on setter methods or fields. For
        consistency with annotation support in Spring 2.5, you may choose
        either Spring's <tt class="interfacename">@Autowired</tt> annotation
        or the <tt class="interfacename">@Resource</tt> annotation from JSR
        250. The semantics for both are consistent throughout the Spring
        Framework. For example, if you prefer <a href="#beans-factory-autowire" title="3.3.5.&nbsp;Autowiring collaborators"><span class="emphasis"><em>autowiring by
        type</em></span></a>, annotate your setter methods or fields with
        <tt class="interfacename">@Autowired</tt>. On the other hand, if you
        prefer to have your dependencies injected <span class="emphasis"><em>by
        name</em></span>, annotate your setter methods or fields with
        <tt class="interfacename">@Resource</tt>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>The TestContext framework does not instrument the manner in
          which a test instance is instantiated. Thus the use of
          <tt class="interfacename">@Autowired</tt> for constructors has no
          effect for test classes.</p></td></tr></table></div><p>Since <tt class="interfacename">@Autowired</tt> performs <a href="#beans-factory-autowire" title="3.3.5.&nbsp;Autowiring collaborators"><span class="emphasis"><em>autowiring by
        type</em></span></a>, if you have multiple bean definitions of the
        same type, you cannot rely on this approach for those particular
        beans. In that case, you can use
        <tt class="interfacename">@Resource</tt> for injection <span class="emphasis"><em>by
        name</em></span>. Alternatively, if your test class implements
        <tt class="classname">ApplicationContextAware</tt>, you can directly
        access the <tt class="classname">ApplicationContext</tt> supplied to your
        test and perform an explicit lookup using (for example) a call to
        <tt class="methodname">applicationContext.getBean("titleDao")</tt>.</p><p>If you don't want dependency injection applied to your test
        instances, simply don't annotate any fields or setter methods with
        <tt class="interfacename">@Autowired</tt> or
        <tt class="interfacename">@Resource</tt>. Alternatively, you can
        disable dependency injection altogether by explicitly configuring your
        class with <tt class="interfacename">@TestExecutionListeners</tt> and
        omitting
        <tt class="literal">DependencyInjectionTestExecutionListener.class</tt> from
        the list of listeners.</p><p>Consider the scenario where we have a class,
        <tt class="classname">HibernateTitleDao</tt> (as outlined in the <a href="#testing-fixture-di" title="8.3.3.2.&nbsp;Dependency Injection of test fixtures">common goals</a> section). First,
        let's look at a JUnit 4.4 based implementation of the test class
        itself which uses <tt class="interfacename">@Autowired</tt> for field
        injection (we will look at the application context configuration after
        all sample code listings). <span class="emphasis"><em>Note: The dependency injection
        behavior in the following code listings is not in any way specific to
        JUnit 4.4. The same DI techniques can be used in conjunction with any
        testing framework.</em></span></p><pre class="programlisting">@RunWith(SpringJUnit4ClassRunner.class)
<i class="lineannotation"><span class="lineannotation">// specifies the Spring configuration to load for this test fixture</span></i>
<span class="bold"><b>@ContextConfiguration(locations={"daos.xml"})</b></span>
public final class HibernateTitleDaoTests {

    <i class="lineannotation"><span class="lineannotation">// this instance will be dependency injected <span class="bold"><b>by type</b></span></span></i>
    <span class="bold"><b>@Autowired</b></span>    
    private HibernateTitleDao titleDao;

    public void testLoadTitle() throws Exception {
        Title title = this.titleDao.loadTitle(new Long(10));
        assertNotNull(title);
    }
}</pre><p>Alternatively, we can configure the class to use
        <tt class="interfacename">@Autowired</tt> for setter injection.</p><pre class="programlisting">@RunWith(SpringJUnit4ClassRunner.class)
<i class="lineannotation"><span class="lineannotation">// specifies the Spring configuration to load for this test fixture</span></i>
<span class="bold"><b>@ContextConfiguration(locations={"daos.xml"})</b></span>
public final class HibernateTitleDaoTests {

    <i class="lineannotation"><span class="lineannotation">// this instance will be dependency injected <span class="bold"><b>by type</b></span></span></i>
    private HibernateTitleDao titleDao;

    <span class="bold"><b>@Autowired</b></span>
    public void setTitleDao(HibernateTitleDao titleDao) {
        this.titleDao = titleDao;
    }

    public void testLoadTitle() throws Exception {
        Title title = this.titleDao.loadTitle(new Long(10));
        assertNotNull(title);
    }
}</pre><p>Now let's take a look at an example using
        <tt class="interfacename">@Resource</tt> for field injection.</p><pre class="programlisting">@RunWith(SpringJUnit4ClassRunner.class)
<i class="lineannotation"><span class="lineannotation">// specifies the Spring configuration to load for this test fixture</span></i>
<span class="bold"><b>@ContextConfiguration(locations={"daos.xml"})</b></span>
public final class HibernateTitleDaoTests {

    <i class="lineannotation"><span class="lineannotation">// this instance will be dependency injected <span class="bold"><b>by name</b></span></span></i>
    <span class="bold"><b>@Resource</b></span>
    private HibernateTitleDao titleDao;

    public void testLoadTitle() throws Exception {
        Title title = this.titleDao.loadTitle(new Long(10));
        assertNotNull(title);
    }
}</pre><p>Finally, here is an example using
        <tt class="interfacename">@Resource</tt> for setter injection.</p><pre class="programlisting">@RunWith(SpringJUnit4ClassRunner.class)
<i class="lineannotation"><span class="lineannotation">// specifies the Spring configuration to load for this test fixture</span></i>
<span class="bold"><b>@ContextConfiguration(locations={"daos.xml"})</b></span>
public final class HibernateTitleDaoTests {

    <i class="lineannotation"><span class="lineannotation">// this instance will be dependency injected <span class="bold"><b>by name</b></span></span></i>
    private HibernateTitleDao titleDao;
    
    <span class="bold"><b>@Resource</b></span>
    public void setTitleDao(HibernateTitleDao titleDao) {
        this.titleDao = titleDao;
    }

    public void testLoadTitle() throws Exception {
        Title title = this.titleDao.loadTitle(new Long(10));
        assertNotNull(title);
    }
}</pre><p>The above code listings use the same XML context file referenced
        by the <tt class="interfacename">@ContextConfiguration</tt> annotation
        (i.e., <tt class="literal">"daos.xml"</tt>) which looks like this:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" 
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- this bean will be injected into the <tt class="classname">HibernateTitleDaoTests</tt> class --&gt;</span></i>
    &lt;bean id="<span class="bold"><b>titleDao</b></span>" class="<span class="bold"><b>com.foo.dao.hibernate.HibernateTitleDao</b></span>"&gt;
        &lt;property name="sessionFactory" ref="sessionFactory"/&gt;
    &lt;/bean&gt;
    
    &lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- dependencies elided for clarity --&gt;</span></i>
    &lt;/bean&gt;

&lt;/beans&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you are extending from a Spring-provided test base class that happens
          to use <tt class="interfacename">@Autowired</tt> on one of its setters methods,
          you might have multiple beans of the affected type defined in your application context:
          e.g. multiple <tt class="interfacename">DataSource</tt> beans. In such a case,
          you may override the setter and use the <tt class="interfacename">@Qualifier</tt>
          annotation to indicate a specific target bean as follows:</p><pre class="programlisting">...
    @Override @Autowired
    public void setDataSource(<span class="bold"><b>@Qualifier("myDataSource")</b></span> DataSource dataSource) {
        super.setDataSource(dataSource);
    }
...</pre><p>The specified qualifier value indicates the specific
          <tt class="interfacename">DataSource</tt> bean to inject,
          narrowing the set of type matches to a specific bean.
          Its value is matched against <tt class="literal">&lt;qualifier&gt;</tt>
          declarations within the corresponding <tt class="literal">&lt;bean&gt;</tt>
          definitions. The bean name is used as a fallback qualifier value,
          so you may effectively also point to a specific bean by name there
          (as shown above, assuming that "myDataSource" is the bean id).
          If there is only one <tt class="interfacename">DataSource</tt> bean
          to begin with, then the qualifier will simply not have any effect
          - independent from the bean name of that single matching bean.</p><p>Alternatively, consider using the <tt class="interfacename">@Resource</tt>
          annotation on such an overridden setter methods, defining the
          target bean name explicitly - with no type matching semantics.
          Note that this always points to a bean with that specific name,
          no matter whether there is one or more beans of the given type.</p><pre class="programlisting">...
    @Override <span class="bold"><b>@Resource("myDataSource")</b></span>
    public void setDataSource(DataSource dataSource) {
        super.setDataSource(dataSource);
    }
...</pre></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-tx"></a>8.3.7.4.&nbsp;Transaction management</h4></div></div><div></div></div><p>In the TestContext framework, transactions are managed by the
        <tt class="classname">TransactionalTestExecutionListener</tt>, which is
        configured via the
        <tt class="interfacename">@TestExecutionListeners</tt> annotation by
        default, even if you do not explicitly declare
        <tt class="interfacename">@TestExecutionListeners</tt> on your test
        class. To enable support for transactions, however, you must provide a
        <tt class="classname">PlatformTransactionManager</tt> bean in the
        application context loaded via
        <tt class="interfacename">@ContextConfiguration</tt> semantics. In
        addition, you must declare
        <tt class="interfacename">@Transactional</tt> either at the class or
        method level.</p><p>For class-level transaction configuration (i.e., setting the
        bean name for the transaction manager and the default rollback flag),
        see the <tt class="interfacename">@TransactionConfiguration</tt> entry
        in the <a href="#testcontext-annotations" title="8.3.7.6.&nbsp;TestContext framework annotation support">TestContext framework
        annotation support</a> section.</p><p>There are several options for configuring transactions for
        individual test methods. If transactions are not enabled for the
        entire test class, methods may be explicitly annotated with
        <tt class="interfacename">@Transactional</tt>. Similarly, if
        transactions <span class="emphasis"><em>are</em></span> enabled for the entire test
        class, methods may be explicitly flagged not to run within a
        transaction by annotating them with
        <tt class="interfacename">@NotTransactional</tt>. To control whether
        or not a transaction should commit for a particular test method, you
        may use the <tt class="interfacename">@Rollback</tt> annotation to
        override the class-level default rollback setting.</p><p><span class="emphasis"><em>Note that <a href="#testcontext-support-classes-junit38" title="8.3.7.5.1.&nbsp;JUnit 3.8 support classes"><tt class="classname">AbstractTransactionalJUnit38SpringContextTests</tt></a>,
        <a href="#testcontext-support-classes-junit44" title="8.3.7.5.2.&nbsp;JUnit 4.4 support classes"><tt class="classname">AbstractTransactionalJUnit4SpringContextTests</tt></a>,
        and <a href="#testcontext-support-classes-testng" title="8.3.7.5.4.&nbsp;TestNG support classes"><tt class="classname">AbstractTransactionalTestNGSpringContextTests</tt></a>
        are pre-configured for transactional support at the class level.
        </em></span></p><p>You will occasionally find that you need to execute certain code
        before or after a transactional test method but outside the
        transactional context, for example to verify the initial database
        state prior to execution of your test or to verify expected
        transactional commit behavior after test execution (e.g., if the test
        was configured not to roll back the transaction).
        <tt class="classname">TransactionalTestExecutionListener</tt> supports the
        <tt class="interfacename">@BeforeTransaction</tt> and
        <tt class="interfacename">@AfterTransaction</tt> annotations exactly
        for such scenarios. Simply annotate any <tt class="literal">public void</tt>
        method in your test class with one of these annotations, and the
        <tt class="classname">TransactionalTestExecutionListener</tt> will ensure
        that your <span class="emphasis"><em>before transaction method</em></span> or
        <span class="emphasis"><em>after transaction method</em></span> is executed at the
        appropriate time.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>Any <span class="emphasis"><em>before methods</em></span> (e.g., methods
          annotated with JUnit 4's @Before) and any <span class="emphasis"><em>after
          methods</em></span> (e.g., methods annotated with JUnit 4's @After)
          will be executed <span class="bold"><b>within</b></span> a
          transaction. In addition, methods annotated with
          <tt class="interfacename">@BeforeTransaction</tt> or
          <tt class="interfacename">@AfterTransaction</tt> will naturally not
          be executed for tests annotated with
          <tt class="interfacename">@NotTransactional</tt>.</p></td></tr></table></div><p>The following JUnit 4 based example displays a fictitious
        integration testing scenario highlighting several of the
        transaction-related annotations. Consult the <a href="#testcontext-annotations" title="8.3.7.6.&nbsp;TestContext framework annotation support">TestContext framework annotation
        support</a> section of the reference manual for further information
        and configuration examples.</p><pre class="programlisting">@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration
<span class="bold"><b>@TransactionConfiguration(transactionManager="txMgr", defaultRollback=false)</b></span>
<span class="bold"><b>@Transactional</b></span>
public class FictitiousTransactionalTest {

    <span class="bold"><b>@BeforeTransaction</b></span>
    public void verifyInitialDatabaseState() {
        <i class="lineannotation"><span class="lineannotation">// logic to verify the initial state before a transaction is started</span></i>
    }

    @Before
    public void setUpTestDataWithinTransaction() {
        <i class="lineannotation"><span class="lineannotation">// set up test data within the transaction</span></i>
    }

    @Test
    <i class="lineannotation"><span class="lineannotation">// overrides the class-level defaultRollback setting</span></i>
    <span class="bold"><b>@Rollback(true)</b></span>
    public void modifyDatabaseWithinTransaction() {
        <i class="lineannotation"><span class="lineannotation">// logic which uses the test data and modifies database state</span></i>
    }

    @After
    public void tearDownWithinTransaction() {
        <i class="lineannotation"><span class="lineannotation">// execute "tear down" logic within the transaction</span></i>
    }

    <span class="bold"><b>@AfterTransaction</b></span>
    public void verifyFinalDatabaseState() {
        <i class="lineannotation"><span class="lineannotation">// logic to verify the final state after transaction has rolled back</span></i>
    }

    @Test
    <span class="bold"><b>@NotTransactional</b></span>
    public void performNonDatabaseRelatedAction() {
        <i class="lineannotation"><span class="lineannotation">// logic which does not modify database state</span></i>
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-support-classes"></a>8.3.7.5.&nbsp;TestContext support classes</h4></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-support-classes-junit38"></a>8.3.7.5.1.&nbsp;JUnit 3.8 support classes</h5></div></div><div></div></div><p>The
          <tt class="literal">org.springframework.test.context.junit38</tt> package
          provides support classes for JUnit 3.8 based test cases.</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">AbstractJUnit38SpringContextTests</tt>:</p><p>Abstract <tt class="classname">TestCase</tt> which integrates
              the <span class="emphasis"><em>Spring TestContext Framework</em></span> with
              explicit <tt class="classname">ApplicationContext</tt> testing
              support in a JUnit 3.8 environment. When you extend the
              <tt class="classname">AbstractJUnit38SpringContextTests</tt> class
              you will have access to the following
              <tt class="literal">protected</tt> instance variables:</p><div class="itemizedlist"><ul type="circle"><li><p><tt class="literal">applicationContext</tt>: use this to
                  perform explicit bean lookups or to test the state of the
                  context as a whole.</p></li></ul></div></li><li><p><tt class="classname">AbstractTransactionalJUnit38SpringContextTests</tt>:</p><p>Abstract <span class="emphasis"><em>transactional</em></span> extension of
              <tt class="classname">AbstractJUnit38SpringContextTests</tt> that
              also adds some convenience functionality for JDBC access.
              Expects a <tt class="classname">javax.sql.DataSource</tt> bean and a
              <tt class="interfacename">PlatformTransactionManager</tt> bean
              to be defined in the <tt class="classname">ApplicationContext</tt>.
              When you extend the
              <tt class="classname">AbstractTransactionalJUnit38SpringContextTests</tt>
              class you will have access to the following
              <tt class="literal">protected</tt> instance variables:</p><div class="itemizedlist"><ul type="circle"><li><p><tt class="literal">applicationContext</tt>: inherited from
                  the <tt class="classname">AbstractJUnit38SpringContextTests</tt>
                  superclass. Use this to perform explicit bean lookups or to
                  test the state of the context as a whole.</p></li><li><p><tt class="literal">simpleJdbcTemplate</tt>: useful for
                  querying to confirm state. For example, you might query
                  before and after testing application code that creates an
                  object and persists it using an ORM tool, to verify that the
                  data appears in the database. (Spring will ensure that the
                  query runs in the scope of the same transaction.) You will
                  need to tell your ORM tool to 'flush' its changes for this
                  to work correctly, for example using the
                  <tt class="methodname">flush()</tt> method on Hibernate's
                  <tt class="classname">Session</tt> interface.</p></li></ul></div></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-support-classes-junit44"></a>8.3.7.5.2.&nbsp;JUnit 4.4 support classes</h5></div></div><div></div></div><p>The <tt class="literal">org.springframework.test.context.junit4</tt>
          package provides support classes for JUnit 4.4 based test
          cases.</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">AbstractJUnit4SpringContextTests</tt>:</p><p>Abstract base test class which integrates the
              <span class="emphasis"><em>Spring TestContext Framework</em></span> with explicit
              <tt class="classname">ApplicationContext</tt> testing support in a
              JUnit 4.4 environment.</p><p>When you extend
              <tt class="classname">AbstractJUnit4SpringContextTests</tt> you will
              have access to the following <tt class="literal">protected</tt>
              instance variables:</p><div class="itemizedlist"><ul type="circle"><li><p><tt class="literal">applicationContext</tt>: use this to
                  perform explicit bean lookups or to test the state of the
                  context as a whole.</p></li></ul></div></li><li><p><tt class="classname">AbstractTransactionalJUnit4SpringContextTests</tt>:</p><p>Abstract <span class="emphasis"><em>transactional</em></span> extension of
              <tt class="classname">AbstractJUnit4SpringContextTests</tt> that
              also adds some convenience functionality for JDBC access.
              Expects a <tt class="classname">javax.sql.DataSource</tt> bean and a
              <tt class="interfacename">PlatformTransactionManager</tt> bean
              to be defined in the
              <tt class="classname">ApplicationContext</tt>.</p><p>When you extend
              <tt class="classname">AbstractTransactionalJUnit4SpringContextTests</tt>
              you will have access to the following
              <tt class="literal">protected</tt> instance variables:</p><div class="itemizedlist"><ul type="circle"><li><p><tt class="literal">applicationContext</tt>: inherited from
                  the <tt class="classname">AbstractJUnit4SpringContextTests</tt>
                  superclass. Use this to perform explicit bean lookups or to
                  test the state of the context as a whole.</p></li><li><p><tt class="literal">simpleJdbcTemplate</tt>: useful for
                  querying to confirm state. For example, you might query
                  before and after testing application code that creates an
                  object and persists it using an ORM tool, to verify that the
                  data appears in the database. (Spring will ensure that the
                  query runs in the scope of the same transaction.) You will
                  need to tell your ORM tool to 'flush' its changes for this
                  to work correctly, for example using the
                  <tt class="methodname">flush()</tt> method on Hibernate's
                  <tt class="classname">Session</tt> interface.</p></li></ul></div></li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>These classes serve only as a convenience for extension. If
            you do not wish for your test classes to be tied to a
            Spring-specific class hierarchy - for example, if you wish to
            directly extend the class you are testing - you may configure your
            own custom test classes by using
            <tt class="interfacename">@RunWith(SpringJUnit4ClassRunner.class)</tt>,
            <tt class="interfacename">@ContextConfiguration</tt>,
            <tt class="interfacename">@TestExecutionListeners</tt>,
            etc.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-junit4-runner"></a>8.3.7.5.3.&nbsp;Custom JUnit 4.4 Runner</h5></div></div><div></div></div><p>The <span class="emphasis"><em>Spring TestContext Framework</em></span> offers
          full integration with JUnit 4.4 via a custom runner. By annotating
          test classes with
          <tt class="literal">@Runwith(SpringJUnit4ClassRunner.class)</tt>,
          developers can implement standard JUnit 4.4 unit and integration
          tests and simultaneously reap the benefits of the TestContext
          framework such as support for loading application contexts,
          dependency injection of test instances, transactional test method
          execution, etc. The following code listing displays the minimal
          requirements for configuring a test class to run with the custom
          Spring Runner. <span class="emphasis"><em>Note that
          <tt class="interfacename">@TestExecutionListeners</tt> has been
          configured with an empty list in order to disable the default
          listeners, which would otherwise require that an
          <tt class="interfacename">ApplicationContext</tt> be configured via
          <tt class="interfacename">@ContextConfiguration</tt>.</em></span></p><pre class="programlisting">@RunWith(SpringJUnit4ClassRunner.class)
@TestExecutionListeners({})
public class SimpleTest {

    @Test
    public void testMethod() {
        <i class="lineannotation"><span class="lineannotation">// execute test logic...</span></i>
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="testcontext-support-classes-testng"></a>8.3.7.5.4.&nbsp;TestNG support classes</h5></div></div><div></div></div><p>The <tt class="literal">org.springframework.test.context.testng</tt>
          package provides support classes for TestNG based test cases.</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">AbstractTestNGSpringContextTests</tt>:</p><p>Abstract base test class which integrates the
              <span class="emphasis"><em>Spring TestContext Framework</em></span> with explicit
              <tt class="classname">ApplicationContext</tt> testing support in a
              TestNG environment.</p><p>When you extend
              <tt class="classname">AbstractTestNGSpringContextTests</tt> you will
              have access to the following <tt class="literal">protected</tt>
              instance variables:</p><div class="itemizedlist"><ul type="circle"><li><p><tt class="literal">applicationContext</tt>: use this to
                  perform explicit bean lookups or to test the state of the
                  context as a whole.</p></li></ul></div></li><li><p><tt class="classname">AbstractTransactionalTestNGSpringContextTests</tt>:</p><p>Abstract <span class="emphasis"><em>transactional</em></span> extension of
              <tt class="classname">AbstractTestNGSpringContextTests</tt> that
              adds some convenience functionality for JDBC access. Expects a
              <tt class="classname">javax.sql.DataSource</tt> bean and a
              <tt class="interfacename">PlatformTransactionManager</tt> bean
              to be defined in the
              <tt class="classname">ApplicationContext</tt>.</p><p>When you extend
              <tt class="classname">AbstractTransactionalTestNGSpringContextTests</tt>
              you will have access to the following
              <tt class="literal">protected</tt> instance variables:</p><div class="itemizedlist"><ul type="circle"><li><p><tt class="literal">applicationContext</tt>: inherited from
                  the <tt class="classname">AbstractTestNGSpringContextTests</tt>
                  superclass. Use this to perform explicit bean lookups or to
                  test the state of the context as a whole.</p></li><li><p><tt class="literal">simpleJdbcTemplate</tt>: useful for
                  querying to confirm state. For example, you might query
                  before and after testing application code that creates an
                  object and persists it using an ORM tool, to verify that the
                  data appears in the database. (Spring will ensure that the
                  query runs in the scope of the same transaction.) You will
                  need to tell your ORM tool to 'flush' its changes for this
                  to work correctly, for example using the
                  <tt class="methodname">flush()</tt> method on Hibernate's
                  <tt class="classname">Session</tt> interface.</p></li></ul></div></li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>These classes serve only as a convenience for extension. If
            you do not wish for your test classes to be tied to a
            Spring-specific class hierarchy - for example, if you wish to
            directly extend the class you are testing - you may configure your
            own custom test classes by using
            <tt class="interfacename">@ContextConfiguration</tt>,
            <tt class="interfacename">@TestExecutionListeners</tt>, etc. and
            by manually instrumenting your test class with a
            <tt class="classname">TestContextManager</tt>. See the source code of
            <tt class="classname">AbstractTestNGSpringContextTests</tt> for an
            example of how to instrument your test class.</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="testcontext-annotations"></a>8.3.7.6.&nbsp;TestContext framework annotation support</h4></div></div><div></div></div><p>The Spring TestContext Framework supports all annotations as
        outlined in the <a href="#integration-testing-common-annotations" title="8.3.5.&nbsp;Common annotations">common
        annotations</a> section. The following annotations, however, are
        <span class="emphasis"><em>only supported when used in conjunction with JUnit (e.g.,
        with the <a href="#testcontext-junit4-runner" title="8.3.7.5.3.&nbsp;Custom JUnit 4.4 Runner">SpringJUnit4ClassRunner</a> or
        the <a href="#testcontext-support-classes-junit38" title="8.3.7.5.1.&nbsp;JUnit 3.8 support classes">JUnit
        3.8</a> and <a href="#testcontext-support-classes-junit44" title="8.3.7.5.2.&nbsp;JUnit 4.4 support classes">JUnit 4.4</a> support
        classes.</em></span></p><div class="itemizedlist"><ul type="disc"><li><p><tt class="interfacename">@IfProfileValue</tt></p></li><li><p><tt class="interfacename">@ProfileValueSourceConfiguration</tt></p></li><li><p><tt class="interfacename">@ExpectedException</tt></p><p>Using Spring's
            <tt class="interfacename">@ExpectedException</tt> annotation in
            conjunction with JUnit 4's
            <tt class="interfacename">@Test(expected=...)</tt> configuration
            would lead to an unresolvable conflict. Developers must therefore
            choose one or the other when integrating with JUnit 4, in which
            case it is generally preferable to use the explicit JUnit 4
            configuration.</p></li><li><p><tt class="interfacename">@Timed</tt></p><p>Spring's <tt class="interfacename">@Timed</tt> annotation
            has different semantics than JUnit 4's
            <tt class="interfacename">@Test(timeout=...)</tt> support.
            Specifically, due to the manner in which JUnit 4 handles test
            execution timeouts (i.e., by executing the test method in a
            separate <tt class="classname">Thread</tt>),
            <tt class="interfacename">@Test(timeout=...)</tt> applies to
            <span class="emphasis"><em>each iteration</em></span> in the case of repetitions
            and preemptively fails the test if the test takes too long.
            Spring's <tt class="interfacename">@Timed</tt>, on the other hand,
            times the <span class="emphasis"><em>total</em></span> test execution time
            (including all repetitions) and does not preemptively fail the test
            but rather waits for the test to actually complete before failing.</p></li><li><p><tt class="interfacename">@Repeat</tt></p></li></ul></div><p>The following non-test-specific annotations are also supported
        by the Spring TestContext Framework with their standard
        semantics.</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="interfacename">@Autowired</tt></p></li><li><p><tt class="interfacename">@Qualifier</tt></p></li><li><p><tt class="interfacename">@Resource</tt> (javax.annotation)
            <span class="emphasis"><em>if JSR-250 is present</em></span></p></li><li><p><tt class="interfacename">@PersistenceContext</tt>
            (javax.persistence) <span class="emphasis"><em>if JPA is present</em></span></p></li><li><p><tt class="interfacename">@PersistenceUnit</tt>
            (javax.persistence) <span class="emphasis"><em>if JPA is present</em></span></p></li><li><p><tt class="interfacename">@Required</tt></p></li><li><p><tt class="interfacename">@Transactional</tt></p></li></ul></div><p>The following list includes all annotations specific to the
        Spring TestContext Framework. Refer to the respective JavaDoc for
        further information, including default attribute values, etc.</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><b><tt class="interfacename">@ContextConfiguration</tt></b></span></p><p>Defines class-level metadata which is used to determine how
            to load and configure an
            <tt class="interfacename">ApplicationContext</tt>. Specifically,
            @ContextConfiguration defines the application context resource
            <tt class="literal">locations</tt> to load as well as the
            <tt class="interfacename">ContextLoader</tt> strategy to use for
            loading the context.</p><pre class="programlisting">@ContextConfiguration(locations={"example/test-context.xml"}, loader=CustomContextLoader.class)
public class CustomConfiguredApplicationContextTests {
    <i class="lineannotation"><span class="lineannotation">// class body...</span></i>
}</pre><p>Note: <tt class="interfacename">@ContextConfiguration</tt>
            provides support for <span class="emphasis"><em>inherited</em></span> resource
            locations by default. See the <a href="#testcontext-ctx-management" title="8.3.7.2.&nbsp;Context management and caching">Context management and
            caching</a> section and JavaDoc for an example and further
            details.</p></li><li><p><span class="bold"><b><tt class="interfacename">@TestExecutionListeners</tt></b></span></p><p>Defines class-level metadata for configuring which
            <tt class="interfacename">TestExecutionListener</tt>s should be
            registered with a <tt class="classname">TestContextManager</tt>.
            Typically, <tt class="interfacename">@TestExecutionListeners</tt>
            will be used in conjunction with
            <tt class="interfacename">@ContextConfiguration</tt>.</p><pre class="programlisting">@ContextConfiguration
@TestExecutionListeners({CustomTestExecutionListener.class, AnotherTestExecutionListener.class})
public class CustomTestExecutionListenerTests {
    <i class="lineannotation"><span class="lineannotation">// class body...</span></i>
}</pre><p>Note: <tt class="interfacename">@TestExecutionListeners</tt>
            provides support for <span class="emphasis"><em>inherited</em></span> listeners by
            default. See the JavaDoc for an example and further
            details.</p></li><li><p><span class="bold"><b><tt class="interfacename">@TransactionConfiguration</tt></b></span></p><p>Defines class-level metadata for configuring transactional
            tests. Specifically, the bean name of the
            <tt class="interfacename">PlatformTransactionManager</tt> that is
            to be used to drive transactions can be explicitly configured if
            the bean name of the desired PlatformTransactionManager is not
            "transactionManager". In addition, the
            <tt class="literal">defaultRollback</tt> flag can optionally be changed
            to <tt class="literal">false</tt>. Typically,
            <tt class="interfacename">@TransactionConfiguration</tt> will be
            used in conjunction with
            <tt class="interfacename">@ContextConfiguration</tt>.</p><pre class="programlisting">@ContextConfiguration
@TransactionConfiguration(transactionManager="txMgr", defaultRollback=false)
public class CustomConfiguredTransactionalTests {
    <i class="lineannotation"><span class="lineannotation">// class body...</span></i>
}</pre></li><li><p><span class="bold"><b><tt class="interfacename">@BeforeTransaction</tt></b></span></p><p>Indicates that the annotated <tt class="literal">public void</tt>
            method should be executed <span class="emphasis"><em>before</em></span> a
            transaction is started for test methods configured to run within a
            transaction via the <tt class="interfacename">@Transactional</tt>
            annotation.</p><pre class="programlisting">@BeforeTransaction
public void beforeTransaction() {
    <i class="lineannotation"><span class="lineannotation">// logic to be executed before a transaction is started</span></i>
}</pre></li><li><p><span class="bold"><b><tt class="interfacename">@AfterTransaction</tt></b></span></p><p>Indicates that the annotated <tt class="literal">public void</tt>
            method should be executed <span class="emphasis"><em>after</em></span> a transaction
            has been ended for test methods configured to run within a
            transaction via the <tt class="interfacename">@Transactional</tt>
            annotation.</p><pre class="programlisting">@AfterTransaction
public void afterTransaction() {
    <i class="lineannotation"><span class="lineannotation">// logic to be executed after a transaction has ended</span></i>
}</pre></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="testing-examples-petclinic"></a>8.3.8.&nbsp;PetClinic example</h3></div></div><div></div></div><p>The PetClinic sample application included with the full Spring
      distribution illustrates several features of the <span class="emphasis"><em>Spring
      TestContext Framework</em></span> in a JUnit 4.4 environment. Most test
      functionality is included in the
      <tt class="classname">AbstractClinicTests</tt>, for which a partial listing
      is shown below:</p><pre class="programlisting"><span class="bold"><b>@ContextConfiguration</b></span>
public abstract class AbstractClinicTests <span class="bold"><b>extends AbstractTransactionalJUnit4SpringContextTests</b></span> {

    <span class="bold"><b>@Autowired</b></span>
    protected Clinic clinic;

    @Test
    public void getVets() {
        Collection&lt;Vet&gt; vets = this.clinic.getVets();
        assertEquals("JDBC query must show the same number of vets",
            <span class="bold"><b>super.countRowsInTable("VETS")</b></span>, vets.size());
        Vet v1 = EntityUtils.getById(vets, Vet.class, 2);
        assertEquals("Leary", v1.getLastName());
        assertEquals(1, v1.getNrOfSpecialties());
        assertEquals("radiology", (v1.getSpecialties().get(0)).getName());
        <i class="lineannotation"><span class="lineannotation">// ...</span></i>
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre><p>Notes:</p><div class="itemizedlist"><ul type="disc"><li><p>This test case extends the
          <tt class="classname">AbstractTransactionalJUnit4SpringContextTests</tt>
          class, from which it inherits configuration for Dependency Injection
          (via the
          <tt class="classname">DependencyInjectionTestExecutionListener</tt>) and
          transactional behavior (via the
          <tt class="classname">TransactionalTestExecutionListener</tt>).</p></li><li><p>The <tt class="literal">clinic</tt> instance variable - the
          application object being tested - is set by Dependency Injection via
          <tt class="interfacename">@Autowired</tt> semantics.</p></li><li><p>The <tt class="methodname">testGetVets()</tt> method illustrates
          how the inherited <tt class="methodname">countRowsInTable()</tt> method
          can be used to easily verify the number of rows in a given table,
          thus testing correct behavior of the application code being tested.
          This allows for stronger tests and lessens dependency on the exact
          test data. For example, you can add additional rows in the database
          without breaking tests.</p></li><li><p>Like many integration tests using a database, most of the
          tests in <tt class="classname">AbstractClinicTests</tt> depend on a
          minimum amount of data already in the database before the test cases
          run. You might, however, choose to populate the database in your
          test cases also - again, within the same transaction.</p></li></ul></div><p>The PetClinic application supports three data access technologies
      - JDBC, Hibernate, and JPA. By declaring
      <tt class="interfacename">@ContextConfiguration</tt> without any
      specific resource locations, the
      <tt class="classname">AbstractClinicTests</tt> class will have its
      application context loaded from the default location,
      <tt class="literal">"AbstractClinicTests-context.xml"</tt>, which declares a
      common <tt class="classname">DataSource</tt>. Subclasses specify additional
      context locations which must declare a
      <tt class="interfacename">PlatformTransactionManager</tt> and a concrete
      implementation of <tt class="interfacename">Clinic</tt>.</p><p>For example, the Hibernate implementation of the PetClinic tests
      contains the following implementation. Note that for this example,
      <tt class="classname">HibernateClinicTests</tt> does not contain a single
      line of code: we only need to declare
      <tt class="interfacename">@ContextConfiguration</tt>, and the tests are
      inherited from <tt class="classname">AbstractClinicTests</tt>. Since
      <tt class="interfacename">@ContextConfiguration</tt> is declared without
      any specific resource locations, the <span class="emphasis"><em>Spring TestContext
      Framework</em></span> will load an application context from all the beans
      defined in <tt class="literal">"AbstractClinicTests-context.xml"</tt> (i.e.,
      the inherited locations) and
      <tt class="literal">"HibernateClinicTests-context.xml"</tt>, with
      <tt class="literal">"HibernateClinicTests-context.xml"</tt> possibly
      overriding beans defined in
      <tt class="literal">"AbstractClinicTests-context.xml"</tt>.</p><pre class="programlisting"><span class="bold"><b>@ContextConfiguration</b></span>
public class HibernateClinicTests extends AbstractClinicTests { }
</pre><p>As you can see in the PetClinic application, the Spring
      configuration is split across multiple files. As is typical of large
      scale applications, configuration locations will often be specified in a
      common base class for all application-specific integration tests. Such a
      base class may also add useful instance variables - populated by
      Dependency Injection, naturally - such as a
      <tt class="classname">HibernateTemplate</tt>, in the case of an application
      using Hibernate.</p><p>As far as possible, you should have exactly the same Spring
      configuration files in your integration tests as in the deployed
      environment. One likely point of difference concerns database connection
      pooling and transaction infrastructure. If you are deploying to a
      full-blown application server, you will probably use its connection pool
      (available through JNDI) and JTA implementation. Thus in production you
      will use a <tt class="classname">JndiObjectFactoryBean</tt> for the
      <tt class="classname">DataSource</tt> and
      <tt class="classname">JtaTransactionManager</tt>. JNDI and JTA will not be
      available in out-of-container integration tests, so you should use a
      combination like the Commons DBCP <tt class="classname">BasicDataSource</tt>
      and <tt class="classname">DataSourceTransactionManager</tt> or
      <tt class="classname">HibernateTransactionManager</tt> for them. You can
      factor out this variant behavior into a single XML file, having the
      choice between application server and 'local' configuration separated
      from all other configuration, which will not vary between the test and
      production environments. In addition, it is advisable to use properties
      files for connection settings: see the PetClinic application for an
      example.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="testing-resources"></a>8.4.&nbsp;Further Resources</h2></div></div><div></div></div><p>This section contains links to further resources about testing in
    general.</p><div class="itemizedlist"><ul type="disc"><li><p>The <a href="http://www.junit.org/" target="_top">JUnit homepage</a>.
        The Spring Framework's unit test suite is written using JUnit 3.8 as
        the testing framework.</p></li><li><p>The <a href="http://testng.org/" target="_top">TestNG homepage</a>.
        TestNG is a testing framework inspired by JUnit 3.8 with added support
        for Java 5 annotations, test groups, data-driven testing, distributed
        testing, etc.</p></li><li><p>The <a href="http://www.mockobjects.com/" target="_top">Mock Objects
        homepage</a>. About Mock Objects, a technique for improving the
        design of code within Test-Driven Development.</p></li><li><p><a href="http://en.wikipedia.org/wiki/Mock_Object" target="_top"> "Mock
        Objects" article at Wikipedia</a>.</p></li><li><p>The <a href="http://www.easymock.org/" target="_top">EasyMock
        homepage</a>. The Spring Framework uses EasyMock extensively in
        its test suite.</p></li><li><p>The <a href="http://www.jmock.org/" target="_top">JMock homepage</a>.
        JMock is a library that supports test-driven development of Java code
        with mock objects.</p></li><li><p>The <a href="http://dbunit.sourceforge.net/" target="_top">DbUnit
        homepage</a>. DbUnit is a JUnit extension (also usable with Ant)
        targeted for database-driven projects that, among other things, puts
        your database into a known state between test runs.</p></li><li><p>The <a href="http://grinder.sourceforge.net/" target="_top">Grinder
        homepage</a>. The Grinder is a Java load-testing framework.</p></li></ul></div></div></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="spring-middle-tier"></a>Middle Tier Data Access</h1></div></div><div></div></div><div class="partintro" lang="en"><div><div></div><div></div></div><p>
				This part of the reference documentation is concerned
				with the middle tier, and specifically the data access
				responsibilities of said tier.
			</p><p>
				Spring's comprehensive transaction management support is
				covered in some detail, followed by thorough coverage of
				the various middle tier data access frameworks and
				technologies that the Spring Framework integrates with.
			</p><div class="itemizedlist"><ul type="disc"><li><p><a href="#transaction" title="Chapter&nbsp;9.&nbsp;Transaction management">Chapter&nbsp;9, <i>Transaction management</i></a></p></li><li><p><a href="#dao" title="Chapter&nbsp;10.&nbsp;DAO support">Chapter&nbsp;10, <i>DAO support</i></a></p></li><li><p><a href="#jdbc" title="Chapter&nbsp;11.&nbsp;Data access using JDBC">Chapter&nbsp;11, <i>Data access using JDBC</i></a></p></li><li><p><a href="#orm" title="Chapter&nbsp;12.&nbsp;Object Relational Mapping (ORM) data access">Chapter&nbsp;12, <i>Object Relational Mapping (ORM) data access</i></a></p></li></ul></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="transaction"></a>Chapter&nbsp;9.&nbsp;Transaction management</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transaction-intro"></a>9.1.&nbsp;Introduction</h2></div></div><div></div></div><p>One of the most compelling reasons to use the Spring Framework is the
    comprehensive transaction support. The Spring Framework provides a consistent
    abstraction for transaction management that delivers the following benefits:</p><div class="itemizedlist"><ul type="disc"><li><p>Provides a consistent programming model across different
        transaction APIs such as JTA, JDBC, Hibernate, JPA, and JDO.</p></li><li><p>Supports <a href="#transaction-declarative" title="9.5.&nbsp;Declarative transaction management">declarative transaction management</a>.</p></li><li><p>Provides a simpler API for <a href="#transaction-programmatic" title="9.6.&nbsp;Programmatic transaction management">programmatic</a>
        transaction management than a number of complex transaction APIs such as JTA.</p></li><li><p>Integrates very well with Spring's various data access abstractions.</p></li></ul></div><p>This chapter is divided up into a number of sections, each detailing one of the
    value-adds or technologies of the Spring Framework's transaction support. The chapter
    closes up with some discussion of best practices surrounding transaction management
    (for example, choosing between declarative and programmatic transaction management).</p><div class="itemizedlist"><ul type="disc"><li><p>The first section, entitled
        <a href="#transaction-motivation" title="9.2.&nbsp;Motivations">Motivations</a>,
        describes <span class="emphasis"><em>why</em></span> one would want to use
        the Spring Framework's transaction abstraction as opposed to EJB CMT
        or driving transactions via a proprietary API such
        as Hibernate.</p></li><li><p>The second section, entitled
        <a href="#transaction-strategies" title="9.3.&nbsp;Key abstractions">Key abstractions</a>
        outlines the core classes in the Spring Framework's transaction support,
        as well as how to configure and obtain <tt class="interfacename">DataSource</tt>
        instances from a variety of sources.</p></li><li><p>The third section, entitled
        <a href="#transaction-declarative" title="9.5.&nbsp;Declarative transaction management">Declarative transaction management</a>,
        covers the Spring Framework's support for declarative transaction management.</p></li><li><p>The fourth section, entitled
        <a href="#transaction-programmatic" title="9.6.&nbsp;Programmatic transaction management">Programmatic transaction management</a>,
        covers the Spring Framework's support for programmatic (that is, explicitly
        coded) transaction management.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transaction-motivation"></a>9.2.&nbsp;Motivations</h2></div></div><div></div></div><div class="sidebar"><p class="title"><b>Is an application server needed for transaction management?</b></p><p>The Spring Framework's transaction management support significantly changes
      traditional thinking as to when a J2EE application requires an application
      server.</p><p>In particular, you don't need an application server just to have
      declarative transactions via EJB. In fact, even if you have an application
      server with powerful JTA capabilities, you may well decide that the Spring Framework's
      declarative transactions offer more power and a much more productive
      programming model than EJB CMT.</p><p>Typically you need an application server's JTA capability only if you need to
      enlist multiple transactional resources, and for many applications being able
      to handle transactions across multiple resources isn't a requirement.
      For example, many high-end applications use a single, highly scalable
      database (such as Oracle 9i RAC). Standalone transaction managers such as
      <a href="http://www.atomikos.com/" target="_top">Atomikos Transactions</a> and
      <a href="http://jotm.objectweb.org/" target="_top">JOTM</a> are other options. (Of course
      you may need other application server capabilities such as JMS and JCA.)</p><p>The most important point is that with the Spring Framework <span class="emphasis"><em>you can
      choose when to scale your application up to a full-blown application
      server</em></span>. Gone are the days when the only alternative to using
      EJB CMT or JTA was to write code using local transactions such as those
      on JDBC connections, and face a hefty rework if you ever needed that code
      to run within global, container-managed transactions. With the Spring Framework,
      only configuration needs to change so that your code doesn't have to.</p></div><p>Traditionally, J2EE developers have had two choices for transaction
    management: <span class="emphasis"><em>global</em></span> or <span class="emphasis"><em>local</em></span> transactions.
    Global transactions are managed by the application server, using the Java Transaction
    API (JTA). Local transactions are resource-specific: the most common example would
    be a transaction associated with a JDBC connection. This choice has profound
    implications. For instance, global transactions provide the ability to work with multiple
    transactional resources (typically relational databases and message queues).
    With local transactions, the application server is not involved in
    transaction management and cannot help ensure correctness across multiple
    resources. (It is worth noting that most applications use a single transaction
    resource.)</p><p><b>Global Transactions.&nbsp;</b>Global transactions have a significant downside, in that code needs
      to use JTA, and JTA is a cumbersome API to use (partly due to its exception
      model). Furthermore, a JTA <tt class="interfacename">UserTransaction</tt>
      normally needs to be sourced from JNDI: meaning that we need to use
      <span class="emphasis"><em>both</em></span> JNDI <span class="emphasis"><em>and</em></span> JTA to use JTA.
      Obviously all use of global transactions limits the reusability of application
      code, as JTA is normally only available in an application server environment.  Previously, the preferred way to use global transactions was via EJB
      <span class="emphasis"><em>CMT</em></span> (<span class="emphasis"><em>Container Managed Transaction</em></span>):
      CMT is a form of <span class="bold"><b>declarative transaction management</b></span>
      (as distinguished from <span class="bold"><b>programmatic transaction management</b></span>).
      EJB CMT removes the need for transaction-related JNDI lookups - although of course
      the use of EJB itself necessitates the use of JNDI. It removes most of the need (although
      not entirely) to write Java code to control transactions. The significant
      downside is that CMT is tied to JTA and an application server
      environment. Also, it is only available if one chooses to implement
      business logic in EJBs, or at least behind a transactional EJB facade. The
      negatives around EJB in general are so great that this is not an
      attractive proposition, especially in the face of compelling alternatives for
      declarative transaction management.</p><p><b>Local Transactions.&nbsp;</b>Local transactions may be easier to use, but have significant
      disadvantages: they cannot work across multiple transactional resources.
	    For example, code that manages transactions using a JDBC connection cannot
	    run within a global JTA transaction. Another downside is that local
	    transactions tend to be invasive to the programming model.</p><p>Spring resolves these problems. It enables application developers to
    use a <span class="emphasis"><em>consistent</em></span> programming model <span class="emphasis"><em>in any
    environment</em></span>. You write your code once, and it can benefit from
    different transaction management strategies in different environments.
    The Spring Framework provides both declarative and programmatic transaction management.
    Declarative transaction management is preferred by most users, and is
    recommended in most cases.</p><p>With programmatic transaction management, developers work with the
    Spring Framework transaction abstraction, which can run over any underlying
    transaction infrastructure. With the preferred declarative model,
    developers typically write little or no code related to transaction
    management, and hence don't depend on the Spring Framework's transaction API
    (or indeed on any other transaction API).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transaction-strategies"></a>9.3.&nbsp;Key abstractions</h2></div></div><div></div></div><p>The key to the Spring transaction abstraction is the notion of a
    <span class="emphasis"><em>transaction strategy</em></span>. A transaction strategy is
    defined by the
    <tt class="interfacename">org.springframework.transaction.PlatformTransactionManager</tt>
    interface, shown below:</p><pre class="programlisting">public interface PlatformTransactionManager {

  TransactionStatus getTransaction(TransactionDefinition definition)
    throws TransactionException;

  void commit(TransactionStatus status) throws TransactionException;

  void rollback(TransactionStatus status) throws TransactionException;
}</pre><p>This is primarily an SPI interface, although it can be used
    <a href="#transaction-programmatic-ptm" title="9.6.2.&nbsp;Using the PlatformTransactionManager">programmatically</a>.
    Note that in keeping with the Spring Framework's philosophy,
    <tt class="interfacename">PlatformTransactionManager</tt> is
    an <span class="emphasis"><em>interface</em></span>, and can thus be easily mocked or stubbed
    as necessary. Nor is it tied to a lookup strategy such as JNDI:
    <tt class="interfacename">PlatformTransactionManager</tt> implementations
    are defined like any other object (or bean) in the Spring Framework's IoC container.
    This benefit alone makes it a worthwhile abstraction even when working
    with JTA: transactional code can be tested much more easily than if it
    used JTA directly.</p><p>Again in keeping with Spring's philosophy, the <tt class="exceptionname">TransactionException</tt>
    that can be thrown by any of the <tt class="interfacename">PlatformTransactionManager</tt>
    interface's methods is <span class="emphasis"><em>unchecked</em></span> (that is it extends the
    <tt class="exceptionname">java.lang.RuntimeException</tt> class). Transaction infrastructure
    failures are almost invariably fatal. In rare cases where application code can actually
    recover from a transaction failure, the application developer can still choose to catch
    and handle <tt class="exceptionname">TransactionException</tt>. The salient point is
    that developers are not <span class="emphasis"><em>forced</em></span> to do so.</p><p>The <tt class="methodname">getTransaction(..)</tt> method returns a
    <tt class="interfacename">TransactionStatus</tt> object, depending on a
    <tt class="interfacename">TransactionDefinition</tt> parameter. The returned
    <tt class="interfacename">TransactionStatus</tt> might represent a new or
    existing transaction (if there were a matching transaction in the current
    call stack - with the implication being that (as with J2EE transaction contexts)
    a <tt class="interfacename">TransactionStatus</tt> is associated with a
    <span class="bold"><b>thread</b></span> of execution).</p><p>The <tt class="interfacename">TransactionDefinition</tt> interface specifies:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><b>Isolation</b></span>: the
        degree of isolation this transaction has from the work of other
        transactions. For example, can this transaction see uncommitted
        writes from other transactions?</p></li><li><p><span class="bold"><b>Propagation</b></span>:
        normally all code executed within a transaction scope will run in that
        transaction. However, there are several options specifying behavior if
        a transactional method is executed when a transaction context already
        exists: for example, simply continue running in the existing transaction
        (the common case); or suspending the existing transaction and creating
        a new transaction. <span class="emphasis"><em>Spring offers all of the transaction propagation
        options familiar from EJB CMT</em></span>. (Some details regarding the semantics of transaction
				propagation in Spring can be found in the section entitled <a href="#tx-propagation" title="9.5.7.&nbsp;Transaction propagation">Section&nbsp;9.5.7, &#8220;Transaction propagation&#8221;</a>.</p></li><li><p><span class="bold"><b>Timeout</b></span>: how long
        this transaction may run before timing out (and automatically being
        rolled back by the underlying transaction infrastructure).</p></li><li><p><span class="bold"><b>Read-only status</b></span>: a read-only
        transaction does not modify any data. Read-only transactions can be a
        useful optimization in some cases (such as when using Hibernate).</p></li></ul></div><p>These settings reflect standard transactional concepts. If necessary,
    please refer to a resource discussing transaction isolation levels and other
    core transaction concepts because understanding such core concepts is essential
    to using the Spring Framework or indeed any other transaction management solution.</p><p>The <tt class="interfacename">TransactionStatus</tt> interface provides a simple
    way for transactional code to control transaction execution and query
    transaction status. The concepts should be familiar, as they are common to
    all transaction APIs:</p><pre class="programlisting">public interface TransactionStatus {

  boolean isNewTransaction();

  void setRollbackOnly();

  boolean isRollbackOnly();
}</pre><p>Regardless of whether you opt for declarative or programmatic transaction
    management in Spring, defining the correct
    <tt class="interfacename">PlatformTransactionManager</tt> implementation is
    absolutely essential. In good Spring fashion, this important definition typically
    is made using via Dependency Injection.</p><p><tt class="interfacename">PlatformTransactionManager</tt> implementations
    normally require knowledge of the environment in which they work: JDBC, JTA,
    Hibernate, etc The following examples from the
    <tt class="literal">dataAccessContext-local.xml</tt> file from Spring's
    <span class="bold"><b>jPetStore</b></span> sample application show how a local
    <tt class="interfacename">PlatformTransactionManager</tt> implementation can be
    defined. (This will work with plain JDBC.)</p><p>We must define a JDBC <tt class="interfacename">DataSource</tt>, and
    then use the Spring <tt class="classname">DataSourceTransactionManager</tt>, giving
    it a reference to the <tt class="interfacename">DataSource</tt>.</p><pre class="programlisting">&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
  &lt;property name="driverClassName" value="${jdbc.driverClassName}" /&gt;
  &lt;property name="url" value="${jdbc.url}" /&gt;
  &lt;property name="username" value="${jdbc.username}" /&gt;
  &lt;property name="password" value="${jdbc.password}" /&gt;
&lt;/bean&gt;</pre><p>The related <tt class="interfacename">PlatformTransactionManager</tt> bean
    definition will look like this:</p><pre class="programlisting">&lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
  &lt;property name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;</pre><p>If we use JTA in a J2EE container, as in the <tt class="filename">'dataAccessContext-jta.xml'</tt>
    file from the same sample application, we use a container <tt class="interfacename">DataSource</tt>,
    obtained via JNDI, in conjunction with Spring's <tt class="classname">JtaTransactionManager</tt>.
    The <tt class="classname">JtaTransactionManager</tt> doesn't need to know about the
    <tt class="interfacename">DataSource</tt>, or any other specific resources, as
    it will use the container's global transaction management infrastructure.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:jee="http://www.springframework.org/schema/jee"
xsi:schemaLocation="
     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
     http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-2.5.xsd"&gt;

  &lt;jee:jndi-lookup id="dataSource" jndi-name="jdbc/jpetstore"/&gt; 

  &lt;bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager" /&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- other <tt class="literal">&lt;bean/&gt;</tt> definitions here --&gt;</span></i>

&lt;/beans&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The above definition of the <tt class="literal">'dataSource'</tt> bean uses the
      <tt class="literal">&lt;jndi-lookup/&gt;</tt> tag from the <tt class="literal">'jee'</tt>
      namespace. For more information on schema-based configuration, see <a href="#xsd-config" title="Appendix&nbsp;A.&nbsp;XML Schema-based configuration">Appendix&nbsp;A, <i>XML Schema-based configuration</i></a>,
      and for more information on the <tt class="literal">&lt;jee/&gt;</tt> tags
      see the section entitled <a href="#xsd-config-body-schemas-jee" title="A.2.3.&nbsp;The jee schema">Section&nbsp;A.2.3, &#8220;The jee schema&#8221;</a>.</p></td></tr></table></div><p>We can also use Hibernate local transactions easily, as shown in the
    following examples from the Spring Framework's  <span class="bold"><b>PetClinic</b></span>
    sample application. In this case, we need to define a Hibernate
    <tt class="classname">LocalSessionFactoryBean</tt>, which application code will
    use to obtain Hibernate <tt class="interfacename">Session</tt> instances.</p><p>The <tt class="interfacename">DataSource</tt> bean definition will be
    similar to the one shown previously (and thus is not shown). If the
    <tt class="interfacename">DataSource</tt> is managed by the JEE container it should
    be non-transactional as the Spring Framework, rather than the JEE container, will
    manage transactions.</p><p>The <tt class="literal">'txManager'</tt> bean in this case is of the
    <tt class="classname">HibernateTransactionManager</tt> type. In the same way as the
    <tt class="classname">DataSourceTransactionManager</tt> needs a reference to the
    <tt class="interfacename">DataSource</tt>, the
    <tt class="classname">HibernateTransactionManager</tt> needs a reference to the
    <tt class="interfacename">SessionFactory</tt>.</p><pre class="programlisting">&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
  &lt;property name="dataSource" ref="dataSource" /&gt;
  &lt;property name="mappingResources"&gt;
  &lt;list&gt;
    &lt;value&gt;org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml&lt;/value&gt;
  &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="hibernateProperties"&gt;
  &lt;value&gt;
	  hibernate.dialect=${hibernate.dialect}
	&lt;/value&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="txManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
  &lt;property name="sessionFactory" ref="sessionFactory" /&gt;
&lt;/bean&gt;</pre><p>With Hibernate and JTA transactions, we can simply use the
    <tt class="classname">JtaTransactionManager</tt> as with JDBC or any other resource strategy.</p><pre class="programlisting">&lt;bean id="txManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;</pre><p>Note that this is identical to JTA configuration for any resource,
    as these are global transactions, which can enlist any transactional
    resource.</p><i><span class="remark">
      <p>In all these cases, application code will not need to change at
      all. We can change how transactions are managed merely by changing
      configuration, even if that change means moving from local to global
      transactions or vice versa.</p>
    </span></i></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tx-resource-synchronization"></a>9.4.&nbsp;Resource synchronization with transactions</h2></div></div><div></div></div><p>It should now be clear how different transaction managers are
    created, and how they are linked to related resources which need to be
    synchronized to transactions (for example <tt class="classname">DataSourceTransactionManager</tt>
    to a JDBC <tt class="interfacename">DataSource</tt>,
    <tt class="classname">HibernateTransactionManager</tt> to a Hibernate
    <tt class="interfacename">SessionFactory</tt>, and so forth). There remains the question
    however of how the application code, directly or indirectly using a
    persistence API (such as JDBC, Hibernate, and JDO), ensures that these resources
    are obtained and handled properly in terms of proper
    creation/reuse/cleanup and trigger (optionally) transaction
    synchronization via the relevant <tt class="interfacename">PlatformTransactionManager</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tx-resource-synchronization-high"></a>9.4.1.&nbsp;High-level approach</h3></div></div><div></div></div><p>The preferred approach is to use Spring's highest level
      persistence integration APIs. These do not replace the native APIs, but
      internally handle resource creation/reuse, cleanup, optional
      transaction synchronization of the resources and exception mapping so
      that user data access code doesn't have to worry about these concerns at
      all, but can concentrate purely on non-boilerplate persistence logic.
      Generally, the same <span class="emphasis"><em>template</em></span> approach is used
      for all persistence APIs, with examples including the
      <tt class="classname">JdbcTemplate</tt>, <tt class="classname">HibernateTemplate</tt>,
      and <tt class="classname">JdoTemplate</tt> classes (detailed in subsequent chapters
      of this reference documentation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tx-resource-synchronization-low"></a>9.4.2.&nbsp;Low-level approach</h3></div></div><div></div></div><p>At a lower level exist classes such as
      <tt class="classname">DataSourceUtils</tt> (for JDBC),
      <tt class="classname">SessionFactoryUtils</tt> (for Hibernate),
      <tt class="classname">PersistenceManagerFactoryUtils</tt> (for JDO), and so on.
      When it is preferable for application code to deal directly with the
      resource types of the native persistence APIs, these classes ensure that
      proper Spring Framework-managed instances are obtained, transactions are
      (optionally) synchronized, and exceptions which happen in the process
      are properly mapped to a consistent API.</p><p>For example, in the case of JDBC, instead of the traditional JDBC approach of
      calling the <tt class="literal">getConnection()</tt> method on the
      <tt class="interfacename">DataSource</tt>, you would instead use Spring's
      <tt class="classname">org.springframework.jdbc.datasource.DataSourceUtils</tt>
      class as follows:</p><pre class="programlisting">Connection conn = DataSourceUtils.getConnection(dataSource);</pre><p>If an existing transaction exists, and already has a connection
      synchronized (linked) to it, that instance will be returned. Otherwise,
      the method call will trigger the creation of a new connection, which
      will be (optionally) synchronized to any existing transaction, and
      made available for subsequent reuse in that same transaction. As mentioned,
      this has the added advantage that any <tt class="exceptionname">SQLException</tt>
      will be wrapped in a Spring Framework
      <tt class="exceptionname">CannotGetJdbcConnectionException</tt> - one of the Spring
      Framework's hierarchy of unchecked DataAccessExceptions. This gives you more
      information than can easily be obtained from the
      <tt class="exceptionname">SQLException</tt>, and ensures portability across
      databases: even across different persistence technologies.</p><p>It should be noted that this will also work fine without Spring
      transaction management (transaction synchronization is optional), so you
      can use it whether or not you are using Spring for transaction
      management.</p><p>Of course, once you've used Spring's JDBC support or Hibernate
      support, you will generally prefer not to use
      <tt class="classname">DataSourceUtils</tt> or the other helper classes, because
      you'll be much happier working via the Spring abstraction than directly
      with the relevant APIs. For example, if you use the Spring
      <tt class="classname">JdbcTemplate</tt> or <tt class="literal">jdbc.object</tt>
      package to simplify your use of JDBC, correct connection retrieval happens
      behind the scenes and you won't need to write any special code.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tx-resource-synchronization-tadsp"></a>9.4.3.&nbsp;<tt class="classname">TransactionAwareDataSourceProxy</tt></h3></div></div><div></div></div><p>At the very lowest level exists the
      <tt class="classname">TransactionAwareDataSourceProxy</tt> class. This is a
      proxy for a target <tt class="interfacename">DataSource</tt>, which wraps the
      target <tt class="interfacename">DataSource</tt> to add awareness of Spring-managed
      transactions. In this respect, it is similar to a transactional JNDI
      <tt class="interfacename">DataSource</tt> as provided by a J2EE server.</p><p>It should almost never be necessary or desirable to use this
      class, except when existing code exists which must be called and passed
      a standard JDBC <tt class="interfacename">DataSource</tt> interface implementation.
      In that case, it's possible to still have this code be usable, but
      participating in Spring managed transactions. It is preferable to write
      your new code using the higher level abstractions mentioned
      above.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transaction-declarative"></a>9.5.&nbsp;Declarative transaction management</h2></div></div><div></div></div><i><span class="remark">Most users of the Spring Framework choose declarative transaction management.
		It is the option with the least impact on application code, and hence is most
    consistent with the ideals of a <span class="emphasis"><em>non-invasive</em></span>
    lightweight container.</span></i><p>The Spring Framework's declarative transaction management is made possible
		with Spring AOP, although, as the transactional aspects code comes with the
		Spring Framework distribution and may be used in a boilerplate fashion, AOP concepts
		do not generally have to be understood to make effective use of this code.</p><p>It may be helpful to begin by considering EJB CMT and explaining the
    similarities and differences with the Spring Framework's declarative transaction
    management. The basic approach is similar: it is possible to specify
    transaction behavior (or lack of it) down to individual method level. It is
    possible to make a <tt class="methodname">setRollbackOnly()</tt> call within a
    transaction context if necessary. The differences are:</p><div class="itemizedlist"><ul type="disc"><li><p>Unlike EJB CMT, which is tied to JTA, the Spring Framework's
				declarative transaction management works in any environment. It can
				work with JDBC, JDO, Hibernate or other transactions under the covers,
				with configuration changes only.</p></li><li><p>The Spring Framework enables declarative transaction management
				to be applied to any class, not merely special classes such as EJBs.</p></li><li><p>The Spring Framework offers declarative
				<a href="#transaction-declarative-rolling-back" title="9.5.3.&nbsp;Rolling back"><span class="emphasis"><em>rollback rules</em></span>:</a> this is
				a feature with no EJB equivalent. Both programmatic and declarative support for rollback rules is
				provided.</p></li><li><p>The Spring Framework gives you an opportunity to customize transactional
        behavior, using AOP. For example, if you want to insert custom
        behavior in the case of transaction rollback, you can. You can also
        add arbitrary advice, along with the transactional advice. With EJB
        CMT, you have no way to influence the container's transaction
        management other than <tt class="methodname">setRollbackOnly()</tt>.</p></li><li><p>The Spring Framework does not support propagation of transaction contexts across remote calls, as
				do high-end application servers. If you need this feature, we recommend that you use EJB. However,
				consider carefully before using such a feature, because normally, one does not want transactions to
				span remote calls.</p></li></ul></div><div class="sidebar"><p class="title"><b>Where is <tt class="classname">TransactionProxyFactoryBean</tt>?</b></p><p>Declarative transaction configuration in versions of Spring 2.0 and above
      differs considerably from previous versions of Spring. The main difference is
      that there is no longer any need to configure
      <tt class="classname">TransactionProxyFactoryBean</tt> beans.</p><p>The old, pre-Spring 2.0 configuration style is still 100%
      valid configuration; think of the new <tt class="literal">&lt;tx:tags/&gt;</tt>
      as simply defining <tt class="classname">TransactionProxyFactoryBean</tt> beans
      on your behalf.</p></div><p>The concept of rollback rules is important: they enable us to
    specify which exceptions (and throwables) should cause automatic roll
    back. We specify this declaratively, in configuration, not in Java code.
    So, while we can still call <tt class="methodname">setRollbackOnly()</tt>on the
    <tt class="interfacename">TransactionStatus</tt> object to roll the current
    transaction back programmatically, most often we can specify a rule that
    <tt class="exceptionname">MyApplicationException</tt> must always result in
    rollback. This has the significant advantage that business objects don't need
    to depend on the transaction infrastructure. For example, they typically
    don't need to import any Spring APIs, transaction or other.</p><p>While the EJB default behavior is for the EJB container to
    automatically roll back the transaction on a <span class="emphasis"><em>system
    exception</em></span> (usually a runtime exception), EJB CMT does not roll
    back the transaction automatically on an <span class="emphasis"><em>application exception</em></span>
    (that is, a checked exception other than <tt class="exceptionname">java.rmi.RemoteException</tt>).
    While the Spring default behavior for declarative transaction management follows
    EJB convention (roll back is automatic only on unchecked exceptions), it is often
		useful to customize this.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tx-decl-explained"></a>9.5.1.&nbsp;Understanding the Spring Framework's declarative transaction implementation</h3></div></div><div></div></div><p>The aim of this section is to dispel the mystique that is sometimes associated
			with the use of declarative transactions. It is all very well for this reference
			documentation simply to tell you to annotate your classes with the
			<tt class="interfacename">@Transactional</tt> annotation, add the line
			(<tt class="literal">'&lt;tx:annotation-driven/&gt;'</tt>) to your configuration,
      and then expect you to understand how it all works. This section will explain the
			inner workings of the Spring Framework's declarative transaction infrastructure to
			help you navigate your way back upstream to calmer waters in the event of
			transaction-related issues.</p><p>The most important concepts to grasp with regard to the Spring Framework's
			declarative transaction support are that this support is enabled
      <a href="#aop-understanding-aop-proxies" title="6.6.1.&nbsp;Understanding AOP proxies"><span class="emphasis"><em>via AOP proxies</em></span></a>,
      and that the transactional advice is driven by <span class="emphasis"><em>metadata</em></span> (currently
      XML- or annotation-based). The combination of AOP with transactional metadata yields
      an AOP proxy that uses a <tt class="classname">TransactionInterceptor</tt> in conjunction
      with an appropriate <tt class="classname">PlatformTransactionManager</tt> implementation
      to drive transactions <span class="emphasis"><em>around method invocations</em></span>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Although knowledge of Spring AOP is not required to use Spring's declarative
        transaction support, it can help. Spring AOP is thoroughly covered in the chapter
        entitled <a href="#aop" title="Chapter&nbsp;6.&nbsp;Aspect Oriented Programming with Spring">Chapter&nbsp;6, <i>Aspect Oriented Programming with Spring</i></a>.</p></td></tr></table></div><p>Conceptually, calling a method on a transactional proxy looks like this...</p><p>
			  </p><div class="mediaobject" align="center"><img src="images/tx.png" align="middle"></div><p>
		  </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-declarative-first-example"></a>9.5.2.&nbsp;A first example</h3></div></div><div></div></div><p>Consider the following interface, and its attendant implementation.
      (The intent is to convey the concepts, and using the rote <tt class="classname">Foo</tt> and
      <tt class="classname">Bar</tt> tropes means that you can concentrate on the transaction
      usage and not have to worry about the domain model.)</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// the service interface that we want to make transactional</span></i>

package x.y.service;

public interface FooService {

  Foo getFoo(String fooName);

  Foo getFoo(String fooName, String barName);

  void insertFoo(Foo foo);

  void updateFoo(Foo foo);

}</pre><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// an implementation of the above interface</span></i>

package x.y.service;

public class DefaultFooService implements FooService {

  public Foo getFoo(String fooName) {
    throw new UnsupportedOperationException();
  }

  public Foo getFoo(String fooName, String barName) {
    throw new UnsupportedOperationException();
  }

  public void insertFoo(Foo foo) {
    throw new UnsupportedOperationException();
  }

  public void updateFoo(Foo foo) {
    throw new UnsupportedOperationException();
  }

}</pre><p><span class="emphasis"><em>(For the purposes of this example, the fact that the
      <tt class="classname">DefaultFooService</tt> class throws
      <tt class="exceptionname">UnsupportedOperationException</tt> instances in the body
      of each implemented method is good; it will allow us to see transactions being created
      and then rolled back in response to the <tt class="exceptionname">UnsupportedOperationException</tt>
      instance being thrown.)</em></span></p><p>Let's assume that the first two methods of the <tt class="interfacename">FooService</tt>
      interface (<tt class="literal">getFoo(String)</tt> and <tt class="literal">getFoo(String, String)</tt>)
      have to execute in the context of a transaction with read-only semantics, and that
      the other methods (<tt class="literal">insertFoo(Foo)</tt> and
      <tt class="literal">updateFoo(Foo)</tt>) have to execute in the context of a transaction
			with read-write semantics. Don't worry about taking the following configuration in
			all at once; everything will be explained in detail in the next few paragraphs.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- from the file <tt class="literal">'context.xml'</tt> --&gt;</span></i>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:aop="http://www.springframework.org/schema/aop"
     <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>xmlns:tx="http://www.springframework.org/schema/tx"</b></span></span></i>
     xsi:schemaLocation="
     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
     <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</b></span></span></i>
     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- this is the service object that we want to make transactional --&gt;</span></i>
  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- the transactional advice (what 'happens'; see the <tt class="literal">&lt;aop:advisor/&gt;</tt> bean below) --&gt;</span></i>
  &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- the transactional semantics... --&gt;</span></i>
  &lt;tx:attributes&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- all methods starting with <tt class="literal">'get'</tt> are read-only --&gt;</span></i>
    &lt;tx:method name="get*" read-only="true"/&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- other methods use the default transaction settings (see below) --&gt;</span></i>
    &lt;tx:method name="*"/&gt;
  &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- ensure that the above transactional advice runs for any execution
    of an operation defined by the <tt class="interfacename">FooService</tt> interface --&gt;</span></i>
  &lt;aop:config&gt;
  &lt;aop:pointcut id="fooServiceOperation" expression="execution(* x.y.service.FooService.*(..))"/&gt;
  &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceOperation"/&gt;
  &lt;/aop:config&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- don't forget the <tt class="interfacename">DataSource</tt> --&gt;</span></i>
  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
  &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt;
  &lt;property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/&gt;
  &lt;property name="username" value="scott"/&gt;
  &lt;property name="password" value="tiger"/&gt;
  &lt;/bean&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- similarly, don't forget the <tt class="interfacename">PlatformTransactionManager</tt> --&gt;</span></i>
  &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
  &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- other <tt class="literal">&lt;bean/&gt;</tt> definitions here --&gt;</span></i>

&lt;/beans&gt;</pre><p>Let's pick apart the above configuration. We have a service object
      (the <tt class="literal">'fooService'</tt> bean) that we want to make transactional.
      The transaction semantics that we want to apply are encapsulated in the
      <tt class="literal">&lt;tx:advice/&gt;</tt> definition. The
      <tt class="literal">&lt;tx:advice/&gt;</tt> definition reads as
      &#8220;<span class="quote"><span class="emphasis"><em>... all methods on starting with <tt class="literal">'get'</tt> are to execute
      in the context of a read-only transaction, and all other methods are to execute
      with the default transaction semantics</em></span></span>&#8221;. The
      <tt class="literal">'transaction-manager'</tt> attribute of the
      <tt class="literal">&lt;tx:advice/&gt;</tt> tag is set to the
      name of the <tt class="interfacename">PlatformTransactionManager</tt> bean
      that is going to actually <span class="emphasis"><em>drive</em></span> the transactions (in this
      case the <tt class="literal">'txManager'</tt> bean).</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>You can actually omit the <tt class="literal">'transaction-manager'</tt>
        attribute in the transactional advice (<tt class="literal">&lt;tx:advice/&gt;</tt>)
        if the bean name of the <tt class="interfacename">PlatformTransactionManager</tt>
        that you want to wire in has the name <tt class="literal">'transactionManager'</tt>.
        If the <tt class="interfacename">PlatformTransactionManager</tt> bean
        that you want to wire in has any other name, then you have to be explicit
        and use the <tt class="literal">'transaction-manager'</tt> attribute as in the example above.</p></td></tr></table></div><p>The <tt class="literal">&lt;aop:config/&gt;</tt> definition ensures that the transactional
      advice defined by the <tt class="literal">'txAdvice'</tt> bean actually executes at the appropriate
      points in the program. First we define a pointcut that matches the execution of any
      operation defined in the <tt class="interfacename">FooService</tt> interface
      (<tt class="literal">'fooServiceOperation'</tt>). Then we associate the pointcut with the
      <tt class="literal">'txAdvice'</tt> using an advisor. The result indicates that at the execution
      of a <tt class="literal">'fooServiceOperation'</tt>, the advice defined by <tt class="literal">'txAdvice'</tt>
      will be run.</p><p>The expression defined within the <tt class="literal">&lt;aop:pointcut/&gt;</tt>
      element is an AspectJ pointcut expression; see the chapter entitled <a href="#aop" title="Chapter&nbsp;6.&nbsp;Aspect Oriented Programming with Spring">Chapter&nbsp;6, <i>Aspect Oriented Programming with Spring</i></a>
      for more details on pointcut expressions in Spring 2.0.</p><p>A common requirement is to make an entire service layer transactional.
      The best way to do this is simply to change the pointcut expression to match
      any operation in your service layer. For example:</p><pre class="programlisting">&lt;aop:config&gt;
  &lt;aop:pointcut id="fooServiceMethods" expression="execution(* x.y.service.*.*(..))"/&gt;
  &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="fooServiceMethods"/&gt;
  &lt;/aop:config&gt;</pre><p><span class="emphasis"><em>(This example assumes that all your service interfaces are defined
      in the <tt class="literal">'x.y.service'</tt> package; see the chapter entitled
      <a href="#aop" title="Chapter&nbsp;6.&nbsp;Aspect Oriented Programming with Spring">Chapter&nbsp;6, <i>Aspect Oriented Programming with Spring</i></a> for more details.)</em></span></p><p>Now that we've analyzed the configuration, you may be asking
      yourself, &#8220;<span class="quote"><span class="emphasis"><em>Okay... but what does all this configuration actually
      do?</em></span></span>&#8221;.</p><p>The above configuration is going to effect the creation of a
      transactional proxy around the object that is created from the
      <tt class="literal">'fooService'</tt> bean definition. The proxy will be configured
      with the transactional advice, so that when an appropriate method is invoked
      <span class="emphasis"><em>on the proxy</em></span>, a transaction <span class="emphasis"><em>may</em></span>
      be started, suspended, be marked as read-only, etc., depending on the
      transaction configuration associated with that method. Consider the following
			program that test drives the above configuration.</p><pre class="programlisting">public final class Boot {

  public static void main(final String[] args) throws Exception {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("context.xml", Boot.class);
    FooService fooService = (FooService) ctx.getBean("fooService");
    fooService.insertFoo (new Foo());
  }
}</pre><p>The output from running the above program will look something
      like this. <span class="emphasis"><em>(Please note that the Log4J output and the stacktrace
      from the <tt class="exceptionname">UnsupportedOperationException</tt> thrown by the
      <tt class="methodname">insertFoo(..)</tt> method of the
      <tt class="classname">DefaultFooService</tt> class have been truncated in
      the interest of clarity.)</em></span></p><pre class="programlisting">  <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>&lt;!-- the Spring container is starting up... --&gt;</b></span></span></i>
[AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy
    for bean 'fooService' with 0 common interceptors and 1 specific interceptors
  <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>&lt;!-- the <tt class="classname">DefaultFooService</tt> is actually proxied --&gt;</b></span></span></i>
[JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service.DefaultFooService]

  <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>&lt;!-- ... the <tt class="literal">insertFoo(..)</tt> method is now being invoked on the proxy --&gt;</b></span></span></i>

[TransactionInterceptor] - Getting transaction for x.y.service.FooService.insertFoo
  <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>&lt;!-- the transactional advice kicks in here... --&gt;</b></span></span></i>
[DataSourceTransactionManager] - Creating new transaction with name [x.y.service.FooService.insertFoo]
[DataSourceTransactionManager] - Acquired Connection
    [org.apache.commons.dbcp.PoolableConnection@a53de4] for JDBC transaction

  <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>&lt;!-- the <tt class="literal">insertFoo(..)</tt> method from <tt class="classname">DefaultFooService</tt> throws an exception... --&gt;</b></span></span></i>
[RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should
    rollback on java.lang.UnsupportedOperationException
[TransactionInterceptor] - Invoking rollback for transaction on x.y.service.FooService.insertFoo
    due to throwable [java.lang.UnsupportedOperationException]

   <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>&lt;!-- and the transaction is rolled back (by default, <tt class="exceptionname">RuntimeException</tt> instances cause rollback) --&gt;</b></span></span></i>
[DataSourceTransactionManager] - Rolling back JDBC transaction on Connection
    [org.apache.commons.dbcp.PoolableConnection@a53de4]
[DataSourceTransactionManager] - Releasing JDBC Connection after transaction
[DataSourceUtils] - Returning JDBC Connection to DataSource

Exception in thread "main" java.lang.UnsupportedOperationException
	at x.y.service.DefaultFooService.insertFoo(DefaultFooService.java:14)
   <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>&lt;!-- AOP infrastructure stack trace elements removed for clarity --&gt;</b></span></span></i>
	at $Proxy0.insertFoo(Unknown Source)
	at Boot.main(Boot.java:11)</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-declarative-rolling-back"></a>9.5.3.&nbsp;Rolling back</h3></div></div><div></div></div><p>The previous section outlined the basics of how to specify the transactional
      settings for the classes, typically service layer classes, in your application in a
      declarative fashion. This section describes how you can control the rollback of
      transactions in a simple declarative fashion.</p><p>The recommended way to indicate to the Spring Framework's
      transaction infrastructure that a transaction's work is to be rolled back is to
      throw an <tt class="exceptionname">Exception</tt> from code that is currently
      executing in the context of a transaction. The Spring Framework's
      transaction infrastructure code will catch any unhandled
			<tt class="exceptionname">Exception</tt> as it bubbles up the call stack, and will
			mark the transaction for rollback.</p><p>Note however that the Spring Framework's transaction infrastructure
			code will, by default, <span class="emphasis"><em>only</em></span> mark a transaction for rollback in
			the case of runtime, unchecked exceptions; that is, when the thrown exception is an
			instance or subclass of <tt class="exceptionname">RuntimeException</tt>.
			(<tt class="literal">Errors</tt> will also - by default - result in a rollback.) Checked
			exceptions that are thrown from a transactional method will
      <span class="emphasis"><em>not</em></span> result in the transaction being rolled back.</p><p>Exactly which <tt class="exceptionname">Exception</tt> types mark a transaction
			for rollback can be configured. Find below a snippet of XML configuration that
			demonstrates how one would configure rollback for a checked, application-specific
			<tt class="exceptionname">Exception</tt> type.</p><pre class="programlisting">&lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
  &lt;tx:attributes&gt;
  &lt;tx:method name="get*" read-only="true" <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>rollback-for="NoProductInStockException"</b></span></span></i>/&gt;
  &lt;tx:method name="*"/&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</pre><p>It is also possible to specify 'no rollback rules', for those times when you do
			<span class="emphasis"><em>not</em></span> want a transaction to be marked for rollback when an exception is thrown.
			In the example configuration below, we effectively are telling the Spring Framework's transaction
			infrastructure to commit the attendant transaction even in the face of an unhandled
			<tt class="exceptionname">InstrumentNotFoundException</tt>.</p><pre class="programlisting">&lt;tx:advice id="txAdvice"&gt;
  &lt;tx:attributes&gt;
  &lt;tx:method name="updateStock" <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>no-rollback-for="InstrumentNotFoundException"</b></span></span></i>/&gt;
  &lt;tx:method name="*"/&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</pre><p>When the Spring Framework's transaction infrastructure has caught an exception and is consulting
			any configured rollback rules to determine whether or not to mark the transaction for rollback, the
			<span class="emphasis"><em>strongest</em></span> matching rule wins. So in the case of the following configuration,
			any exception other than an <tt class="exceptionname">InstrumentNotFoundException</tt> would result in the
			attendant transaction being marked for rollback.</p><pre class="programlisting">&lt;tx:advice id="txAdvice"&gt;
  &lt;tx:attributes&gt;
  &lt;tx:method name="*" rollback-for="Throwable" no-rollback-for="InstrumentNotFoundException"/&gt;
  &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;</pre><p>The second way to indicate that a rollback is required is to do so
			<span class="emphasis"><em>programmatically</em></span>. Although very simple, this way is quite invasive, and tightly couples
			your code to the Spring Framework's transaction infrastructure, as can be seen below:</p><pre class="programlisting">public void resolvePosition() {
  try {
    <i class="lineannotation"><span class="lineannotation">// some business logic...</span></i>
  } catch (NoProductInStockException ex) {
    <i class="lineannotation"><span class="lineannotation">// trigger rollback programmatically</span></i>
    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
  }
}</pre><p>You are strongly encouraged to use the declarative approach to rollback if at all possible.
			Programmatic rollback is available should you absolutely need it, but its usage flies in the face of
			achieving a nice, clean POJO-based architecture.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-declarative-diff-tx"></a>9.5.4.&nbsp;Configuring different transactional semantics for different beans</h3></div></div><div></div></div><p>Consider the scenario where you have a number of service layer objects,
      and you want to apply <span class="emphasis"><em>totally different</em></span> transactional configuration
      to each of them. This is achieved by defining distinct <tt class="literal">&lt;aop:advisor/&gt;</tt>
      elements with differing <tt class="literal">'pointcut'</tt> and <tt class="literal">'advice-ref'</tt>
      attribute values.</p><p>Let's assume that all of your service layer classes are defined in a root
      <tt class="literal">'x.y.service'</tt> package. To make all beans that are instances of classes
      defined in that package (or in subpackages) and that have names ending in
      <tt class="literal">'Service'</tt> have the default transactional configuration, you would write
      the following:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:aop="http://www.springframework.org/schema/aop"
  xmlns:tx="http://www.springframework.org/schema/tx"
  xsi:schemaLocation="
  http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
  http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
  http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;aop:config&gt;

    &lt;aop:pointcut id="serviceOperation"
          expression="<i class="lineannotation"><span class="lineannotation">execution(* x.y.service..*Service.*(..))</span></i>"/&gt;

    &lt;aop:advisor pointcut-ref="serviceOperation" advice-ref="txAdvice"/&gt;

  &lt;/aop:config&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- these two beans will be transactional... --&gt;</span></i>
  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;
  &lt;bean id="barService" class="x.y.service.extras.SimpleBarService"/&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- ... and these two beans won't --&gt;</span></i>
  &lt;bean id="anotherService" class="org.xyz.SomeService"/&gt; <i class="lineannotation"><span class="lineannotation">&lt;!-- (not in the right package) --&gt;</span></i>
  &lt;bean id="barManager" class="x.y.service.SimpleBarManager"/&gt; <i class="lineannotation"><span class="lineannotation">&lt;!-- (doesn't end in 'Service') --&gt;</span></i>

  &lt;tx:advice id="txAdvice"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="get*" read-only="true"/&gt;
      &lt;tx:method name="*"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- other transaction infrastructure beans such as a <tt class="interfacename">PlatformTransactionManager</tt> omitted... --&gt;</span></i>

&lt;/beans&gt;</pre><p>Find below an example of configuring two distinct beans with totally different
    transactional settings.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:aop="http://www.springframework.org/schema/aop"
  xmlns:tx="http://www.springframework.org/schema/tx"
  xsi:schemaLocation="
  http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
  http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
  http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;aop:config&gt;

    &lt;aop:pointcut id="defaultServiceOperation"
          expression="<i class="lineannotation"><span class="lineannotation">execution(* x.y.service.*Service.*(..))</span></i>"/&gt;

    &lt;aop:pointcut id="noTxServiceOperation"
          expression="<i class="lineannotation"><span class="lineannotation">execution(* x.y.service.ddl.DefaultDdlManager.*(..))</span></i>"/&gt;

    &lt;aop:advisor pointcut-ref="defaultServiceOperation" advice-ref="defaultTxAdvice"/&gt;

    &lt;aop:advisor pointcut-ref="noTxServiceOperation" advice-ref="noTxAdvice"/&gt;

  &lt;/aop:config&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- this bean will be transactional (see the <tt class="literal">'defaultServiceOperation'</tt> pointcut) --&gt;</span></i>
  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- this bean will also be transactional, but with totally different transactional settings --&gt;</span></i>
  &lt;bean id="anotherFooService" class="x.y.service.ddl.DefaultDdlManager"/&gt;

  &lt;tx:advice id="defaultTxAdvice"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="get*" read-only="true"/&gt;
      &lt;tx:method name="*"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  &lt;tx:advice id="noTxAdvice"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="*" propagation="NEVER"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- other transaction infrastructure beans such as a <tt class="interfacename">PlatformTransactionManager</tt> omitted... --&gt;</span></i>

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-declarative-txadvice-settings"></a>9.5.5.&nbsp;<tt class="literal">&lt;tx:advice/&gt;</tt> settings</h3></div></div><div></div></div><p>This section summarises the various transactional settings that can be specified
      using the <tt class="literal">&lt;tx:advice/&gt;</tt> tag. The default
      <tt class="literal">&lt;tx:advice/&gt;</tt> settings are:</p><p>
        </p><div class="itemizedlist"><ul type="disc"><li><p>The <a href="#tx-propagation" title="9.5.7.&nbsp;Transaction propagation">propagation setting</a> is <tt class="literal">REQUIRED</tt></p></li><li><p>The isolation level is <tt class="literal">DEFAULT</tt></p></li><li><p>The transaction is read/write</p></li><li><p>The transaction timeout defaults to the default timeout of the
            underlying transaction system, or or none if timeouts are not supported</p></li><li><p>Any <tt class="exceptionname">RuntimeException</tt> will trigger
            rollback, and any checked <tt class="exceptionname">Exception</tt>
            will not</p></li></ul></div><p>
      </p><p>These default settings can be changed; the various
      attributes of the <tt class="literal">&lt;tx:method/&gt;</tt> tags that are nested within
      <tt class="literal">&lt;tx:advice/&gt;</tt> and <tt class="literal">&lt;tx:attributes/&gt;</tt>
      tags are summarized below:</p><p>
        </p><div class="table"><a name="tx-method-settings"></a><p class="title"><b>Table&nbsp;9.1.&nbsp;<tt class="literal">&lt;tx:method/&gt;</tt> settings</b></p><table summary="<tx:method/&gt; settings" border="1"><colgroup><col><col><col><col></colgroup><thead><tr><th>Attribute</th><th>Required?</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">name</tt></td><td>Yes</td><td>&nbsp;</td><td><p>The method name(s) with which the transaction attributes
                  are to be associated. The wildcard (*) character can be used to
                  associate the same transaction attribute settings with a number
                  of methods; for example, <tt class="literal">'get*'</tt>,
                  <tt class="literal">'handle*'</tt>,<tt class="literal"> 'on*Event'</tt>, and so forth.</p></td></tr><tr><td><tt class="literal">propagation</tt></td><td>No</td><td>REQUIRED</td><td>The transaction propagation behavior</td></tr><tr><td><tt class="literal">isolation</tt></td><td>No</td><td>DEFAULT</td><td>The transaction isolation level</td></tr><tr><td><tt class="literal">timeout</tt></td><td>No</td><td>-1</td><td>The transaction timeout value (in seconds)</td></tr><tr><td><tt class="literal">read-only</tt></td><td>No</td><td>false</td><td>Is this transaction read-only?</td></tr><tr><td><tt class="literal">rollback-for</tt></td><td>No</td><td>&nbsp;</td><td><p>The <tt class="literal">Exception(s)</tt> that will trigger
                  rollback; comma-delimited. For example,
                  <tt class="literal">'com.foo.MyBusinessException,ServletException'</tt></p></td></tr><tr><td><tt class="literal">no-rollback-for</tt></td><td>No</td><td>&nbsp;</td><td><p>The <tt class="literal">Exception(s)</tt> that will
                  <span class="emphasis"><em>not</em></span> trigger rollback; comma-delimited.
	                For example,
	                <tt class="literal">'com.foo.MyBusinessException,ServletException'</tt></p></td></tr></tbody></table></div><p>
      </p><p>At the time of writing it is not possible to have explicit control over the
			name of a transaction, where 'name' means the transaction name that will be shown
			in a transaction monitor, if applicable (for example, WebLogic's transaction
			monitor), and in logging output. For declarative transactions, the transaction
			name is always the fully-qualified class name + "." + method name of the
			transactionally-advised class. For example
			<tt class="literal">'com.foo.BusinessService.handlePayment'</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-declarative-annotations"></a>9.5.6.&nbsp;Using <tt class="interfacename">@Transactional</tt></h3></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The functionality offered by the <tt class="interfacename">@Transactional</tt>
				annotation and the support classes is only available to you if you
				are using at least Java 5 (Tiger).</p></td></tr></table></div><p>In addition to the XML-based declarative approach to transaction configuration,
      you can also use an annotation-based approach to transaction configuration. Declaring
      transaction semantics directly in the Java source code puts the declarations much
      closer to the affected code, and there is generally not much danger of undue coupling,
      since code that is meant to be used transactionally is almost always deployed that way
      anyway.</p><p>The ease-of-use afforded by the use of the <tt class="interfacename">@Transactional</tt>
      annotation is best illustrated with an example, after which all of the details
      will be explained. Consider the following class definition:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// the service class that we want to make transactional</span></i>
<span class="bold"><b>@Transactional</b></span>
public class DefaultFooService implements FooService {

  Foo getFoo(String fooName);

  Foo getFoo(String fooName, String barName);

  void insertFoo(Foo foo);

  void updateFoo(Foo foo);
}</pre><p>When the above POJO is defined as a bean in a Spring IoC container, the bean
      instance can be made transactional by adding merely <span class="emphasis"><em>one</em></span> line of
      XML configuration, like so:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- from the file <tt class="literal">'context.xml'</tt> --&gt;</span></i>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:aop="http://www.springframework.org/schema/aop"
     xmlns:tx="http://www.springframework.org/schema/tx"
     xsi:schemaLocation="
     http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
     http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
     http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- this is the service object that we want to make transactional --&gt;</span></i>
  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- enable the configuration of transactional behavior based on annotations --&gt;</span></i>
  <span class="bold"><b>&lt;tx:annotation-driven transaction-manager="txManager"/&gt;</b></span>

  <i class="lineannotation"><span class="lineannotation">&lt;!-- a <tt class="interfacename">PlatformTransactionManager</tt> is still required --&gt;</span></i>
  &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- (this dependency is defined somewhere else) --&gt;</span></i>
  &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- other <tt class="literal">&lt;bean/&gt;</tt> definitions here --&gt;</span></i>

&lt;/beans&gt;</pre><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>You can actually omit the <tt class="literal">'transaction-manager'</tt>
        attribute in the <tt class="literal">&lt;tx:annotation-driven/&gt;</tt> tag
        if the bean name of the <tt class="interfacename">PlatformTransactionManager</tt>
        that you want to wire in has the name <tt class="literal">'transactionManager'</tt>.
        If the <tt class="interfacename">PlatformTransactionManager</tt> bean
        that you want to dependency inject has any other name, then you have to be
        explicit and use the <tt class="literal">'transaction-manager'</tt> attribute as
        in the example above.</p></td></tr></table></div><div class="sidebar"><p class="title"><b>Method visibility and <tt class="interfacename">@Transactional</tt></b></p><p>When using proxies, the <tt class="interfacename">@Transactional</tt> annotation
        should only be applied to methods with <span class="emphasis"><em>public</em></span> visibility.
        If you do annotate protected, private or package-visible methods with the
        <tt class="interfacename">@Transactional</tt> annotation, no error will be raised,
        but the annotated method will not exhibit the configured transactional settings.
        Consider the use of AspectJ (see below) if you need to annotate non-public methods.</p></div><p>The <tt class="interfacename">@Transactional</tt> annotation may be placed
      before an interface definition, a method on an interface, a class definition, or a
      <span class="emphasis"><em>public</em></span> method on a class. However, please note that the mere
      presence of the <tt class="interfacename">@Transactional</tt> annotation is not
      enough to actually turn on the transactional behavior - the
      <tt class="interfacename">@Transactional</tt> annotation <span class="emphasis"><em>is simply metadata</em></span>
      that can be consumed by something that is <tt class="interfacename">@Transactional</tt>-aware
      and that can use the metadata to configure the appropriate beans with transactional
      behavior. In the case of the above example, it is the presence of the
      <tt class="literal">&lt;tx:annotation-driven/&gt;</tt> element that
      <span class="emphasis"><em>switches on</em></span> the transactional behavior.</p><p>The Spring team's recommendation is that you only annotate concrete
      classes with the <tt class="interfacename">@Transactional</tt> annotation,
      as opposed to annotating interfaces. You certainly can place the
      <tt class="interfacename">@Transactional</tt> annotation on an interface (or
      an interface method), but this will only work as you would expect it to if
      you are using interface-based proxies. The fact that annotations are
      <span class="emphasis"><em>not inherited</em></span> means that if you are using class-based
      proxies (<tt class="literal">proxy-target-class="true"</tt>) or the weaving-based aspect
      (<tt class="literal">mode="aspectj"</tt>) then the transaction settings will not be
      recognised by the proxying/weaving infrastructure and the object will not be
      wrapped in a transactional proxy (which would be decidedly <span class="emphasis"><em>bad</em></span>).
      So please do take the Spring team's advice and only annotate concrete classes
      (and the methods of concrete classes) with the
      <tt class="interfacename">@Transactional</tt> annotation.</p><p><span class="emphasis"><em>Note: In proxy mode (which is the default), only 'external'
      method calls coming in through the proxy will be intercepted.</em></span>
      This means that 'self-invocation', i.e. a method within the target object
      calling some other method of the target object, won't lead to an actual
      transaction at runtime even if the invoked method is marked with
      <tt class="interfacename">@Transactional</tt>!</p><p>Consider the use of AspectJ mode (see below) if you expect
      self-invocations to be wrapped with transactions as well. In this case,
      there won't be a proxy in the first place; instead, the target class
      will be 'weaved' (i.e. its byte code will be modified) in order to
      turn <tt class="interfacename">@Transactional</tt> into runtime behavior
      on any kind of method.</p><p>
        </p><div class="table"><a name="tx-annotation-driven-settings"></a><p class="title"><b>Table&nbsp;9.2.&nbsp;<tt class="literal">&lt;tx:annotation-driven/&gt;</tt> settings</b></p><table summary="<tx:annotation-driven/&gt; settings" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Attribute</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal">transaction-manager</tt></td><td>transactionManager</td><td><p>The name of transaction manager to use. Only required
                if the name of the transaction manager is not <tt class="literal">transactionManager</tt>,
                as in the example above.</p></td></tr><tr><td><tt class="literal">mode</tt></td><td>proxy</td><td><p>The default mode "proxy" will process annotated beans
                to be proxied using Spring's AOP framework (following proxy semantics,
                as discussed above, applying to method calls coming in through the proxy only).
                The alternative mode "aspectj" will instead weave the affected classes with
                Spring's AspectJ transaction aspect (modifying the target class byte code
                in order to apply to any kind of method call).
                AspectJ weaving requires spring-aspects.jar on the classpath
                as well as load-time weaving (or compile-time weaving) enabled.
                (See the section entitled <a href="#aop-aj-ltw-spring" title="6.8.4.5.&nbsp;Spring configuration">Section&nbsp;6.8.4.5, &#8220;Spring configuration&#8221;</a>
                for details on how to set up load-time weaving.)</p></td></tr><tr><td><tt class="literal">proxy-target-class</tt></td><td>false</td><td><p>Applies to proxy mode only. Controls what type
                of transactional proxies are created for classes annotated
                with the <tt class="interfacename">@Transactional</tt> annotation.
                If "<tt class="literal">proxy-target-class</tt>" attribute is set to
                "<tt class="literal">true</tt>", then class-based proxies will be created.
                If "<tt class="literal">proxy-target-class</tt>" is "<tt class="literal">false</tt>"
                or if the attribute is omitted, then standard JDK interface-based proxies
                will be created. (See the section entitled <a href="#aop-proxying" title="6.6.&nbsp;Proxying mechanisms">Section&nbsp;6.6, &#8220;Proxying mechanisms&#8221;</a>
                for a detailed examination of the different proxy types.)</p></td></tr><tr><td><tt class="literal">order</tt></td><td>Ordered.LOWEST_PRECEDENCE</td><td><p>Defines the order of the transaction advice that will be applied to
                beans annotated with <tt class="interfacename">@Transactional</tt>. More on the
                rules related to ordering of AOP advice can be found in the AOP chapter (see section
                <a href="#aop-ataspectj-advice-ordering" title="6.2.4.7.&nbsp;Advice ordering">Section&nbsp;6.2.4.7, &#8220;Advice ordering&#8221;</a>). Note that not specifying
                any ordering will leave the decision as to what order advice is run in to
                the AOP subsystem.</p></td></tr></tbody></table></div><p>
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The "<tt class="literal">proxy-target-class</tt>" attribute on the
        <tt class="literal">&lt;tx:annotation-driven/&gt;</tt> element controls
        what type of transactional proxies are created for classes annotated
        with the <tt class="interfacename">@Transactional</tt> annotation.
        If "<tt class="literal">proxy-target-class</tt>" attribute is set to
        "<tt class="literal">true</tt>", then class-based proxies will be created.
        If "<tt class="literal">proxy-target-class</tt>" is "<tt class="literal">false</tt>"
        or if the attribute is omitted, then standard JDK interface-based proxies
        will be created. (See the section entitled <a href="#aop-proxying" title="6.6.&nbsp;Proxying mechanisms">Section&nbsp;6.6, &#8220;Proxying mechanisms&#8221;</a>
        for a detailed examination of the different proxy types.)</p></td></tr></table></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Note that <tt class="literal">&lt;tx:annotation-driven/&gt;</tt> only looks for
        <tt class="interfacename">@Transactional</tt> on beans in the same application context it is defined in.
        This means that, if you put <tt class="literal">&lt;tx:annotation-driven/&gt;</tt> in a
        <tt class="interfacename">WebApplicationContext</tt> for a <tt class="classname">DispatcherServlet</tt>, it only
        checks for <tt class="interfacename">@Transactional</tt> beans in your controllers, and not your services.
        See <a href="#mvc-servlet" title="13.2.&nbsp;The DispatcherServlet">Section&nbsp;13.2, &#8220;The DispatcherServlet&#8221;</a> for more information.</p></td></tr></table></div><p>The most derived location takes precedence when evaluating the transactional
      settings for a method. In the case of the following example, the
      <tt class="classname">DefaultFooService</tt> class is annotated at the class level
      with the settings for a read-only transaction, but the
      <tt class="interfacename">@Transactional</tt> annotation on the
      <tt class="methodname">updateFoo(Foo)</tt> method in the same class takes precedence
      over the transactional settings defined at the class level.</p><pre class="programlisting">@Transactional(readOnly = true)
public class DefaultFooService implements FooService {

  public Foo getFoo(String fooName) {
    <i class="lineannotation"><span class="lineannotation">// do something</span></i>
  }

  <i class="lineannotation"><span class="lineannotation">// <span class="bold"><b>these</b></span> settings have precedence for this method</span></i>
  @Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)
  public void updateFoo(Foo foo) {
    <i class="lineannotation"><span class="lineannotation">// do something</span></i>
  }
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="transaction-declarative-attransactional-settings"></a>9.5.6.1.&nbsp;<tt class="interfacename">@Transactional</tt> settings</h4></div></div><div></div></div><p>The <tt class="interfacename">@Transactional</tt> annotation is
        metadata that specifies that an interface, class, or method must have
        transactional semantics; for example, &#8220;<span class="quote"><span class="emphasis"><em>start a brand new read-only
        transaction when this method is invoked, suspending any existing
        transaction</em></span></span>&#8221;. The default
        <tt class="interfacename">@Transactional</tt> settings are:</p><div class="itemizedlist"><ul type="disc"><li><p>The propagation setting is <tt class="literal">PROPAGATION_REQUIRED</tt></p></li><li><p>The isolation level is <tt class="literal">ISOLATION_DEFAULT</tt></p></li><li><p>The transaction is read/write</p></li><li><p>The transaction timeout defaults to the default timeout of the
            underlying transaction system, or or none if timeouts are not supported</p></li><li><p>Any <tt class="exceptionname">RuntimeException</tt> will trigger
            rollback, and any checked <tt class="exceptionname">Exception</tt>
            will not</p></li></ul></div><p>These default settings can be changed; the various
        properties of the <tt class="interfacename">@Transactional</tt> annotation
        are summarized in the following table:</p><p>
          </p><div class="table"><a name="tx-attransactional-properties"></a><p class="title"><b>Table&nbsp;9.3.&nbsp;<tt class="interfacename">@Transactional</tt> properties</b></p><table summary="@Transactional properties" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><tt class="literal"><a href="#tx-propagation" title="9.5.7.&nbsp;Transaction propagation">propagation</a></tt></td><td>enum: <tt class="classname">Propagation</tt></td><td>optional propagation setting</td></tr><tr><td><tt class="literal">isolation</tt></td><td>enum: <tt class="classname">Isolation</tt></td><td>optional isolation level</td></tr><tr><td><tt class="literal">readOnly</tt></td><td>boolean</td><td>read/write vs. read-only transaction</td></tr><tr><td><tt class="literal">timeout</tt></td><td>int (in seconds granularity)</td><td>the transaction timeout</td></tr><tr><td><tt class="literal">rollbackFor</tt></td><td>an array of <tt class="classname">Class</tt> objects, which
                  must be derived from <tt class="classname">Throwable</tt></td><td>an optional array of exception classes which
                  <span class="bold"><b>must</b></span> cause rollback</td></tr><tr><td><tt class="literal">rollbackForClassname</tt></td><td>an array of <tt class="classname"></tt> class names. Classes
                  must be derived from <tt class="classname">Throwable</tt></td><td>an optional array of names of exception classes that
                  <span class="bold"><b>must</b></span> cause rollback</td></tr><tr><td><tt class="literal">noRollbackFor</tt></td><td>an array of <tt class="classname">Class</tt> objects, which
                  must be derived from <tt class="classname">Throwable</tt></td><td>an optional array of exception classes that
                  <span class="bold"><b>must not</b></span> cause rollback.</td></tr><tr><td><tt class="literal">noRollbackForClassname</tt></td><td>an array of <tt class="classname">String</tt> class names, which
                  must be derived from <tt class="classname">Throwable</tt></td><td>an optional array of names of exception classes that
                  <span class="bold"><b>must not</b></span> cause rollback</td></tr></tbody></table></div><p>
        </p><p>Currently it is not possible to have explicit control over the name of a transaction, where
				'name' means the transaction name that will be shown in a transaction monitor, if applicable (for
				example, WebLogic's transaction monitor), and in logging output. For declarative transactions, the
				transaction name is always the fully-qualified class name + "." + method name of the
				transactionally-advised class. For example, if the <tt class="methodname">handlePayment(..)</tt>
				method of the <tt class="classname">BusinessService</tt> class started a transaction, the name of the
				transaction would be:</p><pre class="programlisting">com.foo.BusinessService.handlePayment</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tx-propagation"></a>9.5.7.&nbsp;Transaction propagation</h3></div></div><div></div></div><p><span class="emphasis"><em>Please note that this section of the Spring reference documentation is
			<span class="emphasis"><em>not</em></span> an introduction to transaction propagation proper; rather it details some of the
			semantics regarding transaction propagation in Spring.</em></span></p><p>In the case of Spring-managed transactions, please be aware of the difference between
			<span class="emphasis"><em>physical</em></span> and <span class="emphasis"><em>logical</em></span> transactions, and how the propagation
			setting applies to this difference.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="tx-propagation-required"></a>9.5.7.1.&nbsp;Required</h4></div></div><div></div></div><p>
					</p><div class="mediaobject" align="center"><img src="images/tx_prop_required.png" align="middle"><div class="caption"><p>PROPAGATION_REQUIRED</p></div></div><p>
				</p><p>When the propagation setting is <tt class="literal">PROPAGATION_REQUIRED</tt>, a
				<span class="emphasis"><em>logical</em></span> transaction scope is created for each method that it gets applied to. Each
				such logical transaction scope can individually decide on rollback-only status, with an outer
				transaction scope being logically independent from the inner transaction scope. Of course, in case of
				standard <tt class="literal">PROPAGATION_REQUIRED</tt> behavior, they will be mapped to the same physical
				transaction. So a rollback-only marker set in the inner transaction scope does affect the outer
				transactions chance to actually commit (as you would expect it to).</p><p>However, in the case where an inner transaction scopes sets the rollback-only marker, the outer
				transaction itself has not decided on the rollback itself, and so the rollback (silently triggered by
				the inner transaction scope) is unexpected: a corresponding
				<tt class="classname">UnexpectedRollbackException</tt> will be thrown at that point. This is
				<span class="emphasis"><em>expected behavior</em></span> so that the caller of a transaction can never be misled to assume
				that a commit was performed when it really was not. So if an inner transaction (that the outer caller is
				not aware of) silently marks a transaction as rollback-only, the outer caller would still innocently
				call commit - and needs to receive an <tt class="classname">UnexpectedRollbackException</tt> to indicate
				clearly that a rollback was performed instead.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="tx-propagation-requires_new"></a>9.5.7.2.&nbsp;RequiresNew</h4></div></div><div></div></div><p>
					</p><div class="mediaobject" align="center"><img src="images/tx_prop_requires_new.png" align="middle"><div class="caption"><p>PROPAGATION_REQUIRES_NEW</p></div></div><p>
				</p><p><tt class="literal">PROPAGATION_REQUIRES_NEW</tt>, in contrast, uses a <span class="emphasis"><em>completely</em></span>
				independent transaction for each affected transaction scope. In that case, the underlying physical
				transactions will be different and hence can commit or rollback independently, with an outer transaction
				not affected by an inner transaction's rollback status.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="tx-propagation-nested"></a>9.5.7.3.&nbsp;Nested</h4></div></div><div></div></div><p><tt class="literal">PROPAGATION_NESTED</tt> is different again in that it uses a
				<span class="emphasis"><em>single</em></span> physical transaction with multiple savepoints that it can roll back to.
				Such partial rollbacks allow an inner transaction scope to trigger a rollback
				<span class="emphasis"><em>for its scope</em></span>, with the outer transaction being able to continue the physical
				transaction despite some operations having been rolled back. This is typically mapped onto JDBC
				savepoints, so will only work with JDBC resource transactions (see Spring's
				<tt class="classname">DataSourceTransactionManager</tt>).</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-declarative-applying-more-than-just-tx-advice"></a>9.5.8.&nbsp;Advising transactional operations</h3></div></div><div></div></div><p>Consider the situation where you would like to execute
			<span class="emphasis"><em>both</em></span> transactional <span class="emphasis"><em>and</em></span>
			(to keep things simple) some basic profiling advice. How do you
			effect this in the context of using
			<tt class="literal">&lt;tx:annotation-driven/&gt;</tt>?</p><p>What we want to see when we invoke the <tt class="methodname">updateFoo(Foo)</tt>
      method is:</p><div class="itemizedlist"><ul type="disc"><li><p>the configured profiling aspect starting up,</p></li><li><p>then the transactional advice executing,</p></li><li><p>then the method on the advised object executing</p></li><li><p>then the transaction committing (we'll assume a sunny day scenario here),</p></li><li><p>and then finally the profiling aspect reporting (somehow) exactly
          how long the whole transactional method invocation took</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>This chapter is not concerned with explaining AOP in any great detail
        (except as it applies to transactions). Please see the chapter entitled
        <a href="#aop" title="Chapter&nbsp;6.&nbsp;Aspect Oriented Programming with Spring">Chapter&nbsp;6, <i>Aspect Oriented Programming with Spring</i></a> for detailed coverage of the various bits and pieces
        of the following AOP configuration (and AOP in general).</p></td></tr></table></div><p>Here is the code for a simple profiling aspect. The
      ordering of advice is controlled via the <tt class="interfacename">Ordered</tt>
      interface. For full details on advice ordering, see <a href="#aop-ataspectj-advice-ordering" title="6.2.4.7.&nbsp;Advice ordering">Section&nbsp;6.2.4.7, &#8220;Advice ordering&#8221;</a>.</p><pre class="programlisting">package x.y;

import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.util.StopWatch;
import org.springframework.core.Ordered;

public class SimpleProfiler implements Ordered {

  private int order;

  <i class="lineannotation"><span class="lineannotation">// allows us to control the ordering of advice</span></i>
  public int getOrder() {
    return this.order;
  }

  public void setOrder(int order) {
    this.order = order;
  }

  <i class="lineannotation"><span class="lineannotation">// this method <span class="emphasis"><em>is</em></span> the around advice</span></i>
  public Object profile(ProceedingJoinPoint call) throws Throwable {
    Object returnValue;
    StopWatch clock = new StopWatch(getClass().getName());
    try {
      clock.start(call.toShortString());
      returnValue = call.proceed();
    } finally {
      clock.stop();
      System.out.println(clock.prettyPrint());
    }
    return returnValue;
  }
}
</pre><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:aop="http://www.springframework.org/schema/aop"
     xmlns:tx="http://www.springframework.org/schema/tx"
     xsi:schemaLocation="
   http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- this is the aspect --&gt;</span></i>
  &lt;bean id="profiler" class="x.y.SimpleProfiler"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span></i>
    &lt;property name="order" <span class="bold"><b>value="1"</b></span>/&gt;
  &lt;/bean&gt;

  &lt;tx:annotation-driven transaction-manager="txManager" <span class="bold"><b>order="200"</b></span>/&gt;

  &lt;aop:config&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- this advice will execute <span class="bold"><b>around</b></span> the transactional advice --&gt;</span></i>
    &lt;aop:aspect id="profilingAspect" ref="profiler"&gt;
      &lt;aop:pointcut id="serviceMethodWithReturnValue"
              expression="execution(!void x.y..*Service.*(..))"/&gt;
      &lt;aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/&gt;
    &lt;/aop:aspect&gt;
  &lt;/aop:config&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/&gt;
    &lt;property name="url" value="jdbc:oracle:thin:@rj-t42:1521:elvis"/&gt;
    &lt;property name="username" value="scott"/&gt;
    &lt;property name="password" value="tiger"/&gt;
  &lt;/bean&gt;

  &lt;bean id="txManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The result of the above configuration will be a <tt class="literal">'fooService'</tt>
      bean that has profiling and transactional aspects applied to it
      <span class="emphasis"><em>in that order</em></span>. The configuration of any number of additional
      aspects is effected in a similar fashion.</p><p>Finally, find below some example configuration for effecting the same
      setup as above, but using the purely XML declarative approach.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:aop="http://www.springframework.org/schema/aop"
     xmlns:tx="http://www.springframework.org/schema/tx"
     xsi:schemaLocation="
   http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;bean id="fooService" class="x.y.service.DefaultFooService"/&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- the profiling advice --&gt;</span></i>
  &lt;bean id="profiler" class="x.y.SimpleProfiler"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- execute before the transactional advice (hence the lower order number) --&gt;</span></i>
    <span class="bold"><b>&lt;property name="order" value="1</b></span>"/&gt;
  &lt;/bean&gt;

  &lt;aop:config&gt;

    &lt;aop:pointcut id="entryPointMethod" expression="execution(* x.y..*Service.*(..))"/&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- will execute after the profiling advice (c.f. the order attribute) --&gt;</span></i>
    &lt;aop:advisor
        advice-ref="txAdvice"
        pointcut-ref="entryPointMethod"
        <span class="bold"><b>order="2</b></span>"/&gt; <i class="lineannotation"><span class="lineannotation">&lt;!-- order value is higher than the profiling aspect --&gt;</span></i>

    &lt;aop:aspect id="profilingAspect" ref="profiler"&gt;
      &lt;aop:pointcut id="serviceMethodWithReturnValue"
              expression="execution(!void x.y..*Service.*(..))"/&gt;
      &lt;aop:around method="profile" pointcut-ref="serviceMethodWithReturnValue"/&gt;
    &lt;/aop:aspect&gt;

  &lt;/aop:config&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="get*" read-only="true"/&gt;
      &lt;tx:method name="*"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- other &lt;bean/&gt; definitions such as a <tt class="interfacename">DataSource</tt> and a <tt class="interfacename">PlatformTransactionManager</tt> here --&gt;</span></i>

&lt;/beans&gt;</pre><p>The result of the above configuration will be a <tt class="literal">'fooService'</tt>
      bean that has profiling and transactional aspects applied to it
      <span class="emphasis"><em>in that order</em></span>. If we wanted the profiling advice to execute
      <span class="emphasis"><em>after</em></span> the transactional advice on the way in, and
      <span class="emphasis"><em>before</em></span> the transactional advice on the way out, then we would
      simply swap the value of the profiling aspect bean's <tt class="literal">'order'</tt>
      property such that it was higher than the transactional advice's order value.</p><p>The configuration of any number of additional aspects is achieved in a
      similar fashion.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-declarative-aspectj"></a>9.5.9.&nbsp;Using <tt class="interfacename">@Transactional</tt> with AspectJ</h3></div></div><div></div></div><p>It is also possible to use the Spring Framework's
      <tt class="interfacename">@Transactional</tt> support outside of a Spring container
      by means of an AspectJ aspect. To use this support you must first
      annotate your classes (and optionally your classes' methods with the
      <tt class="interfacename">@Transactional</tt> annotation, and then you must link
      (weave) your application with the
      <tt class="classname">org.springframework.transaction.aspectj.AnnotationTransactionAspect</tt>
      defined in the <tt class="filename">spring-aspects.jar</tt> file.
      The aspect must also be configured with a transaction manager. You could of course
      use the Spring Framework's IoC container to take care of dependency injecting the
      aspect.  The simplest way to 
      configure the transaction management aspect is to use the 
      <tt class="literal">'&lt;tx:annotation-driven/&gt;'</tt> element and specify the 
      <tt class="literal">mode</tt> attribute to <tt class="literal">asepctj</tt> as described in
      <a href="#transaction-declarative-annotations" title="9.5.6.&nbsp;Using @Transactional">Section&nbsp;9.5.6, &#8220;Using @Transactional&#8221;</a>. 
      
      
      Since we're focusing here on applications running outside of a Spring
      container, we'll show you how to do it programmatically.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Prior to continuing, you may well want to read the previous sections entitled
        <a href="#transaction-declarative-annotations" title="9.5.6.&nbsp;Using @Transactional">Section&nbsp;9.5.6, &#8220;Using @Transactional&#8221;</a> and <a href="#aop" title="Chapter&nbsp;6.&nbsp;Aspect Oriented Programming with Spring">Chapter&nbsp;6, <i>Aspect Oriented Programming with Spring</i></a>
        respectively.</p></td></tr></table></div><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// construct an appropriate transaction manager </span></i>
DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource());

<i class="lineannotation"><span class="lineannotation">// configure the <tt class="classname">AnnotationTransactionAspect</tt> to use it; this must be done before executing any transactional methods</span></i>
AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager); </pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>When using this aspect, you must annotate the <span class="emphasis"><em>implementation</em></span>
	      class (and/or methods within that class), <span class="emphasis"><em>not</em></span> the interface
	      (if any) that the class implements. AspectJ follows Java's rule that annotations on
	      interfaces are <span class="emphasis"><em>not inherited</em></span>.</p></td></tr></table></div><p>The <tt class="interfacename">@Transactional</tt> annotation on a class specifies
	    the default transaction semantics for the execution of any method in the class.</p><p>The <tt class="interfacename">@Transactional</tt> annotation on a method within
	    the class overrides the default transaction semantics given by the class annotation
	    (if present). Any method may be annotated, regardless of visibility.</p><p>To weave your applications with the <tt class="classname">AnnotationTransactionAspect</tt>
	    you must either build your application with AspectJ (see the
	    <a href="http://www.eclipse.org/aspectj/doc/released/devguide/index.html" target="_top">AspectJ Development Guide</a>)
	    or use load-time weaving. See the section entitled <a href="#aop-aj-ltw" title="6.8.4.&nbsp;Load-time weaving with AspectJ in the Spring Framework">Section&nbsp;6.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221;</a> for a
	    discussion of load-time weaving with AspectJ.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transaction-programmatic"></a>9.6.&nbsp;Programmatic transaction management</h2></div></div><div></div></div><p>The Spring Framework provides two means of programmatic transaction management:</p><div class="itemizedlist"><ul type="disc"><li><p>Using the <tt class="classname">TransactionTemplate</tt>.</p></li><li><p>Using a <tt class="interfacename">PlatformTransactionManager</tt>
        implementation directly.</p></li></ul></div><p>If you are going to use programmatic transaction management, the Spring
    team generally recommends using the <tt class="classname">TransactionTemplate</tt>.
		The second approach is similar to using the JTA <tt class="interfacename">UserTransaction</tt>
		API (although exception handling is less cumbersome).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tx-prog-template"></a>9.6.1.&nbsp;Using the <tt class="classname">TransactionTemplate</tt></h3></div></div><div></div></div><p>The <tt class="classname">TransactionTemplate</tt> adopts the same
      approach as other Spring <span class="emphasis"><em>templates</em></span> such as the
      <tt class="classname">JdbcTemplate</tt>. It uses a callback approach, to
      free application code from having to do the boilerplate acquisition
      and release of transactional resources, and results in code that is
      intention driven, in that the code that is written focuses solely
      on what the developer wants to do.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>As you will immediately see in the examples that follow, using
				the <tt class="classname">TransactionTemplate</tt> absolutely
				couples you to Spring's transaction infrastructure and APIs.
				Whether or not programmatic transaction management is suitable
				for your development needs is a decision that you will have to
				make yourself.</p></td></tr></table></div><p>Application code that must execute in a transactional context,
			and that will use the <tt class="classname">TransactionTemplate</tt> explicitly,
			looks like this. You, as an application developer, will write a
			<tt class="interfacename">TransactionCallback</tt> implementation (typically
			expressed as an anonymous inner class) that will contain all of the code
			that you need to have execute in the context of a transaction. You will then
			pass an instance of your custom <tt class="interfacename">TransactionCallback</tt>
			to the <tt class="methodname">execute(..)</tt> method exposed on the
			<tt class="classname">TransactionTemplate</tt>. </p><pre class="programlisting">public class SimpleService implements Service {

  <i class="lineannotation"><span class="lineannotation">// single <tt class="classname">TransactionTemplate</tt> shared amongst all methods in this instance</span></i>
  private final TransactionTemplate transactionTemplate;

  <i class="lineannotation"><span class="lineannotation">// use constructor-injection to supply the <tt class="interfacename">PlatformTransactionManager</tt></span></i>
  public SimpleService(PlatformTransactionManager transactionManager) {
    Assert.notNull(transactionManager, "The 'transactionManager' argument must not be null.");
    this.transactionTemplate = new TransactionTemplate(transactionManager);
  }

  public Object someServiceMethod() {
    return transactionTemplate.execute(new TransactionCallback() {

      <i class="lineannotation"><span class="lineannotation">// the code in this method executes in a transactional context</span></i>
      public Object doInTransaction(TransactionStatus status) {
        updateOperation1();
        return resultOfUpdateOperation2();
      }
    });
  }
}</pre><p>If there is no return value, use the convenient
      <tt class="classname">TransactionCallbackWithoutResult</tt> class via an
      anonymous class like so:</p><pre class="programlisting">transactionTemplate.execute(new <span class="bold"><b>TransactionCallbackWithoutResult</b></span>() {

  protected void doInTransactionWithoutResult(TransactionStatus status) {
    updateOperation1();
    updateOperation2();
  }
});</pre><p>Code within the callback can roll the transaction back by calling
      the <tt class="literal">setRollbackOnly()</tt> method on the supplied
      <tt class="interfacename">TransactionStatus</tt> object.</p><pre class="programlisting">transactionTemplate.execute(new TransactionCallbackWithoutResult() {

  protected void doInTransactionWithoutResult(TransactionStatus status) {
    try {
      updateOperation1();
      updateOperation2();
    } catch (SomeBusinessExeption ex) {
      <span class="bold"><b>status.setRollbackOnly();</b></span>
    }
  }
});</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="tx-prog-template-settings"></a>9.6.1.1.&nbsp;Specifying transaction settings</h4></div></div><div></div></div><p>Transaction settings such as the propagation mode, the isolation level,
				the timeout, and so forth can be set on the <tt class="classname">TransactionTemplate</tt>
				either programmatically or in configuration. <tt class="classname">TransactionTemplate</tt>
				instances by default have the <a href="#transaction-declarative-txadvice-settings" title="9.5.5.&nbsp;<tx:advice/&gt; settings">default transactional settings</a>.
				Find below an example of programmatically customizing the
				transactional settings for a specific <tt class="classname">TransactionTemplate</tt>.
				</p><pre class="programlisting">public class SimpleService implements Service {

  private final TransactionTemplate transactionTemplate;

  public SimpleService(PlatformTransactionManager transactionManager) {
    Assert.notNull(transactionManager, "The 'transactionManager' argument must not be null.");
    this.transactionTemplate = new TransactionTemplate(transactionManager);

    <i class="lineannotation"><span class="lineannotation">// the transaction settings can be set here explicitly if so desired</span></i>
    this.transactionTemplate.setIsolationLevel(TransactionDefinition.ISOLATION_READ_UNCOMMITTED);
    this.transactionTemplate.setTimeout(30); <i class="lineannotation"><span class="lineannotation">// 30 seconds</span></i>
    <i class="lineannotation"><span class="lineannotation">// and so forth...</span></i>
  }
}</pre><p>Find below an example of defining a <tt class="classname">TransactionTemplate</tt> with some custom
				transactional settings, using Spring XML configuration. The '<tt class="literal">sharedTransactionTemplate</tt>'
				can then be injected into as many services as are required.</p><pre class="programlisting">&lt;bean id="sharedTransactionTemplate"
    class="org.springframework.transaction.support.TransactionTemplate"&gt;
  &lt;property name="isolationLevelName" value="ISOLATION_READ_UNCOMMITTED"/&gt;
  &lt;property name="timeout" value="30"/&gt;
&lt;/bean&gt;"</pre></div><p>
				Finally, instances of the <tt class="classname">TransactionTemplate</tt> class are
				threadsafe, in that instances do not maintain any conversational state.
				<tt class="classname">TransactionTemplate</tt> instances <span class="emphasis"><em>do</em></span>
				however maintain configuration state, so while a number of classes
				may choose to share a single instance of a <tt class="classname">TransactionTemplate</tt>, if a class needed
				to use a <tt class="classname">TransactionTemplate</tt> with different settings
				(for example, a different isolation level), then two distinct
				<tt class="classname">TransactionTemplate</tt> instances would need to be
				created and used.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-programmatic-ptm"></a>9.6.2.&nbsp;Using the <tt class="interfacename">PlatformTransactionManager</tt></h3></div></div><div></div></div><p>You can also use the
      <tt class="interfacename">org.springframework.transaction.PlatformTransactionManager</tt>
      directly to manage your transaction. Simply pass the implementation of
      the <tt class="interfacename">PlatformTransactionManager</tt> you're
      using to your bean via a bean reference. Then, using the
      <tt class="interfacename">TransactionDefinition</tt> and
      <tt class="interfacename">TransactionStatus</tt> objects you can
      initiate transactions, rollback and commit.</p><pre class="programlisting">DefaultTransactionDefinition def = new DefaultTransactionDefinition();
<i class="lineannotation"><span class="lineannotation">// explicitly setting the transaction name is something that can only be done programmatically</span></i>
def.setName("SomeTxName");
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

TransactionStatus status = txManager.getTransaction(def);
try {
  <i class="lineannotation"><span class="lineannotation">// execute your business logic here</span></i>
}
catch (MyException ex) {
  txManager.rollback(status);
  throw ex;
}
txManager.commit(status);</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tx-decl-vs-prog"></a>9.7.&nbsp;Choosing between programmatic and declarative transaction management</h2></div></div><div></div></div><p>Programmatic transaction management is usually a good idea only if
    you have a small number of transactional operations. For example, if you
    have a web application that require transactions only for certain update
    operations, you may not want to set up transactional proxies using Spring
    or any other technology. In this case, using the <tt class="classname">TransactionTemplate</tt>
    <span class="emphasis"><em>may</em></span> be a good approach. Being able to set the transaction name
		explicitly is also something that can only be done using the programmatic
		approach to transaction management.</p><p>On the other hand, if your application has numerous transactional
    operations, declarative transaction management is usually worthwhile. It
    keeps transaction management out of business logic, and is not difficult
    to configure. When using the Spring Framework, rather than EJB CMT, the
    configuration cost of declarative transaction management is greatly reduced.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transaction-application-server-integration"></a>9.8.&nbsp;Application server-specific integration</h2></div></div><div></div></div><p>Spring's transaction abstraction generally is application server
    agnostic. Additionally, Spring's <tt class="classname">JtaTransactionManager</tt> class,
    which can optionally perform a JNDI lookup for the JTA
    <tt class="interfacename">UserTransaction</tt> and
    <tt class="interfacename">TransactionManager</tt> objects, autodetects
    the location for the latter object, which varies by application server. Having
    access to the JTA <tt class="interfacename">TransactionManager</tt> allows for
    enhanced transaction semantics, in particular supporting transaction suspension.
    Please see the <tt class="classname">JtaTransactionManager</tt> Javadocs for details.
    </p><p>Spring's <tt class="classname">JtaTransactionManager</tt> is the standard
    choice when running on J2EE application servers, known to work on all common
    servers. Its advanced functionality such as transaction suspension is known to
    work on many servers as well - including GlassFish, JBoss, Geronimo and Oracle
    OC4J - without any special configuration required. However, for fully supported
    transaction suspension and further advanced integration, Spring ships special
    adapters for IBM WebSphere and BEA WebLogic and also for Oracle OC4J.
    We'll discuss these adapters in the following sections.</p><p><span class="emphasis"><em>For standard scenarios, including WebLogic, WebSphere and OC4J,
    consider using the convenient <tt class="literal">'&lt;tx:jta-transaction-manager/&gt;'</tt>
    configuration element.</em></span> This will automatically detect the underlying
    server and choose the best transaction manager available for the platform.
    This means that you won't have to configure server-specific adapter classes
    (as discussed in the following sections) explicitly; they will rather be chosen
    automatically, with the standard <tt class="classname">JtaTransactionManager</tt>
    as default fallback.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-application-server-integration-websphere"></a>9.8.1.&nbsp;IBM WebSphere</h3></div></div><div></div></div><p>On WebSphere 6.0 and above, the recommended Spring JTA transaction
      manager to use is <tt class="classname">WebSphereUowTransactionManager</tt>.
      This special adapter leverages IBM's <tt class="interfacename">UOWManager</tt>
      API which is available in WebSphere Application Server 6.0.2.19 or above
      and 6.1.0.9 or above. With this adapter, Spring-driven transaction suspension
      (suspend/resume as initiated by <tt class="literal">PROPAGATION_REQUIRES_NEW</tt>)
      is officially supported by IBM!</p><p>In a WebSphere 5.1 environment, you may wish to use
      Spring's <tt class="classname">WebSphereTransactionManagerFactoryBean</tt>
      class. This is a factory bean which retrieves the JTA
      <tt class="interfacename">TransactionManager</tt> in a WebSphere environment, which
      is done via WebSphere's <tt class="literal">static</tt> access methods.
      Once the JTA <tt class="interfacename">TransactionManager</tt> instance has
      been obtained via this factory bean, Spring's
      <tt class="classname">JtaTransactionManager</tt> may be configured with a
      reference to it, for enhanced transaction semantics over the use of only
      the JTA <tt class="interfacename">UserTransaction</tt> object.
      Please see the Javadocs for full details.</p><p><span class="emphasis"><em>Note that <tt class="classname">WebSphereTransactionManagerFactoryBean</tt>
      usage is known to work on WAS 5.1 and 6.0 but is not officially supported
      by IBM.</em></span> Prefer <tt class="classname">WebSphereUowTransactionManager</tt>
      when running on WAS 6.0 or higher (see above).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-application-server-integration-weblogic"></a>9.8.2.&nbsp;BEA WebLogic</h3></div></div><div></div></div><p>On WebLogic 8.1 or above, you will generally prefer to use
			the <tt class="classname">WebLogicJtaTransactionManager</tt> instead
      of the stock <tt class="classname">JtaTransactionManager</tt> class.
      This special WebLogic-specific subclass of the normal
      <tt class="classname">JtaTransactionManager</tt> supports the full power of
      Spring's transaction definitions in a WebLogic-managed transaction environment,
      beyond standard JTA semantics: Features include transaction names, per-transaction
      isolation levels, and proper resuming of transactions in all cases.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-application-server-integration-oc4j"></a>9.8.3.&nbsp;Oracle OC4J</h3></div></div><div></div></div><p>Spring ships a special adapter class for OC4J 10.1.3 or above:
			<tt class="classname">OC4JJtaTransactionManager</tt>. This is analogous to
      the <tt class="classname">WebLogicJtaTransactionManager</tt> class discussed
      in the previous section, providing similar value-adds on OC4J:
      transaction names and per-transaction isolation levels.</p><p>Note that the full JTA functionality, including transaction suspension,
      works fine with Spring's <tt class="classname">JtaTransactionManager</tt> on
      OC4J as well. The special <tt class="classname">OC4JJtaTransactionManager</tt>
      adapter simply provides value-adds beyond standard JTA.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transaction-solutions-to-common-problems"></a>9.9.&nbsp;Solutions to common problems</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="transaction-solutions-to-common-problems-wrong-ptm"></a>9.9.1.&nbsp;Use of the wrong transaction manager for a specific <tt class="interfacename">DataSource</tt></h3></div></div><div></div></div><p>You should take care to use the <span class="emphasis"><em>correct</em></span>
      <tt class="interfacename">PlatformTransactionManager</tt>
      implementation for their requirements. Used properly, the Spring Framework
      merely provides a straightforward and portable abstraction. If you are using
      global transactions, you <span class="emphasis"><em>must</em></span> use the
      <tt class="classname">org.springframework.transaction.jta.JtaTransactionManager</tt> class
      (or an
      <a href="#transaction-application-server-integration" title="9.8.&nbsp;Application server-specific integration">application server-specific subclass</a>
       of it) for all your transactional operations. Otherwise the transaction infrastructure
       will attempt to perform local transactions on resources such as container
       <tt class="interfacename">DataSource</tt> instances. Such local transactions
       do not make sense, and a good application server will treat them as errors.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="transaction-resources"></a>9.10.&nbsp;Further Resources</h2></div></div><div></div></div><p>Find below links to further resources about the Spring Framework's transaction support.</p><div class="itemizedlist"><ul type="disc"><li><p><a href="http://www.infoq.com/minibooks/JTDS" target="_top">Java Transaction Design Strategies</a>
				is a book available from <a href="http://www.infoq.com/" target="_top">InfoQ</a> that provides a well-paced
				introduction to transactions in Java. It also includes side-by-side examples of how to configure and use
				transactions using both the Spring Framework and EJB3.</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="dao"></a>Chapter&nbsp;10.&nbsp;DAO support</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dao-introduction"></a>10.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
			The Data Access Object (DAO) support in Spring is aimed at
			making it easy to work with data access technologies like
			JDBC, Hibernate or JDO in a consistent way. This allows one
			to switch between the aforementioned persistence technologies
			fairly easily and it also allows one to code without worrying
			about catching exceptions that are specific to each technology.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dao-exceptions"></a>10.2.&nbsp;Consistent exception hierarchy</h2></div></div><div></div></div><p>
			Spring provides a convenient translation from technology-specific
			exceptions like <tt class="classname">SQLException</tt> to its own
			exception class hierarchy with the
			<tt class="classname">DataAccessException</tt> as the root exception.
			These exceptions wrap the original exception so there is never
			any risk that one might lose any information as to what might
			have gone wrong.
		</p><p>
			In addition to JDBC exceptions, Spring can also wrap Hibernate-specific
			exceptions, converting them from proprietary, checked exceptions
			(in the case of versions of Hibernate prior to Hibernate 3.0), to
			a set of focused runtime exceptions (the same is true for JDO and
			JPA exceptions). This allows one to handle most persistence exceptions,
			which are non-recoverable, only in the appropriate layers, without
			having annoying boilerplate catch-and-throw blocks and exception
			declarations in one's DAOs. (One can still trap and handle exceptions
			anywhere one needs to though.) As mentioned above, JDBC exceptions
			(including database-specific dialects) are also converted to the
			same hierarchy, meaning that one can perform some operations with
			JDBC within a consistent programming model.
		</p><p>
			The above holds true for the various template classes in Springs
			support for various ORM frameworks. If one uses the interceptor-based
			classes then the application must care about handling
			<tt class="classname">HibernateExceptions</tt> and
			<tt class="classname">JDOExceptions</tt> itself, preferably via delegating
			to <tt class="classname">SessionFactoryUtils</tt>'
			<tt class="methodname">convertHibernateAccessException(..)</tt> or
			<tt class="methodname">convertJdoAccessException</tt> methods respectively.
			These methods convert the exceptions to ones that are compatible
			with the exceptions in the <tt class="literal">org.springframework.dao</tt>
			exception hierarchy. As <tt class="classname">JDOExceptions</tt> are
			unchecked, they can simply get thrown too, sacrificing generic DAO
			abstraction in terms of exceptions though.
		</p><p>
			The exception hierarchy that Spring provides can be seen below.
			(Please note that the class hierarchy detailed in the image
			shows only a subset of the entire
			<tt class="classname">DataAccessException</tt> hierarchy.)
		</p><div class="mediaobject" align="center"><img src="images/DataAccessException.gif" align="middle"></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dao-abstract-superclasses"></a>10.3.&nbsp;Consistent abstract classes for DAO support</h2></div></div><div></div></div><p>
			To make it easier to work with a variety of data access technologies
			such as JDBC, JDO and Hibernate in a consistent way, Spring provides
			a set of <tt class="literal">abstract</tt> DAO classes that one can extend.
			These abstract classes have methods for providing the data source and
			any other configuration settings that are specific to the relevant
			data-access technology.
		</p><div class="itemizedlist"><ul type="disc"><li><p>
					<tt class="classname">JdbcDaoSupport</tt> - superclass for JDBC data
					access objects. Requires a <tt class="interfacename">DataSource</tt>
					to be provided; in turn, this class provides a 
					<tt class="classname">JdbcTemplate</tt> instance initialized from the
					supplied <tt class="interfacename">DataSource</tt> to subclasses.
				</p></li><li><p>
					<tt class="classname">HibernateDaoSupport</tt> - superclass for
					Hibernate data access objects. Requires a
					<tt class="interfacename">SessionFactory</tt> to be provided;
					in turn, this class provides a
					<tt class="classname">HibernateTemplate</tt> instance initialized
					from the supplied <tt class="interfacename">SessionFactory</tt>
					to subclasses. Can alternatively be initialized directly via a
					<tt class="classname">HibernateTemplate</tt>, to reuse the latters
					settings like <tt class="interfacename">SessionFactory</tt>,
					flush mode, exception translator, and so forth.
				</p></li><li><p>
					<tt class="classname">JdoDaoSupport</tt> - super class for JDO data
					access objects. Requires a
					<tt class="interfacename">PersistenceManagerFactory</tt>
					to be provided; in turn, this class provides a
					<tt class="classname">JdoTemplate</tt> instance initialized from the
					supplied <tt class="interfacename">PersistenceManagerFactory</tt>
					to subclasses.
				</p></li><li><p>
					<tt class="classname">JpaDaoSupport</tt> - super class for JPA data
					access objects. Requires a
					<tt class="interfacename">EntityManagerFactory</tt> to be provided;
					in turn, this class provides a <tt class="classname">JpaTemplate</tt>
					instance initialized from the supplied
					<tt class="interfacename">EntityManagerFactory</tt> to subclasses.
				</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jdbc"></a>Chapter&nbsp;11.&nbsp;Data access using JDBC</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-introduction"></a>11.1.&nbsp;Introduction</h2></div></div><div></div></div><p>The value-add provided by the Spring Framework's JDBC abstraction
    framework is perhaps best shown by the following list (note that only the
    italicized lines need to be coded by an application developer):</p><div class="orderedlist"><ol type="1"><li><p>Define connection parameters</p></li><li><p>Open the connection</p></li><li><p><span class="emphasis"><em>Specify the statement</em></span></p></li><li><p>Prepare and execute the statement</p></li><li><p>Set up the loop to iterate through the results (if any)</p></li><li><p><span class="emphasis"><em>Do the work for each iteration</em></span></p></li><li><p>Process any exception</p></li><li><p>Handle transactions</p></li><li><p>Close the connection</p></li></ol></div><p>The Spring Framework takes care of all the grungy, low-level details
    that can make JDBC such a tedious API to develop with.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-choose-style"></a>11.1.1.&nbsp;Choosing a style</h3></div></div><div></div></div><p>There are a number of options for selecting an approach to form
      the basis for your JDBC database access. There are three flavors of the
      JdbcTemplate, a new "SimpleJdbc" approach taking advantage of database
      metadata, and there is also the "RDBMS Object" style for a more object
      oriented approach similar in style to the JDO Query design. We'll
      briefly list the primary reasons why you would pick one of these
      approaches. Keep in mind that even if you start using one of these
      approaches, you can still mix and match if there is a feature in a
      different approach that you would like to take advantage of. All
      approaches requires a JDBC 2.0 compliant driver and some advanced
      features require a JDBC 3.0 driver.</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><b>JdbcTemplate</b></span> - this is the
          classic Spring JDBC approach and the most widely used. This is the
          "lowest level" approach and all other approaches use a JdbcTemplate
          under the covers. Works well in a JDK 1.4 and higher
          environment.</p></li><li><p><span class="bold"><b>NamedParameterJdbcTemplate</b></span> -
          wraps a JdbcTemplate to provide more convenient usage with named
          parameters instead of the traditional JDBC "?" place holders. This
          provides better documentation and ease of use when you have multiple
          parameters for an SQL statement. Works with JDK 1.4 and up.</p></li><li><p><span class="bold"><b>SimpleJdbcTemplate</b></span> - this
          class combines the most frequently used features of both
          JdbcTemplate and NamedParameterJdbcTemplate plus it adds additional
          convenience by taking advantage of some Java 5 features like
          varargs, autoboxing and generics to provide an easier to use API.
          Requires JDK 5 or higher.</p></li><li><p><span class="bold"><b>SimpleJdbcInsert and
          SimpleJdbcCall</b></span> - designed to take advantage of database
          metadata to limit the amount of configuration needed. This will
          simplify the coding to a point where you only need to provide the
          name of the table or procedure and provide a Map of parameters
          matching the column names. Designed to work together with the
          SimpleJdbcTemplate. Requires JDK 5 or higher and a database that
          provides adequate metadata.</p></li><li><p><span class="bold"><b>RDBMS Objects including MappingSqlQuery,
          SqlUpdate and StoredProcedure</b></span> - an approach where you
          create reusable and thread safe objects during initialization of
          your data access layer. This approach is modeled after JDO Query
          where you define your query string, declare parameters and compile
          the query. Once that is done any execute methods can be called
          multiple times with various parameter values passed in. Works with
          JDK 1.4 and higher.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-packages"></a>11.1.2.&nbsp;The package hierarchy</h3></div></div><div></div></div><p>The Spring Framework's JDBC abstraction framework consists of four
      different packages, namely <tt class="literal">core</tt>,
      <tt class="literal">datasource</tt>, <tt class="literal">object</tt>, and
      <tt class="literal">support</tt>.</p><p>The <tt class="literal">org.springframework.jdbc.core</tt> package
      contains the <tt class="classname">JdbcTemplate</tt> class and its various
      callback interfaces, plus a variety of related classes. A sub-package
      named <tt class="literal">org.springframework.jdbc.core.simple</tt> contains
      the <tt class="classname">SimpleJdbcTemplate</tt> class and the related
      <tt class="classname">SimpleJdbcInsert</tt> and
      <tt class="classname">SimpleJdbcCall</tt> classes. Another sub-package named
      <tt class="literal">org.springframework.jdbc.core.namedparam</tt> contains the
      <tt class="classname">NamedParameterJdbcTemplate</tt> class and the related
      support classes.</p><p>The <tt class="literal">org.springframework.jdbc.datasource</tt> package
      contains a utility class for easy
      <tt class="interfacename">DataSource</tt> access, and various simple
      <tt class="interfacename">DataSource</tt> implementations that can be
      used for testing and running unmodified JDBC code outside of a J2EE
      container. The utility class provides static methods to obtain
      connections from JNDI and to close connections if necessary. It has
      support for thread-bound connections, e.g. for use with
      <tt class="classname">DataSourceTransactionManager</tt>.</p><p>Next, the <tt class="literal">org.springframework.jdbc.object</tt>
      package contains classes that represent RDBMS queries, updates, and
      stored procedures as thread safe, reusable objects. This approach is
      modeled by JDO, although of course objects returned by queries are
      &#8220;<span class="quote">disconnected</span>&#8221; from the database. This higher level of JDBC
      abstraction depends on the lower-level abstraction in the
      <tt class="literal">org.springframework.jdbc.core</tt> package.</p><p>Finally the <tt class="literal">org.springframework.jdbc.support</tt>
      package is where you find the <tt class="classname">SQLException</tt>
      translation functionality and some utility classes.</p><p>Exceptions thrown during JDBC processing are translated to
      exceptions defined in the <tt class="literal">org.springframework.dao</tt>
      package. This means that code using the Spring JDBC abstraction layer
      does not need to implement JDBC or RDBMS-specific error handling. All
      translated exceptions are unchecked giving you the option of catching
      the exceptions that you can recover from while allowing other exceptions
      to be propagated to the caller.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-core"></a>11.2.&nbsp;Using the JDBC Core classes to control basic JDBC processing and
    error handling</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-JdbcTemplate"></a>11.2.1.&nbsp;<tt class="classname">JdbcTemplate</tt></h3></div></div><div></div></div><p>The <tt class="classname">JdbcTemplate</tt> class is the central class
      in the JDBC core package. It simplifies the use of JDBC since it handles
      the creation and release of resources. This helps to avoid common errors
      such as forgetting to always close the connection. It executes the core
      JDBC workflow like statement creation and execution, leaving application
      code to provide SQL and extract results. This class executes SQL
      queries, update statements or stored procedure calls, imitating
      iteration over <tt class="interfacename">ResultSet</tt>s and extraction
      of returned parameter values. It also catches JDBC exceptions and
      translates them to the generic, more informative, exception hierarchy
      defined in the <tt class="literal">org.springframework.dao</tt>
      package.</p><p>Code using the <tt class="classname">JdbcTemplate</tt> only need to
      implement callback interfaces, giving them a clearly defined contract.
      The <tt class="interfacename">PreparedStatementCreator</tt> callback
      interface creates a prepared statement given a
      <tt class="interfacename">Connection</tt> provided by this class,
      providing SQL and any necessary parameters. The same is true for the
      <tt class="interfacename">CallableStatementCreator</tt> interface which
      creates callable statement. The
      <tt class="interfacename">RowCallbackHandler</tt> interface extracts
      values from each row of a
      <tt class="interfacename">ResultSet</tt>.</p><p>The <tt class="classname">JdbcTemplate</tt> can be used within a DAO
      implementation via direct instantiation with a
      <tt class="interfacename">DataSource</tt> reference, or be configured in
      a Spring IOC container and given to DAOs as a bean reference. Note: the
      <tt class="interfacename">DataSource</tt> should always be configured as
      a bean in the Spring IoC container, in the first case given to the
      service directly, in the second case to the prepared template.</p><p>Finally, all of the SQL issued by this class is logged at the
      <tt class="literal">'DEBUG'</tt> level under the category corresponding to the
      fully qualified class name of the template instance (typically
      <tt class="classname">JdbcTemplate</tt>, but it may be different if a custom
      subclass of the <tt class="classname">JdbcTemplate</tt> class is being
      used).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdbc-JdbcTemplate-examples"></a>11.2.1.1.&nbsp;Examples</h4></div></div><div></div></div><p>Find below some examples of using the
        <tt class="classname">JdbcTemplate</tt> class. (These examples are not an
        exhaustive list of all of the functionality exposed by the
        <tt class="classname">JdbcTemplate</tt>; see the attendant Javadocs for
        that).</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdbc-JdbcTemplate-examples-query"></a>11.2.1.1.1.&nbsp;Querying (SELECT)</h5></div></div><div></div></div><p>A simple query for getting the number of rows in a
          relation.</p><pre class="programlisting">int rowCount = this.jdbcTemplate.queryForInt("select count(0) from t_accrual");</pre><p>A simple query using a bind variable.</p><pre class="programlisting">int countOfActorsNamedJoe = this.jdbcTemplate.queryForInt(
        "select count(0) from t_actors where first_name = ?", new Object[]{"Joe"});</pre><p>Querying for a <tt class="classname">String</tt>.</p><pre class="programlisting">String surname = (String) this.jdbcTemplate.queryForObject(
        "select surname from t_actor where id = ?", 
        new Object[]{new Long(1212)}, String.class);</pre><p>Querying and populating a <span class="emphasis"><em>single</em></span> domain
          object.</p><pre class="programlisting">Actor actor = (Actor) this.jdbcTemplate.queryForObject(
    "select first_name, surname from t_actor where id = ?",
    new Object[]{new Long(1212)},
    new RowMapper() {

        public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
            Actor actor = new Actor();
            actor.setFirstName(rs.getString("first_name"));
            actor.setSurname(rs.getString("surname"));
            return actor;
        }
    });</pre><p>Querying and populating a number of domain objects.</p><pre class="programlisting">Collection actors = this.jdbcTemplate.query(
    "select first_name, surname from t_actor",
    new RowMapper() {

        public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
            Actor actor = new Actor();
            actor.setFirstName(rs.getString("first_name"));
            actor.setSurname(rs.getString("surname"));
            return actor;
        }
    });</pre><p>If the last two snippets of code actually existed in the same
          application, it would make sense to remove the duplication present
          in the two <tt class="interfacename">RowMapper</tt> anonymous inner
          classes, and extract them out into a single class (typically a
          <tt class="literal">static</tt> inner class) that can then be referenced
          by DAO methods as needed. For example, the last code snippet might
          be better off written like so:</p><pre class="programlisting">public Collection findAllActors() {
    return this.jdbcTemplate.query( "select first_name, surname from t_actor", new ActorMapper());
}

private static final class ActorMapper implements RowMapper {

    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
        Actor actor = new Actor();
        actor.setFirstName(rs.getString("first_name"));
        actor.setSurname(rs.getString("surname"));
        return actor;
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdbc-JdbcTemplate-examples-update"></a>11.2.1.1.2.&nbsp;Updating (INSERT/UPDATE/DELETE)</h5></div></div><div></div></div><pre class="programlisting">this.jdbcTemplate.update(
        "insert into t_actor (first_name, surname) values (?, ?)", 
        new Object[] {"Leonor", "Watling"});</pre><pre class="programlisting">this.jdbcTemplate.update(
        "update t_actor set weapon = ? where id = ?", 
        new Object[] {"Banjo", new Long(5276)});</pre><pre class="programlisting">this.jdbcTemplate.update(
        "delete from actor where id = ?",
        new Object[] {new Long.valueOf(actorId)});</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="jdbc-JdbcTemplate-examples-other"></a>11.2.1.1.3.&nbsp;Other operations</h5></div></div><div></div></div><p>The <tt class="methodname">execute(..)</tt> method can be used to
          execute any arbitrary SQL, and as such is often used for DDL
          statements. It is heavily overloaded with variants taking callback
          interfaces, binding variable arrays, and suchlike.</p><pre class="programlisting">this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");</pre><p>Invoking a simple stored procedure (more sophisticated stored
          procedure support is <a href="#jdbc-StoredProcedure" title="11.6.4.&nbsp;StoredProcedure">covered
          later</a>).</p><pre class="programlisting">this.jdbcTemplate.update(
        "call SUPPORT.REFRESH_ACTORS_SUMMARY(?)", 
        new Object[]{Long.valueOf(unionId)});</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jdbc-JdbcTemplate-idioms"></a>11.2.1.2.&nbsp;<tt class="classname">JdbcTemplate</tt> idioms (best
        practices)</h4></div></div><div></div></div><p>Instances of the <tt class="classname">JdbcTemplate</tt> class are
        <span class="emphasis"><em>threadsafe once configured</em></span>. This is important
        because it means that you can configure a single instance of a
        <tt class="classname">JdbcTemplate</tt> and then safely inject this
        <span class="emphasis"><em>shared</em></span> reference into multiple DAOs (or
        repositories). To be clear, the <tt class="classname">JdbcTemplate</tt> is
        stateful, in that it maintains a reference to a
        <tt class="interfacename">DataSource</tt>, but this state is
        <span class="emphasis"><em>not</em></span> conversational state.</p><p>A common idiom when using the
        <tt class="classname">JdbcTemplate</tt> class (and the associated <a href="#jdbc-SimpleJdbcTemplate" title="11.2.3.&nbsp;SimpleJdbcTemplate"><tt class="classname">SimpleJdbcTemplate</tt></a>
        and <a href="#jdbc-NamedParameterJdbcTemplate" title="11.2.2.&nbsp;NamedParameterJdbcTemplate"><tt class="classname">NamedParameterJdbcTemplate</tt></a>
        classes) is to configure a <tt class="interfacename">DataSource</tt>
        in your Spring configuration file, and then dependency inject that
        shared <tt class="interfacename">DataSource</tt> bean into your DAO
        classes; the <tt class="classname">JdbcTemplate</tt> is created in the
        setter for the <tt class="interfacename">DataSource</tt>. This leads
        to DAOs that look in part like this:</p><pre class="programlisting">public class JdbcCorporateEventDao implements CorporateEventDao {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        <span class="bold"><b>this.jdbcTemplate = new JdbcTemplate(dataSource);</b></span>
    }

    <i class="lineannotation"><span class="lineannotation">// JDBC-backed implementations of the methods on the <tt class="interfacename">CorporateEventDao</tt> follow...</span></i>
}</pre><p>The attendant configuration might look like this.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans 
       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

    &lt;bean id="corporateEventDao" class="com.example.JdbcCorporateEventDao"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- the <tt class="interfacename">DataSource</tt> (parameterized for configuration via a <a href="#beans-factory-placeholderconfigurer" title="3.7.2.1.&nbsp;Example: the&#xA;        PropertyPlaceholderConfigurer"><tt class="classname">PropertyPlaceHolderConfigurer</tt></a>) --&gt;</span></i>
    &lt;bean id="dataSource" destroy-method="close" class="org.apache.commons.dbcp.BasicDataSource"&gt;
        &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
        &lt;property name="url" value="${jdbc.url}"/&gt;
        &lt;property name="username" value="${jdbc.username}"/&gt;
        &lt;property name="password" value="${jdbc.password}"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>If you are using Spring's <tt class="classname">JdbcDaoSupport</tt>
        class, and your various JDBC-backed DAO classes extend from it, then
        you inherit a <tt class="methodname">setDataSource(..)</tt> method for
        free from said superclass. It is totally up to you as to whether or
        not you inherit from said class, you certainly are not forced to. If
        you look at the source for the <tt class="classname">JdbcDaoSupport</tt>
        class you will see that there is not a whole lot to it... it is
        provided as a convenience only.</p><p>Regardless of which of the above template initialization styles
        you choose to use (or not), there is (almost) certainly no need to
        create a brand new instance of a <tt class="classname">JdbcTemplate</tt>
        class each and every time you wish to execute some SQL... remember,
        once configured, a <tt class="classname">JdbcTemplate</tt> instance is
        threadsafe. A reason for wanting multiple
        <tt class="classname">JdbcTemplate</tt> instances would be when you have
        an application that accesses multiple databases, which requires
        multiple <tt class="interfacename">DataSources</tt>, and subsequently
        multiple differently configured
        <tt class="classname">JdbcTemplates</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-NamedParameterJdbcTemplate"></a>11.2.2.&nbsp;<tt class="classname">NamedParameterJdbcTemplate</tt></h3></div></div><div></div></div><p>The <tt class="classname">NamedParameterJdbcTemplate</tt> class adds
      support for programming JDBC statements using named parameters (as
      opposed to programming JDBC statements using only classic placeholder
      (<tt class="literal">'?'</tt>) arguments. The
      <tt class="classname">NamedParameterJdbcTemplate</tt> class wraps a
      <tt class="classname">JdbcTemplate</tt>, and delegates to the wrapped
      <tt class="classname">JdbcTemplate</tt> to do much of its work. This section
      will describe only those areas of the
      <tt class="classname">NamedParameterJdbcTemplate</tt> class that differ from
      the <tt class="classname">JdbcTemplate</tt> itself; namely, programming JDBC
      statements using named parameters.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// some JDBC-backed DAO class...</span></i>
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {

    String sql = "select count(0) from T_ACTOR where first_name = :first_name";

    SqlParameterSource namedParameters = new MapSqlParameterSource("first_name", firstName);

    return namedParameterJdbcTemplate.queryForInt(sql, namedParameters);
}</pre><p>Notice the use of the named parameter notation in the value
      assigned to the <tt class="literal">'sql'</tt> variable, and the corresponding
      value that is plugged into the <tt class="literal">'namedParameters'</tt>
      variable (of type <tt class="classname">MapSqlParameterSource</tt>).</p><p>If you like, you can also pass along named parameters (and their
      corresponding values) to a
      <tt class="classname">NamedParameterJdbcTemplate</tt> instance using the
      (perhaps more familiar) <tt class="interfacename">Map</tt>-based style.
      (The rest of the methods exposed by the
      <tt class="interfacename">NamedParameterJdbcOperations</tt> - and
      implemented by the <tt class="classname">NamedParameterJdbcTemplate</tt>
      class) follow a similar pattern and will not be covered here.)</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// some JDBC-backed DAO class...</span></i>
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActorsByFirstName(String firstName) {

    String sql = "select count(0) from T_ACTOR where first_name = :first_name";

    Map namedParameters = Collections.singletonMap("first_name", firstName);

    return this.namedParameterJdbcTemplate.queryForInt(sql, namedParameters);
}</pre><p>Another nice feature related to the
      <tt class="classname">NamedParameterJdbcTemplate</tt> (and existing in the
      same Java package) is the
      <tt class="interfacename">SqlParameterSource</tt> interface. You have
      already seen an example of an implementation of this interface in one of
      the preceding code snippets (the
      <tt class="classname">MapSqlParameterSource</tt> class). The entire point of
      the <tt class="interfacename">SqlParameterSource</tt> is to serve as a
      source of named parameter values to a
      <tt class="classname">NamedParameterJdbcTemplate</tt>. The
      <tt class="classname">MapSqlParameterSource</tt> class is a very simple
      implementation, that is simply an adapter around a
      <tt class="interfacename">java.util.Map</tt>, where the keys are the
      parameter names and the values are the parameter values.</p><p>Another <tt class="interfacename">SqlParameterSource</tt>
      implementation is the
      <tt class="classname">BeanPropertySqlParameterSource</tt> class. This class
      wraps an arbitrary JavaBean (that is, an instance of a class that
      adheres to <a href="http://java.sun.com/products/javabeans/docs/spec.html" target="_top">the JavaBean
      conventions</a>), and uses the properties of the wrapped JavaBean as
      the source of named parameter values.</p><pre class="programlisting">public class Actor {

    private Long id;
    private String firstName;
    private String lastName;
    
    public String getFirstName() {
        return this.firstName;
    }
    
    public String getLastName() {
        return this.lastName;
    }
    
    public Long getId() {
        return this.id;
    }
    
    <i class="lineannotation"><span class="lineannotation">// setters omitted...</span></i>

}</pre><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// some JDBC-backed DAO class...</span></i>
private NamedParameterJdbcTemplate namedParameterJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
}

public int countOfActors(Actor exampleActor) {

    <i class="lineannotation"><span class="lineannotation">// notice how the named parameters match the properties of the above '<tt class="classname">Actor</tt>' class</span></i>
    String sql = "select count(0) from T_ACTOR where first_name = :firstName and last_name = :lastName";

    SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor);

    return this.namedParameterJdbcTemplate.queryForInt(sql, namedParameters);
}</pre><p>Remember that the
      <tt class="classname">NamedParameterJdbcTemplate</tt> class
      <span class="emphasis"><em>wraps</em></span> a classic <tt class="classname">JdbcTemplate</tt>
      template; if you need access to the wrapped
      <tt class="classname">JdbcTemplate</tt> instance (to access some of the
      functionality only present in the <tt class="classname">JdbcTemplate</tt>
      class), then you can use the
      <tt class="methodname">getJdbcOperations()</tt> method to access the
      wrapped <tt class="classname">JdbcTemplate</tt> <span class="emphasis"><em>via the
      <tt class="interfacename">JdbcOperations</tt>
      interface</em></span>.</p><p>See also the section entitled <a href="#jdbc-JdbcTemplate-idioms" title="11.2.1.2.&nbsp;JdbcTemplate idioms (best&#xA;        practices)">Section&nbsp;11.2.1.2, &#8220;JdbcTemplate idioms (best
        practices)&#8221;</a> for some advice on how to best use
      the <tt class="classname">NamedParameterJdbcTemplate</tt> class in the
      context of an application.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SimpleJdbcTemplate"></a>11.2.3.&nbsp;<tt class="classname">SimpleJdbcTemplate</tt></h3></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p><span class="emphasis"><em>The functionality offered by the
        <tt class="classname">SimpleJdbcTemplate</tt> is only available to you if
        you are using Java 5 or later.</em></span></p></td></tr></table></div><p>The <tt class="classname">SimpleJdbcTemplate</tt> class is a wrapper
      around the classic <tt class="classname">JdbcTemplate</tt> that takes
      advantage of Java 5 language features such as varargs and autoboxing.
      The <tt class="classname">SimpleJdbcTemplate</tt> class is somewhat of a sop
      to the syntactic-sugar-like features of Java 5, but as anyone who has
      developed on Java 5 and then had to move back to developing on a
      previous version of the JDK will know, those syntactic-sugar-like
      features sure are nice.</p><p>The value-add of the <tt class="classname">SimpleJdbcTemplate</tt>
      class in the area of syntactic-sugar is best illustrated with a
      <span class="emphasis"><em>'before and after'</em></span> example. The following code
      snippet shows first some data access code using the classic
      <tt class="classname">JdbcTemplate</tt>, followed immediately thereafter by
      a code snippet that does the same job, only this time using the
      <tt class="classname">SimpleJdbcTemplate</tt>.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// classic <tt class="classname">JdbcTemplate</tt>-style...</span></i>
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
}

public Actor findActor(long id) {
    String sql = "select id, first_name, last_name from T_ACTOR where id = ?";
    
    RowMapper mapper = new RowMapper() {
    
        public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
            Actor actor = new Actor();
            actor.setId(rs.getLong("id"));
            actor.setFirstName(rs.getString("first_name"));
            actor.setLastName(rs.getString("last_name"));
            return actor;
        }
    };
    
    <i class="lineannotation"><span class="lineannotation">// notice the cast, the wrapping up of the 'id' argument
    // in an array, and the boxing of the 'id' argument as a reference type</span></i>
    return (Actor) jdbcTemplate.queryForObject(sql, mapper, new Object[] {Long.valueOf(id)});
}</pre><p>Here is the same method, only this time using the
      <tt class="classname">SimpleJdbcTemplate</tt>; notice how much 'cleaner' the
      code is.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// <tt class="classname">SimpleJdbcTemplate</tt>-style...</span></i>
private SimpleJdbcTemplate simpleJdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
}

public Actor findActor(long id) {
    String sql = "select id, first_name, last_name from T_ACTOR where id = ?";

    ParameterizedRowMapper&lt;Actor&gt; mapper = new ParameterizedRowMapper&lt;Actor&gt;() {
    
        <i class="lineannotation"><span class="lineannotation">// notice the return type with respect to Java 5 covariant return types</span></i>
        public Actor mapRow(ResultSet rs, int rowNum) throws SQLException {
            Actor actor = new Actor();
            actor.setId(rs.getLong("id"));
            actor.setFirstName(rs.getString("first_name"));
            actor.setLastName(rs.getString("last_name"));
            return actor;
        }
    };

    return this.simpleJdbcTemplate.queryForObject(sql, mapper, id);
}</pre><p>See also the section entitled <a href="#jdbc-JdbcTemplate-idioms" title="11.2.1.2.&nbsp;JdbcTemplate idioms (best&#xA;        practices)">Section&nbsp;11.2.1.2, &#8220;JdbcTemplate idioms (best
        practices)&#8221;</a> for some advice on how to best use
      the <tt class="classname">SimpleJdbcTemplate</tt> class in the context of an
      application.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The <tt class="classname">SimpleJdbcTemplate</tt> class only offers
        a subset of the methods exposed on the
        <tt class="classname">JdbcTemplate</tt> class. If you need to use a method
        from the <tt class="classname">JdbcTemplate</tt> that is not defined on
        the <tt class="classname">SimpleJdbcTemplate</tt>, you can always access
        the underlying <tt class="classname">JdbcTemplate</tt> by calling the
        <tt class="methodname">getJdbcOperations()</tt> method on the
        <tt class="classname">SimpleJdbcTemplate</tt>, which will then allow you
        to invoke the method that you want. The only downside is that the
        methods on the <tt class="interfacename">JdbcOperations</tt> interface
        are not generified, so you are back to casting and such again.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-datasource"></a>11.2.4.&nbsp;<tt class="interfacename">DataSource</tt></h3></div></div><div></div></div><p>In order to work with data from a database, one needs to obtain a
      connection to the database. The way Spring does this is through a
      <tt class="interfacename">DataSource</tt>. A
      <tt class="interfacename">DataSource</tt> is part of the JDBC
      specification and can be seen as a generalized connection factory. It
      allows a container or a framework to hide connection pooling and
      transaction management issues from the application code. As a developer,
      you don not need to know any details about how to connect to the
      database, that is the responsibility for the administrator that sets up
      the datasource. You will most likely have to fulfill both roles while
      you are developing and testing you code though, but you will not
      necessarily have to know how the production data source is
      configured.</p><p>When using Spring's JDBC layer, you can either obtain a data
      source from JNDI or you can configure your own, using an implementation
      that is provided in the Spring distribution. The latter comes in handy
      for unit testing outside of a web container. We will use the
      <tt class="classname">DriverManagerDataSource</tt> implementation for this
      section but there are several additional implementations that will be
      covered later on. The <tt class="classname">DriverManagerDataSource</tt>
      works the same way that you probably are used to work when you obtain a
      JDBC connection. You have to specify the fully qualified class name of
      the JDBC driver that you are using so that the
      <tt class="classname">DriverManager</tt> can load the driver class. Then you
      have to provide a URL that varies between JDBC drivers. You have to
      consult the documentation for your driver for the correct value to use
      here. Finally you must provide a username and a password that will be
      used to connect to the database. Here is an example of how to configure
      a <tt class="classname">DriverManagerDataSource</tt>:</p><pre class="programlisting">DriverManagerDataSource dataSource = new DriverManagerDataSource();
dataSource.setDriverClassName("org.hsqldb.jdbcDriver");
dataSource.setUrl("jdbc:hsqldb:hsql://localhost:");
dataSource.setUsername("sa");
dataSource.setPassword("");</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SQLExceptionTranslator"></a>11.2.5.&nbsp;<tt class="interfacename">SQLExceptionTranslator</tt></h3></div></div><div></div></div><p><tt class="interfacename">SQLExceptionTranslator</tt> is an
      interface to be implemented by classes that can translate between
      <tt class="classname">SQLExceptions</tt> and Spring's own
      data-access-strategy-agnostic
      <tt class="classname">org.springframework.dao.DataAccessException</tt>.
      Implementations can be generic (for example, using SQLState codes for
      JDBC) or proprietary (for example, using Oracle error codes) for greater
      precision.</p><p><tt class="classname">SQLErrorCodeSQLExceptionTranslator</tt> is the
      implementation of <tt class="interfacename">SQLExceptionTranslator</tt>
      that is used by default. This implementation uses specific vendor codes.
      More precise than <tt class="literal">SQLState</tt> implementation, but vendor
      specific. The error code translations are based on codes held in a
      JavaBean type class named <tt class="classname">SQLErrorCodes</tt>. This
      class is created and populated by an
      <tt class="classname">SQLErrorCodesFactory</tt> which as the name suggests
      is a factory for creating <tt class="classname">SQLErrorCodes</tt> based on
      the contents of a configuration file named <tt class="filename">'sql-error-codes.xml'</tt>. This file is
      populated with vendor codes and based on the DatabaseProductName taken
      from the <tt class="interfacename">DatabaseMetaData</tt>, the codes for
      the current database are used.</p><p>The <tt class="classname">SQLErrorCodeSQLExceptionTranslator</tt>
      applies the following matching rules: </p><div class="itemizedlist"><ul type="disc" compact><li><p>Try custom translation implemented by any subclass. Note
            that this class is concrete and is typically used itself, in which
            case this rule does not apply.</p></li><li><p>Apply error code matching. Error codes are obtained from the
            <tt class="classname">SQLErrorCodesFactory</tt> by default. This looks
            up error codes from the classpath and keys into them from the
            database name from the database metadata.</p></li><li><p>Use the fallback translator.
            <tt class="classname">SQLStateSQLExceptionTranslator</tt> is the
            default fallback translator.</p></li></ul></div><p><tt class="classname">SQLErrorCodeSQLExceptionTranslator</tt> can be
      extended the following way:</p><pre class="programlisting">public class MySQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator {

    protected DataAccessException customTranslate(String task, String sql, SQLException sqlex) {
        if (sqlex.getErrorCode() == -12345) {
            return new DeadlockLoserDataAccessException(task, sqlex);
        }
        return null;
    }
}</pre><p>In this example the specific error code
      <tt class="literal">'-12345'</tt> is translated and any other errors are
      simply left to be translated by the default translator implementation.
      To use this custom translator, it is necessary to pass it to the
      <tt class="classname">JdbcTemplate</tt> using the method
      <tt class="literal">setExceptionTranslator</tt> and to use this
      <tt class="classname">JdbcTemplate</tt> for all of the data access
      processing where this translator is needed. Here is an example of how
      this custom translator can be used:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// create a <tt class="classname">JdbcTemplate</tt> and set data source</span></i> 
JdbcTemplate jt = new JdbcTemplate(); 
jt.setDataSource(dataSource); 
<i class="lineannotation"><span class="lineannotation">// create a custom translator and set the <tt class="interfacename">DataSource</tt> for the default translation lookup</span></i> 
MySQLErrorCodesTransalator tr = new MySQLErrorCodesTransalator(); 
tr.setDataSource(dataSource); 
jt.setExceptionTranslator(tr); 
<i class="lineannotation"><span class="lineannotation">// use the <tt class="classname">JdbcTemplate</tt> for this <tt class="classname">SqlUpdate</tt></span></i>
SqlUpdate su = new SqlUpdate(); 
su.setJdbcTemplate(jt); 
su.setSql("update orders set shipping_charge = shipping_charge * 1.05"); 
su.compile(); 
su.update();</pre><p>The custom translator is passed a data source because we still
      want the default translation to look up the error codes in
      <tt class="literal">sql-error-codes.xml</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-statements-executing"></a>11.2.6.&nbsp;Executing statements</h3></div></div><div></div></div><p>To execute an SQL statement, there is very little code needed. All
      you need is a <tt class="interfacename">DataSource</tt> and a
      <tt class="classname">JdbcTemplate</tt>. Once you have that, you can use a
      number of convenience methods that are provided with the
      <tt class="classname">JdbcTemplate</tt>. Here is a short example showing
      what you need to include for a minimal but fully functional class that
      creates a new table.</p><pre class="programlisting">import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAStatement {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void doExecute() {
        this.jdbcTemplate.execute("create table mytable (id integer, name varchar(100))");
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-statements-querying"></a>11.2.7.&nbsp;Running Queries</h3></div></div><div></div></div><p>In addition to the execute methods, there is a large number of
      query methods. Some of these methods are intended to be used for queries
      that return a single value. Maybe you want to retrieve a count or a
      specific value from one row. If that is the case then you can use
      <tt class="methodname">queryForInt(..)</tt>,
      <tt class="methodname">queryForLong(..)</tt> or
      <tt class="methodname">queryForObject(..)</tt>. The latter will convert the
      returned JDBC <tt class="classname">Type</tt> to the Java class that is
      passed in as an argument. If the type conversion is invalid, then an
      <tt class="exceptionname">InvalidDataAccessApiUsageException</tt> will
      be thrown. Here is an example that contains two query methods, one for
      an <tt class="classname">int</tt> and one that queries for a
      <tt class="classname">String</tt>.</p><pre class="programlisting">import javax.sql.DataSource;
import org.springframework.jdbc.core.JdbcTemplate;

public class RunAQuery {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }
  
    public int getCount() {
        return this.jdbcTemplate.queryForInt("select count(*) from mytable");
    }

    public String getName() {
        return (String) this.jdbcTemplate.queryForObject("select name from mytable", String.class);
    }

    public void setDataSource(DataSource dataSource) {
        this.dataSource = dataSource;
    }
}</pre><p>In addition to the single results query methods there are several
      methods that return a List with an entry for each row that the query
      returned. The most generic method is
      <tt class="methodname">queryForList(..)</tt> which returns a
      <tt class="interfacename">List</tt> where each entry is a
      <tt class="interfacename">Map</tt> with each entry in the map
      representing the column value for that row. If we add a method to the
      above example to retrieve a list of all the rows, it would look like
      this:</p><pre class="programlisting">
private JdbcTemplate jdbcTemplate;

public void setDataSource(DataSource dataSource) {
    this.jdbcTemplate = new JdbcTemplate(dataSource);
}

public List getList() {
    return this.jdbcTemplate.queryForList("select * from mytable");
}</pre><p>The list returned would look something like this:</p><pre class="programlisting">[{name=Bob, id=1}, {name=Mary, id=2}]</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-updates"></a>11.2.8.&nbsp;Updating the database</h3></div></div><div></div></div><p>There are also a number of update methods that you can use. Find
      below an example where a column is updated for a certain primary key. In
      this example an SQL statement is used that has place holders for row
      parameters. Note that the parameter values are passed in as an array of
      objects (and thus primitives have to be wrapped in the primitive wrapper
      classes).</p><pre class="programlisting">import javax.sql.DataSource;

import org.springframework.jdbc.core.JdbcTemplate;

public class ExecuteAnUpdate {

    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public void setName(int id, String name) {
        this.jdbcTemplate.update(
                "update mytable set name = ? where id = ?", 
                new Object[] {name, new Integer(id)});
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-auto-genereted-keys"></a>11.2.9.&nbsp;Retrieving auto-generated keys</h3></div></div><div></div></div><p>One of the <tt class="methodname">update</tt> convenience methods
      provides support for acquiring the primary keys generated by the
      database (part of the JDBC 3.0 standard - see chapter 13.6 of the
      specification for details). The method takes a
      <tt class="classname">PreparedStatementCreator</tt> as its first argument,
      and this is the way the required insert statement is specified. The
      other argument is a <tt class="classname">KeyHolder</tt>, which will contain
      the generated key on successful return from the update. There is not a
      standard single way to create an appropriate
      <tt class="classname">PreparedStatement</tt> (which explains why the method
      signature is the way it is). An example that works on Oracle and may not
      work on other platforms is:</p><pre class="programlisting">final String INSERT_SQL = "insert into my_test (name) values(?)";
final String name = "Rob";

KeyHolder keyHolder = new GeneratedKeyHolder();
jdbcTemplate.update(
    new PreparedStatementCreator() {
        public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {
            PreparedStatement ps =
                connection.prepareStatement(INSERT_SQL, new String[] {"id"});
            ps.setString(1, name);
            return ps;
        }
    },
    keyHolder);

<i class="lineannotation"><span class="lineannotation">// keyHolder.getKey() now contains the generated key</span></i></pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-connections"></a>11.3.&nbsp;Controlling database connections</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-DataSourceUtils"></a>11.3.1.&nbsp;<tt class="classname">DataSourceUtils</tt></h3></div></div><div></div></div><p>The <tt class="classname">DataSourceUtils</tt> class is a convenient
      and powerful helper class that provides <tt class="literal">static</tt>
      methods to obtain connections from JNDI and close connections if
      necessary. It has support for thread-bound connections, for example for
      use with <tt class="classname">DataSourceTransactionManager</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SmartDataSource"></a>11.3.2.&nbsp;<tt class="interfacename">SmartDataSource</tt></h3></div></div><div></div></div><p>The <tt class="interfacename">SmartDataSource</tt> interface is to
      be implemented by classes that can provide a connection to a relational
      database. Extends the <tt class="interfacename">DataSource</tt>
      interface to allow classes using it to query whether or not the
      connection should be closed after a given operation. This can sometimes
      be useful for efficiency, in the cases where one knows that one wants to
      reuse a connection.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-AbstractDataSource"></a>11.3.3.&nbsp;<tt class="classname">AbstractDataSource</tt></h3></div></div><div></div></div><p>This is an <tt class="literal">abstract</tt> base class for Spring's
      <tt class="interfacename">DataSource</tt> implementations, that takes
      care of the "uninteresting" glue. This is the class one would extend if
      one was writing one's own <tt class="interfacename">DataSource</tt>
      implementation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SingleConnectionDataSource"></a>11.3.4.&nbsp;<tt class="classname">SingleConnectionDataSource</tt></h3></div></div><div></div></div><p>The <tt class="classname">SingleConnectionDataSource</tt> class is an
      implementation of the <tt class="interfacename">SmartDataSource</tt>
      interface that wraps a <span class="emphasis"><em>single</em></span>
      <tt class="interfacename">Connection</tt> that is
      <span class="emphasis"><em>not</em></span> closed after use. Obviously, this is not
      multi-threading capable.</p><p>If client code will call close in the assumption of a pooled
      connection, like when using persistence tools, set
      <tt class="literal">suppressClose</tt> to <tt class="literal">true</tt>. This will
      return a close-suppressing proxy instead of the physical connection. Be
      aware that you will not be able to cast this to a native Oracle
      <tt class="interfacename">Connection</tt> or the like anymore.</p><p>This is primarily a test class. For example, it enables easy
      testing of code outside an application server, in conjunction with a
      simple JNDI environment. In contrast to
      <tt class="classname">DriverManagerDataSource</tt>, it reuses the same
      connection all the time, avoiding excessive creation of physical
      connections.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-DriverManagerDataSource"></a>11.3.5.&nbsp;<tt class="classname">DriverManagerDataSource</tt></h3></div></div><div></div></div><p>The <tt class="classname">DriverManagerDataSource</tt> class is an
      implementation of the standard <tt class="interfacename">DataSource</tt>
      interface that configures a plain old JDBC Driver via bean properties, and
      returns a new <tt class="interfacename">Connection</tt> every time.</p><p>This is potentially useful for test or standalone environments
      outside of a J2EE container, either as a
      <tt class="interfacename">DataSource</tt> bean in a Spring IoC
      container, or in conjunction with a simple JNDI environment.
      Pool-assuming <tt class="literal">Connection.close()</tt> calls will simply
      close the connection, so any
      <tt class="interfacename">DataSource</tt>-aware persistence code should
      work. However, using JavaBean style connection pools such as
      commons-dbcp is so easy, even in a test environment, that it is almost
      always preferable to use such a connection pool over
      <tt class="classname">DriverManagerDataSource</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-TransactionAwareDataSourceProxy"></a>11.3.6.&nbsp;<tt class="classname">TransactionAwareDataSourceProxy</tt></h3></div></div><div></div></div><p><tt class="classname">TransactionAwareDataSourceProxy</tt> is a proxy
      for a target <tt class="interfacename">DataSource</tt>, which wraps that
      target <tt class="interfacename">DataSource</tt> to add awareness of
      Spring-managed transactions. In this respect it is similar to a
      transactional JNDI <tt class="interfacename">DataSource</tt> as provided
      by a J2EE server.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>It should almost never be necessary or desirable to use this
        class, except when existing code exists which must be called and
        passed a standard JDBC <tt class="interfacename">DataSource</tt>
        interface implementation. In this case, it's possible to still have
        this code be usable, but participating in Spring managed transactions.
        It is generally preferable to write your own new code using the higher
        level abstractions for resource management, such as
        <tt class="classname">JdbcTemplate</tt> or
        <tt class="classname">DataSourceUtils</tt>.</p></td></tr></table></div><p><span class="emphasis"><em>(See the
      <tt class="classname">TransactionAwareDataSourceProxy</tt> Javadocs for more
      details.)</em></span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-DataSourceTransactionManager"></a>11.3.7.&nbsp;<tt class="classname">DataSourceTransactionManager</tt></h3></div></div><div></div></div><p>The <tt class="classname">DataSourceTransactionManager</tt> class is a
      <tt class="interfacename">PlatformTransactionManager</tt> implementation
      for single JDBC datasources. It binds a JDBC connection from the
      specified data source to the currently executing thread, potentially
      allowing for one thread connection per data source.</p><p>Application code is required to retrieve the JDBC connection via
      <tt class="literal">DataSourceUtils.getConnection(DataSource)</tt> instead of
      J2EE's standard <tt class="literal">DataSource.getConnection</tt>. This is
      recommended anyway, as it throws unchecked
      <tt class="literal">org.springframework.dao</tt> exceptions instead of checked
      <tt class="exceptionname">SQLExceptions</tt>. All framework classes like
      <tt class="classname">JdbcTemplate</tt> use this strategy implicitly. If not
      used with this transaction manager, the lookup strategy behaves exactly
      like the common one - it can thus be used in any case.</p><p>The <tt class="classname">DataSourceTransactionManager</tt> class
      supports custom isolation levels, and timeouts that get applied as
      appropriate JDBC statement query timeouts. To support the latter,
      application code must either use <tt class="classname">JdbcTemplate</tt> or
      call <tt class="literal">DataSourceUtils.applyTransactionTimeout(..)</tt>
      method for each created statement.</p><p>This implementation can be used instead of
      <tt class="classname">JtaTransactionManager</tt> in the single resource
      case, as it does not require the container to support JTA. Switching
      between both is just a matter of configuration, if you stick to the
      required connection lookup pattern. Note that JTA does not support
      custom isolation levels!</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-NativeJdbcExtractor"></a>11.3.8.&nbsp;NativeJdbcExtractor</h3></div></div><div></div></div><p>There are times when we need to access vendor specific JDBC
      methods that differ from the standard JDBC API. This can be problematic
      if we are running in an application server or with a
      <tt class="classname">DataSource</tt> that wraps the
      <tt class="classname">Connection</tt>, <tt class="classname">Statement</tt> and
      <tt class="classname">ResultSet</tt> objects with its own wrapper objects.
      To gain access to the native objects you can configure your
      <tt class="classname">JdbcTemplate</tt> or
      <tt class="classname">OracleLobHandler</tt> with a
      <tt class="classname">NativeJdbcExtractor</tt>.</p><p>The NativeJdbcExtractor comes in a variety of flavors to match
      your execution environment:</p><div class="itemizedlist"><ul type="disc"><li><p>SimpleNativeJdbcExtractor</p></li><li><p>C3P0NativeJdbcExtractor</p></li><li><p>CommonsDbcpNativeJdbcExtractor</p></li><li><p>JBossNativeJdbcExtractor</p></li><li><p>WebLogicNativeJdbcExtractor</p></li><li><p>WebSphereNativeJdbcExtractor</p></li><li><p>XAPoolNativeJdbcExtractor</p></li></ul></div><p>Usually the <tt class="classname">SimpleNativeJdbcExtractor</tt> is
      sufficient for unwrapping a <tt class="classname">Connection</tt> object in
      most environments. See the Java Docs for more details.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-advanced-jdbc"></a>11.4.&nbsp;JDBC batch operations</h2></div></div><div></div></div><p>Most JDBC drivers provide improved performance if you batch multiple
    calls to the same prepared statement. By grouping updates into batches you
    limit the number of round trips to the database. This section will cover
    batch processing using both the JdbcTemplate and the
    SimpleJdbcTemplate.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-advanced-classic"></a>11.4.1.&nbsp;Batch operations with the JdbcTemplate</h3></div></div><div></div></div><p>Using the JdbcTemplate batch processing is accomplished by
      implementing a special interface,
      <tt class="classname">BatchPreparedStatementSetter</tt>, and passing that in
      as the second parameter in your <tt class="classname">batchUpdate</tt>
      method call. This interface has two methods you must implement. One is
      named <tt class="classname">getBatchSize</tt> and here you provide the size
      of the current batch. The other method is
      <tt class="classname">setValues</tt> and it allows you to set the values for
      the parameters of the prepared statement and. This method will get
      called the number of times that you specified in the
      <tt class="classname">getBatchSize</tt> call. Here is an example of this
      where we update the actor table based on entries in a list. The entire
      list is used as the batch in his example.</p><pre class="programlisting">public class JdbcActorDao implements ActorDao {
    private JdbcTemplate jdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }

    public int[] batchUpdate(final List actors) {
        int[] updateCounts = jdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                new BatchPreparedStatementSetter() {
                    public void setValues(PreparedStatement ps, int i) throws SQLException {
                        ps.setString(1, ((Actor)actors.get(i)).getFirstName());
                        ps.setString(2, ((Actor)actors.get(i)).getLastName());
                        ps.setLong(3, ((Actor)actors.get(i)).getId().longValue());
                    }

                    public int getBatchSize() {
                        return actors.size();
                    }
                } );
        return updateCounts;
    }

    //  ... additional methods
}</pre><p>If you are processing stream of updates or reading from a
      file then you might have a preferred batch size, but the last batch
      might not have that number of entries. In this case you can use the
      <tt class="classname">InterruptibleBatchPreparedStatementSetter</tt>
      interface which allows you to interrupt a batch once the input source is
      exhausted. The <tt class="classname">isBatchExhausted</tt> method allows you
      to signal the end of the batch.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-advanced-simple"></a>11.4.2.&nbsp;Batch operations with the SimpleJdbcTemplate</h3></div></div><div></div></div><p>The <tt class="classname">SimpleJdbcTemplate</tt> provides an
      alternate way of providing the batch update. Instead of implementing a
      special batch interface, you simply provide all parameter values in the
      call and the framework will loop over these values and use an internal
      prepared statement setter. The API varies depending on whether you use
      named parameters or not. For the named parameters you provide an array
      of <tt class="classname">SqlParameterSource</tt>, one entry for each member
      of the batch. You can use the
      <tt class="classname">SqlParameterSource.createBatch</tt> method to create
      this array, passing in either an array of JavaBeans or an array of Maps
      containing the parameter values.</p><p>This example shows a batch update using named parameters:</p><pre class="programlisting">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
    }

    public int[] batchUpdate(final List&lt;Actor&gt; actors) {
        SqlParameterSource[] batch = SqlParameterSourceUtils.createBatch(actors.toArray());
        int[] updateCounts = simpleJdbcTemplate.batchUpdate(
                "update t_actor set first_name = :firstName, last_name = :lastName where id = :id",
                batch);
        return updateCounts;
    }

    //  ... additional methods
}</pre><p>For an SQL statement using the classic "?" place holders you
      pass in a List containing an object array with the update values. This
      object array must have one entry for each placeholder in the SQL
      statement and they must be in the same order as they are defined in the
      SQL statement.</p><p>The same example using classic JDBC "?" place holders:</p><pre class="programlisting">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
    }

    public int[] batchUpdate(final List&lt;Actor&gt; actors) {
        List&lt;Object[]&gt; batch = new ArrayList&lt;Object[]&gt;();
        for (Actor actor : actors) {
            Object[] values = new Object[] {
                    actor.getFirstName(),
                    actor.getLastName(),
                    actor.getId()};
            batch.add(values);
        }
        int[] updateCounts = simpleJdbcTemplate.batchUpdate(
                "update t_actor set first_name = ?, last_name = ? where id = ?",
                batch);
        return updateCounts;
    }

    //  ... additional methods
}</pre><p>All batch update methods return an int array containing the
      number of affected rows for each batch entry. This count is reported by
      the JDBC driver and it's not always available in which case the JDBC
      driver simply returns a -2 value.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-simple-jdbc"></a>11.5.&nbsp;Simplifying JDBC operations with the SimpleJdbc classes</h2></div></div><div></div></div><p>The <tt class="classname">SimpleJdbcInsert</tt> and
    <tt class="classname">SimpleJdbcCall</tt> classes provide simplified
    configuration by taking advantage of database metadata that can be
    retrieved via the JDBC driver. This means there is less to configure up
    front, although you can override or turn off the metadata processing if
    you prefer to provide all the details in your code.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-simple-jdbc-insert-1"></a>11.5.1.&nbsp;Inserting data using SimpleJdbcInsert</h3></div></div><div></div></div><p>Let's start by looking at the
      <tt class="classname">SimpleJdbcInsert</tt> class first. We will use the
      minimal amount of configuration options to start with. The
      <tt class="classname">SimpleJdbcInsert</tt> should be instantiated in the
      data access layer's initialization method. For this example, the
      initializing method is the <tt class="classname">setDataSource</tt> method.
      There is no need to subclass the <tt class="classname">SimpleJdbcInsert</tt>
      class, just create a new instance and set the table name using the
      <tt class="classname">withTableName</tt> method. Configuration methods for
      this class follows the "fluid" style returning the instance of the
      <tt class="classname">SimpleJdbcInsert</tt> which allows you to chain all
      configuration methods. In this case there is only one configuration
      method used but we will see examples of multiple ones soon.</p><pre class="programlisting">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        this.insertActor = 
                new SimpleJdbcInsert(dataSource).withTableName("t_actor");
    }

    public void add(Actor actor) {
        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(3);
        parameters.put("id", actor.getId());
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        insertActor.execute(parameters);
    }

    //  ... additional methods
}</pre><p>The execute method used here takes a plain
      <tt class="classname">java.utils.Map</tt> as its only parameter. The
      important thing to note here is that the keys used for the Map must
      match the column names of the table as defined in the database. This is
      because we read the metadata in order to construct the actual insert
      statement.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-simple-jdbc-insert-2"></a>11.5.2.&nbsp;Retrieving auto-generated keys using SimpleJdbcInsert</h3></div></div><div></div></div><p>Next we'll look at the same insert, but instead of passing in the
      id we will retrieve the auto-generated key and set it on the new Actor
      object. When we create the <tt class="classname">SimpleJdbcInsert</tt>, in
      addition to specifying the table name, we specify the name of the
      generated key column using the
      <tt class="classname">usingGeneratedKeyColumns</tt> method.</p><pre class="programlisting">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        this.insertActor =
                new SimpleJdbcInsert(dataSource)
                        .withTableName("t_actor")
                        .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(2);
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    //  ... additional methods
}</pre><p>Here we can see the main difference when executing the
      insert is that we don't add the id to the Map and we call the
      <tt class="literal">executeReturningKey</tt> method. This returns a
      <tt class="literal">java.lang.Number</tt> object that we can use to create an
      instance of the numerical type that is used in our domain class. It's
      important to note that we can't rely on all databases to return a
      specific Java class here, <tt class="literal">java.lang.Number</tt> is the
      base class that we can rely on. If you have multiple auto-generated
      columns or the generated values are non-numeric then you can use a
      <tt class="literal">KeyHolder</tt> that is returned from the
      <tt class="literal">executeReturningKeyHolder</tt> method.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-simple-jdbc-insert-3"></a>11.5.3.&nbsp;Specifying the columns to use for a SimpleJdbcInsert</h3></div></div><div></div></div><p>It's possible to limit the columns used for the insert by
      specifying a list of column names to be used. This is accomplished using
      the <tt class="classname">usingColumns</tt> method.</p><pre class="programlisting">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        this.insertActor =
                new SimpleJdbcInsert(dataSource)
                        .withTableName("t_actor")
                        .usingColumns("first_name", "last_name")
                        .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        Map&lt;String, Object&gt; parameters = new HashMap&lt;String, Object&gt;(2);
        parameters.put("first_name", actor.getFirstName());
        parameters.put("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    //  ... additional methods
}</pre><p>The execution of the insert is the same as if we had relied
      on the metadata for determining what columns to use.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-simple-jdbc-parameters"></a>11.5.4.&nbsp;Using SqlParameterSource to provide parameter values</h3></div></div><div></div></div><p>Using a Map to provide parameter values works fine, but it's not
      the most convenient class to use. Spring provides a couple of
      implementations of the <tt class="classname">SqlParameterSource</tt>
      interface that can be used instead. The first one we'll look at is
      <tt class="classname">BeanPropertySqlParameterSource</tt> which is a very
      convenient class as long as you have a JavaBean compliant class that
      contains your values. It will use the corresponding getter method to
      extract the parameter values. Here is an example:</p><pre class="programlisting">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        this.insertActor =
                new SimpleJdbcInsert(dataSource)
                        .withTableName("t_actor")
                        .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        SqlParameterSource parameters = new BeanPropertySqlParameterSource(actor);
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    //  ... additional methods
}</pre><p>Another option is the
      <tt class="classname">MapSqlParameterSource</tt> that resembles a Map but
      provides a more convenient <tt class="classname">addValue</tt> method that
      can be chained.</p><pre class="programlisting">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcInsert insertActor;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        this.insertActor =
                new SimpleJdbcInsert(dataSource)
                        .withTableName("t_actor")
                        .usingGeneratedKeyColumns("id");
    }

    public void add(Actor actor) {
        SqlParameterSource parameters = new MapSqlParameterSource()
                .addValue("first_name", actor.getFirstName())
                .addValue("last_name", actor.getLastName());
        Number newId = insertActor.executeAndReturnKey(parameters);
        actor.setId(newId.longValue());
    }

    //  ... additional methods
}</pre><p>As you can see, the configuration is the same, it;s just the
      executing code that has to change to use these alternative input
      classes.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-simple-jdbc-call-1"></a>11.5.5.&nbsp;Calling a stored procedure using SimpleJdbcCall</h3></div></div><div></div></div><p>Let's now turn our attention to calling stored procedures using
      the <tt class="classname">SimpleJdbcCall</tt> class. This class is designed
      to make it as simple as possible to call a stored procedure. It takes
      advantage of metadata present in the database to look up names of in and
      out parameters. This means that you don't have to explicitly declare
      parameters. You can of course still declare them if you prefer to do
      that or if you have parameters that don't have an automatic mapping to a
      Java class like ARRAY or STRUCT parameters. In our first example we will
      look at a plain vanilla procedure that only returns scalar values in
      form of VARCHAR and DATE. I have added a birthDate property to the Actor
      class to get some variety in terms of return values. The example
      procedure reads a specified actor entry and returns first_name,
      last_name, and birth_date columns in the form of out parameters. Here is
      the source for the procedure as it would look when using MySQL as the
      database:</p><pre class="programlisting">CREATE PROCEDURE read_actor ( 
  IN in_id INTEGER, 
  OUT out_first_name VARCHAR(100), 
  OUT out_last_name VARCHAR(100), 
  OUT out_birth_date DATE) 
BEGIN 
  SELECT first_name, last_name, birth_date 
  INTO out_first_name, out_last_name, out_birth_date 
  FROM t_actor where id = in_id;
END;</pre><p>As you can see there are four parameters. One is an in
      parameter "in_id" containing the id of the Actor we are looking up. The
      remaining parameters are out parameters and they will be used to return
      the data read from the table.</p><p>The <tt class="classname">SimpleJdbcCall</tt> is declared in a similar
      manner to the <tt class="classname">SimpleJdbcInsert</tt>, no need to
      subclass and we declare it in the initialization method. For this
      example, all we need to specify is the name of the procedure.</p><pre class="programlisting">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        this.procReadActor =
                new SimpleJdbcCall(dataSource)
                        .withProcedureName("read_actor");
    }

    public Actor readActor(Long id) {
        SqlParameterSource in = new MapSqlParameterSource()
                .addValue("in_id", id); 
        Map out = procReadActor.execute(in);
        Actor actor = new Actor();
        actor.setId(id);
        actor.setFirstName((String) out.get("out_first_name"));
        actor.setLastName((String) out.get("out_last_name"));
        actor.setBirthDate((Date) out.get("out_birth_date"));
        return actor;
    }

    //  ... additional methods
}</pre><p>The execution of the call involves creating an
      <tt class="classname">SqlParameterSource</tt> containing the in parameter.
      It's important to match the name of the parameter declared in the stored
      procedure. The case doesn't have to match since we use metadata to
      determine how database objects should be referred to - what you specify
      in your source for the stored procedure is not necessarily the way it is
      stored in the database, some databases transform names to all upper case
      while others use lower case or the case as specified.</p><p>The <tt class="classname">execute</tt> method takes the in parameters
      and returns a Map containing any out parameters keyed by the name as
      specified in the stored procedure. In this case they are
      <tt class="classname">out_first_name, out_last_name</tt> and
      <tt class="classname">out_birth_date</tt>.</p><p>The last part of the <tt class="classname">execute</tt> method just
      creates an Actor instance to use to return the data retrieved. Again,
      it's important to match the names of the out parameters here. Also, the
      case used for the names of the out parameters stored in the results map
      are as they were defined in the database. You will either have to do a
      case-insensitive lookup or instruct Spring to use a
      <tt class="classname">CaseInsensitiveMap</tt> from the Jakarta Commons
      project. The way you do that is by creating your own
      <tt class="classname">JdbcTemplate</tt> and setting the
      <tt class="classname">setResultsMapCaseInsensitive</tt> property to
      <tt class="classname">true</tt>. Then you pass this customized
      <tt class="classname">JdbcTemplate</tt> instance into the constructor of
      your <tt class="classname">SimpleJdbcCall</tt>. You also have to include the
      <tt class="classname">commons-collections.jar</tt> on your classpath for
      this to work. Here is an example of this configuration:</p><pre class="programlisting">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadActor =
                new SimpleJdbcCall(jdbcTemplate)
                        .withProcedureName("read_actor");
    }


    //  ... additional methods
}</pre><p>By doing this, you don't have to worry about the case used
      for the names of your returned out parameters.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-simple-jdbc-call-2"></a>11.5.6.&nbsp;Declaring parameters to use for a SimpleJdbcCall</h3></div></div><div></div></div><p>We have seen how the parameters are deduced based on metadata, but
      you can declare then explicitly if you wish. This is done when the
      <tt class="classname">SimpleJdbcCall</tt> is created and configured using
      the <tt class="classname">declareParameters</tt> method that takes a
      variable number of <tt class="classname">SqlParameter</tt> objects as input.
      See the next section for details on how to define an
      <tt class="classname">SqlParameter</tt>.</p><p>We can opt to declare one, some or all of the parameters
      explicitly. The parameter metadata is still being used. By calling the
      method <tt class="classname">withoutProcedureColumnMetaDataAccess</tt> we
      can specify that we would like to bypass any processing of the metadata
      lookups for potential parameters and only use the declared ones. Another
      situation that can arise is that one or more in parameters have default
      values and we would like to leave them out of the call. To do that we
      will just call the <tt class="classname">useInParameterNames</tt> to specify
      the list of in parameter names to include.</p><p>This is what a fully declared procedure call declaration of our
      earlier example would look like:</p><pre class="programlisting">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcCall procReadActor;

    public void setDataSource(DataSource dataSource) {
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadActor =
                new SimpleJdbcCall(jdbcTemplate)
                        .withProcedureName("read_actor")
                        .withoutProcedureColumnMetaDataAccess()
                        .useInParameterNames("in_id")
                        .declareParameters(
                                new SqlParameter("in_id", Types.NUMERIC),
                                new SqlOutParameter("out_first_name", Types.VARCHAR),
                                new SqlOutParameter("out_last_name", Types.VARCHAR),
                                new SqlOutParameter("out_birth_date", Types.DATE)
                        );
    }


    //  ... additional methods
}</pre><p>The execution and end results are the same, we are just
      specifying all the details explicitly rather than relying on metadata.
      This will be necessary if the database we use is not part of the
      supported databases. Currently we support metadata lookup of stored
      procedure calls for the following databases: Apache Derby, DB2, MySQL,
      Microsoft SQL Server, Oracle and Sybase. We also support metadata lookup
      of stored functions for: MySQL, Microsoft SQL Server and Oracle.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-params"></a>11.5.7.&nbsp;How to define SqlParameters</h3></div></div><div></div></div><p>To define a parameter to be used for the SimpleJdbc classes, and
      also for the RDBMS operations classes covered in the following section,
      you use an <tt class="classname">SqlParameter</tt> or one of its subclasses.
      You typically specify the parameter name and SQL type in the
      constructor. The SQL type is specified using the
      <tt class="classname">java.sql.Types</tt> constants. We have already seen
      declarations like:</p><pre class="programlisting">   new SqlParameter("in_id", Types.NUMERIC),
   new SqlOutParameter("out_first_name", Types.VARCHAR),</pre><p>The first line with the <tt class="classname">SqlParameter</tt>
      declares an in parameter. In parameters can be used for both stored
      procedure calls and for queries using the
      <tt class="classname">SqlQuery</tt> and its subclasses covered in the
      following section.</p><p>The second line with the <tt class="classname">SqlOutParameter</tt>
      declares an out parameter to be used in a stored procedure call. There
      is also an <tt class="classname">SqlInOutParameter</tt> for inout
      parameters, parameters that provide an in value to the procedure and
      that also return a value</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Only parameters declared as <tt class="classname">SqlParameter</tt>
        and <tt class="classname">SqlInOutParameter</tt> will be used to provide
        input values. This is different from the
        <tt class="classname">StoredProcedure</tt> class which for backwards
        compatibility reasons allows input values to be provided for
        parameters declared as <tt class="classname">SqlOutParameter</tt>. </p></td></tr></table></div><p>In addition to the name and the SQL type you can specify
      additional options. For in parameters you can specify a scale for
      numeric data or a type name for custom database types. For out
      parameters you can provide a <tt class="classname">RowMapper</tt> to handle
      mapping of rows returned from a REF cursor. Another option is to specify
      an <tt class="classname">SqlReturnType</tt> that provides and opportunity to
      define customized handling of the return values.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-simple-jdbc-call-3"></a>11.5.8.&nbsp;Calling a stored function using SimpleJdbcCall</h3></div></div><div></div></div><p>Calling a stored function is done almost exactly the same way as
      calling a stored procedure. The only difference is that you need to
      provide a function name rather than a procedure name. This is done by
      using the <tt class="classname">withFunctionName</tt> method. Using this
      method indicates that your call is to a function and the corresponding
      call string for a function call will be generated. There is also a
      specialized execute call <tt class="classname">executeFunction</tt> that
      will return the function return value as an object of a specified type.
      This way you don't have to retrieve the return value from the results
      map. A similar convenience method named
      <tt class="classname">executeObject</tt> is also available for stored
      procedures that only have one out parameter. The following example is
      based on a stored function named <tt class="classname">get_actor_name</tt>
      that returns an actor's full name. Here is the MySQL source for this
      function:</p><pre class="programlisting">CREATE FUNCTION get_actor_name (in_id INTEGER)
RETURNS VARCHAR(200) READS SQL DATA 
BEGIN
  DECLARE out_name VARCHAR(200);
  SELECT concat(first_name, ' ', last_name)
    INTO out_name
    FROM t_actor where id = in_id;
  RETURN out_name;
END;</pre><p>To call this function we again create a
      <tt class="classname">SimpleJdbcCall</tt> in the initialization
      method.</p><pre class="programlisting">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcCall funcGetActorName;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.funcGetActorName =
                new SimpleJdbcCall(jdbcTemplate)
                        .withFunctionName("get_actor_name");
    }

    public String getActorName(Long id) {
        SqlParameterSource in = new MapSqlParameterSource()
                .addValue("in_id", id); 
        String name = funcGetActorName.executeFunction(String.class, in);
        return name;
    }

    //  ... additional methods
}</pre><p>The execute method used returns a
      <tt class="classname">String</tt> containing the return value from the
      function call.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-simple-jdbc-call-4"></a>11.5.9.&nbsp;Returning ResultSet/REF Cursor from a SimpleJdbcCall</h3></div></div><div></div></div><p>Calling a stored procedure or function that returns a result set
      has always been a bit tricky. Some databases return result sets during
      the JDBC results processing while others require an explicitly
      registered out parameter of a specific type. Both approaches still needs
      some additional processing to loop over the result set and process the
      returned rows. With the <tt class="classname">SimpleJdbcCall</tt> you use
      the <tt class="classname">returningResultSet</tt> method and declare a
      <tt class="classname">RowMapper</tt> implementation to be used for a
      specific parameter. In the case where the result set is returned during
      the results processing, there are no names defined, so the returned
      results will have to match the order you declare the
      <tt class="classname">RowMapper</tt> implementations. The name specified
      will still be used to store the processed list of results in the results
      map returned from the execute statement.</p><p>For this example we will use a stored procedure that takes no in
      parameters and returns all rows from the t_actor table. Here is the
      MySQL source for this procedure:</p><pre class="programlisting">CREATE PROCEDURE read_all_actors()
BEGIN
 SELECT a.id, a.first_name, a.last_name, a.birth_date FROM t_actor a;
END;</pre><p>In order to call this procedure we need to declare the
      <tt class="classname">RowMapper</tt> to be used. Since the class we want to
      map to follows the JavaBean rules, we can use a
      <tt class="classname">ParameterizedBeanPropertyRowMapper</tt> that is
      created by passing in the required class to map to in the
      <tt class="classname">newInstance</tt> method.</p><pre class="programlisting">public class JdbcActorDao implements ActorDao {
    private SimpleJdbcTemplate simpleJdbcTemplate;
    private SimpleJdbcCall procReadAllActors;

    public void setDataSource(DataSource dataSource) {
        this.simpleJdbcTemplate = new SimpleJdbcTemplate(dataSource);
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        jdbcTemplate.setResultsMapCaseInsensitive(true);
        this.procReadAllActors =
                new SimpleJdbcCall(jdbcTemplate)
                        .withProcedureName("read_all_actors")
                        .returningResultSet("actors",
                                ParameterizedBeanPropertyRowMapper.newInstance(Actor.class));
    }

    public List getActorsList() {
        Map m = procReadAllActors.execute(new HashMap&lt;String, Object&gt;(0));
        return (List) m.get("actors");
    }

    //  ... additional methods
}</pre><p>The execute call passes in an empty Map since this call
      doesn't take any parameters. The list of Actors is then retrieved from
      the results map and returned to the caller.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-object"></a>11.6.&nbsp;Modeling JDBC operations as Java objects</h2></div></div><div></div></div><p>The <tt class="literal">org.springframework.jdbc.object</tt> package
    contains classes that allow one to access the database in a more
    object-oriented manner. By way of an example, one can execute queries and
    get the results back as a list containing business objects with the
    relational column data mapped to the properties of the business object.
    One can also execute stored procedures and run update, delete and insert
    statements.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>There is a view borne from experience acquired in the field
      amongst some of the Spring developers that the various RDBMS operation
      classes described below (with the exception of the <a href="#jdbc-StoredProcedure" title="11.6.4.&nbsp;StoredProcedure"><tt class="classname">StoredProcedure</tt></a>
      class) can often be replaced with straight
      <tt class="classname">JdbcTemplate</tt> calls... often it is simpler to use
      and plain easier to read a DAO method that simply calls a method on a
      <tt class="classname">JdbcTemplate</tt> direct (as opposed to encapsulating
      a query as a full-blown class).</p><p>It must be stressed however that this is just a
      <span class="emphasis"><em>view</em></span>... if you feel that you are getting measurable
      value from using the RDBMS operation classes, feel free to continue
      using these classes.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SqlQuery"></a>11.6.1.&nbsp;<tt class="classname">SqlQuery</tt></h3></div></div><div></div></div><p><tt class="classname">SqlQuery</tt> is a reusable, threadsafe class
      that encapsulates an SQL query. Subclasses must implement the
      <tt class="methodname">newRowMapper(..)</tt> method to provide a
      <tt class="interfacename">RowMapper</tt> instance that can create one
      object per row obtained from iterating over the
      <tt class="interfacename">ResultSet</tt> that is created during the
      execution of the query. The <tt class="classname">SqlQuery</tt> class is
      rarely used directly since the <tt class="classname">MappingSqlQuery</tt>
      subclass provides a much more convenient implementation for mapping rows
      to Java classes. Other implementations that extend
      <tt class="classname">SqlQuery</tt> are
      <tt class="classname">MappingSqlQueryWithParameters</tt> and
      <tt class="classname">UpdatableSqlQuery</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-MappingSqlQuery"></a>11.6.2.&nbsp;<tt class="classname">MappingSqlQuery</tt></h3></div></div><div></div></div><p><tt class="classname">MappingSqlQuery</tt> is a reusable query in
      which concrete subclasses must implement the abstract
      <tt class="methodname">mapRow(..)</tt> method to convert each row of the
      supplied <tt class="interfacename">ResultSet</tt> into an object. Find
      below a brief example of a custom query that maps the data from the
      customer relation to an instance of the <tt class="classname">Customer</tt>
      class.</p><pre class="programlisting">private class CustomerMappingQuery extends MappingSqlQuery {

    public CustomerMappingQuery(DataSource ds) {
        super(ds, "SELECT id, name FROM customer WHERE id = ?");
        super.declareParameter(new SqlParameter("id", Types.INTEGER));
        compile();
    }

    public Object mapRow(ResultSet rs, int rowNumber) throws SQLException {
        Customer cust = new Customer();
        cust.setId((Integer) rs.getObject("id"));
        cust.setName(rs.getString("name"));
        return cust;
    } 
}</pre><p>We provide a constructor for this customer query that takes the
      <tt class="interfacename">DataSource</tt> as the only parameter. In this
      constructor we call the constructor on the superclass with the
      <tt class="interfacename">DataSource</tt> and the SQL that should be
      executed to retrieve the rows for this query. This SQL will be used to
      create a <tt class="interfacename">PreparedStatement</tt> so it may
      contain place holders for any parameters to be passed in during
      execution. Each parameter must be declared using the
      <tt class="literal">declareParameter</tt> method passing in an
      <tt class="classname">SqlParameter</tt>. The
      <tt class="classname">SqlParameter</tt> takes a name and the JDBC type as
      defined in <tt class="classname">java.sql.Types</tt>. After all parameters
      have been defined we call the <tt class="literal">compile()</tt> method so the
      statement can be prepared and later be executed.</p><pre class="programlisting">public Customer getCustomer(Integer id) {
    CustomerMappingQuery custQry = new CustomerMappingQuery(dataSource); 
    Object[] parms = new Object[1];
    parms[0] = id;
    List customers = custQry.execute(parms);
    if (customers.size() &gt; 0) {
        return (Customer) customers.get(0);
    }
    else {
        return null;
    }
}</pre><p>The method in this example retrieves the customer with the id that
      is passed in as the only parameter. After creating an instance of the
      <tt class="classname">CustomerMappingQuery</tt> class we create an array of
      objects that will contain all parameters that are passed in. In this
      case there is only one parameter and it is passed in as an
      <tt class="classname">Integer</tt>. Now we are ready to execute the query
      using this array of parameters and we get a <tt class="literal">List</tt> that
      contains a <tt class="classname">Customer</tt> object for each row that was
      returned for our query. In this case it will only be one entry if there
      was a match.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SqlUpdate"></a>11.6.3.&nbsp;<tt class="classname">SqlUpdate</tt></h3></div></div><div></div></div><p>The <tt class="classname">SqlUpdate</tt> class encapsulates an SQL
      update. Like a query, an update object is reusable, and like all
      <tt class="classname">RdbmsOperation</tt> classes, an update can have
      parameters and is defined in SQL. This class provides a number of
      <tt class="methodname">update(..)</tt> methods analogous to the
      <tt class="methodname">execute(..)</tt> methods of query objects. This
      class is concrete. Although it can be subclassed (for example to add a
      custom update method) it can easily be parameterized by setting SQL and
      declaring parameters.</p><pre class="programlisting">import java.sql.Types;

import javax.sql.DataSource;

import org.springframework.jdbc.core.SqlParameter;
import org.springframework.jdbc.object.SqlUpdate;

public class UpdateCreditRating extends SqlUpdate {

    public UpdateCreditRating(DataSource ds) {
        setDataSource(ds);
        setSql("update customer set credit_rating = ? where id = ?");
        declareParameter(new SqlParameter(Types.NUMERIC));
        declareParameter(new SqlParameter(Types.NUMERIC));
        compile();
    }

    <i class="lineannotation"><span class="lineannotation">/**
     * @param id for the Customer to be updated
     * @param rating the new value for credit rating
     * @return number of rows updated
     */</span></i>
    public int run(int id, int rating) {
        Object[] params =
            new Object[] {
                new Integer(rating),
                new Integer(id)};
        return update(params);
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-StoredProcedure"></a>11.6.4.&nbsp;<tt class="classname">StoredProcedure</tt></h3></div></div><div></div></div><p>The <tt class="classname">StoredProcedure</tt> class is a superclass
      for object abstractions of RDBMS stored procedures. This class is
      <tt class="literal">abstract</tt>, and its various
      <tt class="literal">execute(..)</tt> methods have <tt class="literal">protected</tt>
      access, preventing use other than through a subclass that offers tighter
      typing.</p><p>The inherited <tt class="literal">sql</tt> property will be the name of
      the stored procedure in the RDBMS.</p><p>To define a parameter to be used for the StoredProcedure classe,
      you use an <tt class="classname">SqlParameter</tt> or one of its subclasses.
      You must specify the parameter name and SQL type in the constructor. The
      SQL type is specified using the <tt class="classname">java.sql.Types</tt>
      constants. We have already seen declarations like:</p><pre class="programlisting">   new SqlParameter("in_id", Types.NUMERIC),
   new SqlOutParameter("out_first_name", Types.VARCHAR),</pre><p>The first line with the <tt class="classname">SqlParameter</tt>
      declares an in parameter. In parameters can be used for both stored
      procedure calls and for queries using the
      <tt class="classname">SqlQuery</tt> and its subclasses covered in the
      following section.</p><p>The second line with the <tt class="classname">SqlOutParameter</tt>
      declares an out parameter to be used in the stored procedure call. There
      is also an <tt class="classname">SqlInOutParameter</tt> for inout
      parameters, parameters that provide an in value to the procedure and
      that also return a value</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p> Parameters declared as <tt class="classname">SqlParameter</tt>
          and <tt class="classname">SqlInOutParameter</tt> will always be used to
          provide input values. In addition to this any parameter declared as
          <tt class="classname">SqlOutParameter</tt> where an non-null input value
          is provided will also be used as an input paraneter. </p></td></tr></table></div><p>In addition to the name and the SQL type you can specify
      additional options. For in parameters you can specify a scale for
      numeric data or a type name for custom database types. For out
      parameters you can provide a <tt class="classname">RowMapper</tt> to handle
      mapping of rows returned from a REF cursor. Another option is to specify
      an <tt class="classname">SqlReturnType</tt> that provides and opportunity to
      define customized handling of the return values.</p><p>Here is an example of a program that calls a function,
      <tt class="literal">sysdate()</tt>, that comes with any Oracle database. To
      use the stored procedure functionality one has to create a class that
      extends <tt class="classname">StoredProcedure</tt>. There are no input
      parameters, but there is an output parameter that is declared as a date
      type using the class <tt class="classname">SqlOutParameter</tt>. The
      <tt class="literal">execute()</tt> method returns a map with an entry for each
      declared output parameter using the parameter name as the key.</p><pre class="programlisting">import java.sql.Types;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.sql.DataSource;

import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.datasource.*;
import org.springframework.jdbc.object.StoredProcedure;

public class TestStoredProcedure {

    public static void main(String[] args)  {
        TestStoredProcedure t = new TestStoredProcedure();
        t.test();
        System.out.println("Done!");
    }
    
    void test() {
        DriverManagerDataSource ds = new DriverManagerDataSource();
        ds.setDriverClassName("oracle.jdbc.OracleDriver");
        ds.setUrl("jdbc:oracle:thin:@localhost:1521:mydb");
        ds.setUsername("scott");
        ds.setPassword("tiger");

        MyStoredProcedure sproc = new MyStoredProcedure(ds);
        Map results = sproc.execute();
        printMap(results);
    }

    private class MyStoredProcedure extends StoredProcedure {
        
        private static final String SQL = "sysdate";

        public MyStoredProcedure(DataSource ds) {
            setDataSource(ds);
            setFunction(true);
            setSql(SQL);
            declareParameter(new SqlOutParameter("date", Types.DATE));
            compile();
        }

        public Map execute() {
            <i class="lineannotation"><span class="lineannotation">// the 'sysdate' sproc has no input parameters, so an empty Map is supplied...</span></i>
            return execute(new HashMap());
        }
    }

    private static void printMap(Map results) {
        for (Iterator it = results.entrySet().iterator(); it.hasNext(); ) {
            System.out.println(it.next());  
        }
    }
}</pre><p>Find below an example of a <tt class="classname">StoredProcedure</tt>
      that has two output parameters (in this case Oracle REF cursors).</p><pre class="programlisting">import oracle.jdbc.driver.OracleTypes;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.object.StoredProcedure;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

public class TitlesAndGenresStoredProcedure extends StoredProcedure {

    private static final String SPROC_NAME = "AllTitlesAndGenres";

    public TitlesAndGenresStoredProcedure(DataSource dataSource) {
        super(dataSource, SPROC_NAME);
        declareParameter(new SqlOutParameter("titles", OracleTypes.CURSOR, new TitleMapper()));
        declareParameter(new SqlOutParameter("genres", OracleTypes.CURSOR, new GenreMapper()));
        compile();
    }

    public Map execute() {
        <i class="lineannotation"><span class="lineannotation">// again, this sproc has no input parameters, so an empty Map is supplied...</span></i>
        return super.execute(new HashMap());
    }
}</pre><p>Notice how the overloaded variants of the
      <tt class="literal">declareParameter(..)</tt> method that have been used in
      the <tt class="classname">TitlesAndGenresStoredProcedure</tt> constructor
      are passed <tt class="interfacename">RowMapper</tt> implementation
      instances; this is a very convenient and powerful way to reuse existing
      functionality. (The code for the two
      <tt class="interfacename">RowMapper</tt> implementations is provided
      below in the interest of completeness.)</p><p>Firstly the <tt class="classname">TitleMapper</tt> class, which simply
      maps a <tt class="interfacename">ResultSet</tt> to a
      <tt class="classname">Title</tt> domain object for each row in the supplied
      <tt class="interfacename">ResultSet</tt>.</p><pre class="programlisting">import com.foo.sprocs.domain.Title;
import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;

public final class TitleMapper implements RowMapper {
    
    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
        Title title = new Title();
        title.setId(rs.getLong("id"));
        title.setName(rs.getString("name"));
        return title;
    }
}</pre><p>Secondly, the <tt class="classname">GenreMapper</tt> class, which
      again simply maps a <tt class="interfacename">ResultSet</tt> to a
      <tt class="classname">Genre</tt> domain object for each row in the supplied
      <tt class="interfacename">ResultSet</tt>.</p><pre class="programlisting">import org.springframework.jdbc.core.RowMapper;

import java.sql.ResultSet;
import java.sql.SQLException;

import com.foo.domain.Genre;

public final class GenreMapper implements RowMapper {
    
    public Object mapRow(ResultSet rs, int rowNum) throws SQLException {
        return new Genre(rs.getString("name"));
    }
}</pre><p>If one needs to pass parameters to a stored procedure (that is the
      stored procedure has been declared as having one or more input
      parameters in its definition in the RDBMS), one would code a strongly
      typed <tt class="literal">execute(..)</tt> method which would delegate to the
      superclass' (untyped) <tt class="literal">execute(Map parameters)</tt> (which
      has <tt class="literal">protected</tt> access); for example:</p><pre class="programlisting">import oracle.jdbc.driver.OracleTypes;
import org.springframework.jdbc.core.SqlOutParameter;
import org.springframework.jdbc.object.StoredProcedure;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

public class TitlesAfterDateStoredProcedure extends StoredProcedure {

    private static final String SPROC_NAME = "TitlesAfterDate";
    private static final String CUTOFF_DATE_PARAM = "cutoffDate";

    public TitlesAfterDateStoredProcedure(DataSource dataSource) {
        super(dataSource, SPROC_NAME);
        declareParameter(new SqlParameter(CUTOFF_DATE_PARAM, Types.DATE);
        declareParameter(new SqlOutParameter("titles", OracleTypes.CURSOR, new TitleMapper()));
        compile();
    }

    public Map execute(Date cutoffDate) {
        Map inputs = new HashMap();
        inputs.put(CUTOFF_DATE_PARAM, cutoffDate);
        return super.execute(inputs);
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-SqlFunction"></a>11.6.5.&nbsp;<tt class="classname">SqlFunction</tt></h3></div></div><div></div></div><p>The <tt class="classname">SqlFunction</tt> RDBMS operation class
      encapsulates an SQL "function" wrapper for a query that returns a single
      row of results. The default behavior is to return an
      <tt class="literal">int</tt>, but that can be overridden by using the methods
      with an extra return type parameter. This is similar to using the
      <tt class="literal">queryForXxx</tt> methods of the
      <tt class="classname">JdbcTemplate</tt>. The advantage with
      <tt class="classname">SqlFunction</tt> is that you don't have to create the
      <tt class="classname">JdbcTemplate</tt>, it is done behind the
      scenes.</p><p>This class is intended to use to call SQL functions that return a
      single result using a query like "select user()" or "select sysdate from
      dual". It is not intended for calling more complex stored functions or
      for using a <tt class="classname">CallableStatement</tt> to invoke a stored
      procedure or stored function. (Use the
      <tt class="classname">StoredProcedure</tt> or <tt class="classname">SqlCall</tt>
      classes for this type of processing).</p><p><tt class="classname">SqlFunction</tt> is a concrete class, and there
      is typically no need to subclass it. Code using this package can create
      an object of this type, declaring SQL and parameters, and then invoke
      the appropriate run method repeatedly to execute the function. Here is
      an example of retrieving the count of rows from a table:</p><pre class="programlisting">public int countRows() {
    SqlFunction sf = new SqlFunction(dataSource, "select count(*) from mytable");
    sf.compile();
    return sf.run();
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jdbc-parameter-handling"></a>11.7.&nbsp;Common issues with parameter and data value handling</h2></div></div><div></div></div><p>There are some issues involving parameters and data values that are
    common across all the different approaches provided by the Spring JDBC
    Framework.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-type-information"></a>11.7.1.&nbsp;Providing SQL type information for parameters</h3></div></div><div></div></div><p>Most of the time Spring will assume the SQL type of the parameters
      based on the type of parameter passed in. It is possible to explicitly
      provide the SQL type to be used when setting parameter values. This is
      sometimes necessary to correctly set NULL values.</p><p>There are a few different ways this can be accomplished:</p><div class="itemizedlist"><ul type="disc"><li><p>Many of the update and query methods of the
          <tt class="classname">JdbcTemplate</tt> take an additional parameter in
          the form of an int array. This array should contain the SQL type
          using constant values from the <tt class="classname">java.sql.Types</tt>
          class. There must be one entry for each parameter.</p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>You can wrap the parameter value that needs this additional
          information using the <tt class="classname">SqlParameterValue</tt>
          class. Create a new instance for each value and pass in the SQL type
          and parameter value in the constructor. You can also provide an
          optional scale parameter for numeric values.</p></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>For methods working with named parameters, you can use the
          <tt class="classname">SqlParameterSource</tt> classes
          <tt class="classname">BeanPropertySqlParameterSource</tt> or
          <tt class="classname">MapSqlParameterSource</tt>. They both have methods
          for registering the SQL type for any of the named parameter
          values.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-lob"></a>11.7.2.&nbsp;Handling BLOB and CLOB objects</h3></div></div><div></div></div><p>You can store images and other binary objects as well and large
      chunks of text. These large object are called BLOB for binary data and
      CLOB for character data. Spring lets you handle these large objects
      using the JdbcTemplate directly and also when using the higher
      abstractions provided by RDBMS Objects and the SimpleJdbc classes. All
      of these approaches use an implementation of the
      <tt class="classname">LobHandler</tt> interface for the actual management of
      the LOB data. The <tt class="classname">LobHandler</tt> provides access to a
      <tt class="classname">LobCreator</tt>, via the
      <tt class="classname">getLobCreator</tt> method, for creating new LOB
      objects to be inserted.</p><p>The <tt class="classname">LobCreator/LobHandler</tt> provides the
      following support for LOB in- and output:</p><div class="itemizedlist"><ul type="disc"><li><p>BLOB</p><div class="itemizedlist"><ul type="circle"><li><p>byte[] &#8211; getBlobAsBytes and setBlobAsBytes</p></li><li><p>InputStream &#8211; getBlobAsBinaryStream and
                setBlobAsBinaryStream</p></li></ul></div></li></ul></div><div class="itemizedlist"><ul type="disc"><li><p>CLOB</p><div class="itemizedlist"><ul type="circle"><li><p>String &#8211; getClobAsString and setClobAsString</p></li><li><p>InputStream &#8211; getClobAsAsciiStream and
                setClobAsAsciiStream</p></li><li><p>Reader &#8211; getClobAsCharacterStream and
                setClobAsCharacterStream</p></li></ul></div></li></ul></div><p>We will now show an example of how to create and insert a BLOB. We
      will later see how to read it back from the database.</p><p>This example uses a JdbcTemplate and an implementation of the
      AbstractLobCreatingPreparedStatementCallback. There is one method that
      must be implemented and it is "setValues". In this method you will be
      provided with a LobCreator that can be used to set the values for the
      LOB columns in your SQL insert statement.</p><p>We are assuming that we have a variable named 'lobHandler' that
      already is set to an instance of a
      <tt class="classname">DefaultLobHandler</tt>. This is typically done using
      dependency injection.</p><div class="programlistingco"><pre class="programlisting">final File blobIn = new File("spring2004.jpg");
final InputStream blobIs = new FileInputStream(blobIn);
final File clobIn = new File("large.txt");
final InputStream clobIs = new FileInputStream(clobIn);
final InputStreamReader clobReader = new InputStreamReader(clobIs);
jdbcTemplate.execute(
  "INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)",
  new AbstractLobCreatingPreparedStatementCallback(lobhandler) {                         <span class="co"><img src="../images/callouts/1.png" alt="(1)"></span>
      protected void setValues(PreparedStatement ps, LobCreator lobCreator) 
          throws SQLException {
        ps.setLong(1, 1L);
        lobCreator.setClobAsCharacterStream(ps, 2, clobReader, (int)clobIn.length());    <span class="co"><img src="../images/callouts/2.png" alt="(2)"></span>
        lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, (int)blobIn.length());           <span class="co"><img src="../images/callouts/3.png" alt="(3)"></span>
      }
  }
);
blobIs.close();
clobReader.close();</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="../images/callouts/1.png" alt="1" border="0"></td><td valign="top" align="left"><p>Here we use the lobHandler that in this example is a plain
            <tt class="classname">DefaultLobHandler</tt></p></td></tr><tr><td width="5%" valign="top" align="left"><img src="../images/callouts/2.png" alt="2" border="0"></td><td valign="top" align="left"><p>Using the method <tt class="classname">setClobAsCharacterStream
            </tt>we pass in the contents of the CLOB</p></td></tr><tr><td width="5%" valign="top" align="left"><img src="../images/callouts/3.png" alt="3" border="0"></td><td valign="top" align="left"><p>Using the method
            <tt class="classname">setBlobAsBinartStream</tt> we pass in the
            contents of the BLOB</p></td></tr></table></div></div><p>Now it's time to read the LOB data from the database. Again, we
      use a JdbcTempate and we have the same instance variable 'lobHandler'
      with a reference to a <tt class="classname">DefaultLobHandler</tt>.</p><div class="programlistingco"><pre class="programlisting">List l = jdbcTemplate.query("select id, a_clob, a_blob from lob_table",
    new RowMapper() {
      public Object mapRow(ResultSet rs, int i) throws SQLException {
        Map results = new HashMap();
        String clobText = lobHandler.getClobAsString(rs, "a_clob");                      <span class="co"><img src="../images/callouts/1.png" alt="(1)"></span>
        results.put("CLOB", clobText);
        byte[] blobBytes = lobHandler.getBlobAsBytes(rs, "a_blob");                      <span class="co"><img src="../images/callouts/2.png" alt="(2)"></span>
        results.put("BLOB", blobBytes);
        return results;
      }
    });
</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><img src="../images/callouts/2.png" alt="2" border="0"></td><td valign="top" align="left"><p>Using the method <tt class="classname">getClobAsString </tt>we
              retrieve the contents of the CLOB</p></td></tr><tr><td width="5%" valign="top" align="left"><img src="../images/callouts/3.png" alt="3" border="0"></td><td valign="top" align="left"><p>Using the method <tt class="classname">getBlobAsBytes</tt> we
              retrieve the contents of the BLOB</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-in-clause"></a>11.7.3.&nbsp;Passing in lists of values for IN clause</h3></div></div><div></div></div><p>The SQL standard allows for selecting rows based on an expression
      that includes a variable list of values. A typical example would be
      "select * from T_ACTOR where id in (1, 2, 3)". This variable list is not
      directly supported for prepared statements by the JDBC standard - there
      is no way of declaring a variable number of place holders. You would
      have to either have a number of variations with the desired number of
      place holders prepared or you would have to dynamically generate the SQL
      string once you know how many place holders are required. The named
      parameter support provided in the
      <tt class="classname">NamedParameterJdbcTemplate</tt> and
      <tt class="classname">SimpleJdbcTemplate</tt> takes the latter approach.
      When you pass in the values you should pass them in as a
      <tt class="classname">java.util.List</tt> of primitive objects. This list
      will be used to insert the required place holders and pass in the values
      during the statement execution.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>You need to be careful when passing in a large number of values.
        The JDBC standard doesn't guarantee that you can use more than 100
        values for an IN expression list. Various databases exceed this
        number, but they usually have a hard limit for how many values are
        allowed. Oracle's limit for instance is 1000.</p></td></tr></table></div><p>In addition to the primitive values in the value list, you can
      create a <tt class="classname">java.util.List</tt> of object arrays. This
      would support a case where there are multiple expressions defined for
      the IN clause like "select * from T_ACTOR where (id, last_name) in ((1,
      'Johnson'), (2, 'Harrop'))". This of course requires that your database
      supports this syntax.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jdbc-complex-types"></a>11.7.4.&nbsp;Handling complex types for stored procedure calls</h3></div></div><div></div></div><p>When calling stored procedures it's sometimes possible to use
      complex types specific to the database. To accommodate these types
      Spring provides a <tt class="classname">SqlReturnType</tt> for handling them
      when they are returned from the stored procedure call and
      <tt class="classname">SqlTypeValue</tt> when they are passed in as a
      parameter to the stored procedure.</p><p>Here is an example of returning the value of an Oracle STRUCT
      object of the user declared type "ITEM_TYPE". The
      <tt class="classname">SqlReturnType</tt> interface has a single method named
      "<tt class="classname">getTypeValue</tt>" that must be implemented. This
      interface is used as part of the declaration of an
      <tt class="classname">SqlOutParameter</tt>.</p><pre class="programlisting">declareParameter(new SqlOutParameter("item", OracleTypes.STRUCT, "ITEM_TYPE",
    new SqlReturnType() {
      public Object getTypeValue(CallableStatement cs, int colIndx, int sqlType, String typeName) 
          throws SQLException {
        STRUCT struct = (STRUCT)cs.getObject(colIndx);
        Object[] attr = struct.getAttributes();
        TestItem item = new TestItem();
        item.setId(((Number) attr[0]).longValue());
        item.setDescription((String)attr[1]);
        item.setExpirationDate((java.util.Date)attr[2]);
        return item;
      }
    }));</pre><p>Going from Java to the database and passing in the
      value of a <tt class="classname">TestItem</tt> into a stored procedure is
      done using the <tt class="classname">SqlTypeValue</tt>. The
      <tt class="classname">SqlTypeValue</tt> interface has a single method named
      "<tt class="classname">createTypeValue</tt>" that must be implemented. The
      active connection is passed in and can be used to create database
      specific objects like <tt class="classname">StructDescriptor</tt>s or
      <tt class="classname">ArrayDescriptor</tt>s</p><pre class="programlisting">SqlTypeValue value = new AbstractSqlTypeValue() {
  protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException {
    StructDescriptor itemDescriptor = new StructDescriptor(typeName, conn);
    Struct item = new STRUCT(itemDescriptor, conn,
        new Object[] {
            testItem.getId(),
            testItem.getDescription(),
            new java.sql.Date(testItem.getExpirationDate().getTime())
        });
    return item;
  }
};</pre><p>This <tt class="classname">SqlTypeValue</tt> can now be added
      to the Map containing the input parameters for the execute call of the
      stored procedure.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="orm"></a>Chapter&nbsp;12.&nbsp;Object Relational Mapping (ORM) data access</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-introduction"></a>12.1.&nbsp;Introduction</h2></div></div><div></div></div><p>The Spring Framework provides integration with <span class="emphasis"><em>Hibernate,
    JDO, Oracle TopLink, iBATIS SQL Maps</em></span> and
    <span class="emphasis"><em>JPA</em></span>: in terms of resource management, DAO
    implementation support, and transaction strategies. For example for
    Hibernate, there is first-class support with lots of IoC convenience
    features, addressing many typical Hibernate integration issues. All of
    these support packages for O/R (Object Relational) mappers comply with
    Spring's generic transaction and DAO exception hierarchies. There are
    usually two integration styles: either using Spring's DAO 'templates' or
    coding DAOs against plain Hibernate/JDO/TopLink/etc APIs. In both cases,
    DAOs can be configured through Dependency Injection and participate in
    Spring's resource and transaction management.</p><p>Spring adds significant support when using the O/R mapping layer of
    your choice to create data access applications. First of all, you should
    know that once you started using Spring's support for O/R mapping, you
    don't have to go all the way. No matter to what extent, you're invited to
    review and leverage the Spring approach, before deciding to take the
    effort and risk of building a similar infrastructure in-house. Much of the
    O/R mapping support, no matter what technology you're using may be used in
    a library style, as everything is designed as a set of reusable JavaBeans.
    Usage inside a Spring IoC container does provide additional benefits in
    terms of ease of configuration and deployment; as such, most examples in
    this section show configuration inside a Spring container.</p><p>Some of the benefits of using the Spring Framework to create your
    ORM DAOs include:</p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Ease of testing.</em></span> Spring's IoC approach
        makes it easy to swap the implementations and config locations of
        Hibernate <tt class="interfacename">SessionFactory</tt> instances,
        JDBC <tt class="interfacename">DataSource</tt> instances, transaction
        managers, and mappes object implementations (if needed). This makes it
        much easier to isolate and test each piece of persistence-related code
        in isolation.</p></li><li><p><span class="emphasis"><em>Common data access exceptions.</em></span> Spring can
        wrap exceptions from your O/R mapping tool of choice, converting them
        from proprietary (potentially checked) exceptions to a common runtime
        DataAccessException hierarchy. This allows you to handle most
        persistence exceptions, which are non-recoverable, only in the
        appropriate layers, without annoying boilerplate catches/throws, and
        exception declarations. You can still trap and handle exceptions
        anywhere you need to. Remember that JDBC exceptions (including DB
        specific dialects) are also converted to the same hierarchy, meaning
        that you can perform some operations with JDBC within a consistent
        programming model.</p></li><li><p><span class="emphasis"><em>General resource management.</em></span> Spring
        application contexts can handle the location and configuration of
        Hibernate <tt class="interfacename">SessionFactory</tt> instances,
        JDBC <tt class="interfacename">DataSource</tt> instances, iBATIS SQL
        Maps configuration objects, and other related resources. This makes
        these values easy to manage and change. Spring offers efficient, easy
        and safe handling of persistence resources. For example: related code
        using Hibernate generally needs to use the same Hibernate
        <tt class="interfacename">Session</tt> for efficiency and proper
        transaction handling. Spring makes it easy to transparently create and
        bind a <tt class="interfacename">Session</tt> to the current thread,
        either by using an explicit 'template' wrapper class at the Java code
        level or by exposing a current <tt class="interfacename">Session</tt>
        through the Hibernate <tt class="interfacename">SessionFactory</tt>
        (for DAOs based on plain Hibernate API). Thus Spring solves many of
        the issues that repeatedly arise from typical Hibernate usage, for any
        transaction environment (local or JTA).</p></li><li><p><span class="emphasis"><em>Integrated transaction management.</em></span> Spring
        allows you to wrap your O/R mapping code with either a declarative,
        AOP style method interceptor, or an explicit 'template' wrapper class
        at the Java code level. In either case, transaction semantics are
        handled for you, and proper transaction handling (rollback, etc) in
        case of exceptions is taken care of. As discussed below, you also get
        the benefit of being able to use and swap various transaction
        managers, without your Hibernate/JDO related code being affected: for
        example, between local transactions and JTA, with the same full
        services (such as declarative transactions) available in both
        scenarios. As an additional benefit, JDBC-related code can fully
        integrate transactionally with the code you use to do O/R mapping.
        This is useful for data access that's not suitable for O/R mapping,
        such as batch processing or streaming of BLOBs, which still needs to
        share common transactions with ORM operations.</p></li></ul></div><p>The PetClinic sample in the Spring distribution offers alternative
    DAO implementations and application context configurations for JDBC,
    Hibernate, Oracle TopLink, and JPA. PetClinic can therefore serve as
    working sample app that illustrates the use of Hibernate, TopLink and JPA
    in a Spring web application. It also leverages declarative transaction
    demarcation with different transaction strategies.</p><p>The JPetStore sample illustrates the use of iBATIS SQL Maps in a
    Spring environment. It also features two web tier versions: one based on
    Spring Web MVC, one based on Struts.</p><p>Beyond the samples shipped with Spring, there are a variety of
    Spring-based O/R mapping samples provided by specific vendors: for
    example, the JDO implementations JPOX (<a href="http://www.jpox.org/" target="_top">http://www.jpox.org/</a>) and Kodo (<a href="http://www.bea.com/kodo/" target="_top">http://www.bea.com/kodo/</a>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-hibernate"></a>12.2.&nbsp;Hibernate</h2></div></div><div></div></div><p>We will start with a coverage of <a href="http://www.hibernate.org/" target="_top">Hibernate 3</a> in a Spring
    environment, using it to demonstrate the approach that Spring takes
    towards integrating O/R mappers. This section will cover many issues in
    detail and show different variations of DAO implementations and
    transaction demarcation. Most of these patterns can be directly translated
    to all other supported ORM tools. The following sections in this chapter
    will then cover the other ORM technologies, showing briefer examples
    there.</p><p><span class="emphasis"><em>Note: As of Spring 2.5, Spring requires Hibernate 3.1 or
    higher. Neither Hibernate 2.1 nor Hibernate 3.0 are supported
    anymore.</em></span></p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-resource-mngmnt"></a>12.2.1.&nbsp;Resource management</h3></div></div><div></div></div><p>Typical business applications are often cluttered with repetitive
      resource management code. Many projects try to invent their own
      solutions for this issue, sometimes sacrificing proper handling of
      failures for programming convenience. Spring advocates strikingly simple
      solutions for proper resource handling, namely IoC via templating; for
      example infrastructure classes with callback interfaces, or applying AOP
      interceptors. The infrastructure cares for proper resource handling, and
      for appropriate conversion of specific API exceptions to an unchecked
      infrastructure exception hierarchy. Spring introduces a DAO exception
      hierarchy, applicable to any data access strategy. For direct JDBC, the
      <tt class="classname">JdbcTemplate</tt> class mentioned in a previous
      section cares for connection handling, and for proper conversion of
      <tt class="classname">SQLException</tt> to the
      <tt class="classname">DataAccessException</tt> hierarchy, including
      translation of database-specific SQL error codes to meaningful exception
      classes. It supports both JTA and JDBC transactions, via respective
      Spring transaction managers.</p><p>Spring also offers Hibernate and JDO support, consisting of a
      <tt class="classname">HibernateTemplate</tt> /
      <tt class="classname">JdoTemplate</tt> analogous to
      <tt class="classname">JdbcTemplate</tt>, a
      <tt class="classname">HibernateInterceptor</tt> /
      <tt class="classname">JdoInterceptor</tt>, and a Hibernate / JDO transaction
      manager. The major goal is to allow for clear application layering, with
      any data access and transaction technology, and for loose coupling of
      application objects. No more business service dependencies on the data
      access or transaction strategy, no more hard-coded resource lookups, no
      more hard-to-replace singletons, no more custom service registries. One
      simple and consistent approach to wiring up application objects, keeping
      them as reusable and free from container dependencies as possible. All
      the individual data access features are usable on their own but
      integrate nicely with Spring's application context concept, providing
      XML-based configuration and cross-referencing of plain JavaBean
      instances that don't need to be Spring-aware. In a typical Spring
      application, many important objects are JavaBeans: data access
      templates, data access objects (that use the templates), transaction
      managers, business services (that use the data access objects and
      transaction managers), web view resolvers, web controllers (that use the
      business services),and so on.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-session-factory-setup"></a>12.2.2.&nbsp;<tt class="interfacename">SessionFactory</tt> setup in a Spring
      container</h3></div></div><div></div></div><p>To avoid tying application objects to hard-coded resource lookups,
      Spring allows you to define resources such as a JDBC
      <tt class="interfacename">DataSource</tt> or a Hibernate
      <tt class="interfacename">SessionFactory</tt> as beans in the Spring
      container. Application objects that need to access resources just
      receive references to such pre-defined instances via bean references
      (the DAO definition in the next section illustrates this). The following
      excerpt from an XML application context definition shows how to set up a
      JDBC <tt class="classname">DataSource</tt> and a Hibernate
      <tt class="interfacename">SessionFactory</tt> on top of it:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="org.hsqldb.jdbcDriver"/&gt;
    &lt;property name="url" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
    &lt;property name="username" value="sa"/&gt;
    &lt;property name="password" value=""/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;product.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;value&gt;
        hibernate.dialect=org.hibernate.dialect.HSQLDialect
      &lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that switching from a local Jakarta Commons DBCP
      <tt class="classname">BasicDataSource</tt> to a JNDI-located
      <tt class="interfacename">DataSource</tt> (usually managed by an
      application server) is just a matter of configuration:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="java:comp/env/jdbc/myds"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>You can also access a JNDI-located
      <tt class="interfacename">SessionFactory</tt>, using Spring's
      <tt class="classname">JndiObjectFactoryBean</tt> to retrieve and expose it.
      However, that is typically not common outside of an EJB context.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-template"></a>12.2.3.&nbsp;The <tt class="classname">HibernateTemplate</tt></h3></div></div><div></div></div><p>The basic programming model for templating looks as follows, for
      methods that can be part of any custom data access object or business
      service. There are no restrictions on the implementation of the
      surrounding object at all, it just needs to provide a Hibernate
      <tt class="interfacename">SessionFactory</tt>. It can get the latter
      from anywhere, but preferably as bean reference from a Spring IoC
      container - via a simple <tt class="methodname">setSessionFactory(..)</tt>
      bean property setter. The following snippets show a DAO definition in a
      Spring container, referencing the above defined
      <tt class="interfacename">SessionFactory</tt>, and an example for a DAO
      method implementation.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private HibernateTemplate hibernateTemplate;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.hibernateTemplate = new HibernateTemplate(sessionFactory);
    }

    public Collection loadProductsByCategory(String category) throws DataAccessException {
    	return this.hibernateTemplate.find("from test.Product product where product.category=?", category);
    }
}</pre><p>The <tt class="classname">HibernateTemplate</tt> class provides many
      methods that mirror the methods exposed on the Hibernate
      <tt class="interfacename">Session</tt> interface, in addition to a
      number of convenience methods such as the one shown above. If you need
      access to the <tt class="interfacename">Session</tt> to invoke methods
      that are not exposed on the <tt class="classname">HibernateTemplate</tt>,
      you can always drop down to a callback-based approach like so.</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private HibernateTemplate hibernateTemplate;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.hibernateTemplate = new HibernateTemplate(sessionFactory);
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        return this.hibernateTemplate.execute(new HibernateCallback() {

            public Object doInHibernate(Session session) {
                Criteria criteria = session.createCriteria(Product.class);
                criteria.add(Expression.eq("category", category));
                criteria.setMaxResults(6);
                return criteria.list();
            }
        };
    }
}</pre><p>A callback implementation effectively can be used for any
      Hibernate data access. <tt class="classname">HibernateTemplate</tt> will
      ensure that <tt class="interfacename">Session</tt> instances are
      properly opened and closed, and automatically participate in
      transactions. The template instances are thread-safe and reusable, they
      can thus be kept as instance variables of the surrounding class. For
      simple single step actions like a single find, load, saveOrUpdate, or
      delete call, <tt class="classname">HibernateTemplate</tt> offers alternative
      convenience methods that can replace such one line callback
      implementations. Furthermore, Spring provides a convenient
      <tt class="classname">HibernateDaoSupport</tt> base class that provides a
      <tt class="methodname">setSessionFactory(..)</tt> method for receiving a
      <tt class="interfacename">SessionFactory</tt>, and
      <tt class="methodname">getSessionFactory()</tt> and
      <tt class="methodname">getHibernateTemplate()</tt>for use by subclasses. In
      combination, this allows for very simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends HibernateDaoSupport implements ProductDao {

    public Collection loadProductsByCategory(String category) throws DataAccessException {
        return this.getHibernateTemplate().find(
            "from test.Product product where product.category=?", category);
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-daos"></a>12.2.4.&nbsp;Implementing Spring-based DAOs without callbacks</h3></div></div><div></div></div><p>As alternative to using Spring's
      <tt class="classname">HibernateTemplate</tt> to implement DAOs, data access
      code can also be written in a more traditional fashion, without wrapping
      the Hibernate access code in a callback, while still respecting and
      participating in Spring's generic
      <tt class="classname">DataAccessException</tt> hierarchy. The
      <tt class="classname">HibernateDaoSupport</tt> base class offers methods to
      access the current transactional <tt class="interfacename">Session</tt>
      and to convert exceptions in such a scenario; similar methods are also
      available as static helpers on the
      <tt class="classname">SessionFactoryUtils</tt> class. Note that such code
      will usually pass '<tt class="literal">false</tt>' as the value of the
      <tt class="methodname">getSession(..)</tt> methods
      '<tt class="literal">allowCreate</tt>' argument, to enforce running within a
      transaction (which avoids the need to close the returned
      <tt class="interfacename">Session</tt>, as its lifecycle is managed by
      the transaction).</p><pre class="programlisting">public class HibernateProductDao extends HibernateDaoSupport implements ProductDao {

    public Collection loadProductsByCategory(String category) throws DataAccessException, MyException {
        Session session = getSession(false);
        try {
            Query query = session.createQuery("from test.Product product where product.category=?");
            query.setString(0, category);
            List result = query.list();
            if (result == null) {
                throw new MyException("No search results.");
            }
            return result;
        }
        catch (HibernateException ex) {
            throw convertHibernateAccessException(ex);
        }
    }
}</pre><p>The advantage of such direct Hibernate access code is that it
      allows <span class="emphasis"><em>any</em></span> checked application exception to be
      thrown within the data access code; contrast this to the
      <tt class="classname">HibernateTemplate</tt> class which is restricted to
      throwing only unchecked exceptions within the callback. Note that you
      can often defer the corresponding checks and the throwing of application
      exceptions to after the callback, which still allows working with
      <tt class="classname">HibernateTemplate</tt>. In general, the
      <tt class="classname">HibernateTemplate</tt> class' convenience methods are
      simpler and more convenient for many scenarios.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-straight"></a>12.2.5.&nbsp;Implementing DAOs based on plain Hibernate 3 API</h3></div></div><div></div></div><p>Hibernate 3 provides a feature called "contextual Sessions", where
      Hibernate itself manages one current
      <tt class="interfacename">Session</tt> per transaction. This is roughly
      equivalent to Spring's synchronization of one Hibernate
      <tt class="interfacename">Session</tt> per transaction. A corresponding
      DAO implementation looks like as follows, based on the plain Hibernate
      API:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private SessionFactory sessionFactory;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.sessionFactory = sessionFactory;
    }

    public Collection loadProductsByCategory(String category) {
        return this.sessionFactory.getCurrentSession()
                .createQuery("from test.Product product where product.category=?")
                .setParameter(0, category)
                .list();
    }
}</pre><p>This style is very similar to what you will find in the Hibernate
      reference documentation and examples, except for holding the
      <tt class="interfacename">SessionFactory</tt> in an instance variable.
      We strongly recommend such an instance-based setup over the old-school
      <tt class="literal">static</tt> <tt class="classname">HibernateUtil</tt> class
      from Hibernate's CaveatEmptor sample application. (In general, do not
      keep any resources in <tt class="literal">static</tt> variables unless
      <span class="emphasis"><em>absolutely</em></span> necessary.)</p><p>The above DAO follows the Dependency Injection pattern: it fits
      nicely into a Spring IoC container, just like it would if coded against
      Spring's <tt class="classname">HibernateTemplate</tt>. Of course, such a DAO
      can also be set up in plain Java (for example, in unit tests): simply
      instantiate it and call <tt class="methodname">setSessionFactory(..)</tt>
      with the desired factory reference. As a Spring bean definition, it
      would look as follows:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on
      Hibernate API only; no import of any Spring class is required. This is
      of course appealing from a non-invasiveness perspective, and will no
      doubt feel more natural to Hibernate developers.</p><p>However, the DAO throws plain
      <tt class="classname">HibernateException</tt> (which is unchecked, so does
      not have to be declared or caught), which means that callers can only
      treat exceptions as generally fatal - unless they want to depend on
      Hibernate's own exception hierarchy. Catching specific causes such as an
      optimistic locking failure is not possible without tieing the caller to
      the implementation strategy. This tradeoff might be acceptable to
      applications that are strongly Hibernate-based and/or do not need any
      special exception treatment.</p><p>Fortunately, Spring's
      <tt class="classname">LocalSessionFactoryBean</tt> supports Hibernate's
      <tt class="methodname">SessionFactory.getCurrentSession()</tt> method for
      any Spring transaction strategy, returning the current Spring-managed
      transactional <tt class="interfacename">Session</tt> even with
      <tt class="classname">HibernateTransactionManager</tt>. Of course, the
      standard behavior of that method remains: returning the current
      <tt class="interfacename">Session</tt> associated with the ongoing JTA
      transaction, if any (no matter whether driven by Spring's
      <tt class="classname">JtaTransactionManager</tt>, by EJB CMT, or by
      JTA).</p><p>In summary: DAOs can be implemented based on the plain Hibernate 3
      API, while still being able to participate in Spring-managed
      transactions.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-tx-programmatic"></a>12.2.6.&nbsp;Programmatic transaction demarcation</h3></div></div><div></div></div><p>Transactions can be demarcated in a higher level of the
      application, on top of such lower-level data access services spanning
      any number of operations. There are no restrictions on the
      implementation of the surrounding business service here as well, it just
      needs a Spring <tt class="classname">PlatformTransactionManager</tt>. Again,
      the latter can come from anywhere, but preferably as bean reference via
      a <tt class="methodname">setTransactionManager(..)</tt> method - just like
      the <tt class="classname">productDAO</tt> should be set via a
      <tt class="methodname">setProductDao(..)</tt> method. The following
      snippets show a transaction manager and a business service definition in
      a Spring application context, and an example for a business method
      implementation.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductServiceImpl implements ProductService {

    private TransactionTemplate transactionTemplate;
    private ProductDao productDao;

    public void setTransactionManager(PlatformTransactionManager transactionManager) {
        this.transactionTemplate = new TransactionTemplate(transactionManager);
    }

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    public void increasePriceOfAllProductsInCategory(final String category) {
        this.transactionTemplate.execute(new TransactionCallbackWithoutResult() {

                public void doInTransactionWithoutResult(TransactionStatus status) {
                    List productsToChange = this.productDao.loadProductsByCategory(category);
                    <i class="lineannotation"><span class="lineannotation">// do the price increase...</span></i>
                }
            }
        );
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-tx-declarative"></a>12.2.7.&nbsp;Declarative transaction demarcation</h3></div></div><div></div></div><p>Alternatively, one can use Spring's declarative transaction
      support, which essentially enables you to replace explicit transaction
      demarcation API calls in your Java code with an AOP transaction
      interceptor configured in a Spring container. This allows you to keep
      business services free of repetitive transaction demarcation code, and
      allows you to focus on adding business logic which is where the real
      value of your application lies. Furthermore, transaction semantics like
      propagation behavior and isolation level can be changed in a
      configuration file and do not affect the business service
      implementations.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="org.springframework.aop.framework.ProxyFactoryBean"&gt;
    &lt;property name="proxyInterfaces" value="product.ProductService"/&gt;
    &lt;property name="target"&gt;
        &lt;bean class="product.DefaultProductService"&gt;
            &lt;property name="productDao" ref="myProductDao"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="interceptorNames"&gt;
      &lt;list&gt;
        &lt;value&gt;myTxInterceptor&lt;/value&gt; <i class="lineannotation"><span class="lineannotation">&lt;!-- the transaction interceptor (configured elsewhere) --&gt;</span></i>
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class ProductServiceImpl implements ProductService {

    private ProductDao productDao;

    public void setProductDao(ProductDao productDao) {
        this.productDao = productDao;
    }

    <i class="lineannotation"><span class="lineannotation">// notice the absence of transaction demarcation code in this method</span></i>
    <i class="lineannotation"><span class="lineannotation">// Spring's declarative transaction infrastructure will be demarcating transactions on your behalf </span></i>
    public void increasePriceOfAllProductsInCategory(final String category) {
        List productsToChange = this.productDao.loadProductsByCategory(category);
        <i class="lineannotation"><span class="lineannotation">// ...</span></i>
    }
}</pre><p>Spring's <tt class="classname">TransactionInterceptor</tt> allows any
      checked application exception to be thrown with the callback code, while
      <tt class="classname">TransactionTemplate</tt> is restricted to unchecked
      exceptions within the callback.
      <tt class="classname">TransactionTemplate</tt> will trigger a rollback in
      case of an unchecked application exception, or if the transaction has
      been marked rollback-only by the application (via
      <tt class="classname">TransactionStatus</tt>).
      <tt class="classname">TransactionInterceptor</tt> behaves the same way by
      default but allows configurable rollback policies per method.</p><p>The following higher level approach to declarative transactions
      doesn't use the <tt class="classname">ProxyFactoryBean</tt>, and as such may
      be easier to use if you have a large number of service objects that you
      wish to make transactional.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>You are <span class="emphasis"><em>strongly</em></span> encouraged to read the
        section entitled <a href="#transaction-declarative" title="9.5.&nbsp;Declarative transaction management">Section&nbsp;9.5, &#8220;Declarative transaction management&#8221;</a> if you
        have not done so already prior to continuing.</p></td></tr></table></div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="interfacename">SessionFactory</tt>, <tt class="interfacename">DataSource</tt>, etc. omitted --&gt;</span></i>

  &lt;bean id="myTxManager" class="org.springframework.orm.hibernate3.HibernateTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;
  
  &lt;aop:config&gt;
    &lt;aop:pointcut id="productServiceMethods" expression="execution(* product.ProductService.*(..))"/&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/&gt;
  &lt;/aop:config&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="myTxManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="increasePrice*" propagation="REQUIRED"/&gt;
      &lt;tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/&gt;
      &lt;tx:method name="*" propagation="SUPPORTS" read-only="true"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  &lt;bean id="myProductService" class="product.SimpleProductService"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-tx-strategies"></a>12.2.8.&nbsp;Transaction management strategies</h3></div></div><div></div></div><p>Both <tt class="classname">TransactionTemplate</tt> and
      <tt class="classname">TransactionInterceptor</tt> delegate the actual
      transaction handling to a
      <tt class="classname">PlatformTransactionManager</tt> instance, which can be
      a <tt class="classname">HibernateTransactionManager</tt> (for a single
      Hibernate <tt class="interfacename">SessionFactory</tt>, using a
      <tt class="classname">ThreadLocal</tt>
      <tt class="interfacename">Session</tt> under the hood) or a
      <tt class="classname">JtaTransactionManager</tt> (delegating to the JTA
      subsystem of the container) for Hibernate applications. You could even
      use a custom <tt class="classname">PlatformTransactionManager</tt>
      implementation. So switching from native Hibernate transaction
      management to JTA, such as when facing distributed transaction
      requirements for certain deployments of your application, is just a
      matter of configuration. Simply replace the Hibernate transaction
      manager with Spring's JTA transaction implementation. Both transaction
      demarcation and data access code will work without changes, as they just
      use the generic transaction management APIs.</p><p>For distributed transactions across multiple Hibernate session
      factories, simply combine <tt class="classname">JtaTransactionManager</tt>
      as a transaction strategy with multiple
      <tt class="classname">LocalSessionFactoryBean</tt> definitions. Each of your
      DAOs then gets one specific
      <tt class="interfacename">SessionFactory</tt> reference passed into its
      corresponding bean property. If all underlying JDBC data sources are
      transactional container ones, a business service can demarcate
      transactions across any number of DAOs and any number of session
      factories without special regard, as long as it is using
      <tt class="classname">JtaTransactionManager</tt> as the strategy.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myDataSource1" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName value="java:comp/env/jdbc/myds1"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myDataSource2" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="java:comp/env/jdbc/myds2"/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory1" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource1"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;product.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;value&gt;
        hibernate.dialect=org.hibernate.dialect.MySQLDialect
        hibernate.show_sql=true
      &lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory2" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="myDataSource2"/&gt;
    &lt;property name="mappingResources"&gt;
      &lt;list&gt;
        &lt;value&gt;inventory.hbm.xml&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="hibernateProperties"&gt;
      &lt;value&gt;
        hibernate.dialect=org.hibernate.dialect.OracleDialect
      &lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="myTxManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory1"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myInventoryDao" class="product.InventoryDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory2"/&gt;
  &lt;/bean&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- this shows the Spring 1.x style of declarative transaction configuration --&gt;</span></i>
  <i class="lineannotation"><span class="lineannotation">&lt;!-- it is totally supported, 100% legal in Spring 2.x, but see also above for the sleeker, Spring 2.0 style --&gt;</span></i>
  &lt;bean id="myProductService"
      class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
    &lt;property name="transactionManager" ref="myTxManager"/&gt;
    &lt;property name="target"&gt;
      &lt;bean class="product.ProductServiceImpl"&gt;
        &lt;property name="productDao" ref="myProductDao"/&gt;
        &lt;property name="inventoryDao" ref="myInventoryDao"/&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="transactionAttributes"&gt;
      &lt;props&gt;
        &lt;prop key="increasePrice*"&gt;PROPAGATION_REQUIRED&lt;/prop&gt;
        &lt;prop key="someOtherBusinessMethod"&gt;PROPAGATION_REQUIRES_NEW&lt;/prop&gt;
        &lt;prop key="*"&gt;PROPAGATION_SUPPORTS,readOnly&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Both <tt class="classname">HibernateTransactionManager</tt> and
      <tt class="classname">JtaTransactionManager</tt> allow for proper JVM-level
      cache handling with Hibernate - without container-specific transaction
      manager lookup or JCA connector (as long as not using EJB to initiate
      transactions).</p><p><tt class="classname">HibernateTransactionManager</tt> can export the
      JDBC <tt class="interfacename">Connection</tt> used by Hibernate to
      plain JDBC access code, for a specific
      <tt class="interfacename">DataSource</tt>. This allows for high-level
      transaction demarcation with mixed Hibernate/JDBC data access completely
      without JTA, as long as you are just accessing one database!
      <tt class="classname">HibernateTransactionManager</tt> will automatically
      expose the Hibernate transaction as JDBC transaction if the passed-in
      <tt class="interfacename">SessionFactory</tt> has been set up with a
      <tt class="interfacename">DataSource</tt> (through the "dataSource"
      property of the <tt class="classname">LocalSessionFactoryBean</tt> class).
      Alternatively, the <tt class="interfacename">DataSource</tt> that the
      transactions are supposed to be exposed for can also be specified
      explicitly, through the "dataSource" property of the
      <tt class="classname">HibernateTransactionManager</tt> class.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-resources"></a>12.2.9.&nbsp;Container resources versus local resources</h3></div></div><div></div></div><p>Spring's resource management allows for simple switching between a
      JNDI <tt class="interfacename">SessionFactory</tt> and a local one,
      without having to change a single line of application code. The decision
      as to whether to keep the resource definitions in the container or
      locally within the application, is mainly a matter of the transaction
      strategy being used. Compared to a Spring-defined local
      <tt class="interfacename">SessionFactory</tt>, a manually registered
      JNDI <tt class="interfacename">SessionFactory</tt> does not provide any
      benefits. Deploying a <tt class="interfacename">SessionFactory</tt>
      through Hibernate's JCA connector provides the added value of
      participating in the J2EE server's management infrastructure, but does
      not add actual value beyond that.</p><p>An important benefit of Spring's transaction support is that it
      isn't bound to a container at all. Configured to any other strategy than
      JTA, it will work in a standalone or test environment too. Especially
      for the typical case of single-database transactions, this is a very
      lightweight and powerful alternative to JTA. When using local EJB
      Stateless Session Beans to drive transactions, you depend both on an EJB
      container and JTA - even if you just access a single database anyway,
      and just use SLSBs for declarative transactions via CMT. The alternative
      of using JTA programmatically requires a J2EE environment as well. JTA
      does not just involve container dependencies in terms of JTA itself and
      of JNDI <tt class="interfacename">DataSource</tt> instances. For
      non-Spring JTA-driven Hibernate transactions, you have to use the
      Hibernate JCA connector, or extra Hibernate transaction code with the
      <tt class="interfacename">TransactionManagerLookup</tt> being configured
      for proper JVM-level caching.</p><p>Spring-driven transactions can work with a locally defined
      Hibernate <tt class="interfacename">SessionFactory</tt> nicely, just
      like with a local JDBC <tt class="interfacename">DataSource</tt> - if
      accessing a single database, of course. Therefore you just have to fall
      back to Spring's JTA transaction strategy when actually facing
      distributed transaction requirements. Note that a JCA connector needs
      container-specific deployment steps, and obviously JCA support in the
      first place. This is far more hassle than deploying a simple web app
      with local resource definitions and Spring-driven transactions. And you
      often need the Enterprise Edition of your container, as for example
      WebLogic Express does not provide JCA. A Spring application with local
      resources and transactions spanning one single database will work in any
      J2EE web container (without JTA, JCA, or EJB) - like Tomcat, Resin, or
      even plain Jetty. Additionally, such a middle tier can be reused in
      desktop applications or test suites easily.</p><p>All things considered: if you do not use EJB, stick with local
      <tt class="interfacename">SessionFactory</tt> setup and Spring's
      <tt class="classname">HibernateTransactionManager</tt> or
      <tt class="classname">JtaTransactionManager</tt>. You will get all of the
      benefits including proper transactional JVM-level caching and
      distributed transactions, without any container deployment hassle. JNDI
      registration of a Hibernate
      <tt class="interfacename">SessionFactory</tt> via the JCA connector
      really only adds value when used in conjunction with EJBs.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-hibernate-invalid-jdbc-access-error"></a>12.2.10.&nbsp;Spurious application server warnings when using Hibernate</h3></div></div><div></div></div><p>In some JTA environments with very strict
      <tt class="interfacename">XADataSource</tt> implementations -- currently
      only some WebLogic and WebSphere versions -- when using Hibernate
      configured without any awareness of the JTA
      <tt class="interfacename">PlatformTransactionManager</tt> object for
      that environment, it is possible for spurious warning or exceptions to
      show up in the application server log. These warnings or exceptions will
      say something to the effect that the connection being accessed is no
      longer valid, or JDBC access is no longer valid, possibly because the
      transaction is no longer active. As an example, here is an actual
      exception from WebLogic:</p><pre class="programlisting">java.sql.SQLException: The transaction is no longer active - status: 'Committed'.
   No further JDBC access is allowed within this transaction.</pre><p>This warning is easy to resolve by simply making Hibernate aware
      of the JTA <tt class="interfacename">PlatformTransactionManager</tt>
      instance, to which it will also synchronize (along with Spring). This
      may be done in two ways:</p><div class="itemizedlist"><ul type="disc"><li><p>If in your application context you are already directly
          obtaining the JTA
          <tt class="interfacename">PlatformTransactionManager</tt> object
          (presumably from JNDI via <tt class="literal">JndiObjectFactoryBean</tt>)
          and feeding it for example to Spring's
          <tt class="classname">JtaTransactionManager</tt>, then the easiest way
          is to simply specify a reference to this as the value of
          <tt class="classname">LocalSessionFactoryBean</tt>'s
          <span class="emphasis"><em>jtaTransactionManager</em></span> property. Spring will
          then make the object available to Hibernate.</p></li><li><p>More likely you do not already have the JTA
          <tt class="interfacename">PlatformTransactionManager</tt> instance
          (since Spring's <tt class="classname">JtaTransactionManager</tt> can
          find it itself) so you need to instead configure Hibernate to also
          look it up directly. This is done by configuring an AppServer
          specific <tt class="literal">TransactionManagerLookup</tt> class in the
          Hibernate configuration, as described in the Hibernate
          manual.</p></li></ul></div><p>It is not necessary to read any more for proper usage, but the
      full sequence of events with and without Hibernate being aware of the
      JTA <tt class="interfacename">PlatformTransactionManager</tt> will now
      be described.</p><p>When Hibernate is not configured with any awareness of the JTA
      <tt class="interfacename">PlatformTransactionManager</tt>, the sequence
      of events when a JTA transaction commits is as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>JTA transaction commits</p></li><li><p>Spring's <tt class="classname">JtaTransactionManager</tt> is
          synchronized to the JTA transaction, so it is called back via an
          <span class="emphasis"><em>afterCompletion</em></span> callback by the JTA transaction
          manager.</p></li><li><p>Among other activities, this can trigger a callback by Spring
          to Hibernate, via Hibernate's
          <tt class="literal">afterTransactionCompletion</tt> callback (used to
          clear the Hibernate cache), followed by an explicit
          <tt class="literal">close()</tt> call on the Hibernate Session, which
          results in Hibernate trying to <tt class="literal">close()</tt> the JDBC
          Connection.</p></li><li><p>In some environments, this
          <tt class="methodname">Connection.close()</tt> call then triggers the
          warning or error, as the application server no longer considers the
          <tt class="interfacename">Connection</tt> usable at all, since the
          transaction has already been committed.</p></li></ul></div><p>When Hibernate is configured with awareness of the JTA
      <tt class="interfacename">PlatformTransactionManager</tt>, the sequence
      of events when a JTA transaction commits is instead as follows:</p><div class="itemizedlist"><ul type="disc"><li><p>JTA transaction is ready to commit</p></li><li><p>Spring's <tt class="classname">JtaTransactionManager</tt> is
          synchronized to the JTA transaction, so it is called back via a
          <span class="emphasis"><em>beforeCompletion</em></span> callback by the JTA
          transaction manager.</p></li><li><p>Spring is aware that Hibernate itself is synchronized to the
          JTA transaction, and behaves differently than in the previous
          scenario. Assuming the Hibernate
          <tt class="interfacename">Session</tt> needs to be closed at all,
          Spring will close it now.</p></li><li><p>JTA Transaction commits</p></li><li><p>Hibernate is synchronized to the JTA transaction, so it is
          called back via an <span class="emphasis"><em>afterCompletion</em></span> callback by
          the JTA transaction manager, and can properly clear its
          cache.</p></li></ul></div><p></p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-jdo"></a>12.3.&nbsp;JDO</h2></div></div><div></div></div><p>Spring supports the standard JDO 2.0/2.1 API as data access
    strategy, following the same style as the Hibernate support. The
    corresponding integration classes reside in the
    <tt class="literal">org.springframework.orm.jdo</tt> package.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jdo-setup"></a>12.3.1.&nbsp;<tt class="interfacename">PersistenceManagerFactory</tt>
      setup</h3></div></div><div></div></div><p>Spring provides a
      <tt class="classname">LocalPersistenceManagerFactoryBean</tt> class that
      allows for defining a local JDO
      <tt class="interfacename">PersistenceManagerFactory</tt> within a Spring
      application context:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myPmf" class="org.springframework.orm.jdo.LocalPersistenceManagerFactoryBean"&gt;
    &lt;property name="configLocation" value="classpath:kodo.properties"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Alternatively, a
      <tt class="interfacename">PersistenceManagerFactory</tt> can also be set
      up through direct instantiation of a
      <tt class="interfacename">PersistenceManagerFactory</tt> implementation
      class. A JDO <tt class="interfacename">PersistenceManagerFactory</tt>
      implementation class is supposed to follow the JavaBeans pattern, just
      like a JDBC <tt class="interfacename">DataSource</tt> implementation
      class, which is a natural fit for a Spring bean definition. This setup
      style usually supports a Spring-defined JDBC
      <tt class="interfacename">DataSource</tt>, passed into the
      "connectionFactory" property. For example, for the open source JDO
      implementation JPOX (<a href="http://www.jpox.org" target="_top">http://www.jpox.org</a>):</p><pre class="programlisting">&lt;beans&gt;

 &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
   &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
   &lt;property name="url" value="${jdbc.url}"/&gt;
   &lt;property name="username" value="${jdbc.username}"/&gt;
   &lt;property name="password" value="${jdbc.password}"/&gt;
 &lt;/bean&gt;

 &lt;bean id="myPmf" class="org.jpox.PersistenceManagerFactoryImpl" destroy-method="close"&gt;
   &lt;property name="connectionFactory" ref="dataSource"/&gt;
   &lt;property name="nontransactionalRead" value="true"/&gt;
 &lt;/bean&gt;

&lt;/beans&gt;</pre><p>A JDO <tt class="interfacename">PersistenceManagerFactory</tt> can
      also be set up in the JNDI environment of a J2EE application server,
      usually through the JCA connector provided by the particular JDO
      implementation. Spring's standard
      <tt class="literal">JndiObjectFactoryBean</tt> can be used to retrieve and
      expose such a <tt class="interfacename">PersistenceManagerFactory</tt>.
      However, outside an EJB context, there is often no compelling benefit in
      holding the <tt class="interfacename">PersistenceManagerFactory</tt> in
      JNDI: only choose such setup for a good reason. See "container resources
      versus local resources" in the Hibernate section for a discussion; the
      arguments there apply to JDO as well.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jdo-template"></a>12.3.2.&nbsp;<tt class="classname">JdoTemplate</tt> and
      <tt class="classname">JdoDaoSupport</tt></h3></div></div><div></div></div><p>Each JDO-based DAO will then receive the
      <tt class="interfacename">PersistenceManagerFactory</tt> through
      dependency injection. Such a DAO could be coded against plain JDO API,
      working with the given
      <tt class="interfacename">PersistenceManagerFactory</tt>, but will
      usually rather be used with the Spring Framework's
      <tt class="classname">JdoTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</pre><pre class="programlisting">public class ProductDaoImpl implements ProductDao {
  
    private JdoTemplate jdoTemplate;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.jdoTemplate = new JdoTemplate(pmf);
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        return (Collection) this.jdoTemplate.execute(new JdoCallback() {
            public Object doInJdo(PersistenceManager pm) throws JDOException {
                Query query = pm.newQuery(Product.class, "category = pCategory");
                query.declareParameters("String pCategory"); 
                List result = query.execute(category);
                <i class="lineannotation"><span class="lineannotation">// do some further stuff with the result list</span></i>
                return result;
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any JDO data
      access. <tt class="classname">JdoTemplate</tt> will ensure that
      <tt class="classname">PersistenceManager</tt>s are properly opened and
      closed, and automatically participate in transactions. The template
      instances are thread-safe and reusable, they can thus be kept as
      instance variables of the surrounding class. For simple single-step
      actions such as a single <tt class="literal">find</tt>,
      <tt class="literal">load</tt>, <tt class="literal">makePersistent</tt>, or
      <tt class="literal">delete</tt> call, <tt class="classname">JdoTemplate</tt>
      offers alternative convenience methods that can replace such one line
      callback implementations. Furthermore, Spring provides a convenient
      <tt class="classname">JdoDaoSupport</tt> base class that provides a
      <tt class="literal">setPersistenceManagerFactory(..)</tt> method for receiving
      a <tt class="classname">PersistenceManagerFactory</tt>, and
      <tt class="methodname">getPersistenceManagerFactory()</tt> and
      <tt class="methodname">getJdoTemplate()</tt> for use by subclasses. In
      combination, this allows for very simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends JdoDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        return getJdoTemplate().find(
            Product.class, "category = pCategory", "String category", new Object[] {category});
    }
}</pre><p>As alternative to working with Spring's
      <tt class="classname">JdoTemplate</tt>, you can also code Spring-based DAOs
      at the JDO API level, explicitly opening and closing a
      <tt class="interfacename">PersistenceManager</tt>. As elaborated in the
      corresponding Hibernate section, the main advantage of this approach is
      that your data access code is able to throw checked exceptions.
      <tt class="classname">JdoDaoSupport</tt> offers a variety of support methods
      for this scenario, for fetching and releasing a transactional
      <tt class="interfacename">PersistenceManager</tt> as well as for
      converting exceptions.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jdo-daos-straight"></a>12.3.3.&nbsp;Implementing DAOs based on the plain JDO API</h3></div></div><div></div></div><p>DAOs can also be written against plain JDO API, without any Spring
      dependencies, directly using an injected
      <tt class="interfacename">PersistenceManagerFactory</tt>. A
      corresponding DAO implementation looks like as follows:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private PersistenceManagerFactory persistenceManagerFactory;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.persistenceManagerFactory = pmf;
    }

    public Collection loadProductsByCategory(String category) {
        PersistenceManager pm = this.persistenceManagerFactory.getPersistenceManager();
        try {
            Query query = pm.newQuery(Product.class, "category = pCategory");
            query.declareParameters("String pCategory"); 
            return query.execute(category);
        }
        finally {
          pm.close();
        }
    }
}</pre><p>As the above DAO still follows the Dependency Injection pattern,
      it still fits nicely into a Spring container, just like it would if
      coded against Spring's <tt class="classname">JdoTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The main issue with such DAOs is that they always get a new
      <tt class="interfacename">PersistenceManager</tt> from the factory. To
      still access a Spring-managed transactional
      <tt class="interfacename">PersistenceManager</tt>, consider defining a
      <tt class="classname">TransactionAwarePersistenceManagerFactoryProxy</tt>
      (as included in Spring) in front of your target
      <tt class="interfacename">PersistenceManagerFactory</tt>, passing the
      proxy into your DAOs.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myPmfProxy"
      class="org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy"&gt;
    &lt;property name="targetPersistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmfProxy"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Your data access code will then receive a transactional
      <tt class="interfacename">PersistenceManager</tt> (if any) from the
      <tt class="methodname">PersistenceManagerFactory.getPersistenceManager()</tt>
      method that it calls. The latter method call goes through the proxy,
      which will first check for a current transactional
      <tt class="interfacename">PersistenceManager</tt> before getting a new
      one from the factory. <tt class="methodname">close()</tt> calls on the
      <tt class="interfacename">PersistenceManager</tt> will be ignored in
      case of a transactional
      <tt class="interfacename">PersistenceManager</tt>.</p><p>If your data access code will always run within an active
      transaction (or at least within active transaction synchronization), it
      is safe to omit the <tt class="methodname">PersistenceManager.close()</tt>
      call and thus the entire <tt class="literal">finally</tt> block, which you
      might prefer to keep your DAO implementations concise:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private PersistenceManagerFactory persistenceManagerFactory;

    public void setPersistenceManagerFactory(PersistenceManagerFactory pmf) {
        this.persistenceManagerFactory = pmf;
    }

    public Collection loadProductsByCategory(String category) {
        PersistenceManager pm = this.persistenceManagerFactory.getPersistenceManager();
        Query query = pm.newQuery(Product.class, "category = pCategory");
        query.declareParameters("String pCategory"); 
        return query.execute(category);
    }
}</pre><p>With such DAOs that rely on active transactions, it is recommended
      to enforce active transactions through turning
      <tt class="classname">TransactionAwarePersistenceManagerFactoryProxy</tt>'s
      "allowCreate" flag off:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myPmfProxy"
      class="org.springframework.orm.jdo.TransactionAwarePersistenceManagerFactoryProxy"&gt;
    &lt;property name="targetPersistenceManagerFactory" ref="myPmf"/&gt;
    &lt;property name="allowCreate" value="false"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmfProxy"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on JDO API
      only; no import of any Spring class is required. This is of course
      appealing from a non-invasiveness perspective, and might feel more
      natural to JDO developers.</p><p>However, the DAO throws plain
      <tt class="exceptionname">JDOException</tt> (which is unchecked, so does
      not have to be declared or caught), which means that callers can only
      treat exceptions as generally fatal - unless they want to depend on
      JDO's own exception structure. Catching specific causes such as an
      optimistic locking failure is not possible without tying the caller to
      the implementation strategy. This tradeoff might be acceptable to
      applications that are strongly JDO-based and/or do not need any special
      exception treatment.</p><p>In summary: DAOs can be implemented based on plain JDO API, while
      still being able to participate in Spring-managed transactions. This
      might in particular appeal to people already familiar with JDO, feeling
      more natural to them. However, such DAOs will throw plain
      <tt class="exceptionname">JDOException</tt>; conversion to Spring's
      <tt class="exceptionname">DataAccessException</tt> would have to happen
      explicitly (if desired).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jdo-tx"></a>12.3.4.&nbsp;Transaction management</h3></div></div><div></div></div><p>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans
        xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:aop="http://www.springframework.org/schema/aop"
        xmlns:tx="http://www.springframework.org/schema/tx"
        xsi:schemaLocation="
   http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;bean id="myTxManager" class="org.springframework.orm.jdo.JdoTransactionManager"&gt;
    &lt;property name="persistenceManagerFactory" ref="myPmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="txManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="increasePrice*" propagation="REQUIRED"/&gt;
      &lt;tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/&gt;
      &lt;tx:method name="*" propagation="SUPPORTS" read-only="true"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

  &lt;aop:config&gt;
    &lt;aop:pointcut id="productServiceMethods" expression="execution(* product.ProductService.*(..))"/&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/&gt;
  &lt;/aop:config&gt;

&lt;/beans&gt;</pre><p>Note that JDO requires an active transaction when modifying a
      persistent object. There is no concept like a non-transactional flush in
      JDO, in contrast to Hibernate. For this reason, the chosen JDO
      implementation needs to be set up for a specific environment: in
      particular, it needs to be explicitly set up for JTA synchronization, to
      detect an active JTA transaction itself. This is not necessary for local
      transactions as performed by Spring's
      <tt class="classname">JdoTransactionManager</tt>, but it is necessary for
      participating in JTA transactions (whether driven by Spring's
      <tt class="classname">JtaTransactionManager</tt> or by EJB CMT / plain
      JTA).</p><p><tt class="classname">JdoTransactionManager</tt> is capable of
      exposing a JDO transaction to JDBC access code that accesses the same
      JDBC <tt class="interfacename">DataSource</tt>, provided that the
      registered <tt class="classname">JdoDialect</tt> supports retrieval of the
      underlying JDBC <tt class="interfacename">Connection</tt>. This is
      the case for JDBC-based JDO 2.0 implementations by default.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jdo-dialect"></a>12.3.5.&nbsp;<tt class="interfacename">JdoDialect</tt></h3></div></div><div></div></div><p>As an advanced feature, both <tt class="classname">JdoTemplate</tt>
      and <tt class="classname">interfacename</tt> support a custom
      <tt class="interfacename">JdoDialect</tt>, to be passed into the
      "jdoDialect" bean property. In such a scenario, the DAOs won't receive a
      <tt class="interfacename">PersistenceManagerFactory</tt> reference but
      rather a full <tt class="classname">JdoTemplate</tt> instance instead (for
      example, passed into <tt class="classname">JdoDaoSupport</tt>'s
      "jdoTemplate" property). A <tt class="interfacename">JdoDialect</tt>
      implementation can enable some advanced features supported by Spring,
      usually in a vendor-specific manner:</p><div class="itemizedlist"><ul type="disc"><li><p>applying specific transaction semantics (such as custom
          isolation level or transaction timeout)</p></li><li><p>retrieving the transactional JDBC
          <tt class="interfacename">Connection</tt> (for exposure to
          JDBC-based DAOs)</p></li><li><p>applying query timeouts (automatically calculated from
          Spring-managed transaction timeout)</p></li><li><p>eagerly flushing a
          <tt class="interfacename">PersistenceManager</tt> (to make
          transactional changes visible to JDBC-based data access code)</p></li><li><p>advanced translation of <tt class="literal">JDOExceptions</tt> to
          Spring <tt class="literal">DataAccessExceptions</tt></p></li></ul></div><p>See the <tt class="classname">JdoDialect</tt> Javadoc for more details
      on its operations and how they are used within Spring's JDO support.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-toplink"></a>12.4.&nbsp;Oracle TopLink</h2></div></div><div></div></div><p>Since Spring 1.2, Spring supports Oracle TopLink (<a href="http://www.oracle.com/technology/products/ias/toplink" target="_top">http://www.oracle.com/technology/products/ias/toplink</a>) as
    data access strategy, following the same style as the Hibernate support.
    Both TopLink 9.0.4 (the production version as of Spring 1.2) and 10.1.3
    (still in beta as of Spring 1.2) are supported. The corresponding
    integration classes reside in the
    <tt class="literal">org.springframework.orm.toplink</tt> package.</p><p>Spring's TopLink support has been co-developed with the Oracle
    TopLink team. Many thanks to the TopLink team, in particular to Jim Clark
    who helped to clarify details in all areas!</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-toplink-abstraction"></a>12.4.1.&nbsp;<tt class="interfacename">SessionFactory</tt> abstraction</h3></div></div><div></div></div><p>TopLink itself does not ship with a SessionFactory abstraction.
      Instead, multi-threaded access is based on the concept of a central
      <tt class="literal">ServerSession</tt>, which in turn is able to spawn
      <tt class="literal">ClientSession</tt> instances for single-threaded usage.
      For flexible setup options, Spring defines a
      <tt class="interfacename">SessionFactory</tt> abstraction for TopLink,
      enabling to switch between different
      <tt class="interfacename">Session</tt> creation strategies.</p><p>As a one-stop shop, Spring provides a
      <tt class="classname">LocalSessionFactoryBean</tt> class that allows for
      defining a TopLink <tt class="interfacename">SessionFactory</tt> with
      bean-style configuration. It needs to be configured with the location of
      the TopLink session configuration file, and usually also receives a
      Spring-managed JDBC <tt class="interfacename">DataSource</tt> to
      use.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="mySessionFactory" class="org.springframework.orm.toplink.LocalSessionFactoryBean"&gt;
    &lt;property name="configLocation" value="toplink-sessions.xml"/&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;
    
&lt;/beans&gt;</pre><pre class="programlisting">&lt;toplink-configuration&gt;

  &lt;session&gt;
    &lt;name&gt;Session&lt;/name&gt;
    &lt;project-xml&gt;toplink-mappings.xml&lt;/project-xml&gt;
    &lt;session-type&gt;
      &lt;server-session/&gt;
    &lt;/session-type&gt;
    &lt;enable-logging&gt;true&lt;/enable-logging&gt;
    &lt;logging-options/&gt;
  &lt;/session&gt;

&lt;/toplink-configuration&gt;</pre><p>Usually, <tt class="classname">LocalSessionFactoryBean</tt> will hold
      a multi-threaded TopLink <tt class="literal">ServerSession</tt> underneath and
      create appropriate client <tt class="interfacename">Session</tt>s for
      it: either a plain <tt class="interfacename">Session</tt> (typical), a
      managed <tt class="literal">ClientSession</tt>, or a transaction-aware
      <tt class="interfacename">Session</tt> (the latter are mainly used
      internally by Spring's TopLink support). It might also hold a
      single-threaded TopLink <tt class="literal">DatabaseSession</tt>; this is
      rather unusual, though.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-toplink-template"></a>12.4.2.&nbsp;<tt class="classname">TopLinkTemplate</tt> and
      <tt class="classname">TopLinkDaoSupport</tt></h3></div></div><div></div></div><p>Each TopLink-based DAO will then receive the
      <tt class="interfacename">SessionFactory</tt> through dependency
      injection, i.e. through a bean property setter or through a constructor
      argument. Such a DAO could be coded against plain TopLink API, fetching
      a <tt class="interfacename">Session</tt> from the given
      <tt class="interfacename">SessionFactory</tt>, but will usually rather
      be used with Spring's <tt class="literal">TopLinkTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;
  
  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;
  
&lt;/beans&gt;</pre><pre class="programlisting">public class TopLinkProductDao implements ProductDao {
  
    private TopLinkTemplate tlTemplate;

    public void setSessionFactory(SessionFactory sessionFactory) {
        this.tlTemplate = new TopLinkTemplate(sessionFactory);
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        return (Collection) this.tlTemplate.execute(new TopLinkCallback() {
            public Object doInTopLink(Session session) throws TopLinkException {
                ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
                findOwnersQuery.addArgument("Category");
                ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
                findOwnersQuery.setSelectionCriteria(
                    builder.get("category").like(builder.getParameter("Category")));

                Vector args = new Vector();
                args.add(category);
                List result = session.executeQuery(findOwnersQuery, args);
                <i class="lineannotation"><span class="lineannotation">// do some further stuff with the result list</span></i>
                return result;
            }
        });
    }
}</pre><p>A callback implementation can effectively be used for any TopLink
      data access. <tt class="classname">TopLinkTemplate</tt> will ensure that
      <tt class="interfacename">Session</tt>s are properly opened and closed,
      and automatically participate in transactions. The template instances
      are thread-safe and reusable, they can thus be kept as instance
      variables of the surrounding class. For simple single-step actions such
      as a single <tt class="literal">executeQuery</tt>, <tt class="literal">readAll</tt>,
      <tt class="literal">readById</tt>, or <tt class="literal">merge</tt> call,
      <tt class="classname">JdoTemplate</tt> offers alternative convenience
      methods that can replace such one line callback implementations.
      Furthermore, Spring provides a convenient
      <tt class="classname">TopLinkDaoSupport</tt> base class that provides a
      <tt class="literal">setSessionFactory(..)</tt> method for receiving a
      <tt class="interfacename">SessionFactory</tt>, and
      <tt class="literal">getSessionFactory()</tt> and
      <tt class="literal">getTopLinkTemplate()</tt> for use by subclasses. In
      combination, this allows for simple DAO implementations for typical
      requirements:</p><pre class="programlisting">public class ProductDaoImpl extends TopLinkDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
        findOwnersQuery.addArgument("Category");
        ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
        findOwnersQuery.setSelectionCriteria(
            builder.get("category").like(builder.getParameter("Category")));

        return getTopLinkTemplate().executeQuery(findOwnersQuery, new Object[] {category});
    }
}</pre><p>Side note: TopLink query objects are thread-safe and can be cached
      within the DAO, i.e. created on startup and kept in instance
      variables.</p><p>As alternative to working with Spring's
      <tt class="classname">TopLinkTemplate</tt>, you can also code your TopLink
      data access based on the raw TopLink API, explicitly opening and closing
      a <tt class="interfacename">Session</tt>. As elaborated in the
      corresponding Hibernate section, the main advantage of this approach is
      that your data access code is able to throw checked exceptions.
      <tt class="classname">TopLinkDaoSupport</tt> offers a variety of support
      methods for this scenario, for fetching and releasing a transactional
      <tt class="interfacename">Session</tt> as well as for converting
      exceptions.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-toplink-straight"></a>12.4.3.&nbsp;Implementing DAOs based on plain TopLink API</h3></div></div><div></div></div><p>DAOs can also be written against plain TopLink API, without any
      Spring dependencies, directly using an injected TopLink
      <tt class="interfacename">Session</tt>. The latter will usually be based
      on a <tt class="interfacename">SessionFactory</tt> defined by a
      <tt class="classname">LocalSessionFactoryBean</tt>, exposed for bean
      references of type <tt class="interfacename">Session</tt> through
      Spring's <tt class="literal">TransactionAwareSessionAdapter</tt>.</p><p>The <tt class="literal">getActiveSession()</tt> method defined on
      TopLink's <tt class="interfacename">Session</tt> interface will return
      the current transactional <tt class="interfacename">Session</tt> in such
      a scenario. If there is no active transaction, it will return the shared
      TopLink <tt class="literal">ServerSession</tt> as-is, which is only supposed
      to be used directly for read-only access. There is also an analogous
      <tt class="methodname">getActiveUnitOfWork()</tt> method, returning the
      TopLink <tt class="interfacename">UnitOfWork</tt> associated with the
      current transaction, if any (returning <tt class="literal">null</tt>
      else).</p><p>A corresponding DAO implementation looks like as follows:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private Session session;

    public void setSession(Session session) {
        this.session = session;
    }

    public Collection loadProductsByCategory(String category) {
        ReadAllQuery findOwnersQuery = new ReadAllQuery(Product.class);
        findOwnersQuery.addArgument("Category");
        ExpressionBuilder builder = this.findOwnersQuery.getExpressionBuilder();
        findOwnersQuery.setSelectionCriteria(
            builder.get("category").like(builder.getParameter("Category")));

        Vector args = new Vector();
        args.add(category);
        return session.getActiveSession().executeQuery(findOwnersQuery, args);
    }
}</pre><p>As the above DAO still follows the Dependency Injection pattern,
      it still fits nicely into a Spring application context, analogous to
      like it would if coded against Spring's
      <tt class="classname">TopLinkTemplate</tt>. Spring's
      <tt class="literal">TransactionAwareSessionAdapter</tt> is used to expose a
      bean reference of type <tt class="interfacename">Session</tt>, to be
      passed into the DAO:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="mySessionAdapter"
      class="org.springframework.orm.toplink.support.TransactionAwareSessionAdapter"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="session" ref="mySessionAdapter"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The main advantage of this DAO style is that it depends on TopLink
      API only; no import of any Spring class is required. This is of course
      appealing from a non-invasiveness perspective, and might feel more
      natural to TopLink developers.</p><p>However, the DAO throws plain
      <tt class="exceptionname">TopLinkException</tt> (which is unchecked, so
      does not have to be declared or caught), which means that callers can
      only treat exceptions as generally fatal - unless they want to depend on
      TopLink's own exception structure. Catching specific causes such as an
      optimistic locking failure is not possible without tying the caller to
      the implementation strategy. This tradeoff might be acceptable to
      applications that are strongly TopLink-based and/or do not need any
      special exception treatment.</p><p>A further disadvantage of that DAO style is that TopLink's
      standard <tt class="methodname">getActiveSession()</tt> feature just works
      within JTA transactions. It does <span class="emphasis"><em>not</em></span> work with any
      other transaction strategy out-of-the-box, in particular not with local
      TopLink transactions.</p><p>Fortunately, Spring's
      <tt class="literal">TransactionAwareSessionAdapter</tt> exposes a
      corresponding proxy for the TopLink <tt class="literal">ServerSession</tt>
      which supports TopLink's <tt class="literal">Session.getActiveSession()</tt>
      and <tt class="literal">Session.getActiveUnitOfWork()</tt> methods for any
      Spring transaction strategy, returning the current Spring-managed
      transactional <tt class="interfacename">Session</tt> even with
      <tt class="literal">TopLinkTransactionManager</tt>. Of course, the standard
      behavior of that method remains: returning the current
      <tt class="interfacename">Session</tt> associated with the ongoing JTA
      transaction, if any (no matter whether driven by Spring's
      <tt class="classname">JtaTransactionManager</tt>, by EJB CMT, or by plain
      JTA).</p><p>In summary: DAOs can be implemented based on plain TopLink API,
      while still being able to participate in Spring-managed transactions.
      This might in particular appeal to people already familiar with TopLink,
      feeling more natural to them. However, such DAOs will throw plain
      <tt class="exceptionname">TopLinkException</tt>; conversion to Spring's
      <tt class="classname">DataAccessException</tt> would have to happen
      explicitly (if desired).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-toplink-tx"></a>12.4.4.&nbsp;Transaction management</h3></div></div><div></div></div><p>To execute service operations within transactions, you can use
      Spring's common declarative transaction facilities. For example:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans
        xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:aop="http://www.springframework.org/schema/aop"
        xmlns:tx="http://www.springframework.org/schema/tx"
        xsi:schemaLocation="
   http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
   http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
   http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;bean id="myTxManager" class="org.springframework.orm.toplink.TopLinkTransactionManager"&gt;
    &lt;property name="sessionFactory" ref="mySessionFactory"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;
  
  &lt;aop:config&gt;
    &lt;aop:pointcut id="productServiceMethods" expression="execution(* product.ProductService.*(..))"/&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/&gt;
  &lt;/aop:config&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="myTxManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="increasePrice*" propagation="REQUIRED"/&gt;
      &lt;tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/&gt;
      &lt;tx:method name="*" propagation="SUPPORTS" read-only="true"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

&lt;/beans&gt;</pre><p>Note that TopLink requires an active
      <tt class="interfacename">UnitOfWork</tt> for modifying a persistent
      object. (You should never modify objects returned by a plain TopLink
      <tt class="interfacename">Session</tt> - those are usually read-only
      objects, directly taken from the second-level cache!) There is no
      concept like a non-transactional flush in TopLink, in contrast to
      Hibernate. For this reason, TopLink needs to be set up for a specific
      environment: in particular, it needs to be explicitly set up for JTA
      synchronization, to detect an active JTA transaction itself and expose a
      corresponding active <tt class="interfacename">Session</tt> and
      <tt class="interfacename">UnitOfWork</tt>. This is not necessary for
      local transactions as performed by Spring's
      <tt class="literal">TopLinkTransactionManager</tt>, but it is necessary for
      participating in JTA transactions (whether driven by Spring's
      <tt class="classname">JtaTransactionManager</tt> or by EJB CMT / plain
      JTA).</p><p>Within your TopLink-based DAO code, use the
      <tt class="literal">Session.getActiveUnitOfWork()</tt> method to access the
      current <tt class="interfacename">UnitOfWork</tt> and perform write
      operations through it. This will only work within an active transaction
      (both within Spring-managed transactions and plain JTA transactions).
      For special needs, you can also acquire separate
      <tt class="interfacename">UnitOfWork</tt> instances that won't
      participate in the current transaction; this is hardly needed,
      though.</p><p><tt class="classname">TopLinkTransactionManager</tt> is capable of
      exposing a TopLink transaction to JDBC access code that accesses the
      same JDBC <tt class="interfacename">DataSource</tt>, provided that
      TopLink works with JDBC in the backend and is thus able to expose the
      underlying JDBC <tt class="interfacename">Connection</tt>. The
      <tt class="interfacename">DataSource</tt> to expose the transactions for
      needs to be specified explicitly; it won't be autodetected.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-ibatis"></a>12.5.&nbsp;iBATIS SQL Maps</h2></div></div><div></div></div><p>The iBATIS support in the Spring Framework much resembles the JDBC /
    Hibernate support in that it supports the same template style programming
    and just as with JDBC or Hibernate, the iBATIS support works with Spring's
    exception hierarchy and let's you enjoy the all IoC features Spring
    has.</p><p>Transaction management can be handled through Spring's standard
    facilities. There are no special transaction strategies for iBATIS, as
    there is no special transactional resource involved other than a JDBC
    <tt class="interfacename">Connection</tt>. Hence, Spring's standard JDBC
    <tt class="classname">DataSourceTransactionManager</tt> or
    <tt class="classname">JtaTransactionManager</tt> are perfectly
    sufficient.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Spring does actually support both iBatis 1.x and 2.x. However,
      only support for iBatis 2.x is actually shipped with the core Spring
      distribution. The iBatis 1.x support classes were moved to the Spring
      Modules project as of Spring 2.0, and you are directed there for
      documentation.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-ibatis-setup"></a>12.5.1.&nbsp;Setting up the <tt class="classname">SqlMapClient</tt></h3></div></div><div></div></div><p>If we want to map the previous Account class with iBATIS 2.x we
      need to create the following SQL map
      <tt class="filename">'Account.xml'</tt>:</p><pre class="programlisting">&lt;sqlMap namespace="Account"&gt;

  &lt;resultMap id="result" class="examples.Account"&gt;
    &lt;result property="name" column="NAME" columnIndex="1"/&gt;
    &lt;result property="email" column="EMAIL" columnIndex="2"/&gt;
  &lt;/resultMap&gt;

  &lt;select id="getAccountByEmail" resultMap="result"&gt;
    select ACCOUNT.NAME, ACCOUNT.EMAIL
    from ACCOUNT
    where ACCOUNT.EMAIL = #value#
  &lt;/select&gt;

  &lt;insert id="insertAccount"&gt;
    insert into ACCOUNT (NAME, EMAIL) values (#name#, #email#)
  &lt;/insert&gt;

&lt;/sqlMap&gt;</pre><p>The configuration file for iBATIS 2 looks like this:</p><pre class="programlisting">&lt;sqlMapConfig&gt;

  &lt;sqlMap resource="example/Account.xml"/&gt;

&lt;/sqlMapConfig&gt;</pre><p>Remember that iBATIS loads resources from the class path, so be
      sure to add the <tt class="filename">'Account.xml'</tt> file to the class
      path.</p><p>We can use the <tt class="classname">SqlMapClientFactoryBean</tt> in
      the Spring container. Note that with iBATIS SQL Maps 2.x, the JDBC
      <tt class="interfacename">DataSource</tt> is usually specified on the
      <tt class="classname">SqlMapClientFactoryBean</tt>, which enables lazy
      loading.</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
  &lt;/bean&gt;

  &lt;bean id="sqlMapClient" class="org.springframework.orm.ibatis.SqlMapClientFactoryBean"&gt;
    &lt;property name="configLocation" value="WEB-INF/sqlmap-config.xml"/&gt;
    &lt;property name="dataSource" ref="dataSource"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-ibatis-template"></a>12.5.2.&nbsp;Using <tt class="classname">SqlMapClientTemplate</tt> and
      <tt class="classname">SqlMapClientDaoSupport</tt></h3></div></div><div></div></div><p>The <tt class="classname">SqlMapClientDaoSupport</tt> class offers a
      supporting class similar to the <tt class="classname">SqlMapDaoSupport</tt>.
      We extend it to implement our DAO:</p><pre class="programlisting">public class SqlMapAccountDao extends SqlMapClientDaoSupport implements AccountDao {

    public Account getAccount(String email) throws DataAccessException {
        return (Account) getSqlMapClientTemplate().queryForObject("getAccountByEmail", email);
    }

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapClientTemplate().update("insertAccount", account);
    }
}</pre><p>In the DAO, we use the pre-configured
      <tt class="classname">SqlMapClientTemplate</tt> to execute the queries,
      after setting up the <tt class="literal">SqlMapAccountDao</tt> in the
      application context and wiring it with our
      <tt class="literal">SqlMapClient</tt> instance:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="sqlMapClient" ref="sqlMapClient"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Note that a <tt class="classname">SqlMapTemplate</tt> instance could
      also be created manually, passing in the <tt class="literal">SqlMapClient</tt>
      as constructor argument. The <tt class="literal">SqlMapClientDaoSupport</tt>
      base class simply pre-initializes a
      <tt class="classname">SqlMapClientTemplate</tt> instance for us.</p><p>The <tt class="classname">SqlMapClientTemplate</tt> also offers a
      generic <tt class="literal">execute</tt> method, taking a custom
      <tt class="literal">SqlMapClientCallback</tt> implementation as argument. This
      can, for example, be used for batching:</p><pre class="programlisting">public class SqlMapAccountDao extends SqlMapClientDaoSupport implements AccountDao {

    public void insertAccount(Account account) throws DataAccessException {
        getSqlMapClientTemplate().execute(new SqlMapClientCallback() {
            public Object doInSqlMapClient(SqlMapExecutor executor) throws SQLException {
                executor.startBatch();
                executor.update("insertAccount", account);
                executor.update("insertAddress", account.getAddress());
                executor.executeBatch();
            }
        });
    }
}</pre><p>In general, any combination of operations offered by the native
      <tt class="literal">SqlMapExecutor</tt> API can be used in such a callback.
      Any <tt class="literal">SQLException</tt> thrown will automatically get
      converted to Spring's generic <tt class="classname">DataAccessException</tt>
      hierarchy.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-ibatis-straight"></a>12.5.3.&nbsp;Implementing DAOs based on plain iBATIS API</h3></div></div><div></div></div><p>DAOs can also be written against plain iBATIS API, without any
      Spring dependencies, directly using an injected
      <tt class="literal">SqlMapClient</tt>. A corresponding DAO implementation
      looks like as follows:</p><pre class="programlisting">public class SqlMapAccountDao implements AccountDao {
        
    private SqlMapClient sqlMapClient;
    
    public void setSqlMapClient(SqlMapClient sqlMapClient) {
        this.sqlMapClient = sqlMapClient;
    }

    public Account getAccount(String email) {
        try {
            return (Account) this.sqlMapClient.queryForObject("getAccountByEmail", email);
        }
        catch (SQLException ex) {
            throw new MyDaoException(ex);
        }
    }

    public void insertAccount(Account account) throws DataAccessException {
        try {
            this.sqlMapClient.update("insertAccount", account);
        }
        catch (SQLException ex) {
            throw new MyDaoException(ex);
        }
    }
}</pre><p>In such a scenario, the <tt class="literal">SQLException</tt> thrown by
      the iBATIS API needs to be handled in a custom fashion: usually,
      wrapping it in your own application-specific DAO exception. Wiring in
      the application context would still look like before, due to the fact
      that the plain iBATIS-based DAO still follows the Dependency Injection
      pattern:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="accountDao" class="example.SqlMapAccountDao"&gt;
    &lt;property name="sqlMapClient" ref="sqlMapClient"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-jpa"></a>12.6.&nbsp;JPA</h2></div></div><div></div></div><p>Spring JPA (available under the
    <tt class="literal">org.springframework.orm.jpa</tt> package) offers
    comprehensive support for the <a href="http://java.sun.com/developer/technicalArticles/J2EE/jpa/index.html" target="_top">Java
    Persistence API</a> in a similar manner to the integration with
    Hibernate or JDO, while being aware of the underlying implementation in
    order to provide additional features.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jpa-setup"></a>12.6.1.&nbsp;JPA setup in a Spring environment</h3></div></div><div></div></div><p>Spring JPA offers three ways of setting up JPA
      <tt class="interfacename">EntityManagerFactory</tt>:</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="orm-jpa-setup-lemfb"></a>12.6.1.1.&nbsp;<tt class="classname">LocalEntityManagerFactoryBean</tt></h4></div></div><div></div></div><p>The <tt class="classname">LocalEntityManagerFactoryBean</tt> creates
        an <tt class="interfacename">EntityManagerFactory</tt> suitable for
        environments which solely use JPA for data access. The factory bean
        will use the JPA <tt class="interfacename">PersistenceProvider</tt>
        autodetection mechanism (according to JPA's Java SE bootstrapping)
        and, in most cases, requires only the persistence unit name to be
        specified:</p><pre class="programlisting">&lt;beans&gt;

   &lt;bean id="myEmf" class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean"&gt;
      &lt;property name="persistenceUnitName" value="myPersistenceUnit"/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;</pre><p>This is the simplest but also most limited form of JPA
        deployment. There is no way to link to an existing JDBC
        <tt class="interfacename">DataSource</tt> and no support for global
        transactions, for example. Furthermore, weaving (byte-code
        transformation) of persistent classes is provider-specific, often
        requiring a specific JVM agent to specified on startup. All in all,
        this option is only really sufficient for standalone applications and
        test environments (which is exactly what the JPA specification
        designed it for).</p><p><span class="emphasis"><em>Only use this option in simple deployment environments
        like standalone applications and integration tests.</em></span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="orm-jpa-setup-jndi"></a>12.6.1.2.&nbsp;<tt class="classname">Obtaining an EntityManagerFactory from
        JNDI</tt></h4></div></div><div></div></div><p>Obtaining an <tt class="interfacename">EntityManagerFactory</tt>
        from JNDI (for example in a Java EE 5 environment), is just a matter
        of changing the XML configuration:</p><pre class="programlisting">&lt;beans&gt;

    &lt;jee:jndi-lookup id="myEmf" jndi-name="persistence/myPersistenceUnit"/&gt;

&lt;/beans&gt;</pre><p>This assumes standard Java EE 5 bootstrapping, with the Java EE
        server autodetecting persistence units (i.e.
        <tt class="literal">META-INF/persistence.xml</tt> files in application jars)
        and <tt class="literal">persistence-unit-ref</tt> entries in the Java EE
        deployment descriptor (e.g. <tt class="literal">web.xml</tt>) defining
        environment naming context locations for those persistence
        units.</p><p>In such a scenario, the entire persistence unit deployment,
        including the weaving (byte-code transformation) of persistent
        classes, is up to the Java EE server. The JDBC
        <tt class="interfacename">DataSource</tt> is defined through a JNDI
        location in the <tt class="literal">META-INF/persistence.xml</tt> file;
        EntityManager transactions are integrated with the server's JTA
        subsystem. Spring merely uses the obtained
        <tt class="interfacename">EntityManagerFactory</tt>, passing it on to
        application objects via dependency injection, and managing
        transactions for it (typically through
        <tt class="classname">JtaTransactionManager</tt>).</p><p>Note that, in case of multiple persistence units used in the
        same application, the bean names of such a JNDI-retrieved persistence
        units should match the persistence unit names that the application
        uses to refer to them (e.g. in <tt class="literal">@PersistenceUnit</tt> and
        <tt class="literal">@PersistenceContext</tt> annotations).</p><p><span class="emphasis"><em>Use this option when deploying to a Java EE 5 server.
        Check your server's documentation on how to deploy a custom JPA
        provider into your server, allowing for a different provider than the
        server's default. </em></span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="orm-jpa-setup-lcemfb"></a>12.6.1.3.&nbsp;<tt class="classname">LocalContainerEntityManagerFactoryBean</tt></h4></div></div><div></div></div><p>The
        <tt class="classname">LocalContainerEntityManagerFactoryBean</tt> gives
        full control over <tt class="interfacename">EntityManagerFactory</tt>
        configuration and is appropriate for environments where fine-grained
        customization is required. The
        <tt class="classname">LocalContainerEntityManagerFactoryBean</tt> will
        create a <tt class="interfacename">PersistenceUnitInfo</tt> based on
        the <tt class="literal">persistence.xml</tt> file, the supplied
        <tt class="literal">dataSourceLookup</tt> strategy and the specified
        <tt class="literal">loadTimeWeaver</tt>. It is thus possible to work with
        custom DataSources outside of JNDI and to control the weaving
        process.</p><pre class="programlisting">&lt;beans&gt;
        
 &lt;bean id="myEmf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="dataSource" ref="someDataSource"/&gt;
  &lt;property name="loadTimeWeaver"&gt;
    &lt;bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/&gt;
  &lt;/property&gt;
 &lt;/bean&gt;
 
&lt;/beans&gt;</pre><p>A typical <tt class="literal">persistence.xml</tt> file looks as follows:</p><pre class="programlisting">&lt;persistence xmlns="http://java.sun.com/xml/ns/persistence" version="1.0"&gt;

  &lt;persistence-unit name="myUnit" transaction-type="RESOURCE_LOCAL"&gt;
    &lt;mapping-file&gt;META-INF/orm.xml&lt;/mapping-file&gt;
    &lt;exclude-unlisted-classes/&gt;
  &lt;/persistence-unit&gt;

&lt;/persistence&gt;</pre><p><span class="emphasis"><em>NOTE: The "exclude-unlisted-classes" element always
        indicates that NO scanning for annotated entity classes is supposed
        to happen, in order to support the
        <tt class="literal">&lt;exclude-unlisted-classes/&gt;</tt> shortcut.
        This is in line with the JPA specification (which suggests that shortcut)
        but unfortunately in conflict with the JPA XSD (which implies "false"
        for that shortcut). As a consequence,
        "<tt class="literal">&lt;exclude-unlisted-classes&gt; false &lt;/exclude-unlisted-classes/&gt;</tt>"
        is not supported! Simply omit the "exclude-unlisted-classes" element if
        you would like entity class scanning to actually happen.</em></span></p><p>This is the most powerful JPA setup option, allowing for
        flexible local configuration within the application. It supports links
        to an existing JDBC <tt class="interfacename">DataSource</tt>,
        supports both local and global transactions, etc. However, it also
        imposes requirements onto the runtime environment, such as the
        availability of a weaving-capable ClassLoader if the persistence
        provider demands byte-code transformation.</p><p>Note that this option may conflict with the built-in JPA
        capabilities of a Java EE 5 server. So when running in a full Java EE
        5 environment, consider obtaining your
        <tt class="interfacename">EntityManagerFactory</tt> from JNDI.
        Alternatively, specify a custom "persistenceXmlLocation" on your
        <tt class="classname">LocalContainerEntityManagerFactoryBean</tt>
        definition, e.g. "META-INF/my-persistence.xml", and only include a
        descriptor with that name in your application jar files. Since the
        Java EE 5 server will only look for default
        <tt class="literal">META-INF/persistence.xml</tt> files, it will ignore such
        custom persistence units and hence avoid conflicts with a
        Spring-driven JPA setup upfront. (This applies to Resin 3.1, for
        example.)</p><p><span class="emphasis"><em>Use this option for full JPA capabilities in a
        Spring-based application environment. This includes web containers
        such as Tomcat as well as standalone applications and integration
        tests with sophisticated persistence requirements.</em></span></p><div class="sidebar"><p class="title"><b>When is load-time weaving required?</b></p><p>Not all JPA providers impose the need of a JVM agent
          (Hibernate being an example). If your provider does not require an
          agent or you have other alternatives (for example applying
          enhancements at build time through a custom compiler or an ant task)
          the load-time weaver <span class="bold"><b>should not</b></span> be
          used.</p></div><p>The <tt class="interfacename">LoadTimeWeaver</tt> interface is a
        Spring-provided class that allows JPA
        <tt class="interfacename">ClassTransformer</tt> instances to be
        plugged in a specific manner depending on the environment (web
        container/application server). Hooking
        <tt class="literal">ClassTransformers</tt> through a Java 5 <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/instrument/package-summary.html" target="_top">agent</a>
        is typically not efficient - the agents work against the
        <span class="emphasis"><em>entire virtual machine</em></span> and inspect
        <span class="emphasis"><em>every</em></span> class that is loaded - something that is
        typically undesirable in a production server enviroment.</p><p>Spring provides a number of
        <tt class="interfacename">LoadTimeWeaver</tt> implementations for
        various environments, allowing
        <tt class="interfacename">ClassTransformer</tt> instances to be
        applied only <span class="emphasis"><em>per ClassLoader</em></span> and not per VM.</p><p>The following sections will discuss typical JPA weaving setup on
        Tomcat as well as using Spring's VM agent. See the AOP chapter section
        entitled <a href="#aop-aj-ltw-spring" title="6.8.4.5.&nbsp;Spring configuration">Section&nbsp;6.8.4.5, &#8220;Spring configuration&#8221;</a> for details on how to set
        up general load-time weaving, covering Tomcat and the VM agent as well
        as WebLogic, OC4J, GlassFish and Resin.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="orm-jpa-setup-lcemfb-tomcat"></a>12.6.1.3.1.&nbsp;Tomcat load-time weaving setup (5.0+)</h5></div></div><div></div></div><p><a href="http://tomcat.apache.org/" target="_top">Apache
          Tomcat's</a> default ClassLoader does not support class
          transformation but allows custom ClassLoaders to be used. Spring
          offers the <tt class="classname">TomcatInstrumentableClassLoader</tt>
          (inside the
          <tt class="literal">org.springframework.instrument.classloading.tomcat</tt>
          package) which extends the Tomcat ClassLoader
          (<tt class="classname">WebappClassLoader</tt>) and allows JPA
          <tt class="classname">ClassTransformer</tt> instances to 'enhance' all
          classes loaded by it. In short, JPA transformers will be applied
          only inside a specific web application (which uses the
          <tt class="classname">TomcatInstrumentableClassLoader</tt>).</p><p>In order to use the custom ClassLoader on:</p><div class="itemizedlist"><div class="orderedlist"><ol type="1"><li><p>Copy <tt class="literal">spring-tomcat-weaver.jar</tt> into
                <span class="emphasis"><em>$CATALINA_HOME</em></span>/server/lib (where
                <span class="emphasis"><em>$CATALINA_HOME</em></span> represents the root of the
                Tomcat installation).</p></li><li><p>Instruct Tomcat to use the custom ClassLoader (instead
                of the default one) by editing the web application context
                file:</p><pre class="programlisting">&lt;Context path="/myWebApp" docBase="/my/webApp/location"&gt;
    &lt;Loader loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"/&gt;
&lt;/Context&gt;</pre><p>Tomcat 5.0.x and 5.5.x series support several context
                locations: server configuration file
                (<span class="emphasis"><em>$CATALINA_HOME/conf/server.xml</em></span>), the
                default context configuration
                (<span class="emphasis"><em>$CATALINA_HOME/conf/context.xml</em></span>) that
                affects all deployed web applications and per-webapp
                configurations, deployed on the server
                <span class="emphasis"><em>($CATALINA_HOME/conf/[enginename]/[hostname]/my-webapp-context.xml</em></span>)
                side or along with the webapp
                (<span class="emphasis"><em>your-webapp.war/META-INF/context.xml</em></span>).
                For efficiency, inside the web-app configuration style is
                recommended since only applications which use JPA will use the
                custom ClassLoader. See the Tomcat 5.x <a href="http://tomcat.apache.org/tomcat-5.5-doc/config/context.html" target="_top">documentation</a>
                for more details about available context locations.</p><p>Note that versions prior to 5.5.20 contained a bug in
                the XML configuration parsing preventing usage of
                <tt class="literal">Loader</tt> tag inside
                <span class="emphasis"><em>server.xml</em></span> (no matter if a ClassLoader is
                specified or not (be it the official or a custom one). See
                Tomcat's bugzilla for <a href="http://issues.apache.org/bugzilla/show_bug.cgi?id=39704" target="_top">more
                details</a>.</p><p>If you are using Tomcat 5.5.20+ you can set
                <span class="emphasis"><em>useSystemClassLoaderAsParent</em></span> to
                <tt class="literal">false</tt> to fix the problem: </p><pre class="programlisting">&lt;Context path="/myWebApp" docBase="/my/webApp/location"&gt;
    &lt;Loader loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"
            useSystemClassLoaderAsParent="false"/&gt;
&lt;/Context&gt;</pre></li></ol></div><div class="orderedlist"><ol type="1"><li><p>Copy <tt class="literal">spring-tomcat-weaver.jar</tt> into
                <span class="emphasis"><em>$CATALINA_HOME</em></span>/lib (where
                <span class="emphasis"><em>$CATALINA_HOME</em></span> represents the root of the
                Tomcat installation).</p></li><li><p>Instruct Tomcat to use the custom ClassLoader (instead
                of the default one) by editing the web application context
                file:</p><pre class="programlisting">&lt;Context path="/myWebApp" docBase="/my/webApp/location"&gt;
    &lt;Loader loaderClass="org.springframework.instrument.classloading.tomcat.TomcatInstrumentableClassLoader"/&gt;
&lt;/Context&gt;</pre><p>Tomcat 6.0.x (similar to 5.0.x/5.5.x) series support
                several context locations: server configuration file
                (<span class="emphasis"><em>$CATALINA_HOME/conf/server.xml</em></span>), the
                default context configuration
                (<span class="emphasis"><em>$CATALINA_HOME/conf/context.xml</em></span>) that
                affects all deployed web applications and per-webapp
                configurations, deployed on the server
                <span class="emphasis"><em>($CATALINA_HOME/conf/[enginename]/[hostname]/my-webapp-context.xml</em></span>)
                side or along with the webapp
                (<span class="emphasis"><em>your-webapp.war/META-INF/context.xml</em></span>).
                For efficiency, inside the web-app configuration style is
                recommended since only applications which use JPA will use the
                custom ClassLoader. See the Tomcat 5.x <a href="http://tomcat.apache.org/tomcat-6.0-doc/config/context.html" target="_top">documentation</a>
                for more details about available context locations.</p></li></ol></div><ul type="disc"><li><p>Tomcat 5.0.x/5.5.x</p></li><li><p>Tomcat 6.0.x</p></li></ul></div><p>The last step required on all Tomcat versions, is to use the
          appropriate the <tt class="interfacename">LoadTimeWeaver</tt> when
          configuring
          <tt class="classname">LocalContainerEntityManagerFactoryBean</tt>:</p><pre class="programlisting">&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="loadTimeWeaver"&gt;
    &lt;bean class="org.springframework.instrument.classloading.ReflectiveLoadTimeWeaver"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Using this technique, JPA applications relying on
          instrumentation, can run in Tomcat without the need of an agent.
          This is important especially when hosting applications which rely on
          different JPA implementations since the JPA transformers are applied
          only at ClassLoader level and thus, are isolated from each
          other.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If TopLink is being used a JPA provider under Tomcat, please
            place the toplink-essentials jar under
            <span class="emphasis"><em>$CATALINA_HOME</em></span>/shared/lib folder instead of
            your war.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="orm-jpa-setup-lcemfb-agent"></a>12.6.1.3.2.&nbsp;General load-time weaving using the VM agent</h5></div></div><div></div></div><p>For environments where class instrumentation is required but
          are not supported by the existing LoadTimeWeaver implementations, a
          JDK agent can be the only solution. For such cases, Spring provides
          <tt class="classname">InstrumentationLoadTimeWeaver</tt> which requires
          a Spring-specific (but very general) VM agent (<tt class="filename">spring-agent.jar</tt>):</p><pre class="programlisting">&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="loadTimeWeaver"&gt;
    &lt;bean class="org.springframework.instrument.classloading.InstrumentationLoadTimeWeaver"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that the virtual machine has to be started with the
          Spring agent, by supplying the following JVM options:</p><pre class="programlisting">-javaagent:/path/to/spring-agent.jar</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="orm-jpa-setup-lcemfb-weaver"></a>12.6.1.3.3.&nbsp;Context-wide load-time weaver setup</h5></div></div><div></div></div><p>Since Spring 2.5, a context-wide <tt class="interfacename">LoadTimeWeaver</tt>
          can be configured using the <tt class="literal">context:load-time-weaver</tt> configuration
          element. Such a 'global' weaver will be picked up by all JPA
          <tt class="classname">LocalContainerEntityManagerFactoryBeans</tt> automatically.</p><p>This is the preferred way of setting up a load-time weaver, delivering
          autodetection of the platform (WebLogic, OC4J, GlassFish, Tomcat, Resin, VM agent)
          as well as automatic propagation of the weaver to all weaver-aware beans.</p><pre class="programlisting">&lt;context:load-time-weaver/&gt;

&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
    ...
&lt;/bean&gt;</pre><p>See the section entitled <a href="#aop-aj-ltw-spring" title="6.8.4.5.&nbsp;Spring configuration">Section&nbsp;6.8.4.5, &#8220;Spring configuration&#8221;</a>
          for details on how to set up general load-time weaving, covering Tomcat
          and the VM agent as well as WebLogic, OC4J, GlassFish and Resin.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="orm-jpa-multiple-pu"></a>12.6.1.4.&nbsp;Dealing with multiple persistence units</h4></div></div><div></div></div><p>For applications that rely on multiple persistence units
        locations (stored in various jars in the classpath for example),
        Spring offers the
        <tt class="interfacename">PersistenceUnitManager</tt> to act as a
        central repository and avoid the (potentially expensive) persistence
        units discovery process. The default implementation allows multiple
        locations to be specified (by default, the classpath is searched for
        <tt class="filename">'META-INF/persistence.xml'</tt> files) which are
        parsed and later on retrieved through the persistence unit
        name:</p><pre class="programlisting">&lt;bean id="pum" class="org.springframework.orm.jpa.persistenceunit.DefaultPersistenceUnitManager"&gt;
  &lt;property name="persistenceXmlLocation"&gt;
    &lt;list&gt;
     &lt;value&gt;org/springframework/orm/jpa/domain/persistence-multi.xml&lt;/value&gt;
     &lt;value&gt;classpath:/my/package/**/custom-persistence.xml&lt;/value&gt;
     &lt;value&gt;classpath*:META-INF/persistence.xml&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
  &lt;property name="dataSources"&gt;
   &lt;map&gt;
    &lt;entry key="localDataSource" value-ref="local-db"/&gt;
    &lt;entry key="remoteDataSource" value-ref="remote-db"/&gt;
   &lt;/map&gt;
  &lt;/property&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- if no datasource is specified, use this one --&gt;</span></i>
  &lt;property name="defaultDataSource" ref="remoteDataSource"/&gt;
&lt;/bean&gt;

&lt;bean id="emf" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
  &lt;property name="persistenceUnitManager" ref="pum"/&gt;
&lt;/bean&gt;</pre><p>Note that the default implementation allows customization of the
        persistence unit infos before feeding them to the JPA provider
        declaratively through its properties (which affect <span class="emphasis"><em>all</em></span>
        hosted units) or programmatically, through the
        <tt class="interfacename">PersistenceUnitPostProcessor</tt>
        (which allows persistence unit selection). If no
        <tt class="interfacename">PersistenceUnitManager</tt> is
        specified, one will be created and used internally by
        <tt class="classname">LocalContainerEntityManagerFactoryBean</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jpa-template"></a>12.6.2.&nbsp;<tt class="classname">JpaTemplate</tt> and
      <tt class="classname">JpaDaoSupport</tt></h3></div></div><div></div></div><p>Each JPA-based DAO will then receive a
      <tt class="interfacename">EntityManagerFactory</tt> via dependency
      injection. Such a DAO can be coded against plain JPA and work with the
      given <tt class="interfacename">EntityManagerFactory</tt> or through
      Spring's <tt class="classname">JpaTemplate</tt>:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"&gt;
    &lt;property name="entityManagerFactory" ref="myEmf"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">public class JpaProductDao implements ProductDao {
  
    private JpaTemplate jpaTemplate;

    public void setEntityManagerFactory(EntityManagerFactory emf) {
        this.jpaTemplate = new JpaTemplate(emf);
    }

    public Collection loadProductsByCategory(final String category) throws DataAccessException {
        return (Collection) this.jpaTemplate.execute(new JpaCallback() {
            public Object doInJpa(EntityManager em) throws PersistenceException {
                Query query = em.createQuery("from Product as p where p.category = :category");
                query.setParameter("category", category);
                List result = query.getResultList(); 
                <i class="lineannotation"><span class="lineannotation">// do some further processing with the result list</span></i>
                return result;
            }
        });
    }
}</pre><p>The <tt class="interfacename">JpaCallback</tt> implementation
      allows any type of JPA data access. The
      <tt class="classname">JpaTemplate</tt> will ensure that
      <tt class="interfacename">EntityManager</tt>s are properly opened and
      closed and automatically participate in transactions. Moreover, the
      <tt class="classname">JpaTemplate</tt> properly handles exceptions, making
      sure resources are cleaned up and the appropriate transactions rolled
      back. The template instances are thread-safe and reusable and they can
      be kept as instance variable of the enclosing class. Note that
      <tt class="classname">JpaTemplate</tt> offers single-step actions such as
      find, load, merge, etc along with alternative convenience methods that
      can replace one line callback implementations.</p><p>Furthermore, Spring provides a convenient
      <tt class="classname">JpaDaoSupport</tt> base class that provides the
      <tt class="literal">get/setEntityManagerFactory</tt> and
      <tt class="methodname">getJpaTemplate()</tt> to be used by
      subclasses:</p><pre class="programlisting">public class ProductDaoImpl extends JpaDaoSupport implements ProductDao {
  
    public Collection loadProductsByCategory(String category) throws DataAccessException {
        Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
        params.put("category", category);
        return getJpaTemplate().findByNamedParams("from Product as p where p.category = :category", params);
    }
}</pre><p>Besides working with Spring's <tt class="classname">JpaTemplate</tt>,
      one can also code Spring-based DAOs against the JPA, doing one's own
      explicit <tt class="interfacename">EntityManager</tt> handling. As also
      elaborated in the corresponding Hibernate section, the main advantage of
      this approach is that your data access code is able to throw checked
      exceptions. <tt class="classname">JpaDaoSupport</tt> offers a variety of
      support methods for this scenario, for retrieving and releasing a
      transaction <tt class="interfacename">EntityManager</tt>, as well as for
      converting exceptions.</p><p><span class="emphasis"><em>JpaTemplate mainly exists as a sibling of JdoTemplate
      and HibernateTemplate, offering the same style for people used to it.
      For newly started projects, consider adopting the native JPA style of
      coding data access objects instead, based on a "shared EntityManager"
      reference obtained through the JPA
      <tt class="literal">@PersistenceContext</tt> annotation (using Spring's
      <tt class="classname">PersistenceAnnotationBeanPostProcessor</tt>; see below
      for details.)</em></span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jpa-straight"></a>12.6.3.&nbsp;Implementing DAOs based on plain JPA</h3></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>While <tt class="interfacename">EntityManagerFactory</tt>
        instances are thread-safe,
        <tt class="interfacename">EntityManager</tt> instances are not. The
        injected JPA <tt class="interfacename">EntityManager</tt> behave just
        like an <tt class="interfacename">EntityManager</tt> fetched from an
        application server's JNDI environment, as defined by the JPA
        specification. It will delegate all calls to the current transactional
        <tt class="interfacename">EntityManager</tt>, if any; else, it will
        fall back to a newly created
        <tt class="interfacename">EntityManager</tt> per operation, making it
        thread-safe.</p></td></tr></table></div><p>It is possible to write code against the plain JPA without using
      any Spring dependencies, using an injected
      <tt class="interfacename">EntityManagerFactory</tt> or
      <tt class="interfacename">EntityManager</tt>. Note that Spring can
      understand <tt class="interfacename">@PersistenceUnit</tt> and
      <tt class="interfacename">@PersistenceContext</tt> annotations both at
      field and method level if a
      <tt class="classname">PersistenceAnnotationBeanPostProcessor</tt> is
      enabled. A corresponding DAO implementation might look like this:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    private EntityManagerFactory emf;

    @PersistenceUnit
    public void setEntityManagerFactory(EntityManagerFactory emf) {
        this.emf = emf;
    }

    public Collection loadProductsByCategory(String category) {
        EntityManager em = this.emf.createEntityManager();
        try {
             Query query = em.createQuery("from Product as p where p.category = ?1");
             query.setParameter(1, category);
             return query.getResultList();
        }
        finally {
            if (em != null) {
                em.close();
            }
        }
    }
}</pre><p>The DAO above has no dependency on Spring and still fits nicely
      into a Spring application context, just like it would if coded against
      Spring's <tt class="classname">JpaTemplate</tt>. Moreover, the DAO takes
      advantage of annotations to require the injection of the default
      <tt class="interfacename">EntityManagerFactory</tt>:</p><pre class="programlisting">&lt;beans&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- bean post-processor for JPA annotations --&gt;</span></i>
  &lt;bean class="org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor"/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</pre><p>Note: As alternative to defining a
      <tt class="classname">PersistenceAnnotationBeanPostProcessor</tt>
      explicitly, consider using Spring 2.5's
      <tt class="literal">context:annotation-config</tt> XML element in your
      application context configuration. This will automatically register all
      of Spring's standard post-processors for annotation-based configuration
      (including <tt class="classname">CommonAnnotationBeanPostProcessor</tt>
      etc).</p><pre class="programlisting">&lt;beans&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- post-processors for all standard config annotations --&gt;</span></i>
  &lt;context:annotation-config/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</pre><p>The main issue with such a DAO is that it always creates a new
      <tt class="interfacename">EntityManager</tt> via the factory. This can
      be easily overcome by requesting a transactional
      <tt class="interfacename">EntityManager</tt> (also called "shared
      EntityManager", since it is a shared, thread-safe proxy for the actual
      transactional EntityManager) to be injected instead of the
      factory:</p><pre class="programlisting">public class ProductDaoImpl implements ProductDao {

    @PersistenceContext
    private EntityManager em;

    public Collection loadProductsByCategory(String category) {
       Query query = em.createQuery("from Product as p where p.category = :category");
       query.setParameter("category", category);
       return query.getResultList(); 
    }
}</pre><p>Note that the <tt class="literal">@PersistenceContext</tt> annotation
      has an optional attribute <tt class="literal">type</tt>, which defaults to
      <tt class="literal">PersistenceContextType.TRANSACTION</tt>. This default is
      what you need to receive a "shared EntityManager" proxy. The
      alternative, <tt class="literal">PersistenceContextType.EXTENDED</tt>, is a
      completely different affair: This results in a so-called "extended
      EntityManager", which is <span class="emphasis"><em>not thread-safe</em></span> and hence
      must not be used in a concurrently accessed component such as a
      Spring-managed singleton bean. Extended EntityManagers are only supposed
      to be used in stateful components that, for example, reside in a
      session, with the lifecycle of the EntityManager not tied to a current
      transaction but rather being completely up to the application.</p><div class="sidebar"><p class="title"><b>Method and Field level Injection</b></p><p>Annotations that indicate dependency injections (such as
        <tt class="literal">@PersistenceUnit</tt> and
        <tt class="literal">@PersistenceContext</tt>) can be applied on field or
        methods inside a class, therefore the expression "method/field level
        injection". Field-level annotations concise and easier to use while
        method-level allow for processing the injected dependency. In both
        cases the member visibility (public, protected, private) does not
        matter.</p><p>What about class level annotations?</p><p>On the Java EE 5 platform, they are used for dependency declaration
        and not for resource injection.</p></div><p>The injected <tt class="interfacename">EntityManager</tt> is
      Spring-managed (aware of the ongoing transaction). It is important to
      note that even though the new implementation prefers method level
      injection (of an <tt class="interfacename">EntityManager</tt> instead of
      an <tt class="interfacename">EntityManagerFactory)</tt>, no change is
      required in the application context XML due to annotation usage.</p><p>The main advantage of this DAO style is that it depends on Java
      Persistence API; no import of any Spring class is required. Moreover, as
      the JPA annotations are understood, the injections are applied
      automatically by the Spring container. This is of course appealing from
      a non-invasiveness perspective, and might feel more natural to JPA
      developers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="orm-jpa-exceptions"></a>12.6.4.&nbsp;Exception Translation</h3></div></div><div></div></div><p>However, the DAO throws the plain
      <tt class="classname">PersistenceException</tt> exception class (which is
      unchecked, and so does not have to be declared or caught) but also
      <tt class="classname">IllegalArgumentException</tt> and
      <tt class="classname">IllegalStateException</tt>, which means that callers
      can only treat exceptions as generally fatal - unless they want to
      depend on JPA's own exception structure. Catching specific causes such
      as an optimistic locking failure is not possible without tying the
      caller to the implementation strategy. This tradeoff might be acceptable
      to applications that are strongly JPA-based and/or do not need any
      special exception treatment. However, Spring offers a solution allowing
      exception translation to be applied transparently through the
      <tt class="interfacename">@Repository</tt> annotation:</p><pre class="programlisting">@Repository
public class ProductDaoImpl implements ProductDao {

    <i class="lineannotation"><span class="lineannotation">// class body here...</span></i>

}</pre><pre class="programlisting">&lt;beans&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="classname">Exception</tt> translation bean post processor --&gt;</span></i>
  &lt;bean class="org.springframework.dao.annotation.PersistenceExceptionTranslationPostProcessor"/&gt;

  &lt;bean id="myProductDao" class="product.ProductDaoImpl"/&gt;

&lt;/beans&gt;</pre><p>The postprocessor will automatically look for all exception
      translators (implementations of the
      <tt class="interfacename">PersistenceExceptionTranslator</tt> interface)
      and advise all beans marked with the
      <tt class="interfacename">@Repository</tt> annotation so that the
      discovered translators can intercept and apply the appropriate
      translation on the thrown exceptions.</p><p>In summary: DAOs can be implemented based on the plain Java
      Persistence API and annotations, while still being able to benefit from
      Spring-managed transactions, dependency injection, and transparent
      exception conversion (if desired) to Spring's custom exception
      hierarchies.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-jpa-tx"></a>12.7.&nbsp;Transaction Management</h2></div></div><div></div></div><p>To execute service operations within transactions, you can use
    Spring's common declarative transaction facilities. For example:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd
       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

  &lt;bean id="myTxManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
    &lt;property name="entityManagerFactory" ref="myEmf"/&gt;
  &lt;/bean&gt;

  &lt;bean id="myProductService" class="product.ProductServiceImpl"&gt;
    &lt;property name="productDao" ref="myProductDao"/&gt;
  &lt;/bean&gt;
  
  &lt;aop:config&gt;
    &lt;aop:pointcut id="productServiceMethods" expression="execution(* product.ProductService.*(..))"/&gt;
    &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="productServiceMethods"/&gt;
  &lt;/aop:config&gt;

  &lt;tx:advice id="txAdvice" transaction-manager="myTxManager"&gt;
    &lt;tx:attributes&gt;
      &lt;tx:method name="increasePrice*" propagation="REQUIRED"/&gt;
      &lt;tx:method name="someOtherBusinessMethod" propagation="REQUIRES_NEW"/&gt;
      &lt;tx:method name="*" propagation="SUPPORTS" read-only="true"/&gt;
    &lt;/tx:attributes&gt;
  &lt;/tx:advice&gt;

&lt;/beans&gt;</pre><p>Spring JPA allows a configured
    <tt class="classname">JpaTransactionManager</tt> to expose a JPA transaction
    to JDBC access code that accesses the same JDBC
    <tt class="interfacename">DataSource</tt>, provided that the registered
    <tt class="interfacename">JpaDialect</tt> supports retrieval of the
    underlying JDBC <tt class="interfacename">Connection</tt>. Out of the box,
    Spring provides dialects for the Toplink, Hibernate and OpenJPA JPA
    implementations. See the next section for details on the
    <tt class="interfacename">JpaDialect</tt> mechanism.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="orm-jpa-dialect"></a>12.8.&nbsp;<tt class="interfacename">JpaDialect</tt></h2></div></div><div></div></div><p>As an advanced feature <tt class="classname">JpaTemplate</tt>,
    <tt class="classname">JpaTransactionManager</tt> and subclasses of
    <tt class="classname">AbstractEntityManagerFactoryBean</tt> support a custom
    <tt class="interfacename">JpaDialect</tt>, to be passed into the
    "jpaDialect" bean property. In such a scenario, the DAOs won't receive an
    <tt class="interfacename">EntityManagerFactory</tt> reference but rather a
    full <tt class="classname">JpaTemplate</tt> instance instead (for example,
    passed into <tt class="classname">JpaDaoSupport</tt>'s "jpaTemplate"
    property). A <tt class="interfacename">JpaDialect</tt> implementation can
    enable some advanced features supported by Spring, usually in a
    vendor-specific manner:</p><div class="itemizedlist"><ul type="disc"><li><p>applying specific transaction semantics (such as custom
        isolation level or transaction timeout)</p></li><li><p>retrieving the transactional JDBC
        <tt class="interfacename">Connection</tt> (for exposure to JDBC-based
        DAOs)</p></li><li><p>advanced translation of <tt class="literal">PersistenceExceptions</tt>
        to Spring <tt class="literal">DataAccessExceptions</tt></p></li></ul></div><p>This is particularly valuable for special transaction semantics and
    for advanced translation of exception. Note that the default
    implementation used (<tt class="classname">DefaultJpaDialect</tt>) doesn't
    provide any special capabilities and if the above features are required,
    the appropriate dialect has to be specified.</p><p>See the <tt class="interfacename">JpaDialect</tt> Javadoc for more
    details of its operations and how they are used within Spring's JPA
    support.</p></div></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="spring-web"></a>The Web</h1></div></div><div></div></div><div class="partintro" lang="en"><div><div></div><div></div></div><p>
				This part of the reference documentation covers the
				Spring Framework's support for the presentation tier
				(and specifically web-based presentation tiers).
			</p><p>
				The Spring Framework's own web framework,
				<a href="#mvc" title="Chapter&nbsp;13.&nbsp;Web MVC framework">Spring Web MVC</a>, is covered in
				the first couple of chapters. A number of the remaining
				chapters in this part of the reference documentation are
				concerned with the Spring Framework's integration with
				other web technologies, such as <a href="#struts" title="15.4.&nbsp;Apache Struts 1.x and 2.x">Struts</a>
				and <a href="#jsf" title="15.3.&nbsp;JavaServer Faces 1.1 and 1.2">JSF</a> (to name but two).
			</p><p>
				This section concludes with coverage of Spring's MVC
				<a href="#portlet" title="Chapter&nbsp;16.&nbsp;Portlet MVC Framework">portlet framework</a>.
			</p><div class="itemizedlist"><ul type="disc"><li><p><a href="#mvc" title="Chapter&nbsp;13.&nbsp;Web MVC framework">Chapter&nbsp;13, <i>Web MVC framework</i></a></p></li><li><p><a href="#view" title="Chapter&nbsp;14.&nbsp;View technologies">Chapter&nbsp;14, <i>View technologies</i></a></p></li><li><p><a href="#web-integration" title="Chapter&nbsp;15.&nbsp;Integrating with other web frameworks">Chapter&nbsp;15, <i>Integrating with other web frameworks</i></a></p></li><li><p><a href="#portlet" title="Chapter&nbsp;16.&nbsp;Portlet MVC Framework">Chapter&nbsp;16, <i>Portlet MVC Framework</i></a></p></li></ul></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mvc"></a>Chapter&nbsp;13.&nbsp;Web MVC framework</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-introduction"></a>13.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Spring's Web MVC framework is designed around a
    <tt class="classname">DispatcherServlet</tt> that dispatches requests to
    handlers, with configurable handler mappings, view resolution, locale and
    theme resolution as well as support for upload files. The default handler
    is a very simple <tt class="interfacename">Controller</tt> interface, just
    offering a <tt class="literal">ModelAndView handleRequest(request,response)</tt>
    method. This can already be used for application controllers, but you will
    prefer the included implementation hierarchy, consisting of, for example
    <tt class="classname">AbstractController</tt>,
    <tt class="classname">AbstractCommandController</tt> and
    <tt class="classname">SimpleFormController</tt>. Application controllers will
    typically be subclasses of those. Note that you can choose an appropriate
    base class: if you don't have a form, you don't need a form controller.
    This is a major difference to Struts.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>Since Spring 2.5, an annotated controller style is available
      for Java 5+ users. This is a compelling alternative to implementing
      traditional <tt class="interfacename">Controller</tt> (sub-)classes,
      allowing for flexible multi-action handling. See the
      <a href="#mvc-annotation" title="13.11.&nbsp;Annotation-based controller configuration">Section&nbsp;13.11, &#8220;Annotation-based controller configuration&#8221;</a> section for details.</p></td></tr></table></div><div class="sidebar"><a name="mvc-open-for-extension"></a><p class="title"><b>&#8220;<span class="quote">Open for extension...</span>&#8221;</b></p><p>One of the overarching design principles in Spring Web MVC (and in
      Spring in general) is the &#8220;<span class="quote"><span class="emphasis"><em>Open for extension, closed
      for modification</em></span></span>&#8221; principle.</p><p>The reason that this principle is being mentioned here is because
      a number of methods in the core classes in Spring Web MVC are marked
      <tt class="literal">final</tt>. This means of course that you as a developer
      cannot override these methods to supply your own behavior... this is
      <span class="emphasis"><em>by design</em></span> and has not been done arbitrarily to
      annoy.</p><p>The book 'Expert Spring Web MVC and Web Flow' by Seth Ladd and
      others explains this principle and the reasons for adhering to it in
      some depth on page 117 (first edition) in the section entitled 'A Look
      At Design'.</p><p>If you don't have access to the aforementioned book, then the
      following article may be of interest the next time you find yourself
      going &#8220;<span class="quote">Gah! Why can't I override this method?</span>&#8221; (if indeed
      you ever do).</p><div class="orderedlist"><ol type="1"><li><p><a href="http://www.objectmentor.com/resources/articles/ocp.pdf" target="_top">Bob
          Martin, The Open-Closed Principle (PDF)</a></p></li></ol></div><p>Note that you cannot add advice to final methods using Spring MVC.
      This means it won't be possible to add advice to for example the
      <tt class="literal">AbstractController.handleRequest()</tt> method. Refer to
      <a href="#aop-understanding-aop-proxies" title="6.6.1.&nbsp;Understanding AOP proxies">Section&nbsp;6.6.1, &#8220;Understanding AOP proxies&#8221;</a> for more information on
      AOP proxies and why you cannot add advice to final methods.</p></div><p>Spring Web MVC allows you to use any object as a command or form
    object - there is no need to implement a framework-specific interface or
    base class. Spring's data binding is highly flexible: for example, it
    treats type mismatches as validation errors that can be evaluated by the
    application, not as system errors. All this means that you don't need to
    duplicate your business objects' properties as simple, untyped strings in
    your form objects just to be able to handle invalid submissions, or to
    convert the Strings properly. Instead, it is often preferable to bind
    directly to your business objects. This is another major difference to
    Struts which is built around required base classes such as
    <tt class="classname">Action</tt> and
    <tt class="classname">ActionForm</tt>.</p><p>Compared to WebWork, Spring has more differentiated object roles. It
    supports the notion of a <tt class="interfacename">Controller</tt>, an
    optional command or form object, and a model that gets passed to the view.
    The model will normally include the command or form object but also
    arbitrary reference data; instead, a WebWork
    <tt class="interfacename">Action</tt> combines all those roles into one
    single object. WebWork does allow you to use existing business objects as
    part of your form, but only by making them bean properties of the
    respective <tt class="interfacename">Action</tt> class. Finally, the same
    <tt class="interfacename">Action</tt> instance that handles the request is
    used for evaluation and form population in the view. Thus, reference data
    needs to be modeled as bean properties of the
    <tt class="interfacename">Action</tt> too. These are (arguably) too many
    roles for one object.</p><p>Spring's view resolution is extremely flexible. A
    <tt class="interfacename">Controller</tt> implementation can even write a
    view directly to the response (by returning <tt class="literal">null</tt> for
    the <tt class="classname">ModelAndView</tt>). In the normal case, a
    <tt class="classname">ModelAndView</tt> instance consists of a view name and a
    model <tt class="interfacename">Map</tt>, which contains bean names and
    corresponding objects (like a command or form, containing reference data).
    View name resolution is highly configurable, either via bean names, via a
    properties file, or via your own
    <tt class="interfacename">ViewResolver</tt> implementation. The fact that
    the model (the M in MVC) is based on the
    <tt class="interfacename">Map</tt> interface allows for the complete
    abstraction of the view technology. Any renderer can be integrated
    directly, whether JSP, Velocity, or any other rendering technology. The
    model <tt class="interfacename">Map</tt> is simply transformed into an
    appropriate format, such as JSP request attributes or a Velocity template
    model.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-introduction-pluggability"></a>13.1.1.&nbsp;Pluggability of other MVC implementations</h3></div></div><div></div></div><p>There are several reasons why some projects will prefer to use
      other MVC implementations. Many teams expect to leverage their existing
      investment in skills and tools. In addition, there is a large body of
      knowledge and experience available for the Struts framework. Thus, if
      you can live with Struts' architectural flaws, it can still be a viable
      choice for the web layer; the same applies to WebWork and other web MVC
      frameworks.</p><p>If you don't want to use Spring's web MVC, but intend to leverage
      other solutions that Spring offers, you can integrate the web MVC
      framework of your choice with Spring easily. Simply start up a Spring
      root application context via its
      <tt class="classname">ContextLoaderListener</tt>, and access it via its
      <tt class="interfacename">ServletContext</tt> attribute (or Spring's
      respective helper method) from within a Struts or WebWork action. Note
      that there aren't any "plug-ins" involved, so no dedicated integration
      is necessary. From the web layer's point of view, you'll simply use
      Spring as a library, with the root application context instance as the
      entry point.</p><p>All your registered beans and all of Spring's services can be at
      your fingertips even without Spring's Web MVC. Spring doesn't compete
      with Struts or WebWork in this scenario, it just addresses the many
      areas that the pure web MVC frameworks don't, from bean configuration to
      data access and transaction handling. So you are able to enrich your
      application with a Spring middle tier and/or data access tier, even if
      you just want to use, for example, the transaction abstraction with JDBC
      or Hibernate.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-features"></a>13.1.2.&nbsp;Features of Spring Web MVC</h3></div></div><div></div></div><div class="sidebar"><p class="title"><b>Spring Web Flow</b></p><p>Spring Web Flow (SWF) aims to be the best solution for the management
  of web application page flow.</p><p>SWF integrates with existing frameworks like Spring MVC, Struts, and
  JSF, in both servlet and portlet environments. If you have a business
  process (or processes) that would benefit from a conversational model as
  opposed to a purely request model, then SWF may be the solution.</p><p>SWF allows you to capture logical page flows as self-contained modules
  that are reusable in different situations, and as such is ideal for building
  web application modules that guide the user through controlled navigations
  that drive business processes.</p><p>For more information about SWF, consult the
  <a href="http://www.springframework.org/webflow" target="_top">Spring Web Flow website</a>.
  </p></div><p>Spring's web module provides a wealth of unique web support
      features, including:</p><div class="itemizedlist"><ul type="disc"><li><p>Clear separation of roles - controller, validator, command
          object, form object, model object,
          <tt class="classname">DispatcherServlet</tt>, handler mapping, view
          resolver, etc. Each role can be fulfilled by a specialized
          object.</p></li><li><p>Powerful and straightforward configuration of both framework
          and application classes as JavaBeans, including easy referencing
          across contexts, such as from web controllers to business objects
          and validators.</p></li><li><p>Adaptability, non-intrusiveness. Use whatever controller
          subclass you need (plain, command, form, wizard, multi-action, or a
          custom one) for a given scenario instead of deriving from a single
          controller for everything.</p></li><li><p>Reusable business code - no need for duplication. You can use
          existing business objects as command or form objects instead of
          mirroring them in order to extend a particular framework base
          class.</p></li><li><p>Customizable binding and validation - type mismatches as
          application-level validation errors that keep the offending value,
          localized date and number binding, etc instead of String-only form
          objects with manual parsing and conversion to business
          objects.</p></li><li><p>Customizable handler mapping and view resolution - handler
          mapping and view resolution strategies range from simple URL-based
          configuration, to sophisticated, purpose-built resolution
          strategies. This is more flexible than some web MVC frameworks which
          mandate a particular technique.</p></li><li><p>Flexible model transfer - model transfer via a name/value
          <tt class="interfacename">Map</tt> supports easy integration with
          any view technology.</p></li><li><p>Customizable locale and theme resolution, support for JSPs
          with or without Spring tag library, support for JSTL, support for
          Velocity without the need for extra bridges, etc.</p></li><li><p>A simple yet powerful JSP tag library known as the Spring tag
          library that provides support for features such as data binding and
          themes. The custom tags allow for maximum flexibility in terms of
          markup code. For information on the tag library descriptor, see the
          appendix entitled <a href="#spring.tld" title="Appendix&nbsp;D.&nbsp;spring.tld">Appendix&nbsp;D, <i>spring.tld</i></a></p></li><li><p>A JSP form tag library, introduced in Spring 2.0, that makes
          writing forms in JSP pages much easier. For information on the tag
          library descriptor, see the appendix entitled <a href="#spring-form.tld" title="Appendix&nbsp;E.&nbsp;spring-form.tld">Appendix&nbsp;E, <i>spring-form.tld</i></a></p></li><li><p>Beans whose lifecycle is scoped to the current HTTP request or
          HTTP <tt class="interfacename">Session</tt>. This is not a specific
          feature of Spring MVC itself, but rather of the
          <tt class="interfacename">WebApplicationContext</tt> container(s)
          that Spring MVC uses. These bean scopes are described in detail in
          the section entitled <a href="#beans-factory-scopes-other" title="3.4.4.&nbsp;The other scopes">Section&nbsp;3.4.4, &#8220;The other scopes&#8221;</a></p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-servlet"></a>13.2.&nbsp;The <tt class="classname">DispatcherServlet</tt></h2></div></div><div></div></div><p>Spring's web MVC framework is, like many other web MVC frameworks,
    request-driven, designed around a central servlet that dispatches requests
    to controllers and offers other functionality facilitating the development
    of web applications. Spring's <tt class="classname">DispatcherServlet</tt>
    however, does more than just that. It is completely integrated with the
    Spring IoC container and as such allows you to use every other feature
    that Spring has.</p><p>The request processing workflow of the Spring Web MVC
    <tt class="classname">DispatcherServlet</tt> is illustrated in the following
    diagram. The pattern-savvy reader will recognize that the
    <tt class="classname">DispatcherServlet</tt> is an expression of the
    &#8220;<span class="quote">Front Controller</span>&#8221; design pattern (this is a pattern that
    Spring Web MVC shares with many other leading web frameworks).</p><div class="mediaobject" align="center"><img src="images/mvc.png" align="middle"><div class="caption"><p>The requesting processing workflow in Spring Web MVC
        (high level)</p></div></div><p>The <tt class="classname">DispatcherServlet</tt> <span class="emphasis"><em>is</em></span>
    an actual <tt class="interfacename">Servlet</tt> (it inherits from the
    <tt class="classname">HttpServlet</tt> base class), and as such is declared in
    the <tt class="literal">web.xml</tt> of your web application. Requests that you
    want the <tt class="classname">DispatcherServlet</tt> to handle will have to
    be mapped using a URL mapping in the same <tt class="literal">web.xml</tt> file.
    This is standard J2EE servlet configuration; an example of such a
    <tt class="classname">DispatcherServlet</tt> declaration and mapping can be
    found below.</p><pre class="programlisting">&lt;web-app&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;example&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;example&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</pre><p>In the example above, all requests ending with
    <tt class="literal">.form</tt> will be handled by the
    <tt class="literal">'example'</tt> <tt class="classname">DispatcherServlet</tt>.
    This is only the first step in setting up Spring Web MVC... the various
    beans used by the Spring Web MVC framework (over and above the
    <tt class="classname">DispatcherServlet</tt> itself) now need to be
    configured.</p><p>As detailed in the section entitled <a href="#context-introduction" title="3.8.&nbsp;The ApplicationContext">Section&nbsp;3.8, &#8220;The ApplicationContext&#8221;</a>,
    <tt class="interfacename">ApplicationContext</tt> instances in Spring can
    be scoped. In the web MVC framework, each
    <tt class="classname">DispatcherServlet</tt> has its own
    <tt class="interfacename">WebApplicationContext</tt>, which inherits all
    the beans already defined in the root
    <tt class="interfacename">WebApplicationContext</tt>. These inherited
    beans defined can be overridden in the servlet-specific scope, and new
    scope-specific beans can be defined local to a given servlet
    instance.</p><div class="mediaobject" align="center"><img src="images/mvc-contexts.gif" align="middle"><div class="caption"><p>Context hierarchy in Spring Web MVC</p></div></div><p>The framework will, on initialization of a
    <tt class="classname">DispatcherServlet</tt>, <span class="emphasis"><em>look for a file named
    <tt class="literal">[servlet-name]-servlet.xml</tt></em></span> in the
    <tt class="literal">WEB-INF</tt> directory of your web application and create
    the beans defined there (overriding the definitions of any beans defined
    with the same name in the global scope).</p><p>Consider the following <tt class="classname">DispatcherServlet</tt>
    servlet configuration (in the <tt class="literal">'web.xml'</tt> file.)</p><pre class="programlisting">&lt;web-app&gt;

    &lt;servlet&gt;
        &lt;servlet-name&gt;<span class="bold"><b>golfing</b></span>&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;<span class="bold"><b>golfing</b></span>&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

&lt;/web-app&gt;</pre><p>With the above servlet configuration in place, you will need to have
    a file called <tt class="literal">'/WEB-INF/<span class="bold"><b>golfing</b></span>-servlet.xml'</tt> in your application;
    this file will contain all of your <span class="emphasis"><em>Spring Web
    MVC-specific</em></span> components (beans). The exact location of this
    configuration file can be changed via a servlet initialization parameter
    (see below for details).</p><p>The <tt class="interfacename">WebApplicationContext</tt> is an
    extension of the plain <tt class="interfacename">ApplicationContext</tt>
    that has some extra features necessary for web applications. It differs
    from a normal <tt class="interfacename">ApplicationContext</tt> in that it
    is capable of resolving themes (see <a href="#mvc-themeresolver" title="13.7.&nbsp;Using themes">Section&nbsp;13.7, &#8220;Using themes&#8221;</a>),
    and that it knows which servlet it is associated with (by having a link to
    the <tt class="interfacename">ServletContext</tt>). The
    <tt class="interfacename">WebApplicationContext</tt> is bound in the
    <tt class="interfacename">ServletContext</tt>, and by using static methods
    on the <tt class="classname">RequestContextUtils</tt> class you can always
    lookup the <tt class="interfacename">WebApplicationContext</tt> in case
    you need access to it.</p><p>The Spring <tt class="classname">DispatcherServlet</tt> has a couple of
    special beans it uses in order to be able to process requests and render
    the appropriate views. These beans are included in the Spring framework
    and can be configured in the
    <tt class="interfacename">WebApplicationContext</tt>, just as any other
    bean would be configured. Each of those beans is described in more detail
    below. Right now, we'll just mention them, just to let you know they exist
    and to enable us to go on talking about the
    <tt class="classname">DispatcherServlet</tt>. For most of the beans, sensible
    defaults are provided so you don't (initially) have to worry about
    configuring them.</p><div class="table"><a name="mvc-webappctx-special-beans-tbl"></a><p class="title"><b>Table&nbsp;13.1.&nbsp;Special beans in the
      <tt class="interfacename">WebApplicationContext</tt></b></p><table summary="Special beans in the&#xA;      WebApplicationContext" border="1"><colgroup><col><col></colgroup><thead><tr><th>Bean type</th><th>Explanation</th></tr></thead><tbody><tr><td>Controllers</td><td><a href="#mvc-controller" title="13.3.&nbsp;Controllers">Controllers</a> are the
            components that form the <tt class="literal">'C'</tt> part of the
            MVC.</td></tr><tr><td>Handler mappings</td><td><a href="#mvc-handlermapping" title="13.4.&nbsp;Handler mappings">Handler mappings</a>
            handle the execution of a list of pre- and post-processors and
            controllers that will be executed if they match certain criteria
            (for instance a matching URL specified with the
            controller)</td></tr><tr><td>View resolvers</td><td><a href="#mvc-viewresolver" title="13.5.&nbsp;Views and resolving them">View resolvers</a> are
            components capable of resolving view names to views</td></tr><tr><td>Locale resolver</td><td>A <a href="#mvc-localeresolver" title="13.6.&nbsp;Using locales">locale resolver</a>
            is a component capable of resolving the locale a client is using,
            in order to be able to offer internationalized views</td></tr><tr><td>Theme resolver</td><td>A <a href="#mvc-themeresolver" title="13.7.&nbsp;Using themes">theme resolver</a>
            is capable of resolving themes your web application can use, for
            example, to offer personalized layouts</td></tr><tr><td>multipart file resolver</td><td>A <a href="#mvc-multipart" title="13.8.&nbsp;Spring's multipart (fileupload) support">multipart file
            resolver</a> offers the functionality to process file uploads
            from HTML forms</td></tr><tr><td>Handler exception resolver(s)</td><td><a href="#mvc-exceptionhandlers" title="13.9.&nbsp;Handling exceptions">Handler exception
            resolvers</a> offer functionality to map exceptions to views or
            implement other more complex exception handling code</td></tr></tbody></table></div><p>When a <tt class="classname">DispatcherServlet</tt> is set up for use
    and a request comes in for that specific
    <tt class="classname">DispatcherServlet</tt>, said
    <tt class="classname">DispatcherServlet</tt> starts processing the request.
    The list below describes the complete process a request goes through when
    handled by a <tt class="classname">DispatcherServlet</tt>:</p><div class="orderedlist"><ol type="1"><li><p>The <tt class="interfacename">WebApplicationContext</tt> is
        searched for and bound in the request as an attribute in order for the
        controller and other elements in the process to use. It is bound by
        default under the key
        <tt class="literal">DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</tt>.</p></li><li><p>The locale resolver is bound to the request to let elements in
        the process resolve the locale to use when processing the request
        (rendering the view, preparing data, etc.) If you don't use the
        resolver, it won't affect anything, so if you don't need locale
        resolving, you don't have to use it.</p></li><li><p>The theme resolver is bound to the request to let elements such
        as views determine which theme to use. The theme resolver does not
        affect anything if you don't use it, so if you don't need themes you
        can just ignore it.</p></li><li><p>If a multipart resolver is specified, the request is inspected
        for multiparts; if multiparts are found, the request is wrapped in a
        <tt class="classname">MultipartHttpServletRequest</tt> for further
        processing by other elements in the process. (See the section entitled
        <a href="#mvc-multipart-resolver" title="13.8.2.&nbsp;Using the&#xA;      MultipartResolver">Section&nbsp;13.8.2, &#8220;Using the
      MultipartResolver&#8221;</a> for further information
        about multipart handling).</p></li><li><p>An appropriate handler is searched for. If a handler is found,
        the execution chain associated with the handler (preprocessors,
        postprocessors, and controllers) will be executed in order to prepare
        a model (for rendering).</p></li><li><p>If a model is returned, the view is rendered. If no model is
        returned (which could be due to a pre- or postprocessor intercepting
        the request, for example, for security reasons), no view is rendered,
        since the request could already have been fulfilled.</p></li></ol></div><p>Exceptions that are thrown during processing of the request get
    picked up by any of the handler exception resolvers that are declared in
    the <tt class="interfacename">WebApplicationContext</tt>. Using these
    exception resolvers allows you to define custom behaviors in case such
    exceptions get thrown.</p><p>The Spring <tt class="classname">DispatcherServlet</tt> also has support
    for returning the <span class="emphasis"><em>last-modification-date</em></span>, as
    specified by the Servlet API. The process of determining the last
    modification date for a specific request is straightforward: the
    <tt class="classname">DispatcherServlet</tt> will first lookup an appropriate
    handler mapping and test if the handler that is found <span class="emphasis"><em>implements
    the interface <tt class="interfacename">LastModified</tt></em></span>
    interface. If so, the value of the <tt class="literal">long
    getLastModified(request)</tt> method of the
    <tt class="interfacename">LastModified</tt> interface is returned to the
    client.</p><p>You can customize Spring's <tt class="classname">DispatcherServlet</tt>
    by adding context parameters in the <tt class="literal">web.xml</tt> file or
    servlet initialization parameters. The possibilities are listed
    below.</p><div class="table"><a name="mvc-disp-servlet-init-params-tbl"></a><p class="title"><b>Table&nbsp;13.2.&nbsp;<tt class="classname">DispatcherServlet</tt> initialization
      parameters</b></p><table summary="DispatcherServlet initialization&#xA;      parameters" border="1"><colgroup><col><col></colgroup><thead><tr><th>Parameter</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="literal">contextClass</tt></td><td>Class that implements
            <tt class="interfacename">WebApplicationContext</tt>, which will
            be used to instantiate the context used by this servlet. If this
            parameter isn't specified, the
            <tt class="classname">XmlWebApplicationContext</tt> will be
            used.</td></tr><tr><td><tt class="literal">contextConfigLocation</tt></td><td>String which is passed to the context instance (specified
            by <tt class="literal">contextClass</tt>) to indicate where context(s)
            can be found. The string is potentially split up into multiple
            strings (using a comma as a delimiter) to support multiple
            contexts (in case of multiple context locations, of beans that are
            defined twice, the latest takes precedence).</td></tr><tr><td><tt class="literal">namespace</tt></td><td>the namespace of the
            <tt class="interfacename">WebApplicationContext</tt>. Defaults to
            <tt class="literal">[servlet-name]-servlet</tt>.</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-controller"></a>13.3.&nbsp;Controllers</h2></div></div><div></div></div><p>The notion of a controller is part of the MVC design pattern (more
    specifically, it is the <span class="emphasis"><em>'C'</em></span> in MVC). Controllers
    provide access to the application behavior which is typically defined by a
    service interface. Controllers interpret user input and transform such
    input into a sensible model which will be represented to the user by the
    view. Spring has implemented the notion of a controller in a very abstract
    way enabling a wide variety of different kinds of controllers to be
    created. Spring contains form-specific controllers, command-based
    controllers, and controllers that execute wizard-style logic, to name but
    a few.</p><p>Spring's basis for the controller architecture is the
    <tt class="interfacename">org.springframework.web.servlet.mvc.Controller</tt>
    interface, the source code for which is listed below.</p><pre class="programlisting">public interface Controller {

    /**
     * Process the request and return a ModelAndView object which the DispatcherServlet
     * will render.
     */
    ModelAndView handleRequest(
        HttpServletRequest request,
        HttpServletResponse response) throws Exception;

}</pre><p>As you can see, the <tt class="interfacename">Controller</tt>
    interface defines a single method that is responsible for handling a
    request and returning an appropriate model and view. These three concepts
    are the basis for the Spring MVC implementation -
    <tt class="classname">ModelAndView</tt> and
    <tt class="interfacename">Controller</tt>. While the
    <tt class="interfacename">Controller</tt> interface is quite abstract,
    Spring offers a lot of <tt class="interfacename">Controller</tt>
    implementations out of the box that already contain a lot of the
    functionality you might need. The
    <tt class="interfacename">Controller</tt> interface just defines the most
    basic responsibility required of every controller; namely handling a
    request and returning a model and a view.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-abstractcontroller"></a>13.3.1.&nbsp;<tt class="classname">AbstractController</tt> and
      <tt class="classname">WebContentGenerator</tt></h3></div></div><div></div></div><p>To provide a basic infrastructure, all of Spring's various
      <tt class="interfacename">Controller</tt> inherit from
      <tt class="classname">AbstractController</tt>, a class offering caching
      support and, for example, the setting of the mimetype.</p><div class="table"><a name="mvc-controller-abstract-features"></a><p class="title"><b>Table&nbsp;13.3.&nbsp;Features offered by the
        <tt class="classname">AbstractController</tt></b></p><table summary="Features offered by the&#xA;        AbstractController" border="1"><colgroup><col><col></colgroup><thead><tr><th>Feature</th><th>Explanation</th></tr></thead><tbody><tr><td><tt class="literal">supportedMethods</tt></td><td>indicates what methods this controller should accept.
              Usually this is set to both <tt class="literal">GET</tt> and
              <tt class="literal">POST</tt>, but you can modify this to reflect the
              method you want to support. If a request is received with a
              method that is not supported by the controller, the client will
              be informed of this (expedited by the throwing of a
              <tt class="classname">ServletException</tt>).</td></tr><tr><td><tt class="literal">requireSession</tt></td><td>indicates whether or not this controller requires a HTTP
              session to do its work. If a session is not present when such a
              controller receives a request, the user is informed of this by a
              <tt class="classname">ServletException</tt> being thrown.</td></tr><tr><td><tt class="literal">synchronizeOnSession</tt></td><td>use this if you want handling by this controller to be
              synchronized on the user's HTTP session.</td></tr><tr><td><tt class="literal">cacheSeconds</tt></td><td>when you want a controller to generate a caching
              directive in the HTTP response, specify a positive integer here.
              By default the value of this property is set to
              <span class="emphasis"><em>-1</em></span> so no caching directives will be
              included in the generated response.</td></tr><tr><td><tt class="literal">useExpiresHeader</tt></td><td>tweaks your controllers to specify the HTTP 1.0
              compatible <span class="emphasis"><em>"Expires"</em></span> header in the
              generated response. By default the value of this property is
              <tt class="literal">true</tt>.</td></tr><tr><td><tt class="literal">useCacheHeader</tt></td><td>tweaks your controllers to specify the HTTP 1.1
              compatible <span class="emphasis"><em>"Cache-Control"</em></span> header in the
              generated response. By default the value of this property is
              <tt class="literal">true</tt>.</td></tr></tbody></table></div><p>When using the <tt class="classname">AbstractController</tt> as the
      baseclass for your controllers you only have to override the
      <tt class="literal">handleRequestInternal(HttpServletRequest,
      HttpServletResponse)</tt> method, implement your logic, and return
      a <tt class="classname">ModelAndView</tt> object. Here is short example
      consisting of a class and a declaration in the web application
      context.</p><pre class="programlisting">package samples;

public class SampleController extends AbstractController {

    public ModelAndView handleRequestInternal(
        HttpServletRequest request,
        HttpServletResponse response) throws Exception {

        ModelAndView mav = new ModelAndView("hello");
        mav.addObject("message", "Hello World!");
        return mav;        
    }
}</pre><pre class="programlisting">&lt;bean id="sampleController" class="samples.SampleController"&gt;
    &lt;property name="cacheSeconds" value="120"/&gt;
&lt;/bean&gt;</pre><p>The above class and the declaration in the web application context
      is all you need besides setting up a handler mapping (see the section
      entitled <a href="#mvc-handlermapping" title="13.4.&nbsp;Handler mappings">Section&nbsp;13.4, &#8220;Handler mappings&#8221;</a>) to get this very simple
      controller working. This controller will generate caching directives
      telling the client to cache things for 2 minutes before rechecking. This
      controller also returns a hard-coded view (which is typically considered
      bad practice).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-othersimplecontrollers"></a>13.3.2.&nbsp;Other simple controllers</h3></div></div><div></div></div><p>Although you can extend <tt class="classname">AbstractController</tt>,
      Spring provides a number of concrete implementations which offer
      functionality that is commonly used in simple MVC applications. The
      <tt class="classname">ParameterizableViewController</tt> is basically the
      same as the example above, except for the fact that you can specify the
      view name that it will return in the web application context (and thus
      remove the need to hard-code the viewname in the Java class).</p><p>The <tt class="classname">UrlFilenameViewController</tt> inspects the
      URL and retrieves the filename of the file request and uses that as a
      viewname. For example, the filename of
      <tt class="literal">http://www.springframework.org/index.html</tt> request is
      <tt class="literal">index</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-multiaction"></a>13.3.3.&nbsp;The <tt class="classname">MultiActionController</tt></h3></div></div><div></div></div><p>Spring offers a <tt class="classname">MultiActionController</tt> class
      that supports the aggregation of multiple request-handling methods into
      one controller, which then allows you to group related functionality
      together. (If you are a Struts veteran you might recognize the
      similarity between the Struts <tt class="classname">DispatchAction</tt> and
      the Spring MVC <tt class="classname">MultiActionController</tt>.) The
      <tt class="classname">MultiActionController</tt> class is defined in a
      distinct package -
      <tt class="literal">org.springframework.web.servlet.mvc.multiaction</tt> - and
      it is capable of mapping requests to method names and then invoking the
      correct method to handle a particular request. Using the
      <tt class="classname">MultiActionController</tt> is especially handy when
      you have a lot of related functionality that would perhaps be nice to
      define all in a single class without having to implement one
      <tt class="interfacename">Controller</tt> for each bit of functionality.
      The <tt class="classname">MultiActionController</tt> typically is not
      appropriate for capturing very complex request-handling logic or use
      cases that address totally-different areas of functionality, and you are
      encouraged to stick with the standard <span class="emphasis"><em>'one
      piece-of-functionality maps to one
      <tt class="interfacename">Controller</tt>'</em></span> for such
      cases.</p><p>There are two usage-styles for the
      <tt class="classname">MultiActionController</tt>. Either you subclass the
      <tt class="classname">MultiActionController</tt> and specify the methods
      that will be resolved by the
      <tt class="interfacename">MethodNameResolver</tt> on your subclass, or
      you define a delegate object, on which methods resolved by the
      <tt class="interfacename">MethodNameResolver</tt> will be invoked. If
      you choose the former style, you do not need to set a delegate, but for
      the latter style, you will need to inject your delegate object into the
      <tt class="classname">MultiActionController</tt> as a collaborator (either
      as a single constructor argument or via the
      '<tt class="methodname">setDelegate</tt>' method).</p><p>The <tt class="classname">MultiActionController</tt> needs some
      strategy to determine which method to invoke when handling an incoming
      request: this strategy is defined by the
      <tt class="interfacename">MethodNameResolver</tt> interface. The
      <tt class="classname">MultiActionController</tt> class exposes the
      '<tt class="literal">methodNameResolver</tt>' property so that you can inject
      a <tt class="interfacename">MethodNameResolver</tt> that is capable of
      doing that. The methods that you define on a
      <tt class="classname">MultiActionController</tt> (or on the class of the
      injected delegate object) must conform to the following
      signature:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// '<tt class="literal">anyMeaningfulName</tt>' can be replaced by any method name</span></i>
public [ModelAndView | Map | void] anyMeaningfulName(HttpServletRequest, HttpServletResponse [,HttpSession] [,AnyObject])</pre><p>The full details of this method signature are covered in the
      <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/servlet/mvc/multiaction/MultiActionController.html" target="_top">class-level
      Javadoc</a> of the <tt class="classname">MultiActionController</tt>
      source itself. If you are planning to use the
      <tt class="classname">MultiActionController</tt>, you are highly encouraged
      to consult that Javadoc. However, below you will find some basic
      examples of valid <tt class="classname">MultiActionController</tt> method
      signatures.</p><p>The standard signature (mirrors the
      <tt class="interfacename">Controller</tt> interface method).</p><pre class="programlisting">public ModelAndView displayCatalog(HttpServletRequest, HttpServletResponse)</pre><p>This signature accepts a <tt class="classname">Login</tt> argument
      that will be populated (bound) with parameters retrieved from the
      request.</p><pre class="programlisting">public ModelAndView login(HttpServletRequest, HttpServletResponse, Login)</pre><p>This signature requires that the request already have a valid
      session.</p><pre class="programlisting">public ModelAndView viewCart(HttpServletRequest, HttpServletResponse, HttpSession)</pre><p>This signature accepts a <tt class="classname">Product</tt> argument
      that will be populated (bound) with parameters retrieved from the
      request <span class="emphasis"><em>and</em></span> requires that the request already have
      a valid session. Note that the order of arguments is important: the
      session must be the third argument, and an object to be bound must
      always be the final argument (fourth when a session is specified, or
      third otherwise).</p><pre class="programlisting">public ModelAndView updateCart(HttpServletRequest, HttpServletResponse, HttpSession, Product)</pre><p>This signature has a <tt class="literal">void</tt> return type
      indicating that the handler method assumes the responsibility of writing
      the response.</p><pre class="programlisting">public void home(HttpServletRequest, HttpServletResponse)</pre><p>This signature has a <tt class="interfacename">Map</tt> return
      type indicating that a view name translator will be responsible for
      providing the view name based upon the request, and the model will
      consist of the <tt class="interfacename">Map's</tt> entries (see the
      section entitled <a href="#mvc-coc" title="13.10.&nbsp;Convention over configuration">Section&nbsp;13.10, &#8220;Convention over configuration&#8221;</a> below).</p><pre class="programlisting">public Map list(HttpServletRequest, HttpServletResponse)</pre><p>The <tt class="interfacename">MethodNameResolver</tt> is
      responsible for resolving method names based on the specifics of the
      incoming <tt class="interfacename">HttpServletRequest</tt>. A number of
      <tt class="interfacename">MethodNameResolver</tt> implementations are
      provided for you, and of course you can always write your own. Please
      also note that the <tt class="classname">InternalPathMethodNameResolver</tt>
      is the default <tt class="interfacename">MethodNameResolver</tt> that
      will be used if you don't inject one explicitly.</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">InternalPathMethodNameResolver</tt> -
          interprets the final filename from the request path and uses that as
          the method name/</p><p>For example,
          '<tt class="literal">http://www.sf.net/testing.view</tt>' will result in
          the method <tt class="methodname">testing(HttpServletRequest,
          HttpServletResponse)</tt> being invoked.</p></li><li><p><tt class="classname">ParameterMethodNameResolver</tt> -
          interprets a request parameter as the name of the method that is to
          be invoked.</p><p>For example,
          '<tt class="literal">http://www.sf.net/index.view?method=testIt</tt>' will
          result in the method <tt class="methodname">testIt(HttpServletRequest,
          HttpServletResponse)</tt> being invoked. The
          '<tt class="literal">paramName</tt>' property specifies the name of the
          request parameter that is to be used.</p></li><li><p><tt class="classname">PropertiesMethodNameResolver</tt> - uses a
          user-defined <tt class="classname">Properties</tt> object with request
          URLs mapped to method names. For example, when the
          <tt class="classname">Properties</tt> contain
          '<tt class="literal">/index/welcome.html=doIt</tt>' and a request to
          <tt class="literal">/index/welcome.html</tt> comes in, the
          <tt class="methodname">doIt(HttpServletRequest,
          HttpServletResponse)</tt> method will be invoked. This
          particular <tt class="interfacename">MethodNameResolver</tt> uses
          the Spring <tt class="classname">PathMatcher</tt> class internally, so
          if the <tt class="classname">Properties</tt> contained
          '<tt class="literal">/**/welcom?.html</tt>', the example would also have
          worked.</p></li></ul></div><p>You may also declare custom methods for handling
      <tt class="classname">Exceptions</tt> that occur during request handling.
      The valid signature for such a method is similar to the request handling
      methods in that the <tt class="interfacename">HttpServletRequest</tt>
      and <tt class="interfacename">HttpServletResponse</tt> must be provided
      as the first and second parameters respectively. Unlike request handling
      methods however, the method's name is irrelevant. Instead, when
      determining which <tt class="classname">Exception</tt> handling method to
      invoke, the decision is based upon the most specific possible match
      among the methods whose third argument is some type of
      <tt class="classname">Exception</tt>. Here is an example signature for one
      such <tt class="classname">Exception</tt> handling method.</p><pre class="programlisting">public ModelAndView processException(HttpServletRequest, HttpServletResponse, IllegalArgumentException)</pre><p>Let's look at an example showing the delegate-style of
      <tt class="classname">MultiActionController</tt> usage in conjunction with
      the <tt class="classname">ParameterMethodNameResolver</tt>.</p><pre class="programlisting">&lt;bean id="paramMultiController"
      class="org.springframework.web.servlet.mvc.multiaction.MultiActionController"&gt;

    &lt;property name="methodNameResolver"&gt;
        &lt;bean class="org.springframework.web.servlet.mvc.multiaction.ParameterMethodNameResolver"&gt;
            &lt;property name="paramName" value="method"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;

    &lt;property name="delegate"&gt;
        &lt;bean class="samples.SampleDelegate"/&gt;
    &lt;/property&gt;

&lt;/bean&gt;
}</pre><pre class="programlisting">public class SampleDelegate {

    public ModelAndView retrieveIndex(HttpServletRequest req, HttpServletResponse resp) {
        return new ModelAndView("index", "date", new Long(System.currentTimeMillis()));
    }
}</pre><p>When using the delegate shown above, we could also configure the
      <tt class="classname">PropertiesMethodNameResolver</tt> to match any number
      couple of URLs to the method we defined:</p><pre class="programlisting">&lt;bean id="propsResolver"
      class="org....mvc.multiaction.PropertiesMethodNameResolver"&gt;
    &lt;property name="mappings"&gt;
        &lt;value&gt;
/index/welcome.html=retrieveIndex
/**/notwelcome.html=retrieveIndex
/*/user?.html=retrieveIndex
        &lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="paramMultiController" class="org....mvc.multiaction.MultiActionController"&gt;

    &lt;property name="methodNameResolver" ref="propsResolver"/&gt;
    &lt;property name="delegate"&gt;
        &lt;bean class="samples.SampleDelegate"/&gt;
    &lt;/property&gt;

&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-controller-command"></a>13.3.4.&nbsp;Command controllers</h3></div></div><div></div></div><p>Spring's <span class="emphasis"><em>command controllers</em></span> are a
      fundamental part of the Spring Web MVC package. Command controllers
      provide a way to interact with data objects and dynamically bind
      parameters from the <tt class="interfacename">HttpServletRequest</tt> to
      the data object specified. They perform a somewhat similar role to the
      Struts <tt class="classname">ActionForm</tt>, but in Spring, your data
      objects don't have to implement a framework-specific interface. First,
      lets examine what command controllers are available straight out of the
      box.</p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="classname">AbstractCommandController</tt> - a command
          controller you can use to create your own command controller,
          capable of binding request parameters to a data object you specify.
          This class does not offer form functionality; it does however offer
          validation features and lets you specify in the controller itself
          what to do with the command object that has been populated with
          request parameter values.</p></li><li><p><tt class="classname">AbstractFormController</tt> - an abstract
          controller offering form submission support. Using this controller
          you can model forms and populate them using a command object you
          retrieve in the controller. After a user has filled the form, the
          <tt class="classname">AbstractFormController</tt> binds the fields,
          validates the command object, and hands the object back to the
          controller to take the appropriate action. Supported features are:
          invalid form submission (resubmission), validation, and normal form
          workflow. You implement methods to determine which views are used
          for form presentation and success. Use this controller if you need
          forms, but don't want to specify what views you're going to show the
          user in the application context.</p></li><li><p><tt class="classname">SimpleFormController</tt> - a form
          controller that provides even more support when creating a form with
          a corresponding command object. The
          <tt class="classname">SimpleFormController</tt> let's you specify a
          command object, a viewname for the form, a viewname for page you
          want to show the user when form submission has succeeded, and
          more.</p></li><li><p><tt class="classname">AbstractWizardFormController</tt> - as the
          class name suggests, this is an abstract class - your wizard
          controller should extend it. This means you have to implement the
          <tt class="literal">validatePage()</tt>,
          <tt class="literal">processFinish()</tt> and
          <tt class="literal">processCancel()</tt> methods.</p><p>You probably also want to write a contractor, which should at
          the very least call <tt class="literal">setPages()</tt> and
          <tt class="literal">setCommandName()</tt>. The former takes as its
          argument an array of type String. This array is the list of views
          which comprise your wizard. The latter takes as its argument a
          String, which will be used to refer to your command object from
          within your views.</p><p>As with any instance of
          <tt class="classname">AbstractFormController</tt>, you are required to
          use a command object - a JavaBean which will be populated with the
          data from your forms. You can do this in one of two ways: either
          call <tt class="literal">setCommandClass()</tt> from the constructor with
          the class of your command object, or implement the
          <tt class="literal">formBackingObject()</tt> method.</p><p><tt class="classname">AbstractWizardFormController</tt> has a
          number of concrete methods that you may wish to override. Of these,
          the ones you are likely to find most useful are:
          <tt class="literal">referenceData(..)</tt> which you can use to pass model
          data to your view in the form of a
          <tt class="interfacename">Map</tt>;
          <tt class="literal">getTargetPage()</tt> if your wizard needs to change
          page order or omit pages dynamically; and
          <tt class="literal">onBindAndValidate()</tt> if you want to override the
          built-in binding and validation workflow.</p><p>Finally, it is worth pointing out the
          <tt class="literal">setAllowDirtyBack()</tt> and
          <tt class="literal">setAllowDirtyForward()</tt>, which you can call from
          <tt class="literal">getTargetPage()</tt> to allow users to move backwards
          and forwards in the wizard even if validation fails for the current
          page.</p><p>For a full list of methods, see the Javadoc for
          <tt class="classname">AbstractWizardFormController</tt>. There is an
          implemented example of this wizard in the jPetStore included in the
          Spring distribution:
          <tt class="classname">org.springframework.samples.jpetstore.web.spring.OrderFormController</tt>.</p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-handlermapping"></a>13.4.&nbsp;Handler mappings</h2></div></div><div></div></div><p>Using a handler mapping you can map incoming web requests to
    appropriate handlers. There are some handler mappings you can use out of
    the box, for example, the <tt class="classname">SimpleUrlHandlerMapping</tt>
    or the <tt class="classname">BeanNameUrlHandlerMapping</tt>, but let's first
    examine the general concept of a
    <tt class="interfacename">HandlerMapping</tt>.</p><p>The functionality a basic
    <tt class="interfacename">HandlerMapping</tt> provides is the delivering
    of a <tt class="literal">HandlerExecutionChain</tt>, which must contain the
    handler that matches the incoming request, and may also contain a list of
    handler interceptors that are applied to the request. When a request comes
    in, the <tt class="classname">DispatcherServlet</tt> will hand it over to the
    handler mapping to let it inspect the request and come up with an
    appropriate HandlerExecutionChain. Then the
    <tt class="classname">DispatcherServlet</tt> will execute the handler and
    interceptors in the chain (if any).</p><p>The concept of configurable handler mappings that can optionally
    contain interceptors (executed before or after the actual handler was
    executed, or both) is extremely powerful. A lot of supporting
    functionality can be built into custom
    <tt class="interfacename">HandlerMapping</tt>s. Think of a custom handler
    mapping that chooses a handler not only based on the URL of the request
    coming in, but also on a specific state of the session associated with the
    request.</p><p>This section describes two of Spring's most commonly used handler
    mappings. They both extend the <tt class="literal">AbstractHandlerMapping</tt>
    and share the following properties:</p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">interceptors</tt>: the list of interceptors to
        use. <tt class="interfacename">HandlerInterceptor</tt>s are discussed
        in <a href="#mvc-handlermapping-interceptor" title="13.4.3.&nbsp;Intercepting requests - the&#xA;      HandlerInterceptor interface">Section&nbsp;13.4.3, &#8220;Intercepting requests - the
      HandlerInterceptor interface&#8221;</a>.</p></li><li><p><tt class="literal">defaultHandler</tt>: the default handler to use,
        when this handler mapping does not result in a matching
        handler.</p></li><li><p><tt class="literal">order</tt>: based on the value of the order
        property (see the <tt class="literal">org.springframework.core.Ordered</tt>
        interface), Spring will sort all handler mappings available in the
        context and apply the first matching handler.</p></li><li><p><tt class="literal">alwaysUseFullPath</tt>: if this property is set to
        <tt class="literal">true</tt>, Spring will use the full path within the
        current servlet context to find an appropriate handler. If this
        property is set to <tt class="literal">false</tt> (the default), the path
        within the current servlet mapping will be used. For example, if a
        servlet is mapped using <tt class="literal">/testing/*</tt> and the
        <tt class="literal">alwaysUseFullPath</tt> property is set to true,
        <tt class="literal">/testing/viewPage.html</tt> would be used, whereas if
        the property is set to false, <tt class="literal">/viewPage.html</tt> would
        be used.</p></li><li><p><tt class="literal">urlDecode</tt>: the default value for this
        property is <tt class="literal">true</tt>, as of Spring 2.5. If you prefer
        to compare encoded paths, switch this flag to
        <tt class="literal">false</tt>. However, note that the
        <tt class="interfacename">HttpServletRequest</tt> always exposes the
        servlet path in decoded form. Be aware that the servlet path will not
        match when compared with encoded paths.</p></li><li><p><tt class="literal">lazyInitHandlers</tt>: allows for lazy
        initialization of <span class="emphasis"><em>singleton</em></span> handlers (prototype
        handlers are always lazily initialized). Default value is
        <tt class="literal">false</tt>.</p></li></ul></div><p>(<span class="emphasis"><em>Note: the last three properties are only available to
    subclasses of
    <tt class="classname">org.springframework.web.servlet.handler.AbstractUrlHandlerMapping</tt></em></span>).</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-handlermapping-beanname"></a>13.4.1.&nbsp;<tt class="classname">BeanNameUrlHandlerMapping</tt></h3></div></div><div></div></div><p>A very simple, but very powerful handler mapping is the
      <tt class="classname">BeanNameUrlHandlerMapping</tt>, which maps incoming
      HTTP requests to names of beans, defined in the web application context.
      Let's say we want to enable a user to insert an account and we've
      already provided an appropriate form controller (see <a href="#mvc-controller-command" title="13.3.4.&nbsp;Command controllers">Section&nbsp;13.3.4, &#8220;Command controllers&#8221;</a> for more information on command- and
      form controllers) and a JSP view (or Velocity template) that renders the
      form. When using the <tt class="classname">BeanNameUrlHandlerMapping</tt>,
      we could map the HTTP request with the URL
      <tt class="literal">http://samples.com/editaccount.form</tt> to the
      appropriate form <tt class="interfacename">Controller</tt> as
      follows:</p><pre class="programlisting">&lt;beans&gt;
  &lt;bean id="handlerMapping" class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt;

  &lt;bean name="/editaccount.form" class="org.springframework.web.servlet.mvc.SimpleFormController"&gt;
    &lt;property name="formView" value="account"/&gt;
    &lt;property name="successView" value="account-created"/&gt;
    &lt;property name="commandName" value="account"/&gt;
    &lt;property name="commandClass" value="samples.Account"/&gt;
  &lt;/bean&gt;
&lt;beans&gt;</pre><p>All incoming requests for the URL
      <tt class="literal">/editaccount.form</tt> will now be handled by the form
      <tt class="interfacename">Controller</tt> in the source listing above.
      Of course we have to define a servlet-mapping in
      <tt class="literal">web.xml</tt> as well, to let through all the requests
      ending with <tt class="literal">.form</tt>.</p><pre class="programlisting">&lt;web-app&gt;
    ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

   <i class="lineannotation"><span class="lineannotation">&lt;!-- maps the sample dispatcher to <tt class="literal">*.form</tt> --&gt;</span></i>
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    ...
&lt;/web-app&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you want to use the
        <tt class="classname">BeanNameUrlHandlerMapping</tt>, you don't
        necessarily have to define it in the web application context (as
        indicated above). By default, if no handler mapping can be found in
        the context, the <tt class="classname">DispatcherServlet</tt> creates a
        <tt class="classname">BeanNameUrlHandlerMapping</tt> for you!</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-handlermapping-urlhandlermapping"></a>13.4.2.&nbsp;<tt class="classname">SimpleUrlHandlerMapping</tt></h3></div></div><div></div></div><p>A further - and much more powerful handler mapping - is the
      <tt class="classname">SimpleUrlHandlerMapping</tt>. This mapping is
      configurable in the application context and has Ant-style path matching
      capabilities (see the Javadoc for the
      <tt class="classname">org.springframework.util.PathMatcher</tt> class). Here
      is an example:</p><pre class="programlisting">&lt;web-app&gt;
    ...
    &lt;servlet&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
    &lt;/servlet&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- maps the sample dispatcher to *.form --&gt;</span></i>
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.form&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- maps the sample dispatcher to *.html --&gt;</span></i>
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;sample&lt;/servlet-name&gt;
        &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;
    ...
&lt;/web-app&gt;</pre><p>The above <tt class="literal">web.xml</tt> configuration snippet enables
      all requests ending with .html and <tt class="literal">.form</tt> to be
      handled by the sample dispatcher servlet.</p><pre class="programlisting">&lt;beans&gt;
        
    <i class="lineannotation"><span class="lineannotation">&lt;!-- no <tt class="literal">'id'</tt> required, <tt class="interfacename">HandlerMapping</tt> beans are automatically detected by the <tt class="classname">DispatcherServlet</tt> --&gt;</span></i>
    &lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="mappings"&gt;
            &lt;value&gt;
                /*/account.form=editAccountFormController
                /*/editaccount.form=editAccountFormController
                /ex/view*.html=helpController
                /**/help.html=helpController
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="helpController"
          class="org.springframework.web.servlet.mvc.UrlFilenameViewController"/&gt;

    &lt;bean id="editAccountFormController"
          class="org.springframework.web.servlet.mvc.SimpleFormController"&gt;
        &lt;property name="formView" value="account"/&gt;
        &lt;property name="successView" value="account-created"/&gt;
        &lt;property name="commandName" value="Account"/&gt;
        &lt;property name="commandClass" value="samples.Account"/&gt;
    &lt;/bean&gt;
&lt;beans&gt;</pre><p>This handler mapping routes requests for
      <tt class="literal">'help.html'</tt> in any directory to the
      <tt class="literal">'helpController'</tt>, which is a
      <tt class="classname">UrlFilenameViewController</tt> (more about controllers
      can be found in the section entitled <a href="#mvc-controller" title="13.3.&nbsp;Controllers">Section&nbsp;13.3, &#8220;Controllers&#8221;</a>).
      Requests for a resource beginning with <tt class="literal">'view'</tt>, and
      ending with <tt class="literal">'.html'</tt> in the directory
      <tt class="literal">'ex'</tt> will be routed to the
      <tt class="literal">'helpController'</tt>. Two further mappings are also
      defined for <tt class="literal">'editAccountFormController'</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-handlermapping-interceptor"></a>13.4.3.&nbsp;Intercepting requests - the
      <tt class="interfacename">HandlerInterceptor</tt> interface</h3></div></div><div></div></div><p>Spring's handler mapping mechanism has the notion of handler
      interceptors, that can be extremely useful when you want to apply
      specific functionality to certain requests, for example, checking for a
      principal.</p><p>Interceptors located in the handler mapping must implement
      <tt class="interfacename">HandlerInterceptor</tt> from the
      <tt class="literal">org.springframework.web.servlet</tt> package. This
      interface defines three methods, one that will be called
      <span class="emphasis"><em>before</em></span> the actual handler will be executed, one
      that will be called <span class="emphasis"><em>after</em></span> the handler is executed,
      and one that is called <span class="emphasis"><em>after the complete request has
      finished</em></span>. These three methods should provide enough
      flexibility to do all kinds of pre- and post-processing.</p><p>The <tt class="literal">preHandle(..)</tt> method returns a boolean
      value. You can use this method to break or continue the processing of
      the execution chain. When this method returns <tt class="literal">true</tt>,
      the handler execution chain will continue, when it returns false, the
      <tt class="classname">DispatcherServlet</tt> assumes the interceptor itself
      has taken care of requests (and, for example, rendered an appropriate
      view) and does not continue executing the other interceptors and the
      actual handler in the execution chain.</p><p>The following example provides an interceptor that intercepts all
      requests and reroutes the user to a specific page if the time is not
      between 9 a.m. and 6 p.m.</p><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="handlerMapping"
          class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="interceptors"&gt;
            &lt;list&gt;
                &lt;ref bean="officeHoursInterceptor"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name="mappings"&gt;
            &lt;value&gt;
                /*.form=editAccountFormController
                /*.view=editAccountFormController
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="officeHoursInterceptor"
          class="samples.TimeBasedAccessInterceptor"&gt;
        &lt;property name="openingTime" value="9"/&gt;
        &lt;property name="closingTime" value="18"/&gt;
    &lt;/bean&gt;
&lt;beans&gt;</pre><pre class="programlisting">package samples;

public class TimeBasedAccessInterceptor extends HandlerInterceptorAdapter {

    private int openingTime;
    private int closingTime;

    public void setOpeningTime(int openingTime) {
        this.openingTime = openingTime;
    }

    public void setClosingTime(int closingTime) {
        this.closingTime = closingTime;
    }

    public boolean preHandle(
            HttpServletRequest request,
            HttpServletResponse response,
            Object handler) throws Exception {

        Calendar cal = Calendar.getInstance();
        int hour = cal.get(HOUR_OF_DAY);
        if (openingTime &lt;= hour &lt; closingTime) {
            return true;
        } else {
            response.sendRedirect("http://host.com/outsideOfficeHours.html");
            return false;
        }
    }
}</pre><p>Any request coming in, will be intercepted by the
      <tt class="classname">TimeBasedAccessInterceptor</tt>, and if the current
      time is outside office hours, the user will be redirected to a static
      html file, saying, for example, he can only access the website during
      office hours.</p><p>As you can see, Spring has an adapter class (the cunningly named
      <tt class="classname">HandlerInterceptorAdapter</tt>) to make it easier to
      extend the <tt class="interfacename">HandlerInterceptor</tt>
      interface.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-viewresolver"></a>13.5.&nbsp;Views and resolving them</h2></div></div><div></div></div><p>All MVC frameworks for web applications provide a way to address
    views. Spring provides view resolvers, which enable you to render models
    in a browser without tying you to a specific view technology. Out of the
    box, Spring enables you to use JSPs, Velocity templates and XSLT views,
    for example. The section entitled <a href="#view" title="Chapter&nbsp;14.&nbsp;View technologies">Chapter&nbsp;14, <i>View technologies</i></a> has details of
    how to integrate and use a number of disparate view technologies.</p><p>The two interfaces which are important to the way Spring handles
    views are <tt class="interfacename">ViewResolver</tt> and
    <tt class="interfacename">View</tt>. The
    <tt class="interfacename">ViewResolver</tt> provides a mapping between
    view names and actual views. The <tt class="interfacename">View</tt>
    interface addresses the preparation of the request and hands the request
    over to one of the view technologies.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-viewresolver-resolver"></a>13.5.1.&nbsp;Resolving views - the <tt class="interfacename">ViewResolver</tt>
      interface</h3></div></div><div></div></div><p>As discussed in the section entitled <a href="#mvc-controller" title="13.3.&nbsp;Controllers">Section&nbsp;13.3, &#8220;Controllers&#8221;</a>, all controllers in the Spring Web MVC
      framework return a <tt class="classname">ModelAndView</tt> instance. Views
      in Spring are addressed by a view name and are resolved by a view
      resolver. Spring comes with quite a few view resolvers. We'll list most
      of them and then provide a couple of examples.</p><div class="table"><a name="mvc-view-resolvers-tbl"></a><p class="title"><b>Table&nbsp;13.4.&nbsp;View resolvers</b></p><table summary="View resolvers" border="1"><colgroup><col><col></colgroup><thead><tr><th><tt class="interfacename">ViewResolver</tt></th><th>Description</th></tr></thead><tbody><tr><td><tt class="classname">AbstractCachingViewResolver</tt></td><td>An abstract view resolver which takes care of caching
              views. Often views need preparation before they can be used,
              extending this view resolver provides caching of views.</td></tr><tr><td><tt class="classname">XmlViewResolver</tt></td><td>An implementation of
              <tt class="interfacename">ViewResolver</tt> that accepts a
              configuration file written in XML with the same DTD as Spring's
              XML bean factories. The default configuration file is
              <tt class="literal">/WEB-INF/views.xml</tt>.</td></tr><tr><td><tt class="classname">ResourceBundleViewResolver</tt></td><td>An implementation of
              <tt class="interfacename">ViewResolver</tt> that uses bean
              definitions in a <tt class="classname">ResourceBundle</tt>,
              specified by the bundle basename. The bundle is typically
              defined in a properties file, located in the classpath. The
              default file name is
              <tt class="literal">views.properties</tt>.</td></tr><tr><td><tt class="classname">UrlBasedViewResolver</tt></td><td>A simple implementation of the
              <tt class="interfacename">ViewResolver</tt> interface that
              effects the direct resolution of symbolic view names to URLs,
              without an explicit mapping definition. This is appropriate if
              your symbolic names match the names of your view resources in a
              straightforward manner, without the need for arbitrary
              mappings.</td></tr><tr><td><tt class="classname">InternalResourceViewResolver</tt></td><td>A convenience subclass of
              <tt class="classname">UrlBasedViewResolver</tt> that supports
              <tt class="classname">InternalResourceView</tt> (i.e. Servlets and
              JSPs), and subclasses such as <tt class="classname">JstlView</tt>
              and <tt class="classname">TilesView</tt>. The view class for all
              views generated by this resolver can be specified via
              <tt class="literal">setViewClass(..)</tt>. See the Javadocs for the
              <tt class="classname">UrlBasedViewResolver</tt> class for
              details.</td></tr><tr><td><tt class="classname">VelocityViewResolver</tt> /
              <tt class="classname">FreeMarkerViewResolver</tt></td><td>A convenience subclass of
              <tt class="classname">UrlBasedViewResolver</tt> that supports
              <tt class="classname">VelocityView</tt> (i.e. Velocity templates) or
              <tt class="classname">FreeMarkerView</tt> respectively and custom
              subclasses of them.</td></tr></tbody></table></div><p>As an example, when using JSP for a view technology you can use
      the <tt class="classname">UrlBasedViewResolver</tt>. This view resolver
      translates a view name to a URL and hands the request over to the
      RequestDispatcher to render the view.</p><pre class="programlisting">&lt;bean id="viewResolver"
      class="org.springframework.web.servlet.view.UrlBasedViewResolver"&gt;
    &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;
    &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
    &lt;property name="suffix" value=".jsp"/&gt;
&lt;/bean&gt;</pre><p>When returning <tt class="literal">test</tt> as a viewname, this view
      resolver will hand the request over to the
      <tt class="classname">RequestDispatcher</tt> that will send the request to
      <tt class="literal">/WEB-INF/jsp/test.jsp</tt>.</p><p>When mixing different view technologies in a web application, you
      can use the <tt class="classname">ResourceBundleViewResolver</tt>:</p><pre class="programlisting">&lt;bean id="viewResolver"
      class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename" value="views"/&gt;
    &lt;property name="defaultParentView" value="parentView"/&gt;
&lt;/bean&gt;</pre><p>The <tt class="classname">ResourceBundleViewResolver</tt> inspects the
      <tt class="classname">ResourceBundle</tt> identified by the basename, and
      for each view it is supposed to resolve, it uses the value of the
      property <tt class="literal">[viewname].class</tt> as the view class and the
      value of the property <tt class="literal">[viewname].url</tt> as the view url.
      As you can see, you can identify a parent view, from which all views in
      the properties file sort of extend. This way you can specify a default
      view class, for example.</p><p><span class="emphasis"><em>A note on caching</em></span> - subclasses of
      <tt class="classname">AbstractCachingViewResolver</tt> cache view instances
      they have resolved. This greatly improves performance when using certain
      view technologies. It's possible to turn off the cache, by setting the
      <tt class="literal">cache</tt> property to <tt class="literal">false</tt>.
      Furthermore, if you have the requirement to be able to refresh a certain
      view at runtime (for example when a Velocity template has been
      modified), you can use the <tt class="literal">removeFromCache(String viewName,
      Locale loc)</tt> method.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-viewresolver-chaining"></a>13.5.2.&nbsp;Chaining ViewResolvers</h3></div></div><div></div></div><p>Spring supports more than just one view resolver. This allows you
      to chain resolvers and, for example, override specific views in certain
      circumstances. Chaining view resolvers is pretty straightforward - just
      add more than one resolver to your application context and, if
      necessary, set the <tt class="literal">order</tt> property to specify an
      order. Remember, the higher the order property, the later the view
      resolver will be positioned in the chain.</p><p>In the following example, the chain of view resolvers consists of
      two resolvers, a <tt class="classname">InternalResourceViewResolver</tt>
      (which is always automatically positioned as the last resolver in the
      chain) and an <tt class="classname">XmlViewResolver</tt> for specifying
      Excel views (which are not supported by the
      <tt class="classname">InternalResourceViewResolver</tt>):</p><pre class="programlisting">&lt;bean id="jspViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
  &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;
  &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
  &lt;property name="suffix" value=".jsp"/&gt;
&lt;/bean&gt;

&lt;bean id="excelViewResolver" class="org.springframework.web.servlet.view.XmlViewResolver"&gt;
  &lt;property name="order" value="1"/&gt;
  &lt;property name="location" value="/WEB-INF/views.xml"/&gt;
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- in <tt class="literal">views.xml</tt> --&gt;</span></i>

&lt;beans&gt;
  &lt;bean name="report" class="org.springframework.example.ReportExcelView"/&gt;
&lt;/beans&gt;</pre><p>If a specific view resolver does not result in a view, Spring will
      inspect the context to see if other view resolvers are configured. If
      there are additional view resolvers, it will continue to inspect them.
      If not, it will throw an <tt class="classname">Exception</tt>.</p><p>You have to keep something else in mind - the contract of a view
      resolver mentions that a view resolver <span class="emphasis"><em>can</em></span> return
      null to indicate the view could not be found. Not all view resolvers do
      this however! This is because in some cases, the resolver simply cannot
      detect whether or not the view exists. For example, the
      <tt class="classname">InternalResourceViewResolver</tt> uses the
      <tt class="classname">RequestDispatcher</tt> internally, and dispatching is
      the only way to figure out if a JSP exists - this can only be done once.
      The same holds for the <tt class="classname">VelocityViewResolver</tt> and
      some others. Check the Javadoc for the view resolver to see if you're
      dealing with a view resolver that does not report non-existing views. As
      a result of this, putting an
      <tt class="classname">InternalResourceViewResolver</tt> in the chain in a
      place other than the last, will result in the chain not being fully
      inspected, since the <tt class="classname">InternalResourceViewResolver</tt>
      will <span class="emphasis"><em>always</em></span> return a view!</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-redirecting"></a>13.5.3.&nbsp;Redirecting to views</h3></div></div><div></div></div><p>As has been mentioned, a controller normally returns a logical
      view name, which a view resolver resolves to a particular view
      technology. For view technologies such as JSPs that are actually
      processed via the Servlet/JSP engine, this is normally handled via
      <tt class="classname">InternalResourceViewResolver</tt> /
      <tt class="classname">InternalResourceView</tt> which will ultimately end up
      issuing an internal forward or include, via the Servlet API's
      <tt class="literal">RequestDispatcher.forward(..)</tt> or
      <tt class="literal">RequestDispatcher.include()</tt>. For other view
      technologies, such as Velocity, XSLT, etc., the view itself produces the
      content on the response stream.</p><p>It is sometimes desirable to issue an HTTP redirect back to the
      client, before the view is rendered. This is desirable for example when
      one controller has been called with <tt class="literal">POST</tt>ed data, and
      the response is actually a delegation to another controller (for example
      on a successful form submission). In this case, a normal internal
      forward will mean the other controller will also see the same
      <tt class="literal">POST</tt> data, which is potentially problematic if it can
      confuse it with other expected data. Another reason to do a redirect
      before displaying the result is that this will eliminate the possibility
      of the user doing a double submission of form data. The browser will
      have sent the initial <tt class="literal">POST</tt>, will have seen a redirect
      back and done a subsequent <tt class="literal">GET</tt> because of that, and
      thus as far as it is concerned, the current page does not reflect the
      result of a <tt class="literal">POST</tt>, but rather of a
      <tt class="literal">GET</tt>, so there is no way the user can accidentally
      re-<tt class="literal">POST</tt> the same data by doing a refresh. The refresh
      would just force a <tt class="literal">GET</tt> of the result page, not a
      resend of the initial <tt class="literal">POST</tt> data.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mvc-redirecting-redirect-view"></a>13.5.3.1.&nbsp;<tt class="classname">RedirectView</tt></h4></div></div><div></div></div><p>One way to force a redirect as the result of a controller
        response is for the controller to create and return an instance of
        Spring's <tt class="classname">RedirectView</tt>. In this case,
        <tt class="classname">DispatcherServlet</tt> will not use the normal view
        resolution mechanism, but rather as it has been given the (redirect)
        view already, will just ask it to do its work.</p><p>The <tt class="classname">RedirectView</tt> simply ends up issuing
        an <tt class="literal">HttpServletResponse.sendRedirect()</tt> call, which
        will come back to the client browser as an HTTP redirect. All model
        attributes are simply exposed as HTTP query parameters. This does mean
        that the model must contain only objects (generally Strings or
        convertible to Strings) which can be readily converted to a
        string-form HTTP query parameter.</p><p>If using <tt class="classname">RedirectView</tt> and the view is
        created by the controller itself, it is preferable for the redirect
        URL to be injected into the controller so that it is not baked into
        the controller but configured in the context along with the view
        names.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mvc-redirecting-redirect-prefix"></a>13.5.3.2.&nbsp;The <tt class="literal">redirect:</tt> prefix</h4></div></div><div></div></div><p>While the use of <tt class="classname">RedirectView</tt> works fine,
        if the controller itself is creating the
        <tt class="classname">RedirectView</tt>, there is no getting around the
        fact that the controller is aware that a redirection is happening.
        This is really suboptimal and couples things too tightly. The
        controller should not really care about how the response gets
        handled... it should generally think only in terms of view names that
        have been injected into it.</p><p>The special <tt class="literal">redirect:</tt> prefix allows this to
        be achieved. If a view name is returned which has the prefix
        redirect:, then <tt class="classname">UrlBasedViewResolver</tt> (and all
        subclasses) will recognize this as a special indication that a
        redirect is needed. The rest of the view name will be treated as the
        redirect URL.</p><p>The net effect is the same as if the controller had returned a
        <tt class="classname">RedirectView</tt>, but now the controller itself can
        deal just in terms of logical view names. A logical view name such as
        <tt class="literal">redirect:/my/response/controller.html</tt> will redirect
        relative to the current servlet context, while a name such as
        <tt class="literal">redirect:http://myhost.com/some/arbitrary/path.html</tt>
        will redirect to an absolute URL. The important thing is that as long
        as this redirect view name is injected into the controller like any
        other logical view name, the controller is not even aware that
        redirection is happening.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mvc-redirecting-forward-prefix"></a>13.5.3.3.&nbsp;The <tt class="literal">forward:</tt> prefix</h4></div></div><div></div></div><p>It is also possible to use a special <tt class="literal">forward:</tt>
        prefix for view names that will ultimately be resolved by
        <tt class="classname">UrlBasedViewResolver</tt> and subclasses. All this
        does is create an <tt class="classname">InternalResourceView</tt> (which
        ultimately does a <tt class="literal">RequestDispatcher.forward()</tt>)
        around the rest of the view name, which is considered a URL.
        Therefore, there is never any use in using this prefix when using
        <tt class="classname">InternalResourceViewResolver</tt> /
        <tt class="classname">InternalResourceView</tt> anyway (for JSPs for
        example), but it's of potential use when you are primarily using
        another view technology, but still want to force a forward to happen
        to a resource to be handled by the Servlet/JSP engine. (Note that you
        may also chain multiple view resolvers, instead.)</p><p>As with the <tt class="literal">redirect:</tt> prefix, if the view
        name with the prefix is just injected into the controller, the
        controller does not have to be aware that anything special is
        happening in terms of handling the response.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-localeresolver"></a>13.6.&nbsp;Using locales</h2></div></div><div></div></div><p>Most parts of Spring's architecture support internationalization,
    just as the Spring web MVC framework does.
    <tt class="classname">DispatcherServlet</tt> enables you to automatically
    resolve messages using the client's locale. This is done with
    <tt class="interfacename">LocaleResolver</tt> objects.</p><p>When a request comes in, the
    <tt class="classname">DispatcherServlet</tt> looks for a locale resolver and
    if it finds one it tries to use it to set the locale. Using the
    <tt class="literal">RequestContext.getLocale()</tt> method, you can always
    retrieve the locale that was resolved by the locale resolver.</p><p>Besides the automatic locale resolution, you can also attach an
    interceptor to the handler mapping (see <a href="#mvc-handlermapping-interceptor" title="13.4.3.&nbsp;Intercepting requests - the&#xA;      HandlerInterceptor interface">Section&nbsp;13.4.3, &#8220;Intercepting requests - the
      HandlerInterceptor interface&#8221;</a> for more information on
    handler mapping interceptors), to change the locale under specific
    circumstances, based on a parameter in the request, for example.</p><p>Locale resolvers and interceptors are all defined in the
    <tt class="literal">org.springframework.web.servlet.i18n</tt> package, and are
    configured in your application context in the normal way. Here is a
    selection of the locale resolvers included in Spring.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-acceptheader"></a>13.6.1.&nbsp;<tt class="classname">AcceptHeaderLocaleResolver</tt></h3></div></div><div></div></div><p>This locale resolver inspects the
      <tt class="literal">accept-language</tt> header in the request that was sent
      by the browser of the client. Usually this header field contains the
      locale of the client's operating system.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-cookie"></a>13.6.2.&nbsp;<tt class="classname">CookieLocaleResolver</tt></h3></div></div><div></div></div><p>This locale resolver inspects a <tt class="classname">Cookie</tt> that
      might exist on the client, to see if a locale is specified. If so, it
      uses that specific locale. Using the properties of this locale resolver,
      you can specify the name of the cookie, as well as the maximum age. Find
      below an example of defining a
      <tt class="classname">CookieLocaleResolver</tt>.</p><pre class="programlisting">&lt;bean id="localeResolver" class="org.springframework.web.servlet.i18n.CookieLocaleResolver"&gt;

    &lt;property name="cookieName" value="clientlanguage"/&gt;
    
    <i class="lineannotation"><span class="lineannotation">&lt;!-- in seconds. If set to <tt class="literal">-1</tt>, the cookie is not persisted (deleted when browser shuts down) --&gt;</span></i>
    &lt;property name="cookieMaxAge" value="100000"&gt;

&lt;/bean&gt;</pre><div class="table"><a name="mvc-cookie-locale-resolver-props-tbl"></a><p class="title"><b>Table&nbsp;13.5.&nbsp;<tt class="classname">CookieLocaleResolver</tt> properties</b></p><table summary="CookieLocaleResolver properties" border="1"><colgroup><col><col><col></colgroup><thead><tr><th>Property</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td>cookieName</td><td>classname + LOCALE</td><td>The name of the cookie</td></tr><tr><td>cookieMaxAge</td><td>Integer.MAX_INT</td><td>The maximum time a cookie will stay persistent on the
              client. If -1 is specified, the cookie will not be persisted. It
              will only be available until the client shuts down his or her
              browser.</td></tr><tr><td>cookiePath</td><td>/</td><td>Using this parameter, you can limit the visibility of the
              cookie to a certain part of your site. When cookiePath is
              specified, the cookie will only be visible to that path, and the
              paths below it.</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-session"></a>13.6.3.&nbsp;<tt class="classname">SessionLocaleResolver</tt></h3></div></div><div></div></div><p>The <tt class="classname">SessionLocaleResolver</tt> allows you to
      retrieve locales from the session that might be associated with the
      user's request.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-localeresolver-interceptor"></a>13.6.4.&nbsp;<tt class="classname">LocaleChangeInterceptor</tt></h3></div></div><div></div></div><p>You can build in changing of locales using the
      <tt class="classname">LocaleChangeInterceptor</tt>. This interceptor needs
      to be added to one of the handler mappings (see <a href="#mvc-handlermapping" title="13.4.&nbsp;Handler mappings">Section&nbsp;13.4, &#8220;Handler mappings&#8221;</a>). It will detect a parameter in the
      request and change the locale (it calls <tt class="literal">setLocale()</tt>
      on the <tt class="interfacename">LocaleResolver</tt> that also exists in
      the context).</p><pre class="programlisting">&lt;bean id="localeChangeInterceptor"
      class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"&gt;
    &lt;property name="paramName" value="siteLanguage"/&gt;
&lt;/bean&gt;

&lt;bean id="localeResolver"
      class="org.springframework.web.servlet.i18n.CookieLocaleResolver"/&gt;

&lt;bean id="urlMapping"
      class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
    &lt;property name="interceptors"&gt;
        &lt;list&gt;
            &lt;ref bean="localeChangeInterceptor"/&gt;
        &lt;/list&gt;
    &lt;/property&gt;
    &lt;property name="mappings"&gt;
        &lt;value&gt;/**/*.view=someController&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>All calls to all <tt class="literal">*.view</tt> resources containing a
      parameter named <tt class="literal">siteLanguage</tt> will now change the
      locale. So a request for the following URL,
      <tt class="literal">http://www.sf.net/home.view?siteLanguage=nl</tt> will
      change the site language to Dutch.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-themeresolver"></a>13.7.&nbsp;Using themes</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-themeresolver-introduction"></a>13.7.1.&nbsp;Introduction</h3></div></div><div></div></div><p>The <span class="emphasis"><em>theme</em></span> support provided by the Spring web
      MVC framework enables you to further enhance the user experience by
      allowing the look and feel of your application to be
      <span class="emphasis"><em>themed</em></span>. A theme is basically a collection of static
      resources affecting the visual style of the application, typically style
      sheets and images.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-themeresolver-defining"></a>13.7.2.&nbsp;Defining themes</h3></div></div><div></div></div><p>When you want to use themes in your web application you'll have to
      set up a
      <tt class="interfacename">org.springframework.ui.context.ThemeSource</tt>.
      The <tt class="interfacename">WebApplicationContext</tt> interface
      extends <tt class="interfacename">ThemeSource</tt> but delegates its
      responsibilities to a dedicated implementation. By default the delegate
      will be a
      <tt class="classname">org.springframework.ui.context.support.ResourceBundleThemeSource</tt>
      that loads properties files from the root of the classpath. If you want
      to use a custom <tt class="interfacename">ThemeSource</tt>
      implementation or if you need to configure the basename prefix of the
      <tt class="classname">ResourceBundleThemeSource</tt>, you can register a
      bean in the application context with the reserved name "themeSource".
      The web application context will automatically detect that bean and
      start using it.</p><p>When using the <tt class="classname">ResourceBundleThemeSource</tt>, a
      theme is defined in a simple properties file. The properties file lists
      the resources that make up the theme. Here is an example:</p><pre class="programlisting">styleSheet=/themes/cool/style.css
background=/themes/cool/img/coolBg.jpg</pre><p>The keys of the properties are the names used to refer to the
      themed elements from view code. For a JSP this would typically be done
      using the <tt class="literal">spring:theme</tt> custom tag, which is very
      similar to the <tt class="literal">spring:message</tt> tag. The following JSP
      fragment uses the theme defined above to customize the look and
      feel:</p><pre class="programlisting">&lt;%@ taglib prefix="spring" uri="http://www.springframework.org/tags"%&gt;
&lt;html&gt;
   &lt;head&gt;
      &lt;link rel="stylesheet" href="&lt;spring:theme code="styleSheet"/&gt;" type="text/css"/&gt;
   &lt;/head&gt;
   &lt;body background="&lt;spring:theme code="background"/&gt;"&gt;
      ...
   &lt;/body&gt;
&lt;/html&gt;</pre><p>By default, the <tt class="classname">ResourceBundleThemeSource</tt>
      uses an empty basename prefix. As a result the properties files will be
      loaded from the root of the classpath, so we'll have to put our
      <tt class="literal">cool.properties</tt> theme definition in a directory at
      the root of the classpath, e.g. in <tt class="literal">/WEB-INF/classes</tt>.
      Note that the <tt class="classname">ResourceBundleThemeSource</tt> uses the
      standard Java resource bundle loading mechanism, allowing for full
      internationalization of themes. For instance, we could have a
      <tt class="literal">/WEB-INF/classes/cool_nl.properties</tt> that references a
      special background image, e.g. with Dutch text on it.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-themeresolver-resolving"></a>13.7.3.&nbsp;Theme resolvers</h3></div></div><div></div></div><p>Now that we have our themes defined, the only thing left to do is
      decide which theme to use. The <tt class="classname">DispatcherServlet</tt>
      will look for a bean named "themeResolver" to find out which
      <tt class="interfacename">ThemeResolver</tt> implementation to use. A
      theme resolver works in much the same way as a
      <tt class="interfacename">LocaleResolver</tt>. It can detect the theme
      that should be used for a particular request and can also alter the
      request's theme. The following theme resolvers are provided by
      Spring:</p><div class="table"><a name="mvc-theme-resolver-impls-tbl"></a><p class="title"><b>Table&nbsp;13.6.&nbsp;<tt class="interfacename">ThemeResolver</tt>
        implementations</b></p><table summary="ThemeResolver&#xA;        implementations" border="1"><colgroup><col><col></colgroup><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody><tr><td><tt class="classname">FixedThemeResolver</tt></td><td>Selects a fixed theme, set using the "defaultThemeName"
              property.</td></tr><tr><td><tt class="classname">SessionThemeResolver</tt></td><td>The theme is maintained in the users HTTP session. It
              only needs to be set once for each session, but is not persisted
              between sessions.</td></tr><tr><td><tt class="classname">CookieThemeResolver</tt></td><td>The selected theme is stored in a cookie on the
              user-agent's machine.</td></tr></tbody></table></div><p>Spring also provides a
      <tt class="classname">ThemeChangeInterceptor</tt>, which allows changing the
      theme on every request by including a simple request parameter.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-multipart"></a>13.8.&nbsp;Spring's multipart (fileupload) support</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-multipart-introduction"></a>13.8.1.&nbsp;Introduction</h3></div></div><div></div></div><p>Spring has built-in multipart support to handle fileuploads in web
      applications. The design for the multipart support is done with
      pluggable <tt class="interfacename">MultipartResolver</tt> objects,
      defined in the <tt class="literal">org.springframework.web.multipart</tt>
      package. Out of the box, Spring provides a
      <tt class="interfacename">MultipartResolver</tt> for use with
      <span class="emphasis"><em>Commons FileUpload</em></span> (<a href="http://jakarta.apache.org/commons/fileupload" target="_top">http://jakarta.apache.org/commons/fileupload</a>).
      How uploading files is supported will be described in the rest of
      this chapter.</p><p>By default, no multipart handling will be done by Spring, as some
      developers will want to handle multiparts themselves. You will have to
      enable it yourself by adding a multipart resolver to the web
      application's context. After you have done that, each request will be
      inspected to see if it contains a multipart. If no multipart is found,
      the request will continue as expected. However, if a multipart is found
      in the request, the <tt class="classname">MultipartResolver</tt> that has
      been declared in your context will be used. After that, the multipart
      attribute in your request will be treated like any other
      attribute.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-multipart-resolver"></a>13.8.2.&nbsp;Using the
      <tt class="interfacename">MultipartResolver</tt></h3></div></div><div></div></div><p>The following example shows how to use the
      <tt class="classname">CommonsMultipartResolver</tt>:</p><pre class="programlisting">&lt;bean id="multipartResolver"
    class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- one of the properties available; the maximum file size in bytes --&gt;</span></i>
    &lt;property name="maxUploadSize" value="100000"/&gt;
&lt;/bean&gt;</pre><p>This is an example using the
      <tt class="classname">CosMultipartResolver</tt>:</p><pre class="programlisting">&lt;bean id="multipartResolver" class="org.springframework.web.multipart.cos.CosMultipartResolver"&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- one of the properties available; the maximum file size in bytes --&gt;</span></i>
    &lt;property name="maxUploadSize" value="100000"/&gt;
&lt;/bean&gt;</pre><p>Of course you also need to put the appropriate jars in your
      classpath for the multipart resolver to work. In the case of the
      <tt class="classname">CommonsMultipartResolver</tt>, you need to use
      <tt class="literal">commons-fileupload.jar</tt>; in the case of the
      <tt class="classname">CosMultipartResolver</tt>, use
      <tt class="literal">cos.jar</tt>.</p><p>Now that you have seen how to set Spring up to handle multipart
      requests, let's talk about how to actually use it. When the Spring
      <tt class="classname">DispatcherServlet</tt> detects a multi-part request,
      it activates the resolver that has been declared in your context and
      hands over the request. What the resolver then does is wrap the current
      <tt class="classname">HttpServletRequest</tt> into a
      <tt class="classname">MultipartHttpServletRequest</tt> that has support for
      multipart file uploads. Using the
      <tt class="classname">MultipartHttpServletRequest</tt> you can get
      information about the multiparts contained by this request and actually
      get access to the multipart files themselves in your controllers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-multipart-forms"></a>13.8.3.&nbsp;Handling a file upload in a form</h3></div></div><div></div></div><p>After the <tt class="classname">MultipartResolver</tt> has finished
      doing its job, the request will be processed like any other. To use it,
      you create a form with an upload field (see immediately below), then let
      Spring bind the file onto your form (backing object). To actually let
      the user upload a file, we have to create a (HTML) form:</p><pre class="programlisting">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Upload a file please&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Please upload a file&lt;/h1&gt;
        &lt;form method="post" action="upload.form" enctype="multipart/form-data"&gt;
            &lt;input type="file" name="file"/&gt;
            &lt;input type="submit"/&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre><p>As you can see, we've created a field named after the property of
      the bean that holds the <tt class="literal">byte[]</tt>. Furthermore we've
      added the encoding attribute
      (<tt class="literal">enctype="multipart/form-data"</tt>) which is necessary to
      let the browser know how to encode the multipart fields (do not forget
      this!).</p><p>Just as with any other property that's not automagically
      convertible to a string or primitive type, to be able to put binary data
      in your objects you have to register a custom editor with the
      <tt class="classname">ServletRequestDatabinder</tt>. There are a couple of
      editors available for handling files and setting the results on an
      object. There's a <tt class="classname">StringMultipartEditor</tt> capable
      of converting files to Strings (using a user-defined character set) and
      there is a <tt class="classname">ByteArrayMultipartEditor</tt> which
      converts files to byte arrays. They function just as the
      <tt class="classname">CustomDateEditor</tt> does.</p><p>So, to be able to upload files using a (HTML) form, declare the
      resolver, a url mapping to a controller that will process the bean, and
      the controller itself.</p><pre class="programlisting">&lt;beans&gt;
  <i class="lineannotation"><span class="lineannotation">&lt;!-- lets use the Commons-based implementation of the MultipartResolver interface --&gt;</span></i>
    &lt;bean id="multipartResolver"
        class="org.springframework.web.multipart.commons.CommonsMultipartResolver"/&gt;

    &lt;bean id="urlMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;
        &lt;property name="mappings"&gt;
            &lt;value&gt;
                /upload.form=fileUploadController
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

    &lt;bean id="fileUploadController" class="examples.FileUploadController"&gt;
        &lt;property name="commandClass" value="examples.FileUploadBean"/&gt;
        &lt;property name="formView" value="fileuploadform"/&gt;
        &lt;property name="successView" value="confirmation"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>After that, create the controller and the actual class to hold the
      file property.</p><pre class="programlisting">public class FileUploadController extends SimpleFormController {

    protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,
            Object command, BindException errors) throws ServletException, IOException {

        <i class="lineannotation"><span class="lineannotation"> // cast the bean</span></i>
        FileUploadBean bean = (FileUploadBean) command;

        <i class="lineannotation"><span class="lineannotation"> let's see if there's content there</span></i>
        byte[] file = bean.getFile();
        if (file == null) {
            <i class="lineannotation"><span class="lineannotation"> // hmm, that's strange, the user did not upload anything</span></i>
        }

        <i class="lineannotation"><span class="lineannotation"> // well, let's do nothing with the bean for now and return</span></i>
        return super.onSubmit(request, response, command, errors);
    }

    protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder)
        throws ServletException {
        // to actually be able to convert Multipart instance to byte[]
        // we have to register a custom editor
        binder.registerCustomEditor(byte[].class, new ByteArrayMultipartFileEditor());
        // now Spring knows how to handle multipart object and convert them
    }
}

public class FileUploadBean {

    private byte[] file;

    public void setFile(byte[] file) {
        this.file = file;
    }

    public byte[] getFile() {
        return file;
    }
}</pre><p>As you can see, the <tt class="classname">FileUploadBean</tt> has a
      property typed <tt class="literal">byte[]</tt> that holds the file. The
      controller registers a custom editor to let Spring know how to actually
      convert the multipart objects the resolver has found to properties
      specified by the bean. In this example, nothing is done with the
      <tt class="literal">byte[]</tt> property of the bean itself, but in practice
      you can do whatever you want (save it in a database, mail it to
      somebody, etc).</p><p>An equivalent example in which a file is bound straight to a
      String-typed property on a (form backing) object might look like:</p><pre class="programlisting">public class FileUploadController extends SimpleFormController {

    protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,
            Object command, BindException errors) throws ServletException, IOException {

        <i class="lineannotation"><span class="lineannotation"> // cast the bean</span></i>
        FileUploadBean bean = (FileUploadBean) command;

        <i class="lineannotation"><span class="lineannotation"> let's see if there's content there</span></i>
        String file = bean.getFile();
        if (file == null) {
            <i class="lineannotation"><span class="lineannotation"> // hmm, that's strange, the user did not upload anything</span></i>
        }

        <i class="lineannotation"><span class="lineannotation"> // well, let's do nothing with the bean for now and return</span></i>
        return super.onSubmit(request, response, command, errors);
    }

    protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder)
        throws ServletException {
        // to actually be able to convert Multipart instance to a String
        // we have to register a custom editor
        binder.registerCustomEditor(String.class, new StringMultipartFileEditor());
        // now Spring knows how to handle multipart object and convert them
    }

}

public class FileUploadBean {

    private String file;

    public void setFile(String file) {
        this.file = file;
    }

    public String getFile() {
        return file;
    }
}</pre><p>Of course, this last example only makes (logical) sense in the
      context of uploading a plain text file (it wouldn't work so well in the
      case of uploading an image file).</p><p>The third (and final) option is where one binds directly to a
      <tt class="interfacename">MultipartFile</tt> property declared on the
      (form backing) object's class. In this case one does not need to
      register any custom <tt class="interfacename">PropertyEditor</tt>
      because there is no type conversion to be performed.</p><pre class="programlisting">public class FileUploadController extends SimpleFormController {

    protected ModelAndView onSubmit(HttpServletRequest request, HttpServletResponse response,
            Object command, BindException errors) throws ServletException, IOException {

        <i class="lineannotation"><span class="lineannotation"> // cast the bean</span></i>
        FileUploadBean bean = (FileUploadBean) command;

        <i class="lineannotation"><span class="lineannotation"> let's see if there's content there</span></i>
        MultipartFile file = bean.getFile();
        if (file == null) {
            <i class="lineannotation"><span class="lineannotation"> // hmm, that's strange, the user did not upload anything</span></i>
        }

        <i class="lineannotation"><span class="lineannotation"> // well, let's do nothing with the bean for now and return</span></i>
        return super.onSubmit(request, response, command, errors);
    }
}

public class FileUploadBean {

    private MultipartFile file;

    public void setFile(MultipartFile file) {
        this.file = file;
    }

    public MultipartFile getFile() {
        return file;
    }
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-exceptionhandlers"></a>13.9.&nbsp;Handling exceptions</h2></div></div><div></div></div><p>Spring provides <tt class="literal">HandlerExceptionResolvers</tt> to ease
    the pain of unexpected exceptions occurring while your request is being
    handled by a controller which matched the request.
    <tt class="literal">HandlerExceptionResolvers</tt> somewhat resemble the
    exception mappings you can define in the web application descriptor
    <tt class="literal">web.xml</tt>. However, they provide a more flexible way to
    handle exceptions. They provide information about what handler was
    executing when the exception was thrown. Furthermore, a programmatic way
    of handling exception gives you many more options for how to respond
    appropriately before the request is forwarded to another URL (the same end
    result as when using the servlet specific exception mappings).</p><p>Besides implementing the
    <tt class="interfacename">HandlerExceptionResolver</tt> interface, which
    is only a matter of implementing the <tt class="literal">resolveException(Exception,
    Handler)</tt> method and returning a
    <tt class="classname">ModelAndView</tt>, you may also use the
    <tt class="classname">SimpleMappingExceptionResolver</tt>. This resolver
    enables you to take the class name of any exception that might be thrown
    and map it to a view name. This is functionally equivalent to the
    exception mapping feature from the Servlet API, but it's also possible to
    implement more finely grained mappings of exceptions from different
    handlers.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-coc"></a>13.10.&nbsp;Convention over configuration</h2></div></div><div></div></div><p>For a lot of projects, sticking to established conventions and
    having reasonable defaults is just what they (the projects) need... this
    theme of convention-over-configuration now has explicit support in Spring
    Web MVC. What this means is that if you establish a set of naming
    conventions and suchlike, you can <span class="emphasis"><em>substantially</em></span> cut
    down on the amount of configuration that is required to set up handler
    mappings, view resolvers, <tt class="classname">ModelAndView</tt> instances,
    etc. This is a great boon with regards to rapid prototyping, and can also
    lend a degree of (always good-to-have) consistency across a codebase
    should you choose to move forward with it into production.</p><p>This convention over configuration support address the three core
    areas of MVC - namely, the models, views, and controllers.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-coc-ccnhm"></a>13.10.1.&nbsp;The Controller -
      <tt class="classname">ControllerClassNameHandlerMapping</tt></h3></div></div><div></div></div><p>The <tt class="classname">ControllerClassNameHandlerMapping</tt> class
      is a <tt class="interfacename">HandlerMapping</tt> implementation that
      uses a convention to determine the mapping between request URLs and the
      <tt class="interfacename">Controller</tt> instances that are to handle
      those requests.</p><p>An example; consider the following (simplistic)
      <tt class="interfacename">Controller</tt> implementation. Take especial
      notice of the <span class="emphasis"><em>name</em></span> of the class.</p><pre class="programlisting">public class <span class="bold"><b>ViewShoppingCartController</b></span> implements Controller {

    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
        <i class="lineannotation"><span class="lineannotation">// the implementation is not hugely important for this example...</span></i>
    }
}</pre><p>Here is a snippet from the attendent Spring Web MVC configuration
      file...</p><pre class="programlisting">&lt;bean class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"/&gt;
                
&lt;bean id="<span class="bold"><b>viewShoppingCart</b></span>" class="x.y.z.ViewShoppingCartController"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- inject dependencies as required... --&gt;</span></i>
&lt;/bean&gt;</pre><p>The <tt class="classname">ControllerClassNameHandlerMapping</tt> finds
      all of the various handler (or
      <tt class="interfacename">Controller</tt>) beans defined in its
      application context and strips <tt class="literal">'Controller'</tt> off the
      name to define its handler mappings.</p><p>Let's look at some more examples so that the central idea becomes
      immediately familiar.</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">WelcomeController</tt> maps to the
          <tt class="literal">'/welcome*'</tt> request URL</p></li><li><p><tt class="classname">HomeController</tt> maps to the
          <tt class="literal">'/home*'</tt> request URL</p></li><li><p><tt class="classname">IndexController</tt> maps to the
          <tt class="literal">'/index*'</tt> request URL</p></li><li><p><tt class="classname">RegisterController</tt> maps to the
          <tt class="literal">'/register*'</tt> request URL</p></li><li><p><tt class="classname">DisplayShoppingCartController</tt> maps to
          the <tt class="literal">'/displayshoppingcart*'</tt> request URL</p><p><span class="emphasis"><em>(Notice the casing - all lowercase - in the case of
          camel-cased <tt class="interfacename">Controller</tt> class
          names.)</em></span></p></li></ul></div><p>In the case of <tt class="classname">MultiActionController</tt>
      handler classes, the mappings generated are (ever so slightly) more
      complex, but hopefully no less understandable. Some examples (all of the
      <tt class="interfacename">Controller</tt> names in this next bit are
      assumed to be <tt class="classname">MultiActionController</tt>
      implementations).</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">AdminController</tt> maps to the
          <tt class="literal">'/admin<span class="bold"><b>/*</b></span>'</tt>
          request URL</p></li><li><p><tt class="classname">CatalogController</tt> maps to the
          <tt class="literal">'/catalog<span class="bold"><b>/*</b></span>'</tt>
          request URL</p></li></ul></div><p>If you follow the pretty standard convention of naming your
      <tt class="interfacename">Controller</tt> implementations as
      <tt class="literal">xxx<span class="bold"><b>Controller</b></span></tt>, then
      the <tt class="classname">ControllerClassNameHandlerMapping</tt> will save
      you the tedium of having to firstly define and then having to maintain a
      potentially <span class="emphasis"><em>looooong</em></span>
      <tt class="classname">SimpleUrlHandlerMapping</tt> (or suchlike).</p><p>The <tt class="classname">ControllerClassNameHandlerMapping</tt> class
      extends the <tt class="classname">AbstractHandlerMapping</tt> base class so
      you can define <tt class="interfacename">HandlerInterceptor</tt>
      instances and everything else just like you would with many other
      <tt class="interfacename">HandlerMapping</tt> implementations.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-coc-modelmap"></a>13.10.2.&nbsp;The Model - <tt class="classname">ModelMap</tt>
      (<tt class="classname">ModelAndView</tt>)</h3></div></div><div></div></div><p>The <tt class="classname">ModelMap</tt> class is essentially a
      glorified <tt class="interfacename">Map</tt> that can make adding
      objects that are to be displayed in (or on) a
      <tt class="interfacename">View</tt> adhere to a common naming
      convention. Consider the following
      <tt class="interfacename">Controller</tt> implementation; notice that
      objects are added to the <tt class="classname">ModelAndView</tt> without any
      associated name being specified.</p><pre class="programlisting">public class DisplayShoppingCartController implements Controller {

    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
        
        List cartItems = <i class="lineannotation"><span class="lineannotation">// get a <tt class="interfacename">List</tt> of <tt class="classname">CartItem</tt> objects</span></i>
        User user = <i class="lineannotation"><span class="lineannotation">// get the <tt class="classname">User</tt> doing the shopping</span></i>
        
        ModelAndView mav = new ModelAndView("displayShoppingCart"); <i class="lineannotation"><span class="lineannotation">&lt;-- the logical view name</span></i>

        mav.addObject(cartItems); <i class="lineannotation"><span class="lineannotation">&lt;-- look ma, no name, just the object</span></i>
        mav.addObject(user); <i class="lineannotation"><span class="lineannotation">&lt;-- and again ma!</span></i>

        return mav;
    }
}</pre><p>The <tt class="classname">ModelAndView</tt> class uses a
      <tt class="classname">ModelMap</tt> class that is a custom
      <tt class="interfacename">Map</tt> implementation that automatically
      generates a key for an object when an object is added to it. The
      strategy for determining the name for an added object is, in the case of
      a scalar object such as <tt class="classname">User</tt>, to use the short
      class name of the object's class. Find below some examples of the names
      that are generated for scalar objects put into a
      <tt class="classname">ModelMap</tt> instance.</p><div class="itemizedlist"><ul type="disc"><li><p>An <tt class="classname">x.y.User</tt> instance added will have
          the name <tt class="literal">'user'</tt> generated</p></li><li><p>An <tt class="classname">x.y.Registration</tt> instance added will
          have the name <tt class="literal">'registration'</tt> generated</p></li><li><p>An <tt class="classname">x.y.Foo</tt> instance added will have the
          name <tt class="literal">'foo'</tt> generated</p></li><li><p>A <tt class="classname">java.util.HashMap</tt> instance added will
          have the name <tt class="literal">'hashMap'</tt> generated (you'll
          probably want to be explicit about the name in this case because
          <tt class="literal">'hashMap'</tt> is less than intuitive).</p></li><li><p>Adding <tt class="literal">null</tt> will result in an
          <tt class="classname">IllegalArgumentException</tt> being thrown. If the
          object (or objects) that you are adding could potentially be
          <tt class="literal">null</tt>, then you will also want to be explicit
          about the name).</p></li></ul></div><div class="sidebar"><p class="title"><b>What, no automatic pluralisation?</b></p><p>Spring Web MVC's convention over configuration support does not
        support automatic pluralisation. That is to say, you cannot add a
        <tt class="interfacename">List</tt> of <tt class="classname">Person</tt>
        objects to a <tt class="classname">ModelAndView</tt> and have the
        generated name be 'people'.</p><p>This decision was taken after some debate, with the
        &#8220;<span class="quote">Principle of Least Surprise</span>&#8221; winning out in the
        end.</p></div><p>The strategy for generating a name after adding a
      <tt class="interfacename">Set</tt>, <tt class="interfacename">List</tt>
      or array object is to peek into the collection, take the short class
      name of the first object in the collection, and use that with
      <tt class="literal">'List'</tt> appended to the name. Some examples will make
      the semantics of name generation for collections clearer...</p><div class="itemizedlist"><ul type="disc"><li><p>An <tt class="classname">x.y.User[]</tt> array with one or more
          <tt class="classname">x.y.User</tt> elements added will have the name
          <tt class="literal">'userList'</tt> generated</p></li><li><p>An <tt class="classname">x.y.Foo[]</tt> array with one or more
          <tt class="classname">x.y.User</tt> elements added will have the name
          <tt class="literal">'fooList'</tt> generated</p></li><li><p>A <tt class="classname">java.util.ArrayList</tt> with one or more
          <tt class="classname">x.y.User</tt> elements added will have the name
          <tt class="literal">'userList'</tt> generated</p></li><li><p>A <tt class="classname">java.util.HashSet</tt> with one or more
          <tt class="classname">x.y.Foo</tt> elements added will have the name
          <tt class="literal">'fooList'</tt> generated</p></li><li><p>An <span class="bold"><b>empty</b></span>
          <tt class="classname">java.util.ArrayList</tt> will not be added at all
          (i.e. the <tt class="methodname">addObject(..)</tt> call will
          essentially be a no-op).</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-coc-r2vnt"></a>13.10.3.&nbsp;The View -
      <tt class="interfacename">RequestToViewNameTranslator</tt></h3></div></div><div></div></div><p>The <tt class="interfacename">RequestToViewNameTranslator</tt>
      interface is responsible for determining a logical
      <tt class="interfacename">View</tt> name when no such logical view name
      is explicitly supplied. It has just one implementation, the rather
      cunningly named
      <tt class="classname">DefaultRequestToViewNameTranslator</tt> class.</p><p>The <tt class="classname">DefaultRequestToViewNameTranslator</tt> maps
      request URLs to logical view names in a fashion that is probably best
      explained by recourse to an example.</p><pre class="programlisting">public class RegistrationController implements Controller {
                
    public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) {
        <i class="lineannotation"><span class="lineannotation">// process the request...</span></i>
        ModelAndView mav = new ModelAndView();
        <i class="lineannotation"><span class="lineannotation">// add <span class="bold"><b>data</b></span> as necessary to the model...</span></i>
        return mav;
        <i class="lineannotation"><span class="lineannotation">// notice that no <tt class="interfacename">View</tt> or logical view name has been set</span></i>
    }
}</pre><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
        "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;
&lt;beans&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- this bean with the well known name generates view names for us --&gt;</span></i>
    &lt;bean id="viewNameTranslator" class="org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator"/&gt;

    &lt;bean class="x.y.RegistrationController"&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- inject dependencies as necessary --&gt;</span></i>
    &lt;/bean&gt;
    
    <i class="lineannotation"><span class="lineannotation">&lt;!-- maps request URLs to Controller names --&gt;</span></i>
    &lt;bean class="org.springframework.web.servlet.mvc.support.ControllerClassNameHandlerMapping"/&gt;

    &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
        &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
        &lt;property name="suffix" value=".jsp"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;
</pre><p>Notice how in the implementation of the
      <tt class="literal">handleRequest(..)</tt> method no
      <tt class="interfacename">View</tt> or logical view name is ever set on
      the <tt class="classname">ModelAndView</tt> that is returned. It is the
      <tt class="classname">DefaultRequestToViewNameTranslator</tt> that will be
      tasked with generating a <span class="emphasis"><em>logical view name</em></span> from the
      URL of the request. In the case of the above
      <tt class="classname">RegistrationController</tt>, which is being used in
      conjunction with the
      <tt class="classname">ControllerClassNameHandlerMapping</tt>, a request URL
      of <tt class="literal">'http://localhost/registration.html'</tt> will result
      in a logical view name of <tt class="literal">'registration'</tt> being
      generated by the
      <tt class="classname">DefaultRequestToViewNameTranslator</tt>. This logical
      view name will then be resolved into the
      <tt class="literal">'/WEB-INF/jsp/registration.jsp'</tt> view by the
      <tt class="classname">InternalResourceViewResolver</tt> bean.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>You don't even need to define a
        <tt class="classname">DefaultRequestToViewNameTranslator</tt> bean
        explicitly. If you are okay with the default settings of the
        <tt class="classname">DefaultRequestToViewNameTranslator</tt>, then you
        can rely on the fact that the Spring Web MVC
        <tt class="classname">DispatcherServlet</tt> will actually instantiate an
        instance of this class if one is not explicitly configured.</p></td></tr></table></div><p>Of course, if you need to change the default settings, then you do
      need to configure your own
      <tt class="classname">DefaultRequestToViewNameTranslator</tt> bean
      explicitly. Please do consult the quite comprehensive Javadoc for the
      <tt class="classname">DefaultRequestToViewNameTranslator</tt> class for
      details of the various properties that can be configured.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-annotation"></a>13.11.&nbsp;Annotation-based controller configuration</h2></div></div><div></div></div><p>There is a current trend to favor annotations over XML files for
    some types of configuration data. To facilitate this, Spring is now (since
    2.5) providing support for configuring the MVC framework components using
    annotations.</p><p>Spring 2.5 introduces an annotation-based programming model for MVC
    controllers, using annotations such as
    <tt class="interfacename">@RequestMapping</tt>,
    <tt class="interfacename">@RequestParam</tt>,
    <tt class="interfacename">@ModelAttribute</tt>, etc. This annotation
    support is available for both Servlet MVC and Portlet MVC. Controllers
    implemented in this style do not have to extend specific base classes or
    implement specific interfaces. Furthermore, they do not usually have
    direct dependencies on Servlet or Portlet API's, although they can easily
    get access to Servlet or Portlet facilities if desired.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>The Spring distribution ships with the
      <span class="emphasis"><em>PetClinic</em></span> sample, which is a web application that takes
      advantage of the annotation support described in this section, in the context
      of simple form processing. You can find the <span class="emphasis"><em>PetClinic</em></span>
      application in the <tt class="literal">'samples/petclinic'</tt> directory.</p><p>For a further sample application that builds on annotation-based Web MVC,
      check out <span class="emphasis"><em>imagedb</em></span>. The focus in that sample is on stateless
      multi-action controllers, including the processing of multipart file uploads.
      You can find the <span class="emphasis"><em>imagedb</em></span> application in the
      <tt class="literal">'samples/imagedb'</tt> directory.</p></td></tr></table></div><p>The following sections document these annotations and how they are
    most commonly used in a Servlet environment.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-ann-setup"></a>13.11.1.&nbsp;Setting up the dispatcher for annotation support</h3></div></div><div></div></div><p><span class="emphasis"><em><tt class="interfacename">@RequestMapping</tt> will only be processed
      if a corresponding <tt class="interfacename">HandlerMapping</tt> (for type level annotations)
      and/or <tt class="interfacename">HandlerAdapter</tt> (for method level annotations) is
      present in the dispatcher.</em></span> This is the case by default in both
      <tt class="classname">DispatcherServlet</tt> and <tt class="classname">DispatcherPortlet</tt>.</p><p>However, if you are defining custom <tt class="interfacename">HandlerMappings</tt> or
      <tt class="interfacename">HandlerAdapters</tt>, then you need to make sure that a
      corresponding custom <tt class="classname">DefaultAnnotationHandlerMapping</tt>
      and/or <tt class="classname">AnnotationMethodHandlerAdapter</tt> is defined as well
      - provided that you intend to use <tt class="interfacename">@RequestMapping</tt>.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

    &lt;bean class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping"/&gt;

    &lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"/&gt;

    <i class="lineannotation"><span class="lineannotation">// ... (controller bean definitions) ...</span></i>

&lt;/beans&gt;
</pre><p>Defining a <tt class="classname">DefaultAnnotationHandlerMapping</tt>
      and/or <tt class="classname">AnnotationMethodHandlerAdapter</tt> explicitly
      also makes sense if you would like to customize the mapping strategy,
      e.g. specifying a custom <tt class="interfacename">PathMatcher</tt> or
      <tt class="interfacename">WebBindingInitializer</tt> (see below).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-ann-controller"></a>13.11.2.&nbsp;Defining a controller with
      <tt class="interfacename">@Controller</tt></h3></div></div><div></div></div><p>The <tt class="interfacename">@Controller</tt> annotation indicates
      that a particular class serves the role of a <span class="emphasis"><em>controller</em></span>.
      There is no need to extend any controller base class or reference the
      Servlet API. You are of course still able to reference Servlet-specific
      features if you need to.</p><p>The basic purpose of the <tt class="interfacename">@Controller</tt>
      annotation is to act as a stereotype for the annotated class, indicating
      its role. The dispatcher will scan such annotated classes for mapped
      methods, detecting <tt class="interfacename">@RequestMapping</tt>
      annotations (see the next section).</p><p>Annotated controller beans may be defined explicitly,
      using a standard Spring bean definition in the dispatcher's context.
      However, the <tt class="interfacename">@Controller</tt> stereotype also
      allows for autodetection, aligned with Spring 2.5's general support for
      detecting component classes in the classpath and auto-registering bean
      definitions for them.</p><p>To enable autodetection of such annotated controllers, you have to add
      component scanning to your configuration. This is easily achieved by using
      the <span class="emphasis"><em>spring-context</em></span> schema as shown in the following
      XML snippet:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p" 
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
        http://www.springframework.org/schema/context 
        http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    &lt;context:component-scan base-package="org.springframework.samples.petclinic.web"/&gt;

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-ann-requestmapping"></a>13.11.3.&nbsp;Mapping requests with
      <tt class="interfacename">@RequestMapping</tt></h3></div></div><div></div></div><p>The <tt class="interfacename">@RequestMapping</tt> annotation is used
      to map URLs like '/editPet.do' onto an entire class or a particular handler method.
      Typically the type-level annotation maps a specific request path (or path pattern)
      onto a form controller, with additional method-level annotations 'narrowing' the
      primary mapping for a specific HTTP method request method ("GET"/"POST") or
      specific HTTP request parameters.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p><tt class="interfacename">@RequestMapping</tt> at the type
        level may be used for plain implementations of the
        <tt class="interfacename">Controller</tt> interface as well.
        In this case, the request processing code would follow the
        traditional <tt class="literal">handleRequest</tt> signature,
        while the controller's mapping would be expressed through an
        <tt class="interfacename">@RequestMapping</tt> annotation.
        This works for pre-built <tt class="interfacename">Controller</tt>
        base classes, such as <tt class="classname">SimpleFormController</tt>,
        too.</p><p>In the following discussion, we'll focus on controllers
        that are based on annotated handler methods.</p></td></tr></table></div><p>The following is an example of a form controller from the
      PetClinic sample application using this annotation:</p><pre class="programlisting">@Controller
<span class="bold"><b>@RequestMapping("/editPet.do")</b></span>
@SessionAttributes("pet")
public class EditPetForm {

    private final Clinic clinic;

    @Autowired
    public EditPetForm(Clinic clinic) {
        this.clinic = clinic;
    }

    @ModelAttribute("types")
    public Collection&lt;PetType&gt; populatePetTypes() {
        return this.clinic.getPetTypes();
    }

    <span class="bold"><b>@RequestMapping(method = RequestMethod.GET)</b></span>
    public String setupForm(@RequestParam("petId") int petId, ModelMap model) {
        Pet pet = this.clinic.loadPet(petId);
        model.addAttribute("pet", pet);
        return "petForm";
    }

    <span class="bold"><b>@RequestMapping(method = RequestMethod.POST)</b></span>
    public String processSubmit(
            @ModelAttribute("pet") Pet pet, BindingResult result, SessionStatus status) {

        new PetValidator().validate(pet, result);
        if (result.hasErrors()) {
            return "petForm";
        }
        else {
            this.clinic.storePet(pet);
            status.setComplete();
            return "redirect:owner.do?ownerId=" + pet.getOwner().getId();
        }
    }
}</pre><p>For a traditional multi-action controller the URLs are typically
      mapped directly on the methods since the controller responds to multiple
      URLs. The following is an example of a multi-action controller from the
      PetClinic sample application using
      <tt class="classname">@RequestMapping</tt>:</p><pre class="programlisting">@Controller
public class ClinicController {

    private final Clinic clinic;

    @Autowired
    public ClinicController(Clinic clinic) {
        this.clinic = clinic;
    }

    /**
     * Custom handler for the welcome view.
     * Note that this handler relies on the RequestToViewNameTranslator to
     * determine the logical view name based on the request URL: "/welcome.do"
     * -&gt; "welcome".
     */
    <span class="bold"><b>@RequestMapping("/welcome.do")</b></span>
    public void welcomeHandler() {
    }

    /**
     * Custom handler for displaying vets.
     * Note that this handler returns a plain {@link ModelMap} object instead of
     * a ModelAndView, thus leveraging convention-based model attribute names.
     * It relies on the RequestToViewNameTranslator to determine the logical
     * view name based on the request URL: "/vets.do" -&gt; "vets".
     * @return a ModelMap with the model attributes for the view
     */
    <span class="bold"><b>@RequestMapping("/vets.do")</b></span>
    public ModelMap vetsHandler() {
        return new ModelMap(this.clinic.getVets());
    }

    /**
     * Custom handler for displaying an owner.
     * Note that this handler returns a plain {@link ModelMap} object instead of
     * a ModelAndView, thus leveraging convention-based model attribute names.
     * It relies on the RequestToViewNameTranslator to determine the logical
     * view name based on the request URL: "/owner.do" -&gt; "owner".
     * @param ownerId the ID of the owner to display
     * @return a ModelMap with the model attributes for the view
     */
    <span class="bold"><b>@RequestMapping("/owner.do")</b></span>
    public ModelMap ownerHandler(@RequestParam("ownerId") int ownerId) {
        return new ModelMap(this.clinic.loadOwner(ownerId));
    }
}</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mvc-ann-requestmapping-advanced"></a>13.11.3.1.&nbsp;Advanced <tt class="interfacename">@RequestMapping</tt> options</h4></div></div><div></div></div><p><span class="emphasis"><em>Ant-style path patterns are supported (e.g. "/myPath/*.do").</em></span>
        At the method level, relative paths (e.g. "edit.do") are supported
        within the primary mapping expressed at the type level.</p><p>The handler method names are taken into account for narrowing
        if no path was specified explicitly, according to the specified
        <tt class="interfacename">org.springframework.web.servlet.mvc.multiaction.MethodNameResolver</tt>
        (by default an
        <tt class="classname">org.springframework.web.servlet.mvc.multiaction.InternalPathMethodNameResolver</tt>).
        Note that this only applies in case of ambiguous annotation mappings
        that do not specify a path mapping explicitly. In other words,
        the method name is only used for narrowing among a set of matching
        methods; it does not constitute a primary path mapping itself.</p><p>If you have a single default method (without explicit path mapping),
        then all requests without a more specific mapped method found will
        be dispatched to it. If you have multiple such default methods, then
        the method name will be taken into account for choosing between them.</p><p><span class="emphasis"><em>Path mappings can be narrowed through parameter conditions:</em></span>
        a sequence of "myParam=myValue" style expressions, with a request only
        mapped if each such parameter is found to have the given value.
        "myParam" style expressions are also supported, with such parameters
        having to be present in the request (allowed to have any value).
        Finally, "!myParam" style expressions indicate that the specified parameter
        is <span class="emphasis"><em>not</em></span> supposed to be present in the request.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-ann-requestmapping-arguments"></a>13.11.4.&nbsp;Supported handler method arguments and return types</h3></div></div><div></div></div><p>Handler methods which are annotated with
      <tt class="classname">@RequestMapping</tt> are allowed to have very flexible
      signatures. They may have arguments of the following types, in arbitrary
      order (except for validation results, which need to follow right after
      the corresponding command object, if desired):

      </p><div class="itemizedlist"><ul type="disc"><li><p>Request and/or response objects (Servlet API). You may choose any
          specific request/response type, e.g. <tt class="interfacename">ServletRequest</tt> /
          <tt class="interfacename">HttpServletRequest</tt>.</p></li><li><p>Session object (Servlet API): of type <tt class="interfacename">HttpSession</tt>.
          An argument of this type will enforce the presence of a corresponding session.
          As a consequence, such an argument will never be <tt class="literal">null</tt>.
          <span class="emphasis"><em>Note that session access may not be thread-safe, in particular
          in a Servlet environment: Consider switching the
          <tt class="classname">AnnotationMethodHandlerAdapter</tt>'s
          "synchronizeOnSession" flag to "true" if multiple requests are allowed
          to access a session concurrently.</em></span></p></li><li><p><tt class="classname">org.springframework.web.context.request.WebRequest</tt>
          or <tt class="classname">org.springframework.web.context.request.NativeWebRequest</tt>.
          Allows for generic request parameter access as well as request/session
          attribute access, without ties to the native Servlet/Portlet API.</p></li><li><p><tt class="classname">java.util.Locale</tt> for the current request
          locale (determined by the most specific locale resolver available,
          i.e. the configured <tt class="interfacename">LocaleResolver</tt>
          in a Servlet environment).</p></li><li><p><tt class="classname">java.io.InputStream</tt> /
          <tt class="classname">java.io.Reader</tt> for access to the request's content.
          This will be the raw InputStream/Reader as exposed by the Servlet API.</p></li><li><p><tt class="classname">java.io.OutputStream</tt> /
          <tt class="classname">java.io.Writer</tt> for generating the response's content.
          This will be the raw OutputStream/Writer as exposed by the Servlet API.</p></li><li><p><tt class="classname">@RequestParam</tt> annotated parameters
          for access to specific Servlet request parameters. Parameter values
          will be converted to the declared method argument type.</p></li><li><p><tt class="interfacename">java.util.Map</tt> /
          <tt class="interfacename">org.springframework.ui.Model</tt> /
          <tt class="classname">org.springframework.ui.ModelMap</tt> for
          enriching the implicit model that will be exposed to the web view.</p></li><li><p>Command/form objects to bind parameters to: as bean
          properties or fields, with customizable type conversion, depending
          on <tt class="classname">@InitBinder</tt> methods and/or the
          HandlerAdapter configuration - see the
          "<tt class="literal">webBindingInitializer</tt>" property on
          <tt class="classname">AnnotationMethodHandlerAdapter</tt>. Such
          command objects along with their validation results will be
          exposed as model attributes, by default using the non-qualified
          command class name in property notation (e.g. "orderAddress" for
          type "mypackage.OrderAddress"). Specify a parameter-level
          <tt class="classname">ModelAttribute</tt> annotation for declaring a
          specific model attribute name.</p></li><li><p><tt class="classname">org.springframework.validation.Errors</tt> /
          <tt class="classname">org.springframework.validation.BindingResult</tt>
          validation results for a preceding command/form object (the
          immediate preceding argument).</p></li><li><p><tt class="classname">org.springframework.web.bind.support.SessionStatus</tt>
          status handle for marking form processing as complete (triggering
          the cleanup of session attributes that have been indicated by the
          <tt class="classname">@SessionAttributes</tt> annotation at the
          handler type level).</p></li></ul></div><p>The following return types are supported for handler methods:

      </p><div class="itemizedlist"><ul type="disc"><li><p>A <tt class="classname">ModelAndView</tt> object, with the model implicitly
          enriched with command objects and the results of <tt class="literal">@ModelAttribute</tt>
          annotated reference data accessor methods.</p></li><li><p>A <tt class="interfacename">Model</tt> object, with the view name implicitly
          determined through a <tt class="interfacename">RequestToViewNameTranslator</tt>
          and the model implicitly enriched with command objects and the results of
          <tt class="literal">@ModelAttribute</tt> annotated reference data accessor methods.</p></li><li><p>A <tt class="interfacename">Map</tt> object for exposing a model, with the view name
          implicitly determined through a <tt class="interfacename">RequestToViewNameTranslator</tt>
          and the model implicitly enriched with command objects and the results of
          <tt class="literal">@ModelAttribute</tt> annotated reference data accessor methods.</p></li><li><p>A <tt class="interfacename">View</tt> object, with the model implicitly
          determined through command objects and <tt class="literal">@ModelAttribute</tt>
          annotated reference data accessor methods. The handler method may also
          programmatically enrich the model by declaring a <tt class="interfacename">Model</tt>
          argument (see above).</p></li><li><p>A <tt class="classname">String</tt> value which is interpreted as view name,
          with the model implicitly determined through command objects and
          <tt class="literal">@ModelAttribute</tt> annotated reference data accessor methods.
          The handler method may also programmatically enrich the model by declaring a
          <tt class="interfacename">Model</tt> argument (see above).</p></li><li><p><tt class="literal">void</tt> if the method handles the response itself
          (by writing the response content directly, declaring an argument of type
          <tt class="interfacename">ServletResponse</tt> /
          <tt class="interfacename">HttpServletResponse</tt> for that purpose)
          or if the view name is supposed to be implicitly determined through a
          <tt class="interfacename">RequestToViewNameTranslator</tt>
          (not declaring a response argument in the handler method signature).</p></li><li><p>Any other return type will be considered as single model attribute
          to be exposed to the view, using the attribute name specified through
          <tt class="literal">@ModelAttribute</tt> at the method level (or the default
          attribute name based on the return type's class name otherwise). The model
          will be implicitly enriched with command objects and the results of
          <tt class="literal">@ModelAttribute</tt> annotated reference data accessor methods.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-ann-requestparam"></a>13.11.5.&nbsp;Binding request parameters to method parameters with
      <tt class="classname">@RequestParam</tt></h3></div></div><div></div></div><p>The <tt class="classname">@RequestParam</tt> annotation is used to
      bind request parameters to a method parameter in your controller.</p><p>The following code snippet from the PetClinic sample application
      shows the usage:</p><pre class="programlisting">@Controller
@RequestMapping("/editPet.do")
@SessionAttributes("pet")
public class EditPetForm {

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>

    @RequestMapping(method = RequestMethod.GET)
    public String setupForm(<span class="bold"><b>@RequestParam("petId") int petId</b></span>, ModelMap model) {
        Pet pet = this.clinic.loadPet(petId);
        model.addAttribute("pet", pet);
        return "petForm";
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
</pre><p>Parameters using this annotation are required by default, but you
      can specify that a parameter is optional by setting
      <tt class="interfacename">@RequestParam</tt>'s
      <tt class="literal">required</tt> attribute to <tt class="literal">false</tt> (e.g.,
      <tt class="literal">@RequestParam(value="id", required="false")</tt>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-ann-modelattrib"></a>13.11.6.&nbsp;Providing a link to data from the model with
      <tt class="classname">@ModelAttribute</tt></h3></div></div><div></div></div><p><tt class="classname">@ModelAttribute</tt> has two usage scenarios in
      controllers. When placed on a method parameter,
      <tt class="classname">@ModelAttribute</tt> is used to map a model attribute
      to the specific, annotated method parameter (see the
      <tt class="literal">processSubmit()</tt> method below). This is how the
      controller gets a reference to the object holding the data entered in
      the form. In addition, the parameter can be declared as the specific
      type of the form backing object rather than as a generic
      <tt class="classname">java.lang.Object</tt>, thus increasing type
      safety.</p><p><tt class="classname">@ModelAttribute</tt> is also used at the method
      level to provide <span class="emphasis"><em>reference data</em></span> for the model (see
      the <tt class="literal">populatePetTypes()</tt> method below). For this usage
      the method signature can contain the same types as documented above for
      the <tt class="classname">@RequestMapping</tt> annotation.</p><p><span class="emphasis"><em>Note:</em></span> <tt class="classname">@ModelAttribute</tt>
      annotated methods will be executed <span class="emphasis"><em>before</em></span> the
      chosen <tt class="classname">@RequestMapping</tt> annotated handler method.
      They effectively pre-populate the implicit model with specific attributes,
      often loaded from a database. Such an attribute can then already be
      accessed through <tt class="classname">@ModelAttribute</tt> annotated
      handler method parameters in the chosen handler method, potentially
      with binding and validation applied to it.</p><p>The following code snippet shows these two usages of this
      annotation:</p><pre class="programlisting">@Controller
@RequestMapping("/editPet.do")
@SessionAttributes("pet")
public class EditPetForm {

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>

    <span class="bold"><b>@ModelAttribute("types")</b></span>
    public Collection&lt;PetType&gt; populatePetTypes() {
        return this.clinic.getPetTypes();
    }

    @RequestMapping(method = RequestMethod.POST)
    public String processSubmit(
            <span class="bold"><b>@ModelAttribute("pet") Pet pet</b></span>, BindingResult result, SessionStatus status) {

        new PetValidator().validate(pet, result);
        if (result.hasErrors()) {
            return "petForm";
        }
        else {
            this.clinic.storePet(pet);
            status.setComplete();
            return "redirect:owner.do?ownerId=" + pet.getOwner().getId();
        }
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-ann-sessionattrib"></a>13.11.7.&nbsp;Specifying attributes to store in a Session with
      <tt class="classname">@SessionAttributes</tt></h3></div></div><div></div></div><p>The type-level <tt class="classname">@SessionAttributes</tt>
      annotation declares session attributes used by a specific handler. This
      will typically list the names of model attributes which should be
      transparently stored in the session or some conversational storage,
      serving as form-backing beans between subsequent requests.</p><p>The following code snippet shows the usage of this
      annotation:</p><pre class="programlisting">@Controller
@RequestMapping("/editPet.do")
<span class="bold"><b>@SessionAttributes("pet")</b></span>
public class EditPetForm {
    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mvc-ann-webdatabinder"></a>13.11.8.&nbsp;Customizing <tt class="classname">WebDataBinder</tt>
      initialization</h3></div></div><div></div></div><p>To customize request parameter binding with PropertyEditors, etc.
      via Spring's <tt class="classname">WebDataBinder</tt>, you can either use
      <tt class="interfacename">@InitBinder</tt>-annotated methods within your
      controller or externalize your configuration by providing a custom
      <tt class="interfacename">WebBindingInitializer</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mvc-ann-initbinder"></a>13.11.8.1.&nbsp;Customizing data binding with
        <tt class="interfacename">@InitBinder</tt></h4></div></div><div></div></div><p>Annotating controller methods with
        <tt class="interfacename">@InitBinder</tt> allows you to configure web
        data binding directly within your controller class.
        <tt class="interfacename">@InitBinder</tt> identifies methods which
        initialize the <tt class="classname">WebDataBinder</tt> which will be used
        for populating command and form object arguments of annotated handler
        methods.</p><p>Such init-binder methods support all arguments that
        <tt class="interfacename">@RequestMapping</tt> supports, except for
        command/form objects and corresponding validation result objects.
        Init-binder methods must not have a return value. Thus, they are
        usually declared as <tt class="literal">void</tt>. Typical arguments include
        <tt class="classname">WebDataBinder</tt> in combination with
        <tt class="interfacename">WebRequest</tt> or
        <tt class="classname">java.util.Locale</tt>, allowing code to register
        context-specific editors.</p><p>The following example demonstrates the use of
        <tt class="interfacename">@InitBinder</tt> for configuring a
        <tt class="classname">CustomDateEditor</tt> for all
        <tt class="classname">java.util.Date</tt> form properties.</p><pre class="programlisting">@Controller
public class MyFormController {

    <span class="bold"><b>@InitBinder</b></span>
    public void initBinder(WebDataBinder binder) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        dateFormat.setLenient(false);
        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mvc-ann-webbindinginitializer"></a>13.11.8.2.&nbsp;Configuring a custom
        <tt class="interfacename">WebBindingInitializer</tt></h4></div></div><div></div></div><p>To externalize data binding initialization, you can provide a
        custom implementation of the
        <tt class="interfacename">WebBindingInitializer</tt> interface, which
        you then enable by supplying a custom bean configuration for an
        <tt class="classname">AnnotationMethodHandlerAdapter</tt>, thus overriding
        the default configuration.</p><p>The following example from the PetClinic application shows a
        configuration using a custom implementation of the
        <tt class="interfacename">WebBindingInitializer</tt> interface,
        <tt class="classname">org.springframework.samples.petclinic.web.ClinicBindingInitializer</tt>,
        which configures PropertyEditors required by several of the PetClinic
        controllers.</p><pre class="programlisting">&lt;bean class="org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter"&gt;
    &lt;property name="cacheSeconds" value="0" /&gt;
    &lt;property name="webBindingInitializer"&gt;
        &lt;bean class="org.springframework.samples.petclinic.web.ClinicBindingInitializer" /&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mvc-resources"></a>13.12.&nbsp;Further Resources</h2></div></div><div></div></div><p>Find below links and pointers to further resources about Spring Web
    MVC.</p><div class="itemizedlist"><ul type="disc"><li><p>The Spring distribution ships with a Spring Web MVC tutorial
        that guides the reader through building a complete Spring Web
        MVC-based application using a step-by-step approach. This tutorial is
        available in the <tt class="literal">'docs'</tt> directory of the Spring
        distribution. An online version can also be found on the <a href="http://springframework.org/" target="_top">Spring Framework website</a>.</p></li><li><p>The book entitled &#8220;<span class="quote">Expert Spring Web MVC and
        Web Flow</span>&#8221; by Seth Ladd and others (published by Apress) is an
        excellent hardcopy source of Spring Web MVC goodness.</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="view"></a>Chapter&nbsp;14.&nbsp;View technologies</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-introduction"></a>14.1.&nbsp;Introduction</h2></div></div><div></div></div><p>One of the areas in which Spring excels is in the separation of view
    technologies from the rest of the MVC framework. For example, deciding to
    use Velocity or XSLT in place of an existing JSP is primarily a matter of
    configuration. This chapter covers the major view technologies that work
    with Spring and touches briefly on how to add new ones. This chapter
    assumes you are already familiar with <a href="#mvc-viewresolver" title="13.5.&nbsp;Views and resolving them">Section&nbsp;13.5, &#8220;Views and resolving them&#8221;</a>
    which covers the basics of how views in general are coupled to the MVC
    framework.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-jsp"></a>14.2.&nbsp;JSP &amp; JSTL</h2></div></div><div></div></div><p>Spring provides a couple of out-of-the-box solutions for JSP and
    JSTL views. Using JSP or JSTL is done using a normal view resolver defined
    in the <tt class="interfacename">WebApplicationContext</tt>. Furthermore,
    of course you need to write some JSPs that will actually render the view.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jsp-resolver"></a>14.2.1.&nbsp;View resolvers</h3></div></div><div></div></div><p>Just as with any other view technology you're integrating with
      Spring, for JSPs you'll need a view resolver that will resolve your
      views. The most commonly used view resolvers when developing with JSPs
      are the <tt class="classname">InternalResourceViewResolver</tt> and the
      <tt class="classname">ResourceBundleViewResolver</tt>. Both are declared in the
      <tt class="interfacename">WebApplicationContext</tt>:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- the <tt class="classname">ResourceBundleViewResolver</tt> --&gt;</span></i>
&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
  &lt;property name="basename" value="views"/&gt;
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation"># And a sample properties file is uses (views.properties in WEB-INF/classes):</span></i>
welcome.class=org.springframework.web.servlet.view.JstlView
welcome.url=/WEB-INF/jsp/welcome.jsp

productList.class=org.springframework.web.servlet.view.JstlView
productList.url=/WEB-INF/jsp/productlist.jsp</pre><p>As you can see, the <tt class="classname">ResourceBundleViewResolver</tt> needs
      a properties file defining the view names mapped to 1) a class and 2) a URL. With a
      <tt class="classname">ResourceBundleViewResolver</tt> you can mix different types of views using
      only one resolver.</p><pre class="programlisting">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;
  &lt;property name="viewClass" value="org.springframework.web.servlet.view.JstlView"/&gt;
  &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;
  &lt;property name="suffix" value=".jsp"/&gt;
&lt;/bean&gt;</pre><p>The <tt class="classname">InternalResourceBundleViewResolver</tt> can be configured for using
      JSPs as described above. As a best practice, we strongly encourage
      placing your JSP files in a directory under the <tt class="filename">'WEB-INF'</tt> directory, so
      there can be no direct access by clients.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jsp-jstl"></a>14.2.2.&nbsp;'Plain-old' JSPs versus JSTL</h3></div></div><div></div></div><p>When using the Java Standard Tag Library you must use a special view
      class, the <tt class="classname">JstlView</tt>, as JSTL needs some preparation
      before things such as the i18N features will work.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jsp-tags"></a>14.2.3.&nbsp;Additional tags facilitating development</h3></div></div><div></div></div><p>Spring provides data binding of request parameters to command
      objects as described in earlier chapters. To facilitate the development
      of JSP pages in combination with those data binding features, Spring
      provides a few tags that make things even easier. All Spring tags have
      <span class="emphasis"><em>HTML escaping</em></span> features to enable or disable
      escaping of characters.</p><p>The tag library descriptor (TLD) is included in the
      <tt class="filename">spring.jar</tt> as well in the distribution itself.
      Further information about the individual tags can be found in the appendix entitled
      <a href="#spring.tld" title="Appendix&nbsp;D.&nbsp;spring.tld">Appendix&nbsp;D, <i>spring.tld</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jsp-formtaglib"></a>14.2.4.&nbsp;Using Spring's form tag library</h3></div></div><div></div></div><p>As of version 2.0, Spring provides a comprehensive set of data
      binding-aware tags for handling form elements when using JSP and Spring
      Web MVC. Each tag provides support for the set of attributes of its
      corresponding HTML tag counterpart, making the tags familiar and intuitive
      to use. The tag-generated HTML is HTML 4.01/XHTML 1.0 compliant.</p><p>Unlike other form/input tag libraries, Spring's form tag library is
      integrated with Spring Web MVC, giving the tags access to the command
      object and reference data your controller deals with. As you will see in
      the following examples, the form tags make JSPs easier to develop, read
      and maintain.</p><p>Let's go through the form tags and look at an example of how each
      tag is used. We have included generated HTML snippets where certain tags
      require further commentary.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jsp-formtaglib-configuration"></a>14.2.4.1.&nbsp;Configuration</h4></div></div><div></div></div><p>The form tag library comes bundled in
        <tt class="literal">spring.jar</tt>. The library descriptor is called
        <tt class="literal">spring-form.tld</tt>.</p><p>To use the tags from this library, add the following directive to
        the top of your JSP page:</p><pre class="programlisting">&lt;%@ taglib prefix="form" uri="http://www.springframework.org/tags/form" %&gt;</pre><p>... where <tt class="literal">form</tt> is the tag name prefix you want
        to use for the tags from this library.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jsp-formtaglib-formtag"></a>14.2.4.2.&nbsp;The <tt class="literal">form</tt> tag</h4></div></div><div></div></div><p>This tag renders an HTML 'form' tag and exposes a binding path to
        inner tags for binding. It puts the command object in the
        <tt class="literal">PageContext</tt> so that the command object can be
        accessed by inner tags. <span class="emphasis"><em>All the other tags in this library are
        nested tags of the <tt class="literal">form</tt> tag</em></span>.</p><p>Let's assume we have a domain object called
        <tt class="classname">User</tt>. It is a JavaBean with properties such as
        <tt class="literal">firstName</tt> and <tt class="literal">lastName</tt>. We will
        use it as the form backing object of our form controller which returns
        <tt class="literal">form.jsp</tt>. Below is an example of what
        <tt class="literal">form.jsp</tt> would look like:</p><pre class="programlisting">&lt;form:form&gt;
      &lt;table&gt;
          &lt;tr&gt;
              &lt;td&gt;First Name:&lt;/td&gt;
              &lt;td&gt;&lt;form:input path="firstName" /&gt;&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
              &lt;td&gt;Last Name:&lt;/td&gt;
              &lt;td&gt;&lt;form:input path="lastName" /&gt;&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
              &lt;td colspan="2"&gt;
                  &lt;input type="submit" value="Save Changes" /&gt;
              &lt;/td&gt;
          &lt;/tr&gt;
      &lt;/table&gt;
  &lt;/form:form&gt;</pre><p>The <tt class="literal">firstName</tt> and <tt class="literal">lastName</tt>
        values are retrieved from the command object placed in the
        <tt class="interfacename">PageContext</tt> by the page controller. Keep
        reading to see more complex examples of how inner tags are used with the
        <tt class="literal">form</tt> tag.</p><p>The generated HTML looks like a standard form:</p><pre class="programlisting">&lt;form method="POST"&gt;
      &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;First Name:&lt;/td&gt;
            &lt;td&gt;&lt;input name="firstName" type="text" value="Harry"/&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;Last Name:&lt;/td&gt;
            &lt;td&gt;&lt;input name="lastName" type="text" value="Potter"/&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td colspan="2"&gt;
              &lt;input type="submit" value="Save Changes" /&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
  &lt;/form&gt;</pre><p>The preceding JSP assumes that the variable name of the form
        backing object is <tt class="literal">'command'</tt>. If you have put the form
        backing object into the model under another name (definitely a best
        practice), then you can bind the form to the named variable like
        so:</p><pre class="programlisting">&lt;form:form <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>commandName="user"</b></span></span></i>&gt;
      &lt;table&gt;
          &lt;tr&gt;
              &lt;td&gt;First Name:&lt;/td&gt;
              &lt;td&gt;&lt;form:input path="firstName" /&gt;&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
              &lt;td&gt;Last Name:&lt;/td&gt;
              &lt;td&gt;&lt;form:input path="lastName" /&gt;&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
              &lt;td colspan="2"&gt;
                  &lt;input type="submit" value="Save Changes" /&gt;
              &lt;/td&gt;
          &lt;/tr&gt;
      &lt;/table&gt;
  &lt;/form:form&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jsp-formtaglib-inputtag"></a>14.2.4.3.&nbsp;The <tt class="literal">input</tt> tag</h4></div></div><div></div></div><p>This tag renders an HTML 'input' tag with type 'text' using the
        bound value. For an example of this tag, see <a href="#view-jsp-formtaglib-formtag" title="14.2.4.2.&nbsp;The form tag">Section&nbsp;14.2.4.2, &#8220;The form tag&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jsp-formtaglib-checkboxtag"></a>14.2.4.4.&nbsp;The <tt class="literal">checkbox</tt> tag</h4></div></div><div></div></div><p>This tag renders an HTML 'input' tag with type 'checkbox'.</p><p>Let's assume our <tt class="classname">User</tt> has preferences such
        as newsletter subscription and a list of hobbies. Below is an example of
        the <tt class="classname">Preferences</tt> class:</p></div><pre class="programlisting">public class Preferences {

      private boolean receiveNewsletter;

      private String[] interests;

      private String favouriteWord;

      public boolean isReceiveNewsletter() {
          return receiveNewsletter;
      }

      public void setReceiveNewsletter(boolean receiveNewsletter) {
          this.receiveNewsletter = receiveNewsletter;
      }

      public String[] getInterests() {
          return interests;
      }

      public void setInterests(String[] interests) {
          this.interests = interests;
      }

      public String getFavouriteWord() {
          return favouriteWord;
      }

      public void setFavouriteWord(String favouriteWord) {
          this.favouriteWord = favouriteWord;
      }
  }</pre><p>The <tt class="literal">form.jsp</tt> would look like:</p><pre class="programlisting">&lt;form:form&gt;
      &lt;table&gt;
          &lt;tr&gt;
              &lt;td&gt;Subscribe to newsletter?:&lt;/td&gt;
              <i class="lineannotation"><span class="lineannotation">&lt;%-- Approach 1: Property is of type <tt class="classname">java.lang.Boolean</tt> --%&gt;</span></i>
              &lt;td&gt;&lt;form:checkbox path="preferences.receiveNewsletter"/&gt;&lt;/td&gt;
          &lt;/tr&gt;

          &lt;tr&gt;
              &lt;td&gt;Interests:&lt;/td&gt;
              &lt;td&gt;
                  <i class="lineannotation"><span class="lineannotation">&lt;%-- Approach 2: Property is of an array or of type <tt class="interfacename">java.util.Collection</tt> --%&gt;</span></i>
                  Quidditch: &lt;form:checkbox path="preferences.interests" value="Quidditch"/&gt;
                  Herbology: &lt;form:checkbox path="preferences.interests" value="Herbology"/&gt;
                  Defence Against the Dark Arts: &lt;form:checkbox path="preferences.interests"
                      value="Defence Against the Dark Arts"/&gt;
              &lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
              &lt;td&gt;Favourite Word:&lt;/td&gt;
              &lt;td&gt;
                  <i class="lineannotation"><span class="lineannotation">&lt;%-- Approach 3: Property is of type <tt class="classname">java.lang.Object</tt> --%&gt;</span></i>
                  Magic: &lt;form:checkbox path="preferences.favouriteWord" value="Magic"/&gt;
              &lt;/td&gt;
          &lt;/tr&gt;
      &lt;/table&gt;
  &lt;/form:form&gt;</pre><p>There are 3 approaches to the <tt class="literal">checkbox</tt> tag which
      should meet all your checkbox needs. </p><div class="itemizedlist"><ul type="disc"><li><p>Approach One - When the bound value is of type
            <tt class="literal">java.lang.Boolean</tt>, the
            <tt class="literal">input(checkbox)</tt> is marked as 'checked' if the
            bound value is <tt class="literal">true</tt>. The <tt class="literal">value</tt>
            attribute corresponds to the resolved value of the
            <tt class="literal">setValue(Object)</tt> value property.</p></li><li><p>Approach Two - When the bound value is of type
            <tt class="literal">array</tt> or
            <tt class="interfacename">java.util.Collection</tt>, the
            <tt class="literal">input(checkbox)</tt> is marked as 'checked' if the
            configured <tt class="literal">setValue(Object)</tt> value is present in
            the bound <tt class="interfacename">Collection</tt>.</p></li><li><p>Approach Three - For any other bound value type, the
            <tt class="literal">input(checkbox)</tt> is marked as 'checked' if the
            configured <tt class="literal">setValue(Object)</tt> is equal to the bound
            value.</p></li></ul></div><p>Note that regardless of the approach, the same HTML structure is
      generated. Below is an HTML snippet of some checkboxes:</p><pre class="programlisting">&lt;tr&gt;
      &lt;td&gt;Interests:&lt;/td&gt;
      &lt;td&gt;
          Quidditch: &lt;input name="preferences.interests" type="checkbox" value="Quidditch"/&gt;
          &lt;input type="hidden" value="1" name="_preferences.interests"/&gt;
          Herbology: &lt;input name="preferences.interests" type="checkbox" value="Herbology"/&gt;
          &lt;input type="hidden" value="1" name="_preferences.interests"/&gt;
          Defence Against the Dark Arts: &lt;input name="preferences.interests" type="checkbox"
              value="Defence Against the Dark Arts"/&gt;
          &lt;input type="hidden" value="1" name="_preferences.interests"/&gt;
      &lt;/td&gt;
  &lt;/tr&gt;</pre><p>What you might not expect to see is the additional hidden field
      after each checkbox. When a checkbox in an HTML page is
      <span class="emphasis"><em>not</em></span> checked, its value will not be sent to the server
      as part of the HTTP request parameters once the form is submitted, so we
      need a workaround for this quirk in HTML in order for Spring form data
      binding to work. The <tt class="literal">checkbox</tt> tag follows the existing
      Spring convention of including a hidden parameter prefixed by an
      underscore ("_") for each checkbox. By doing this, you are effectively
      telling Spring that &#8220;<span class="quote">
          <span class="emphasis"><em>the checkbox was visible in the form and I want my object to
          which the form data will be bound to reflect the state of the checkbox
          no matter what</em></span>
        </span>&#8221;.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jsp-formtaglib-checkboxestag"></a>14.2.4.5.&nbsp;The <tt class="literal">checkboxes</tt> tag</h4></div></div><div></div></div><p>This tag renders multiple HTML 'input' tags with type
        'checkbox'.</p><p>Building on the example from the previous
        <tt class="classname">checkbox</tt> tag section. Sometimes you prefer not to
        have to list all the possible hobbies in your JSP page. You would rather
        provide a list at runtime of the available options and pass that in to
        the tag. That is the purpose of the <tt class="classname">checkboxes</tt>
        tag. You pass in an <tt class="classname">Array</tt>, a
        <tt class="classname">List</tt> or a <tt class="classname">Map</tt> containing
        the available options in the "items" property. Typically the bound
        property is a collection so it can hold multiple values selected by the
        user. Below is an example of the JSP using this tag:</p></div><pre class="programlisting">&lt;form:form&gt;
      &lt;table&gt;
          &lt;tr&gt;
              &lt;td&gt;Interests:&lt;/td&gt;
              &lt;td&gt;
                  <i class="lineannotation"><span class="lineannotation">&lt;%-- Property is of an array or of type <tt class="interfacename">java.util.Collection</tt> --%&gt;</span></i>
                  &lt;form:checkboxes path="preferences.interests" items="${interestList}"/&gt;
              &lt;/td&gt;
          &lt;/tr&gt;
      &lt;/table&gt;
  &lt;/form:form&gt;</pre><p>This example assumes that the "interestList" is a
      <tt class="classname">List</tt> available as a model attribute containing
      strings of the values to be selected from. In the case where you use a
      Map, the map entry key will be used as the value and the map entry's value
      will be used as the label to be displayed. You can also use a custom
      object where you can provide the property names for the value using
      "itemValue" and the label using "itemLabel".</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jsp-formtaglib-radiobuttontag"></a>14.2.4.6.&nbsp;The <tt class="literal">radiobutton</tt> tag</h4></div></div><div></div></div><p>This tag renders an HTML 'input' tag with type 'radio'.</p><p>A typical usage pattern will involve multiple tag instances bound
        to the same property but with different values.</p><pre class="programlisting">&lt;tr&gt;
      &lt;td&gt;Sex:&lt;/td&gt;
      &lt;td&gt;Male: &lt;form:radiobutton path="sex" value="M"/&gt; &lt;br/&gt;
          Female: &lt;form:radiobutton path="sex" value="F"/&gt; &lt;/td&gt;
  &lt;/tr&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jsp-formtaglib-radiobuttonstag"></a>14.2.4.7.&nbsp;The <tt class="literal">radiobuttons</tt> tag</h4></div></div><div></div></div><p>This tag renders multiple HTML 'input' tags with type
        'radio'.</p><p>Just like the <tt class="classname">checkboxes</tt> tag above, you
        might want to pass in the available options as a runtime variable. For
        this usage you would use the <tt class="classname">radiobuttons</tt> tag.
        You pass in an <tt class="classname">Array</tt>, a
        <tt class="classname">List</tt> or a <tt class="classname">Map</tt> containing
        the available options in the "items" property. In the case where you use
        a Map, the map entry key will be used as the value and the map entry's
        value will be used as the label to be displayed. You can also use a
        custom object where you can provide the property names for the value
        using "itemValue" and the label using "itemLabel".</p><pre class="programlisting">&lt;tr&gt;
      &lt;td&gt;Sex:&lt;/td&gt;
      &lt;td&gt;&lt;form:radiobuttons path="sex" items="${sexOptions}"/&gt;&lt;/td&gt;
  &lt;/tr&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jsp-formtaglib-passwordtag"></a>14.2.4.8.&nbsp;The <tt class="literal">password</tt> tag</h4></div></div><div></div></div><p>This tag renders an HTML 'input' tag with type 'password' using
        the bound value.</p><pre class="programlisting">&lt;tr&gt;
      &lt;td&gt;Password:&lt;/td&gt;
      &lt;td&gt;
          &lt;form:password path="password" /&gt;
      &lt;/td&gt;
  &lt;/tr&gt;</pre><p>Please note that by default, the password value is
        <span class="emphasis"><em>not</em></span> shown. If you do want the password value to be
        shown, then set the value of the <tt class="literal">'showPassword'</tt>
        attribute to true, like so.</p><pre class="programlisting">&lt;tr&gt;
      &lt;td&gt;Password:&lt;/td&gt;
      &lt;td&gt;
          &lt;form:password path="password" value="^76525bvHGq" showPassword="true" /&gt;
      &lt;/td&gt;
  &lt;/tr&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jsp-formtaglib-selecttag"></a>14.2.4.9.&nbsp;The <tt class="literal">select</tt> tag</h4></div></div><div></div></div><p>This tag renders an HTML 'select' element. It supports data
        binding to the selected option as well as the use of nested
        <tt class="literal">option</tt> and <tt class="literal">options</tt> tags.</p><p>Let's assume a <tt class="classname">User</tt> has a list of
        skills.</p><pre class="programlisting">&lt;tr&gt;
      &lt;td&gt;Skills:&lt;/td&gt;
      &lt;td&gt;&lt;form:select path="skills" items="${skills}"/&gt;&lt;/td&gt;
  &lt;/tr&gt;</pre><p>If the <tt class="literal">User's</tt> skill were in Herbology, the HTML
        source of the 'Skills' row would look like:</p><pre class="programlisting">&lt;tr&gt;
      &lt;td&gt;Skills:&lt;/td&gt;
      &lt;td&gt;&lt;select name="skills" multiple="true"&gt;
          &lt;option value="Potions"&gt;Potions&lt;/option&gt;
          &lt;option value="Herbology" selected="selected"&gt;Herbology&lt;/option&gt;
          &lt;option value="Quidditch"&gt;Quidditch&lt;/option&gt;&lt;/select&gt;
      &lt;/td&gt;
  &lt;/tr&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jsp-formtaglib-optiontag"></a>14.2.4.10.&nbsp;The <tt class="literal">option</tt> tag</h4></div></div><div></div></div><p>This tag renders an HTML 'option'. It sets 'selected' as
        appropriate based on the bound value.</p><pre class="programlisting">&lt;tr&gt;
      &lt;td&gt;House:&lt;/td&gt;
      &lt;td&gt;
          &lt;form:select path="house"&gt;
              &lt;form:option value="Gryffindor"/&gt;
              &lt;form:option value="Hufflepuff"/&gt;
              &lt;form:option value="Ravenclaw"/&gt;
              &lt;form:option value="Slytherin"/&gt;
          &lt;/form:select&gt;
      &lt;/td&gt;
  &lt;/tr&gt;</pre><p>If the <tt class="literal">User's</tt> house was in Gryffindor, the HTML
        source of the 'House' row would look like:</p><pre class="programlisting">&lt;tr&gt;
      &lt;td&gt;House:&lt;/td&gt;
      &lt;td&gt;
          &lt;select name="house"&gt;
              &lt;option value="Gryffindor" selected="selected"&gt;Gryffindor&lt;/option&gt;
              &lt;option value="Hufflepuff"&gt;Hufflepuff&lt;/option&gt;
              &lt;option value="Ravenclaw"&gt;Ravenclaw&lt;/option&gt;
              &lt;option value="Slytherin"&gt;Slytherin&lt;/option&gt;
          &lt;/select&gt;
      &lt;/td&gt;
   &lt;/tr&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jsp-formtaglib-optionstag"></a>14.2.4.11.&nbsp;The <tt class="literal">options</tt> tag</h4></div></div><div></div></div><p>This tag renders a list of HTML 'option' tags. It sets the
        'selected' attribute as appropriate based on the bound value.</p><pre class="programlisting">&lt;tr&gt;
      &lt;td&gt;Country:&lt;/td&gt;
      &lt;td&gt;
          &lt;form:select path="country"&gt;
              &lt;form:option value="-" label="--Please Select"/&gt;
              &lt;form:options items="${countryList}" itemValue="code" itemLabel="name"/&gt;
          &lt;/form:select&gt;
      &lt;/td&gt;
  &lt;/tr&gt;</pre><p>If the <tt class="classname">User</tt> lived in the UK, the HTML
        source of the 'Country' row would look like:</p><pre class="programlisting">&lt;tr&gt;
      &lt;td&gt;Country:&lt;/td&gt;
      &lt;td&gt;
          &lt;select name="country"&gt;
              &lt;option value="-"&gt;--Please Select&lt;/option&gt;
              &lt;option value="AT"&gt;Austria&lt;/option&gt;
              &lt;option value="UK" selected="selected"&gt;United Kingdom&lt;/option&gt;
              &lt;option value="US"&gt;United States&lt;/option&gt;
          &lt;/select&gt;
      &lt;/td&gt;
  &lt;/tr&gt;</pre><p>As the example shows, the combined usage of an
        <tt class="literal">option</tt> tag with the <tt class="literal">options</tt> tag
        generates the same standard HTML, but allows you to explicitly specify a
        value in the JSP that is for display only (where it belongs) such as the
        default string in the example: "-- Please Select".</p><p>The <tt class="literal">items</tt> attribute is typically populated with a
        collection or array of item objects. <tt class="literal">itemValue</tt> and
        <tt class="literal">itemLabel</tt> simply refer to bean properties of those
        item objects, if specified; otherwise, the item objects themselves will
        be stringified. Alternatively, you may specify a <tt class="literal">Map</tt>
        of items, in which case the map keys are interpreted as option values and
        the map values correspond to option labels. If <tt class="literal">itemValue</tt>
        and/or <tt class="literal">itemLabel</tt> happen to be specified as well,
        the item value property will apply to the map key and the item label
        property will apply to the map value.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jsp-formtaglib-textAreatag"></a>14.2.4.12.&nbsp;The <tt class="literal">textarea</tt> tag</h4></div></div><div></div></div><p>This tag renders an HTML 'textarea'.</p><pre class="programlisting">&lt;tr&gt;
      &lt;td&gt;Notes:&lt;/td&gt;
      &lt;td&gt;&lt;form:textarea path="notes" rows="3" cols="20" /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;form:errors path="notes" /&gt;&lt;/td&gt;
  &lt;/tr&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jsp-formtaglib-hiddeninputtag"></a>14.2.4.13.&nbsp;The <tt class="literal">hidden</tt> tag</h4></div></div><div></div></div><p>This tag renders an HTML 'input' tag with type 'hidden' using the
        bound value. To submit an unbound hidden value, use the HTML
        <tt class="literal">input</tt> tag with type 'hidden'.</p><pre class="programlisting">&lt;form:hidden path="house" /&gt;
  </pre><p>If we choose to submit the 'house' value as a hidden one, the HTML
        would look like:</p><pre class="programlisting">&lt;input name="house" type="hidden" value="Gryffindor"/&gt;
  </pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jsp-formtaglib-errorstag"></a>14.2.4.14.&nbsp;The <tt class="literal">errors</tt> tag</h4></div></div><div></div></div><p>This tag renders field errors in an HTML 'span' tag. It provides
        access to the errors created in your controller or those that were
        created by any validators associated with your controller.</p><p>Let's assume we want to display all error messages for the
        <tt class="literal">firstName</tt> and <tt class="literal">lastName</tt> fields once
        we submit the form. We have a validator for instances of the
        <tt class="classname">User</tt> class called
        <tt class="classname">UserValidator</tt>.</p><pre class="programlisting">public class UserValidator implements Validator {

      public boolean supports(Class candidate) {
          return User.class.isAssignableFrom(candidate);
      }

      public void validate(Object obj, Errors errors) {
          ValidationUtils.rejectIfEmptyOrWhitespace(errors, "firstName", "required", "Field is required.");
          ValidationUtils.rejectIfEmptyOrWhitespace(errors, "lastName", "required", "Field is required.");
      }
  }</pre><p>The <tt class="literal">form.jsp</tt> would look like:</p><pre class="programlisting">&lt;form:form&gt;
      &lt;table&gt;
          &lt;tr&gt;
              &lt;td&gt;First Name:&lt;/td&gt;
              &lt;td&gt;&lt;form:input path="firstName" /&gt;&lt;/td&gt;
              <i class="lineannotation"><span class="lineannotation">&lt;%-- Show errors for firstName field --%&gt;</span></i>
              &lt;td&gt;&lt;form:errors path="firstName" /&gt;&lt;/td&gt;
          &lt;/tr&gt;

          &lt;tr&gt;
              &lt;td&gt;Last Name:&lt;/td&gt;
              &lt;td&gt;&lt;form:input path="lastName" /&gt;&lt;/td&gt;
              <i class="lineannotation"><span class="lineannotation">&lt;%-- Show errors for lastName field --%&gt;</span></i>
              &lt;td&gt;&lt;form:errors path="lastName"  /&gt;&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
              &lt;td colspan="3"&gt;
                  &lt;input type="submit" value="Save Changes" /&gt;
              &lt;/td&gt;
          &lt;/tr&gt;
      &lt;/table&gt;
  &lt;/form:form&gt;</pre><p>If we submit a form with empty values in the
        <tt class="literal">firstName</tt> and <tt class="literal">lastName</tt> fields,
        this is what the HTML would look like:</p><pre class="programlisting">&lt;form method="POST"&gt;
      &lt;table&gt;
          &lt;tr&gt;
              &lt;td&gt;First Name:&lt;/td&gt;
              &lt;td&gt;&lt;input name="firstName" type="text" value=""/&gt;&lt;/td&gt;
              <i class="lineannotation"><span class="lineannotation">&lt;%-- Associated errors to firstName field displayed --%&gt;</span></i>
              &lt;td&gt;&lt;span name="firstName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
          &lt;/tr&gt;

          &lt;tr&gt;
              &lt;td&gt;Last Name:&lt;/td&gt;
              &lt;td&gt;&lt;input name="lastName" type="text" value=""/&gt;&lt;/td&gt;
              <i class="lineannotation"><span class="lineannotation">&lt;%-- Associated errors to lastName field displayed --%&gt;</span></i>
              &lt;td&gt;&lt;span name="lastName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
              &lt;td colspan="3"&gt;
                  &lt;input type="submit" value="Save Changes" /&gt;
              &lt;/td&gt;
          &lt;/tr&gt;
      &lt;/table&gt;
  &lt;/form&gt;</pre><p>What if we want to display the entire list of errors for a given
        page? The example below shows that the <tt class="literal">errors</tt> tag
        also supports some basic wildcarding functionality.</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">path="*"</tt> - displays all errors</p></li><li><p><tt class="literal">path="lastName*"</tt> - displays all errors
            associated with the <tt class="literal">lastName</tt> field</p></li></ul></div><p>The example below will display a list of errors at the top of the
        page, followed by field-specific errors next to the fields:</p><pre class="programlisting">&lt;form:form&gt;
      &lt;form:errors path="*" cssClass="errorBox" /&gt;
      &lt;table&gt;
          &lt;tr&gt;
              &lt;td&gt;First Name:&lt;/td&gt;
              &lt;td&gt;&lt;form:input path="firstName" /&gt;&lt;/td&gt;
              &lt;td&gt;&lt;form:errors path="firstName" /&gt;&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
              &lt;td&gt;Last Name:&lt;/td&gt;
              &lt;td&gt;&lt;form:input path="lastName" /&gt;&lt;/td&gt;
              &lt;td&gt;&lt;form:errors path="lastName"  /&gt;&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
              &lt;td colspan="3"&gt;
                  &lt;input type="submit" value="Save Changes" /&gt;
              &lt;/td&gt;
          &lt;/tr&gt;
      &lt;/table&gt;
  &lt;/form:form&gt;</pre><p>The HTML would look like:</p><pre class="programlisting">&lt;form method="POST"&gt;
      &lt;span name="*.errors" class="errorBox"&gt;Field is required.&lt;br/&gt;Field is required.&lt;/span&gt;
      &lt;table&gt;
          &lt;tr&gt;
              &lt;td&gt;First Name:&lt;/td&gt;
              &lt;td&gt;&lt;input name="firstName" type="text" value=""/&gt;&lt;/td&gt;
              &lt;td&gt;&lt;span name="firstName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
          &lt;/tr&gt;

          &lt;tr&gt;
              &lt;td&gt;Last Name:&lt;/td&gt;
              &lt;td&gt;&lt;input name="lastName" type="text" value=""/&gt;&lt;/td&gt;
              &lt;td&gt;&lt;span name="lastName.errors"&gt;Field is required.&lt;/span&gt;&lt;/td&gt;
          &lt;/tr&gt;
          &lt;tr&gt;
              &lt;td colspan="3"&gt;
                  &lt;input type="submit" value="Save Changes" /&gt;
              &lt;/td&gt;
          &lt;/tr&gt;
  &lt;/form&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-tiles"></a>14.3.&nbsp;Tiles</h2></div></div><div></div></div><p>It is possible to integrate Tiles - just as any other view
    technology - in web applications using Spring. The following describes in
    a broad way how to do this.</p><p><span class="emphasis"><em>NOTE:</em></span> This section focuses on Spring's support
    for Tiles 2 (the standalone version of Tiles, requiring Java 5+) in the
    <tt class="literal">org.springframework.web.servlet.view.tiles2</tt> package.
    Spring also continues to support Tiles 1.x (a.k.a. "Struts Tiles",
    as shipped with Struts 1.1+; compatible with Java 1.4) in the original
    <tt class="literal">org.springframework.web.servlet.view.tiles</tt> package.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-tiles-dependencies"></a>14.3.1.&nbsp;Dependencies</h3></div></div><div></div></div><p>To be able to use Tiles you have to have a couple of additional
      dependencies included in your project. The following is the list of
      dependencies you need.</p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="literal">Tiles version 2.0.4 or higher</tt></p></li><li><p><tt class="literal">Commons BeanUtils</tt></p></li><li><p><tt class="literal">Commons Digester</tt></p></li><li><p><tt class="literal">Commons Logging</tt></p></li></ul></div><p>These dependencies are all available in the Spring distribution.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-tiles-integrate"></a>14.3.2.&nbsp;How to integrate Tiles</h3></div></div><div></div></div><p>To be able to use Tiles, you have to configure it using files
      containing definitions (for basic information on definitions and other
      Tiles concepts, please have a look at <a href="http://tiles.apache.org" target="_top">http://tiles.apache.org</a>). In Spring this is done
      using the <tt class="classname">TilesConfigurer</tt>. Have a look at the
      following piece of example ApplicationContext configuration:</p><pre class="programlisting">&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles2.TilesConfigurer"&gt;
  &lt;property name="definitions"&gt;
    &lt;list&gt;
      &lt;value&gt;/WEB-INF/defs/general.xml&lt;/value&gt;
      &lt;value&gt;/WEB-INF/defs/widgets.xml&lt;/value&gt;
      &lt;value&gt;/WEB-INF/defs/administrator.xml&lt;/value&gt;
      &lt;value&gt;/WEB-INF/defs/customer.xml&lt;/value&gt;
      &lt;value&gt;/WEB-INF/defs/templates.xml&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>As you can see, there are five files containing definitions, which
      are all located in the <tt class="filename">'WEB-INF/defs'</tt> directory.
      At initialization of the <tt class="interfacename">WebApplicationContext</tt>,
      the files will be loaded and the definitions factory will be initialized.
      After that has been done, the Tiles includes in the definition files can be used
      as views within your Spring web application. To be able to use the views
      you have to have a <tt class="interfacename">ViewResolver</tt> just as with any
      other view technology used with Spring. Below you can find two
      possibilities, the <tt class="classname">UrlBasedViewResolver</tt> and
      the <tt class="classname">ResourceBundleViewResolver</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tiles-url"></a>14.3.2.1.&nbsp;<tt class="classname">UrlBasedViewResolver</tt></h4></div></div><div></div></div><p>The <tt class="classname">UrlBasedViewResolver</tt> instantiates the given
        <tt class="literal">viewClass</tt> for each view it has to resolve.</p><pre class="programlisting">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.UrlBasedViewResolver"&gt;
  &lt;property name="viewClass" value="org.springframework.web.servlet.view.tiles2.TilesView"/&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tiles-resource"></a>14.3.2.2.&nbsp;<tt class="classname">ResourceBundleViewResolver</tt></h4></div></div><div></div></div><p>The <tt class="classname">ResourceBundleViewResolver</tt> has to be provided with a
        property file containing viewnames and viewclasses the resolver can
        use:</p><pre class="programlisting">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
  &lt;property name="basename" value="views"/&gt;
&lt;/bean&gt;</pre><pre class="programlisting">...
welcomeView.class=org.springframework.web.servlet.view.tiles2.TilesView
welcomeView.url=welcome <i class="lineannotation"><span class="lineannotation">(this is the name of a Tiles definition)</span></i>

vetsView.class=org.springframework.web.servlet.view.tiles2.TilesView
vetsView.url=vetsView <i class="lineannotation"><span class="lineannotation">(again, this is the name of a Tiles definition)</span></i>

findOwnersForm.class=org.springframework.web.servlet.view.JstlView
findOwnersForm.url=/WEB-INF/jsp/findOwners.jsp
...</pre><p>As you can see, when using the <tt class="classname">ResourceBundleViewResolver</tt>,
        you can easily mix different view technologies.</p></div><p>Note that the <tt class="classname">TilesView</tt> class for Tiles 2 supports
      JSTL (the JSP Standard Tag Library) out of the box, whereas there is a separate
			<tt class="classname">TilesJstlView</tt> subclass in the Tiles 1.x support.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-tiles-preparer"></a>14.3.2.3.&nbsp;<tt class="classname">SimpleSpringPreparerFactory</tt> and <tt class="classname">SpringBeanPreparerFactory</tt></h4></div></div><div></div></div><p>As an advanced feature, Spring also supports two special Tiles 2
        <tt class="interfacename">PreparerFactory</tt> implementations. Check out the
        Tiles documentation for details on how to use <tt class="interfacename">ViewPreparer</tt>
        references in your Tiles definition files.</p><p>Specify <tt class="classname">SimpleSpringPreparerFactory</tt> to autowire
        ViewPreparer instances based on specified preparer classes, applying Spring's
        container callbacks as well as applying configured Spring BeanPostProcessors.
        If Spring's context-wide annotation-config has been activated, annotations in
        ViewPreparer classes will be automatically detected and applied.
        Note that this expects preparer <span class="emphasis"><em>classes</em></span> in the Tiles definition files,
        just like the default <tt class="classname">PreparerFactory</tt> does.</p><p>Specify <tt class="classname">SpringBeanPreparerFactory</tt> to operate on specified
        preparer <span class="emphasis"><em>names</em></span> instead of classes, obtaining the corresponding
        Spring bean from the DispatcherServlet's application context. The full bean
        creation process will be in the control of the Spring application context in
        this case, allowing for the use of explicit dependency injection configuration,
        scoped beans etc. Note that you need to define one Spring bean definition per
        preparer name (as used in your Tiles definitions).</p><pre class="programlisting">&lt;bean id="tilesConfigurer" class="org.springframework.web.servlet.view.tiles2.TilesConfigurer"&gt;
  &lt;property name="definitions"&gt;
    &lt;list&gt;
      &lt;value&gt;/WEB-INF/defs/general.xml&lt;/value&gt;
      &lt;value&gt;/WEB-INF/defs/widgets.xml&lt;/value&gt;
      &lt;value&gt;/WEB-INF/defs/administrator.xml&lt;/value&gt;
      &lt;value&gt;/WEB-INF/defs/customer.xml&lt;/value&gt;
      &lt;value&gt;/WEB-INF/defs/templates.xml&lt;/value&gt;
    &lt;/list&gt;
  &lt;/property&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- resolving preparer names as Spring bean definition names --&gt;</span></i>
  &lt;property name="preparerFactoryClass"
       value="org.springframework.web.servlet.view.tiles2.SpringBeanPreparerFactory"/&gt;

&lt;/bean&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-velocity"></a>14.4.&nbsp;Velocity &amp; FreeMarker</h2></div></div><div></div></div><p><a href="http://velocity.apache.org" target="_top">Velocity</a> and
    <a href="http://www.freemarker.org" target="_top">FreeMarker</a> are two
    templating languages that can both be used as view technologies within
    Spring MVC applications. The languages are quite similar and serve similar
    needs and so are considered together in this section. For semantic and
    syntactic differences between the two languages, see the <a href="http://www.freemarker.org" target="_top">FreeMarker</a> web site.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-dependencies"></a>14.4.1.&nbsp;Dependencies</h3></div></div><div></div></div><p>Your web application will need to include
      <tt class="filename">velocity-1.x.x.jar</tt> or
      <tt class="filename">freemarker-2.x.jar</tt> in order to
      work with Velocity or FreeMarker respectively and
      <tt class="filename">commons-collections.jar</tt>
      needs also to be available for Velocity. Typically they are included in
      the <tt class="literal">WEB-INF/lib</tt> folder where they are guaranteed to
      be found by a J2EE server and added to the classpath for your
      application. It is of course assumed that you already have the
      <tt class="filename">spring.jar</tt> in your
      <tt class="filename">'WEB-INF/lib'</tt> directory too!
      The latest stable Velocity, FreeMarker and Commons
      Collections jars are supplied with the Spring framework and can be
      copied from the relevant <tt class="filename">/lib/</tt>
      sub-directories. If you make use of Spring's 'dateToolAttribute' or
      'numberToolAttribute' in your Velocity views, you will also need to include the
      <tt class="filename">velocity-tools-generic-1.x.jar</tt></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-contextconfig"></a>14.4.2.&nbsp;Context configuration</h3></div></div><div></div></div><p>A suitable configuration is initialized by adding the relevant
      configurer bean definition to your <tt class="filename">'*-servlet.xml'</tt> as shown below:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- 
  This bean sets up the Velocity environment for us based on a root path for templates.
  Optionally, a properties file can be specified for more control over the Velocity
  environment, but the defaults are pretty sane for file based template loading.
--&gt;</span></i>
&lt;bean id="velocityConfig" class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"&gt;
  &lt;property name="resourceLoaderPath" value="/WEB-INF/velocity/"/&gt;
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- 

  View resolvers can also be configured with ResourceBundles or XML files. If you need
  different view resolving based on Locale, you have to use the resource bundle resolver.

--&gt;</span></i>
&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.velocity.VelocityViewResolver"&gt;
  &lt;property name="cache" value="true"/&gt;
  &lt;property name="prefix" value=""/&gt;
  &lt;property name="suffix" value=".vm"/&gt;
&lt;/bean&gt;</pre><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- freemarker config --&gt;</span></i>
&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt;
  &lt;property name="templateLoaderPath" value="/WEB-INF/freemarker/"/&gt;
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- 

  View resolvers can also be configured with ResourceBundles or XML files. If you need
  different view resolving based on Locale, you have to use the resource bundle resolver.

--&gt;</span></i>
&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver"&gt;
  &lt;property name="cache" value="true"/&gt;
  &lt;property name="prefix" value=""/&gt;
  &lt;property name="suffix" value=".ftl"/&gt;
&lt;/bean&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>For non web-apps add a <tt class="classname">VelocityConfigurationFactoryBean</tt> or a
      <tt class="classname">FreeMarkerConfigurationFactoryBean</tt> to your application context definition file.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-createtemplates"></a>14.4.3.&nbsp;Creating templates</h3></div></div><div></div></div><p>Your templates need to be stored in the directory specified by the
      <tt class="literal">*Configurer</tt> bean shown above. This document does not cover
      details of creating templates for the two languages - please see their
      relevant websites for information. If you use the view resolvers
      highlighted, then the logical view names relate to the template file
      names in similar fashion to
      <tt class="classname">InternalResourceViewResolver</tt> for JSP's. So if your
      controller returns a ModelAndView object containing a view name of
      "welcome" then the resolvers will look for the
      <tt class="literal">/WEB-INF/freemarker/welcome.ftl</tt> or
      <tt class="literal">/WEB-INF/velocity/welcome.vm</tt> template as
      appropriate.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-advancedconfig"></a>14.4.4.&nbsp;Advanced configuration</h3></div></div><div></div></div><p>The basic configurations highlighted above will be suitable for
      most application requirements, however additional configuration options
      are available for when unusual or advanced requirements dictate.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-velocity-example-velocityproperties"></a>14.4.4.1.&nbsp;velocity.properties</h4></div></div><div></div></div><p>This file is completely optional, but if specified, contains the
        values that are passed to the Velocity runtime in order to configure
        velocity itself. Only required for advanced configurations, if you
        need this file, specify its location on the
        <tt class="literal">VelocityConfigurer</tt> bean definition above.</p><pre class="programlisting">&lt;bean id="velocityConfig" class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"&gt;
  &lt;property name="configLocation value="/WEB-INF/velocity.properties"/&gt;
&lt;/bean&gt;</pre><p>Alternatively, you can specify velocity properties directly in
        the bean definition for the Velocity config bean by replacing the
        "configLocation" property with the following inline properties.</p><pre class="programlisting">&lt;bean id="velocityConfig" class="org.springframework.web.servlet.view.velocity.VelocityConfigurer"&gt;
  &lt;property name="velocityProperties"&gt;
    &lt;props&gt;
      &lt;prop key="resource.loader"&gt;file&lt;/prop&gt;
      &lt;prop key="file.resource.loader.class"&gt;
        org.apache.velocity.runtime.resource.loader.FileResourceLoader
      &lt;/prop&gt;
      &lt;prop key="file.resource.loader.path"&gt;${webapp.root}/WEB-INF/velocity&lt;/prop&gt;
      &lt;prop key="file.resource.loader.cache"&gt;false&lt;/prop&gt;
    &lt;/props&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Refer to the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/ui/velocity/VelocityEngineFactory.html" target="_top">API
        documentation</a> for Spring configuration of Velocity, or the
        Velocity documentation for examples and definitions of the
        <tt class="filename">'velocity.properties'</tt> file itself.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="views-freemarker"></a>14.4.4.2.&nbsp;FreeMarker</h4></div></div><div></div></div><p>FreeMarker 'Settings' and 'SharedVariables' can be passed
        directly to the FreeMarker <tt class="literal">Configuration</tt> object
        managed by Spring by setting the appropriate bean properties on the
        <tt class="literal">FreeMarkerConfigurer</tt> bean. The
        <tt class="literal">freemarkerSettings</tt> property requires a
        <tt class="literal">java.util.Properties</tt> object and the
        <tt class="literal">freemarkerVariables</tt> property requires a
        <tt class="literal">java.util.Map</tt>.</p><pre class="programlisting">&lt;bean id="freemarkerConfig" class="org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer"&gt;
  &lt;property name="templateLoaderPath" value="/WEB-INF/freemarker/"/&gt;
  &lt;property name="freemarkerVariables"&gt;
    &lt;map&gt;
      &lt;entry key="xml_escape" value-ref="fmXmlEscape"/&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="fmXmlEscape" class="freemarker.template.utility.XmlEscape"/&gt;</pre><p>See the FreeMarker documentation for details of settings and
        variables as they apply to the <tt class="classname">Configuration</tt>
        object.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-velocity-forms"></a>14.4.5.&nbsp;Bind support and form handling</h3></div></div><div></div></div><p>Spring provides a tag library for use in JSP's that contains
      (amongst other things) a <tt class="literal">&lt;spring:bind/&gt;</tt> tag.
      This tag primarily enables forms to display values from form backing
      objects and to show the results of failed validations from a
      <tt class="literal">Validator</tt> in the web or business tier. From version
      1.1, Spring now has support for the same functionality in both Velocity
      and FreeMarker, with additional convenience macros for generating form
      input elements themselves.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-bind-macros"></a>14.4.5.1.&nbsp;The bind macros</h4></div></div><div></div></div><p>A standard set of macros are maintained within the
        <tt class="literal">spring.jar</tt> file for both languages, so they are
        always available to a suitably configured application.</p><p>Some of the macros defined in the Spring libraries are
        considered internal (private) but no such scoping exists in the macro
        definitions making all macros visible to calling code and user
        templates. The following sections concentrate only on the macros you
        need to be directly calling from within your templates. If you wish to
        view the macro code directly, the files are called spring.vm /
        spring.ftl and are in the packages
        <tt class="literal">org.springframework.web.servlet.view.velocity</tt> or
        <tt class="literal">org.springframework.web.servlet.view.freemarker</tt>
        respectively.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-simple-binding"></a>14.4.5.2.&nbsp;Simple binding</h4></div></div><div></div></div><p>In your html forms (vm / ftl templates) that act as the
        'formView' for a Spring form controller, you can use code similar to
        the following to bind to field values and display error messages for
        each input field in similar fashion to the JSP equivalent. Note that
        the name of the command object is "command" by default, but can be
        overridden in your MVC configuration by setting the 'commandName' bean
        property on your form controller. Example code is shown below for the
        <tt class="literal">personFormV</tt> and <tt class="literal">personFormF</tt>
        views configured earlier;</p><pre class="programlisting">&lt;!-- velocity macros are automatically available --&gt;
&lt;html&gt;
...
&lt;form action="" method="POST"&gt;
  Name: 
  #springBind( "command.name" )
  &lt;input type="text" 
    name="${status.expression}" 
    value="$!status.value" /&gt;&lt;br&gt;
  #foreach($error in $status.errorMessages) &lt;b&gt;$error&lt;/b&gt; &lt;br&gt; #end
  &lt;br&gt;
  ... 
  &lt;input type="submit" value="submit"/&gt;
&lt;/form&gt;
...
&lt;/html&gt;</pre><pre class="programlisting">&lt;!-- freemarker macros have to be imported into a namespace.  We strongly
recommend sticking to 'spring' --&gt;
&lt;#import "spring.ftl" as spring /&gt;
&lt;html&gt;
...
&lt;form action="" method="POST"&gt;
  Name: 
  &lt;@spring.bind "command.name" /&gt; 
  &lt;input type="text" 
    name="${spring.status.expression}" 
    value="${spring.status.value?default("")}" /&gt;&lt;br&gt;
  &lt;#list spring.status.errorMessages as error&gt; &lt;b&gt;${error}&lt;/b&gt; &lt;br&gt; &lt;/#list&gt;
  &lt;br&gt;
  ... 
  &lt;input type="submit" value="submit"/&gt;
&lt;/form&gt;
...
&lt;/html&gt;</pre><p><tt class="literal">#springBind</tt> /
        <tt class="literal">&lt;@spring.bind&gt;</tt> requires a 'path' argument
        which consists of the name of your command object (it will be
        'command' unless you changed it in your FormController properties)
        followed by a period and the name of the field on the command object
        you wish to bind to. Nested fields can be used too such as
        "command.address.street". The <tt class="literal">bind</tt> macro assumes
        the default HTML escaping behavior specified by the ServletContext
        parameter <tt class="literal">defaultHtmlEscape</tt> in web.xml</p><p>The optional form of the macro called
        <tt class="literal">#springBindEscaped</tt> /
        <tt class="literal">&lt;@spring.bindEscaped&gt;</tt> takes a second argument
        and explicitly specifies whether HTML escaping should be used in the
        status error messages or values. Set to true or false as required.
        Additional form handling macros simplify the use of HTML escaping and
        these macros should be used wherever possible. They are explained in
        the next section.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="views-form-macros"></a>14.4.5.3.&nbsp;Form input generation macros</h4></div></div><div></div></div><p>Additional convenience macros for both languages simplify both
        binding and form generation (including validation error display). It
        is never necessary to use these macros to generate form input fields,
        and they can be mixed and matched with simple HTML or calls direct to
        the spring bind macros highlighted previously.</p><p>The following table of available macros show the VTL and FTL
        definitions and the parameter list that each takes.</p><div class="table"><a name="views-macros-defs-tbl"></a><p class="title"><b>Table&nbsp;14.1.&nbsp;Table of macro definitions</b></p><table summary="Table of macro definitions" border="1"><colgroup><col align="left"><col><col></colgroup><thead><tr><th align="center">macro</th><th align="center">VTL definition</th><th align="center">FTL definition</th></tr></thead><tbody><tr><td align="left"><span class="bold"><b>message</b></span> (output a
                string from a resource bundle based on the code
                parameter)</td><td><tt class="literal">#springMessage($code)</tt></td><td><tt class="literal">&lt;@spring.message
                code/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>messageText</b></span> (output a
                string from a resource bundle based on the code parameter,
                falling back to the value of the default parameter)</td><td><tt class="literal">#springMessageText($code
                $text)</tt></td><td><tt class="literal">&lt;@spring.messageText code,
                text/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>url</b></span> (prefix a relative
                URL with the application's context root)</td><td><tt class="literal">#springUrl($relativeUrl)</tt></td><td><tt class="literal">&lt;@spring.url
                relativeUrl/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formInput</b></span> (standard
                input field for gathering user input)</td><td><tt class="literal">#springFormInput($path
                $attributes)</tt></td><td><tt class="literal">&lt;@spring.formInput path, attributes,
                fieldType/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formHiddenInput *</b></span>
                (hidden input field for submitting non-user input)</td><td><tt class="literal">#springFormHiddenInput($path
                $attributes)</tt></td><td><tt class="literal">&lt;@spring.formHiddenInput path,
                attributes/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formPasswordInput</b></span> *
                (standard input field for gathering passwords. Note that no
                value will ever be populated in fields of this type)</td><td><tt class="literal">#springFormPasswordInput($path
                $attributes)</tt></td><td><tt class="literal">&lt;@spring.formPasswordInput path,
                attributes/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formTextarea</b></span> (large
                text field for gathering long, freeform text input)</td><td><tt class="literal">#springFormTextarea($path
                $attributes)</tt></td><td><tt class="literal">&lt;@spring.formTextarea path,
                attributes/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formSingleSelect</b></span> (drop
                down box of options allowing a single required value to be
                selected)</td><td><tt class="literal">#springFormSingleSelect( $path $options
                $attributes)</tt></td><td><tt class="literal">&lt;@spring.formSingleSelect path, options,
                attributes/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formMultiSelect</b></span> (a
                list box of options allowing the user to select 0 or more
                values)</td><td><tt class="literal">#springFormMultiSelect($path $options
                $attributes)</tt></td><td><tt class="literal">&lt;@spring.formMultiSelect path, options,
                attributes/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formRadioButtons</b></span> (a
                set of radio buttons allowing a single selection to be made
                from the available choices)</td><td><tt class="literal">#springFormRadioButtons($path $options
                $separator $attributes)</tt></td><td><tt class="literal">&lt;@spring.formRadioButtons path, options
                separator, attributes/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>formCheckboxes</b></span> (a set
                of checkboxes allowing 0 or more values to be
                selected)</td><td><tt class="literal">#springFormCheckboxes($path $options
                $separator $attributes)</tt></td><td><tt class="literal">&lt;@spring.formCheckboxes path, options,
                separator, attributes/&gt;</tt></td></tr><tr><td align="left"><span class="bold"><b>showErrors</b></span> (simplify
                display of validation errors for the bound field)</td><td><tt class="literal">#springShowErrors($separator
                $classOrStyle)</tt></td><td><tt class="literal">&lt;@spring.showErrors separator,
                classOrStyle/&gt;</tt></td></tr></tbody></table></div><p>* In FTL (FreeMarker), these two macros are not actually
        required as you can use the normal <tt class="literal">formInput</tt> macro,
        specifying '<tt class="literal">hidden</tt>' or
        '<tt class="literal">password</tt>' as the value for the
        <tt class="literal">fieldType</tt> parameter.</p><p>The parameters to any of the above macros have consistent
        meanings:</p><div class="itemizedlist"><ul type="disc"><li><p>path: the name of the field to bind to (ie
            "command.name")</p></li><li><p>options: a Map of all the available values that can be
            selected from in the input field. The keys to the map represent
            the values that will be POSTed back from the form and bound to the
            command object. Map objects stored against the keys are the labels
            displayed on the form to the user and may be different from the
            corresponding values posted back by the form. Usually such a map
            is supplied as reference data by the controller. Any Map
            implementation can be used depending on required behavior. For
            strictly sorted maps, a <tt class="literal">SortedMap</tt> such as a
            <tt class="literal">TreeMap</tt> with a suitable Comparator may be used
            and for arbitrary Maps that should return values in insertion
            order, use a <tt class="literal">LinkedHashMap</tt> or a
            <tt class="literal">LinkedMap</tt> from commons-collections.</p></li><li><p>separator: where multiple options are available as discreet
            elements (radio buttons or checkboxes), the sequence of characters
            used to separate each one in the list (ie "&lt;br&gt;").</p></li><li><p>attributes: an additional string of arbitrary tags or text
            to be included within the HTML tag itself. This string is echoed
            literally by the macro. For example, in a textarea field you may
            supply attributes as 'rows="5" cols="60"' or you could pass style
            information such as 'style="border:1px solid silver"'.</p></li><li><p>classOrStyle: for the showErrors macro, the name of the CSS
            class that the span tag wrapping each error will use. If no
            information is supplied (or the value is empty) then the errors
            will be wrapped in &lt;b&gt;&lt;/b&gt; tags.</p></li></ul></div><p>Examples of the macros are outlined below some in FTL and some
        in VTL. Where usage differences exist between the two languages, they
        are explained in the notes.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="views-form-macros-input"></a>14.4.5.3.1.&nbsp;Input Fields</h5></div></div><div></div></div><pre class="programlisting">&lt;!-- the Name field example from above using form macros in VTL --&gt;
...
    Name:
    #springFormInput("command.name" "")&lt;br&gt;
    #springShowErrors("&lt;br&gt;" "")&lt;br&gt;</pre><p>The formInput macro takes the path parameter (command.name)
          and an additional attributes parameter which is empty in the example
          above. The macro, along with all other form generation macros,
          performs an implicit spring bind on the path parameter. The binding
          remains valid until a new bind occurs so the showErrors macro
          doesn't need to pass the path parameter again - it simply operates
          on whichever field a bind was last created for.</p><p>The showErrors macro takes a separator parameter (the
          characters that will be used to separate multiple errors on a given
          field) and also accepts a second parameter, this time a class name
          or style attribute. Note that FreeMarker is able to specify default
          values for the attributes parameter, unlike Velocity, and the two
          macro calls above could be expressed as follows in FTL:</p><pre class="programlisting">&lt;@spring.formInput "command.name"/&gt;
&lt;@spring.showErrors "&lt;br&gt;"/&gt;</pre><p>Output is shown below of the form fragment generating the name
          field, and displaying a validation error after the form was
          submitted with no value in the field. Validation occurs through
          Spring's Validation framework.</p><p>The generated HTML looks like this:</p><pre class="programlisting">Name:
  &lt;input type="text" name="name" value=""     
&gt;
&lt;br&gt;
  &lt;b&gt;required&lt;/b&gt;
&lt;br&gt;
&lt;br&gt;</pre><p>The formTextarea macro works the same way as the formInput
          macro and accepts the same parameter list. Commonly, the second
          parameter (attributes) will be used to pass style information or
          rows and cols attributes for the textarea.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="views-form-macros-select"></a>14.4.5.3.2.&nbsp;Selection Fields</h5></div></div><div></div></div><p>Four selection field macros can be used to generate common UI
          value selection inputs in your HTML forms.</p><div class="itemizedlist"><ul type="disc"><li><p>formSingleSelect</p></li><li><p>formMultiSelect</p></li><li><p>formRadioButtons</p></li><li><p>formCheckboxes</p></li></ul></div><p>Each of the four macros accepts a Map of options containing
          the value for the form field, and the label corresponding to that
          value. The value and the label can be the same.</p><p>An example of radio buttons in FTL is below. The form backing
          object specifies a default value of 'London' for this field and so
          no validation is necessary. When the form is rendered, the entire
          list of cities to choose from is supplied as reference data in the
          model under the name 'cityMap'.</p><pre class="programlisting">...
  Town:
  &lt;@spring.formRadioButtons "command.address.town", cityMap, "" /&gt;&lt;br&gt;&lt;br&gt;</pre><p>This renders a line of radio buttons, one for each value in
          <tt class="literal">cityMap</tt> using the separator "". No additional
          attributes are supplied (the last parameter to the macro is
          missing). The cityMap uses the same String for each key-value pair
          in the map. The map's keys are what the form actually submits as
          POSTed request parameters, map values are the labels that the user
          sees. In the example above, given a list of three well known cities
          and a default value in the form backing object, the HTML would
          be</p><pre class="programlisting">Town:
&lt;input type="radio" name="address.town" value="London"
   
&gt;
London
&lt;input type="radio" name="address.town" value="Paris"
  checked="checked" 
&gt;
Paris
&lt;input type="radio" name="address.town" value="New York"
   
&gt;
New York</pre><p>If your application expects to handle cities by internal codes
          for example, the map of codes would be created with suitable keys
          like the example below.</p><pre class="programlisting">protected Map referenceData(HttpServletRequest request) throws Exception {
  Map cityMap = new LinkedHashMap();
  cityMap.put("LDN", "London");
  cityMap.put("PRS", "Paris");
  cityMap.put("NYC", "New York");
  
  Map m = new HashMap();
  m.put("cityMap", cityMap);
  return m;
}</pre><p>The code would now produce output where the radio values are
          the relevant codes but the user still sees the more user friendly
          city names.</p><pre class="programlisting">Town:
&lt;input type="radio" name="address.town" value="LDN"
   
&gt;
London
&lt;input type="radio" name="address.town" value="PRS"
  checked="checked" 
&gt;
Paris
&lt;input type="radio" name="address.town" value="NYC"
   
&gt;
New York</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="views-form-macros-html-escaping"></a>14.4.5.4.&nbsp;HTML escaping and XHTML compliance</h4></div></div><div></div></div><p>Default usage of the form macros above will result in HTML tags
        that are HTML 4.01 compliant and that use the default value for HTML
        escaping defined in your web.xml as used by Spring's bind support. In
        order to make the tags XHTML compliant or to override the default HTML
        escaping value, you can specify two variables in your template (or in
        your model where they will be visible to your templates). The
        advantage of specifying them in the templates is that they can be
        changed to different values later in the template processing to
        provide different behavior for different fields in your form.</p><p>To switch to XHTML compliance for your tags, specify a value of
        'true' for a model/context variable named xhtmlCompliant:</p><pre class="programlisting">## for Velocity..
#set($springXhtmlCompliant = true)

&lt;#-- for FreeMarker --&gt;
&lt;#assign xhtmlCompliant = true in spring&gt;</pre><p>Any tags generated by the Spring macros will now be XHTML
        compliant after processing this directive.</p><p>In similar fashion, HTML escaping can be specified per
        field:</p><pre class="programlisting">&lt;#-- until this point, default HTML escaping is used --&gt;

&lt;#assign htmlEscape = true in spring&gt;
&lt;#-- next field will use HTML escaping --&gt;
&lt;@spring.formInput "command.name" /&gt;

&lt;#assign htmlEscape = false in spring&gt;
&lt;#-- all future fields will be bound with HTML escaping off --&gt;</pre></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-xslt"></a>14.5.&nbsp;XSLT</h2></div></div><div></div></div><p>XSLT is a transformation language for XML and is popular as a view
    technology within web applications. XSLT can be a good choice as a view
    technology if your application naturally deals with XML, or if your model
    can easily be converted to XML. The following section shows how to produce
    an XML document as model data and have it transformed with XSLT in a
    Spring Web MVC application.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-xslt-firstwords"></a>14.5.1.&nbsp;My First Words</h3></div></div><div></div></div><p>This example is a trivial Spring application that creates a list
      of words in the <tt class="interfacename">Controller</tt> and adds them to the model
      map. The map is  returned along with the view name of our XSLT view. See the section
      entitled <a href="#mvc-controller" title="13.3.&nbsp;Controllers">Section&nbsp;13.3, &#8220;Controllers&#8221;</a> for details of Spring Web MVC's
      <tt class="interfacename">Controller</tt> interface. The XSLT view will turn the list of
      words into a simple XML document ready for transformation.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-beandefs"></a>14.5.1.1.&nbsp;Bean definitions</h4></div></div><div></div></div><p>Configuration is standard for a simple Spring application. The
        dispatcher servlet config file contains a reference to a
        <tt class="interfacename">ViewResolver</tt>, URL mappings and a single controller
        bean...</p><pre class="programlisting">&lt;bean id="homeController"class="xslt.HomeController"/&gt;</pre><p>... that encapsulates our word generation logic.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-controllercode"></a>14.5.1.2.&nbsp;Standard MVC controller code</h4></div></div><div></div></div><p>The controller logic is encapsulated in a subclass of
        <tt class="classname">AbstractController</tt>, with the handler method being defined like so...</p><pre class="programlisting">protected ModelAndView handleRequestInternal(
    HttpServletRequest request,
    HttpServletResponse response) throws Exception {
        
    Map map = new HashMap();
    List wordList = new ArrayList();
        
    wordList.add("hello");
    wordList.add("world");
       
    map.put("wordList", wordList);
      
    return new ModelAndView("home", map);
}</pre><p>So far we've done nothing that's XSLT specific. The model data
        has been created in the same way as you would for any other Spring MVC
        application. Depending on the configuration of the application now,
        that list of words could be rendered by JSP/JSTL by having them added
        as request attributes, or they could be handled by Velocity by adding
        the object to the <tt class="classname">VelocityContext</tt>. In
        order to have XSLT render them, they of course have to be converted into
        an XML document somehow.
        There are software packages available that will automatically 'domify'
        an object graph, but within Spring, you have complete flexibility to
        create the DOM from your model in any way you choose. This prevents
        the transformation of XML playing too great a part in the structure of
        your model data which is a danger when using tools to manage the
        domification process.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-subclassing"></a>14.5.1.3.&nbsp;Convert the model data to XML</h4></div></div><div></div></div><p>In order to create a DOM document from our list of words or any
        other model data, we must subclass the (provided)
        <tt class="classname">org.springframework.web.servlet.view.xslt.AbstractXsltView</tt>
        class. In doing so, we must also typically implement the abstract method
        <tt class="methodname">createXsltSource(..)</tt> method. The first parameter passed
        to this method is our model map. Here's the complete listing of the
        <tt class="classname">HomePage</tt> class in our trivial word application:</p><pre class="programlisting">
package xslt;

<i class="lineannotation"><span class="lineannotation">// imports omitted for brevity</span></i>

public class HomePage extends AbstractXsltView {

    protected Source createXsltSource(Map model, String rootName, HttpServletRequest
        request, HttpServletResponse response) throws Exception {

        Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
        Element root = document.createElement(rootName);

        List words = (List) model.get("wordList");
        for (Iterator it = words.iterator(); it.hasNext();) {
            String nextWord = (String) it.next();
            Element wordNode = document.createElement("word");
            Text textNode = document.createTextNode(nextWord);
            wordNode.appendChild(textNode);
            root.appendChild(wordNode);
        }
        return new DOMSource(root);
    }

}</pre><p>A series of parameter name/value pairs can optionally be
        defined by your subclass which will be added to the transformation
        object. The parameter names must match those defined in your XSLT
        template declared with
        <tt class="literal">&lt;xsl:param name="myParam"&gt;defaultValue&lt;/xsl:param&gt;</tt>.
        To  specify the parameters, override the
        <tt class="methodname">getParameters()</tt> method of the
        <tt class="classname">AbstractXsltView</tt> class and return a
        <tt class="interfacename">Map</tt> of the name/value pairs. If your parameters
        need to derive information from the current request, you can override the
        <tt class="methodname">getParameters(HttpServletRequest request)</tt> method instead.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-viewdefinitions"></a>14.5.1.4.&nbsp;Defining the view properties</h4></div></div><div></div></div><p>The views.properties file (or equivalent xml definition if
        you're using an XML based view resolver as we did in the Velocity
        examples above) looks like this for the one-view application that is
        'My First Words':</p><pre class="programlisting">home.class=xslt.HomePage
home.stylesheetLocation=/WEB-INF/xsl/home.xslt
home.root=words</pre><p>Here, you can see how the view is tied in
        with the <tt class="classname">HomePage</tt> class just written which handles the model
        domification in the first property <tt class="literal">'.class'</tt>. The <tt class="literal">'stylesheetLocation'</tt>
        property points to the XSLT file which will handle the XML
        transformation into HTML for us and the final property <tt class="literal">'.root'</tt> is the
        name that will be used as the root of the XML document. This gets
        passed to the <tt class="classname">HomePage</tt> class above in the second parameter to the
        <tt class="methodname">createXsltSource(..)</tt> method(s).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-xslt-transforming"></a>14.5.1.5.&nbsp;Document transformation</h4></div></div><div></div></div><p>Finally, we have the XSLT code used for transforming the above
        document. As shown in the above <tt class="filename">'views.properties'</tt> file, the stylesheet is called
        <tt class="filename">'home.xslt'</tt> and it lives in the war file in the
        <tt class="filename">'WEB-INF/xsl'</tt> directory.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

    &lt;xsl:output method="html" omit-xml-declaration="yes"/&gt;

    &lt;xsl:template match="/"&gt;
        &lt;html&gt;
            &lt;head&gt;&lt;title&gt;Hello!&lt;/title&gt;&lt;/head&gt;
            &lt;body&gt;
                &lt;h1&gt;My First Words&lt;/h1&gt;
                &lt;xsl:apply-templates/&gt;
            &lt;/body&gt;
        &lt;/html&gt;
    &lt;/xsl:template&gt;

    &lt;xsl:template match="word"&gt;
        &lt;xsl:value-of select="."/&gt;&lt;br/&gt;
    &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-xslt-summary"></a>14.5.2.&nbsp;Summary</h3></div></div><div></div></div><p>A summary of the files discussed and their location in the WAR
      file is shown in the simplified WAR structure below.</p><pre class="programlisting">ProjectRoot
  |
  +- WebContent
      |
      +- WEB-INF
          |
          +- classes
          |    |
          |    +- xslt
          |    |   |
          |    |   +- HomePageController.class 
          |    |   +- HomePage.class
          |    |
          |    +- views.properties
          |
          +- lib
          |   |
          |   +- spring.jar
          |
          +- xsl
          |   |
          |   +- home.xslt
          |
          +- frontcontroller-servlet.xml</pre><p>You will also need to ensure that an XML parser and an XSLT engine are available on the
            classpath. JDK 1.4 provides them by default, and most J2EE containers
            will also make them available by default, but it's a possible source of
            errors to be aware of.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-document"></a>14.6.&nbsp;Document views (PDF/Excel)</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-document-intro"></a>14.6.1.&nbsp;Introduction</h3></div></div><div></div></div><p>Returning an HTML page isn't always the best way for the user to
      view the model output, and Spring makes it simple to generate a PDF
      document or an Excel spreadsheet dynamically from the model data. The
      document is the view and will be streamed from the server with the
      correct content type to (hopefully) enable the client PC to run their
      spreadsheet or PDF viewer application in response.</p><p>In order to use Excel views, you need to add the 'poi' library to
      your classpath, and for PDF generation, the iText.jar. Both are included
      in the main Spring distribution.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-document-config"></a>14.6.2.&nbsp;Configuration and setup</h3></div></div><div></div></div><p>Document based views are handled in an almost identical fashion to
      XSLT views, and the following sections build upon the previous one by
      demonstrating how the same controller used in the XSLT example is
      invoked to render the same model as both a PDF document and an Excel
      spreadsheet (which can also be viewed or manipulated in Open
      Office).</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-document-configviews"></a>14.6.2.1.&nbsp;Document view definitions</h4></div></div><div></div></div><p>Firstly, let's amend the views.properties file (or xml
        equivalent) and add a simple view definition for both document types.
        The entire file now looks like this with the XSLT view shown from
        earlier.. </p><pre class="programlisting">home.class=xslt.HomePage
home.stylesheetLocation=/WEB-INF/xsl/home.xslt
home.root=words

xl.class=excel.HomePage

pdf.class=pdf.HomePage</pre><p> <span class="emphasis"><em>If you want to start with a
        template spreadsheet to add your model data to, specify the location
        as the 'url' property in the view definition</em></span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-document-configcontroller"></a>14.6.2.2.&nbsp;Controller code</h4></div></div><div></div></div><p>The controller code we'll use remains exactly the same from the
        XSLT example earlier other than to change the name of the view to use.
        Of course, you could be clever and have this selected based on a URL
        parameter or some other logic - proof that Spring really is very good
        at decoupling the views from the controllers!</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-document-configsubclasses"></a>14.6.2.3.&nbsp;Subclassing for Excel views</h4></div></div><div></div></div><p>Exactly as we did for the XSLT example, we'll subclass suitable
        abstract classes in order to implement custom behavior in generating
        our output documents. For Excel, this involves writing a subclass of
        <tt class="literal">org.springframework.web.servlet.view.document.AbstractExcelView</tt>
		(for Excel files generated by POI)
			or <tt class="literal">org.springframework.web.servlet.view.document.AbstractJExcelView</tt>
		(for JExcelApi-generated Excel files).
        and implementing the <tt class="literal">buildExcelDocument</tt></p><p>Here's the complete listing for our POI Excel view which displays
        the word list from the model map in consecutive rows of the first
        column of a new spreadsheet.. </p><pre class="programlisting">package excel;

// imports omitted for brevity

public class HomePage extends AbstractExcelView {

    protected void buildExcelDocument(
        Map model,
        HSSFWorkbook wb,
        HttpServletRequest req,
        HttpServletResponse resp)
        throws Exception {
    
        HSSFSheet sheet;
        HSSFRow sheetRow;
        HSSFCell cell;

        // Go to the first sheet
        // getSheetAt: only if wb is created from an existing document
        //sheet = wb.getSheetAt( 0 );
        sheet = wb.createSheet("Spring");
        sheet.setDefaultColumnWidth((short)12);

        // write a text at A1
        cell = getCell( sheet, 0, 0 );
        setText(cell,"Spring-Excel test");

        List words = (List ) model.get("wordList");
        for (int i=0; i &lt; words.size(); i++) {
            cell = getCell( sheet, 2+i, 0 );
            setText(cell, (String) words.get(i));

        }
    }
}</pre><p>And this a view generating the same Excel file, now using JExcelApi: </p><pre class="programlisting">package excel;
			
// imports omitted for brevity

public class HomePage extends AbstractExcelView {

    protected void buildExcelDocument(Map model,
        WritableWorkbook wb,
        HttpServletRequest request,
        HttpServletResponse response)
    throws Exception {
			
        WritableSheet sheet = wb.createSheet("Spring");

        sheet.addCell(new Label(0, 0, "Spring-Excel test");
		
        List words  = (List)model.get("wordList");
        for (int i = -; i &lt; words.size(); i++) {
            sheet.addCell(new Label(2+i, 0, (String)words.get(i));
        }
    }
}
</pre><p>			
		</p><p>Note the differences between the APIs. We've found that the
		JExcelApi is somewhat more intuitive and furthermore, JExcelApi
		has a bit better image-handling capabilities. There have been 
		memory problems with large Excel file when using JExcelApi however.</p><p>If you now amend the controller such that it returns
        <tt class="literal">xl</tt> as the name of the view (<tt class="literal">return new
        ModelAndView("xl", map);</tt>) and run your application again,
        you should find that the Excel spreadsheet is created and downloaded
        automatically when you request the same page as before.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-document-configsubclasspdf"></a>14.6.2.4.&nbsp;Subclassing for PDF views</h4></div></div><div></div></div><p>The PDF version of the word list is even simpler. This time, the
        class extends
        <tt class="literal">org.springframework.web.servlet.view.document.AbstractPdfView</tt>
        and implements the <tt class="literal">buildPdfDocument()</tt> method as
        follows.. </p><pre class="programlisting">package pdf;

// imports omitted for brevity

public class PDFPage extends AbstractPdfView {

    protected void buildPdfDocument(
        Map model,
        Document doc,
        PdfWriter writer,
        HttpServletRequest req,
        HttpServletResponse resp)
        throws Exception {
        
        List words = (List) model.get("wordList");
        
        for (int i=0; i&lt;words.size(); i++)
            doc.add( new Paragraph((String) words.get(i)));
    
    }
}</pre><p> Once again, amend the controller to return the
        <tt class="literal">pdf</tt> view with a <tt class="literal">return new
        ModelAndView("pdf", map);</tt> and reload the URL in your
        application. This time a PDF document should appear listing each of
        the words in the model map.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="view-jasper-reports"></a>14.7.&nbsp;JasperReports</h2></div></div><div></div></div><p>JasperReports (<a href="http://jasperreports.sourceforge.net" target="_top">http://jasperreports.sourceforge.net</a>)
    is a powerful open-source reporting engine that supports the creation of report
    designs using an easily understood XML file format. JasperReports is capable of
    rendering reports output into four different formats: CSV, Excel, HTML and PDF.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-dependencies"></a>14.7.1.&nbsp;Dependencies</h3></div></div><div></div></div><p>Your application will need to include the latest release of
      JasperReports, which at the time of writing was 0.6.1. JasperReports
      itself depends on the following projects:</p><div class="itemizedlist"><ul type="bullet"><li style="list-style-type: disc"><p>BeanShell</p></li><li style="list-style-type: disc"><p>Commons BeanUtils</p></li><li style="list-style-type: disc"><p>Commons Collections</p></li><li style="list-style-type: disc"><p>Commons Digester</p></li><li style="list-style-type: disc"><p>Commons Logging</p></li><li style="list-style-type: disc"><p>iText</p></li><li style="list-style-type: disc"><p>POI</p></li></ul></div><p>JasperReports also requires a JAXP compliant XML parser.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-configuration"></a>14.7.2.&nbsp;Configuration</h3></div></div><div></div></div><p>To configure JasperReports views in your Spring container configuration
      you need to define a <tt class="interfacename">ViewResolver</tt> to map view
      names to the appropriate view class depending on which format you want your
      report rendered in.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-configuration-resolver"></a>14.7.2.1.&nbsp;Configuring the <tt class="interfacename">ViewResolver</tt></h4></div></div><div></div></div><p>Typically, you will use the <tt class="classname">ResourceBundleViewResolver</tt>
        to map view names to view classes and files in a properties file.</p><pre class="programlisting">&lt;bean id="viewResolver" class="org.springframework.web.servlet.view.ResourceBundleViewResolver"&gt;
    &lt;property name="basename" value="views"/&gt;
&lt;/bean&gt;</pre><p>Here we've configured an instance of the <tt class="classname">ResourceBundleViewResolver</tt>
        class that will look for view  mappings in the resource bundle with base name
        <tt class="literal">views</tt>. (The content of this file is described in the next section.)</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-configuration-views"></a>14.7.2.2.&nbsp;Configuring the <tt class="literal">View</tt>s</h4></div></div><div></div></div><p>The Spring Framework contains five different <tt class="interfacename">View</tt>
        implementations for JasperReports, four of which correspond to one of the four output
        formats supported by JasperReports, and one that allows for the format to be determined at runtime:</p><div class="table"><a name="view-jasper-reports-configuration-views-classes"></a><p class="title"><b>Table&nbsp;14.2.&nbsp;JasperReports <tt class="interfacename">View</tt> classes</b></p><table summary="JasperReports View classes" border="1"><colgroup><col><col></colgroup><thead><tr><th>Class Name</th><th>Render Format</th></tr></thead><tbody><tr><td><tt class="classname">JasperReportsCsvView</tt></td><td>CSV</td></tr><tr><td><tt class="classname">JasperReportsHtmlView</tt></td><td>HTML</td></tr><tr><td><tt class="classname">JasperReportsPdfView</tt></td><td>PDF</td></tr><tr><td><tt class="classname">JasperReportsXlsView</tt></td><td>Microsoft Excel</td></tr><tr><td><tt class="classname">JasperReportsMultiFormatView</tt></td><td>The view is <a href="#view-jasper-reports-configuration-multiformat-view" title="14.7.2.4.&nbsp;Using JasperReportsMultiFormatView">decided upon at runtime</a></td></tr></tbody></table></div><p>Mapping one of these classes to a view name and a report file is a matter of
        adding the appropriate entries into the resource bundle configured in the previous
        section as shown here:</p><pre class="programlisting">simpleReport.class=org.springframework.web.servlet.view.jasperreports.JasperReportsPdfView
simpleReport.url=/WEB-INF/reports/DataSourceReport.jasper</pre><p>Here you can see that the view with name <tt class="literal">simpleReport</tt>
        is mapped to the <tt class="classname">JasperReportsPdfView</tt> class, causing the
        output of this report to be rendered in PDF format. The <tt class="literal">url</tt>
        property of the view is set to the location of the underlying report file.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-configuration-report-files"></a>14.7.2.3.&nbsp;About Report Files</h4></div></div><div></div></div><p>JasperReports has two distinct types of report file: the design
        file, which has a <tt class="literal">.jrxml</tt> extension, and the
        compiled report file, which has a <tt class="literal">.jasper</tt>
        extension. Typically, you use the JasperReports Ant task to compile
        your <tt class="literal">.jrxml</tt> design file into a
        <tt class="literal">.jasper</tt> file before deploying it into your
        application. With the Spring Framework you can map either of these files to your
        report file and the framework will take care of compiling the
        <tt class="literal">.jrxml</tt> file on the fly for you. You should note
        that after a <tt class="literal">.jrxml</tt> file is compiled by the Spring Framework,
        the compiled report is cached for the lifetime of the application. To make
        changes to the file you will need to restart your application.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-configuration-multiformat-view"></a>14.7.2.4.&nbsp;Using <tt class="classname">JasperReportsMultiFormatView</tt></h4></div></div><div></div></div><p>The <tt class="classname">JasperReportsMultiFormatView</tt> allows for
        report format to be specified at runtime. The actual rendering of the
        report is delegated to one of the other JasperReports view classes -
        the <tt class="classname">JasperReportsMultiFormatView</tt> class simply adds
        a wrapper layer that allows for the exact implementation to be
        specified at runtime.</p><p>The <tt class="classname">JasperReportsMultiFormatView</tt> class
        introduces two concepts: the format key and the discriminator key. The
        <tt class="classname">JasperReportsMultiFormatView</tt> class uses the mapping
        key to lookup the actual view implementation class and uses the format
        key to lookup up the mapping key. From a coding perspective you add an
        entry to your model with the formay key as the key and the mapping key
        as the value, for example:</p><pre class="programlisting">public ModelAndView handleSimpleReportMulti(HttpServletRequest request,
HttpServletResponse response) throws Exception {

  String uri = request.getRequestURI();
  String format = uri.substring(uri.lastIndexOf(".") + 1);

  Map model = getModel();
  model.put("format", format);

  return new ModelAndView("simpleReportMulti", model);
}</pre><p>In this example, the mapping key is determined from the
        extension of the request URI and is added to the model under the
        default format key: <tt class="literal">format</tt>. If you wish to use a
        different format key then you can configure this using the
        <tt class="literal">formatKey</tt> property of the
        <tt class="classname">JasperReportsMultiFormatView</tt> class.</p><p>By default the following mapping key mappings are configured in
        <tt class="classname">JasperReportsMultiFormatView</tt>:</p><div class="table"><a name="view-jasper-reports-configuration-multiformat-view-mappings"></a><p class="title"><b>Table&nbsp;14.3.&nbsp;<tt class="classname">JasperReportsMultiFormatView</tt> Default Mapping Key Mappings</b></p><table summary="JasperReportsMultiFormatView Default Mapping Key Mappings" border="1"><colgroup><col><col></colgroup><thead><tr><th>Mapping Key</th><th>View Class</th></tr></thead><tbody><tr><td>csv</td><td><tt class="classname">JasperReportsCsvView</tt></td></tr><tr><td>html</td><td><tt class="classname">JasperReportsHtmlView</tt></td></tr><tr><td>pdf</td><td><tt class="classname">JasperReportsPdfView</tt></td></tr><tr><td>xls</td><td><tt class="classname">JasperReportsXlsView</tt></td></tr></tbody></table></div><p>So in the example above a request to URI /foo/myReport.pdf
            would be mapped to the <tt class="literal">JasperReportsPdfView</tt> class.
            You can override the mapping key to view class mappings using the
            <tt class="literal">formatMappings</tt> property of
            <tt class="classname">JasperReportsMultiFormatView</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-model"></a>14.7.3.&nbsp;Populating the <tt class="classname">ModelAndView</tt></h3></div></div><div></div></div><p>In order to render your report correctly in the format you have
      chosen, you must supply Spring with all of the data needed to populate
      your report. For JasperReports this means you must pass in all report
      parameters along with the report datasource. Report parameters are
      simple name/value pairs and can be added be to the
      <tt class="interfacename">Map</tt> for your model as you would add any name/value
      pair.</p><p>When adding the datasource to the model you have two approaches to
      choose from. The first approach is to add an instance of
      <tt class="classname">JRDataSource</tt> or a <tt class="interfacename">Collection</tt> type to the
      model <tt class="interfacename">Map</tt> under any arbitrary key. Spring will then
      locate this object in the model and treat it as the report datasource.
      For example, you may populate your model like so:</p><pre class="programlisting">private Map getModel() {
  Map model = new HashMap();
  Collection beanData = getBeanData();
  model.put("myBeanData", beanData);
  return model;
}</pre><p>The second approach is to add the instance of
      <tt class="literal">JRDataSource</tt> or <tt class="literal">Collection</tt> under a
      specific key and then configure this key using the
      <tt class="literal">reportDataKey</tt> property of the view class. In both
      cases Spring will instances of <tt class="literal">Collection</tt> in a
      <tt class="literal">JRBeanCollectionDataSource</tt> instance. For example:</p><pre class="programlisting">private Map getModel() {
  Map model = new HashMap();
  Collection beanData = getBeanData();
  Collection someData = getSomeData();
  model.put("myBeanData", beanData);
  model.put("someData", someData);
  return model;
}</pre><p>Here you can see that two <tt class="literal">Collection</tt>
      instances are being added to the model. To ensure that the correct one
      is used, we simply modify our view configuration as appropriate:</p><pre class="programlisting">simpleReport.class=org.springframework.web.servlet.view.jasperreports.JasperReportsPdfView
simpleReport.url=/WEB-INF/reports/DataSourceReport.jasper
simpleReport.reportDataKey=myBeanData</pre><p>Be aware that when using the first approach, Spring will use the
      first instance of <tt class="literal">JRDataSource</tt> or
      <tt class="literal">Collection</tt> that it encounters. If you need to place
      multiple instances of <tt class="literal">JRDataSource</tt> or
      <tt class="literal">Collection</tt> into the model then you need to use the
      second approach.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-subreports"></a>14.7.4.&nbsp;Working with Sub-Reports</h3></div></div><div></div></div><p>JasperReports provides support for embedded sub-reports within
      your master report files. There are a wide variety of mechanisms for
      including sub-reports in your report files. The easiest way is to hard
      code the report path and the SQL query for the sub report into your
      design files. The drawback of this approach is obvious - the values are
      hard-coded into your report files reducing reusability and making it
      harder to modify and update report designs. To overcome this you can
      configure sub-reports declaratively and you can include additional data
      for these sub-reports directly from your controllers.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-subreports-config-reports"></a>14.7.4.1.&nbsp;Configuring Sub-Report Files</h4></div></div><div></div></div><p>To control which sub-report files are included in a master
        report using Spring, your report file must be configured to accept
        sub-reports from an external source. To do this you declare a
        parameter in your report file like so:</p><pre class="programlisting">&lt;parameter name="ProductsSubReport" class="net.sf.jasperreports.engine.JasperReport"/&gt;</pre><p>Then, you define your sub-report to use this sub-report parameter:</p><pre class="programlisting">&lt;subreport&gt;
    &lt;reportElement isPrintRepeatedValues="false" x="5" y="25" width="325"
        height="20" isRemoveLineWhenBlank="true" backcolor="#ffcc99"/&gt;
    &lt;subreportParameter name="City"&gt;
        &lt;subreportParameterExpression&gt;&lt;![CDATA[$F{city}]]&gt;&lt;/subreportParameterExpression&gt;
    &lt;/subreportParameter&gt;
    &lt;dataSourceExpression&gt;&lt;![CDATA[$P{SubReportData}]]&gt;&lt;/dataSourceExpression&gt;
    &lt;subreportExpression class="net.sf.jasperreports.engine.JasperReport"&gt;
                  &lt;![CDATA[$P{ProductsSubReport}]]&gt;&lt;/subreportExpression&gt;
&lt;/subreport&gt;</pre><p>This defines a master report file that
        expects the sub-report to be passed in as an instance of
        <tt class="literal">net.sf.jasperreports.engine.JasperReports</tt> under the
        parameter <tt class="literal">ProductsSubReport</tt>. When configuring your
        Jasper view class, you can instruct Spring to load a report file and
        pass into the JasperReports engine as a sub-report using the
        <tt class="literal">subReportUrls</tt> property:</p><pre class="programlisting">&lt;property name="subReportUrls"&gt;
    &lt;map&gt;
        &lt;entry key="ProductsSubReport" value="/WEB-INF/reports/subReportChild.jrxml"/&gt;
    &lt;/map&gt;
&lt;/property&gt;</pre><p>Here, the key of the <tt class="interfacename">Map</tt>
        corresponds to the name of the sub-report parameter in th report
        design file, and the entry is the URL of the report file. Spring will
        load this report file, compiling it if necessary, and will pass into
        the JasperReports engine under the given key.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="view-jasper-reports-subreports-config-datasources"></a>14.7.4.2.&nbsp;Configuring Sub-Report Data Sources</h4></div></div><div></div></div><p>This step is entirely optional when using Spring configure your
        sub-reports. If you wish, you can still configure the data source for
        your sub-reports using static queries. However, if you want Spring to
        convert data returned in your <tt class="literal">ModelAndView</tt> into
        instances of <tt class="literal">JRDataSource</tt> then you need to specify
        which of the parameters in your <tt class="literal">ModelAndView</tt> Spring
        should convert. To do this configure the list of parameter names using
        the <tt class="literal">subReportDataKeys</tt> property of the your chosen
        view class: </p><pre class="programlisting">&lt;property name="subReportDataKeys"
    value="SubReportData"/&gt;</pre><p> Here, the key you supply MUST
        correspond to both the key used in your <tt class="literal">ModelAndView</tt>
        and the key used in your report design file.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="view-jasper-reports-exporter-parameters"></a>14.7.5.&nbsp;Configuring Exporter Parameters</h3></div></div><div></div></div><p>If you have special requirements for exporter configuration -
      perhaps you want a specific page size for your PDF report, then you can
      configure these exporter parameters declaratively in your Spring
      configuration file using the <tt class="literal">exporterParameters</tt>
      property of the view class. The <tt class="literal">exporterParameters</tt>
      property is typed as <tt class="interfacename">Map</tt> and in your configuration
      the key of an entry should be the fully-qualified name of a static field
      that contains the exporter parameter definition and the value of an
      entry should be the value you want to assign to the parameter. An
      example of this is shown below:</p><pre class="programlisting">&lt;bean id="htmlReport" class="org.springframework.web.servlet.view.jasperreports.JasperReportsHtmlView"&gt;
  &lt;property name="url" value="/WEB-INF/reports/simpleReport.jrxml"/&gt;
  &lt;property name="exporterParameters"&gt;
    &lt;map&gt;
      &lt;entry key="net.sf.jasperreports.engine.export.JRHtmlExporterParameter.HTML_FOOTER"&gt;
        &lt;value&gt;Footer by Spring!
          &amp;lt;/td&amp;gt;&amp;lt;td width="50%"&amp;gt;&amp;amp;nbsp; &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
          &amp;lt;/table&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
        &lt;/value&gt;
      &lt;/entry&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Here you can see that the <tt class="classname">JasperReportsHtmlView</tt> is
      being configured with an exporter parameter for
      <tt class="literal">net.sf.jasperreports.engine.export.JRHtmlExporterParameter.HTML_FOOTER</tt>
      which will output a footer in the resulting HTML.</p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="web-integration"></a>Chapter&nbsp;15.&nbsp;Integrating with other web frameworks</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="intro"></a>15.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
      This chapter details Spring's integration with third party web frameworks
      such as <a href="http://java.sun.com/javaee/javaserverfaces/" target="_top">JSF</a>,
      <a href="http://struts.apache.org/" target="_top">Struts</a>,
      <a href="http://www.opensymphony.com/webwork/" target="_top">WebWork</a>, and
      <a href="http://tapestry.apache.org/" target="_top">Tapestry</a>.
    </p><div class="sidebar"><p class="title"><b>Spring Web Flow</b></p><p>Spring Web Flow (SWF) aims to be the best solution for the management
  of web application page flow.</p><p>SWF integrates with existing frameworks like Spring MVC, Struts, and
  JSF, in both servlet and portlet environments. If you have a business
  process (or processes) that would benefit from a conversational model as
  opposed to a purely request model, then SWF may be the solution.</p><p>SWF allows you to capture logical page flows as self-contained modules
  that are reusable in different situations, and as such is ideal for building
  web application modules that guide the user through controlled navigations
  that drive business processes.</p><p>For more information about SWF, consult the
  <a href="http://www.springframework.org/webflow" target="_top">Spring Web Flow website</a>.
  </p></div><p>
      One of the core value propositions of the Spring Framework is that of
      enabling <span class="emphasis"><em>choice</em></span>. In a general sense, Spring does not
      force one to use or buy into any particular architecture, technology, or
      methodology (although it certainly recommends some over others). This freedom
      to pick and choose the architecture, technology, or methodology that is most
      relevant to a developer and his or her development team is arguably most evident
      in the web area, where Spring provides its own web framework
      (<a href="#mvc" title="Chapter&nbsp;13.&nbsp;Web MVC framework">Spring MVC</a>), while at the same time providing integration
      with a number of popular third party web frameworks. This allows one to continue
      to leverage any and all of the skills one may have acquired in a
      particular web framework such as Struts, while at the same time being able to
      enjoy the benefits afforded by Spring in other areas such as data access,
      declarative transaction management, and flexible configuration and application
      assembly.
    </p><p>
      Having dispensed with the woolly sales patter (c.f. the previous paragraph),
      the remainder of this chapter will concentrate upon the meaty details of
      integrating your favourite web framework with Spring. One thing that is often
      commented upon by developers coming to Java from other languages is the seeming
      super-abundance of web frameworks available in Java... there are indeed a great
      number of web frameworks in the Java space; in fact there are far too many to
      cover with any semblance of detail in a single chapter. This chapter thus picks
      four of the more popular web frameworks in Java, starting with the Spring
      configuration that is common to all of the supported web frameworks, and then
      detailing the specific integration options for each supported web framework.
    </p><p>
      <span class="emphasis"><em>
        Please note that this chapter does not attempt to explain how to use any
        of the supported web frameworks. For example, if you want to use Struts for
        the presentation layer of your web application, the assumption is that you
        are already familiar with Struts. If you need further details about any of
        the supported web frameworks themselves, please do consult the section
        entitled <a href="#web-integration-resources" title="15.7.&nbsp;Further Resources">Section&nbsp;15.7, &#8220;Further Resources&#8221;</a> at the end of this chapter.
      </em></span>
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="web-integration-common"></a>15.2.&nbsp;Common configuration</h2></div></div><div></div></div><p>
      Before diving into the integration specifics of each supported web framework, let
      us first take a look at the Spring configuration that <span class="emphasis"><em>not</em></span>
      specific to any one web framework. (This section is equally applicable to Spring's
      own web framework, Spring MVC.)
    </p><p>
      One of the concepts (for want of a better word) espoused by (Spring's) lightweight
      application model is that of a layered architecture. Remember that in a 'classic'
      layered architecture, the web layer is but one of many layers... it serves as one
      of the entry points into a server side application, and it delegates to service
      objects (facades) defined in a service layer to satisfy business specific (and
      presentation-technology agnostic) use cases. In Spring, these service objects,
      any other business-specific objects, data access objects, etc. exist in a
      distinct 'business context', which contains <span class="emphasis"><em>no</em></span> web or
      presentation layer objects (presentation objects such as Spring MVC controllers
      are typically configured in a distinct 'presentation context'). This section
      details how one configures a Spring container (a
      <tt class="classname">WebApplicationContext</tt>) that contains all of the
      'business beans' in one's application.
    </p><p>
      Onto specifics... all that one need do is to declare a
      <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/context/ContextLoaderListener.html" target="_top"><tt class="classname">ContextLoaderListener</tt></a>
      in the standard J2EE servlet <tt class="literal">web.xml</tt> file of one's web application,
      and add a <tt class="literal">contextConfigLocation</tt> &lt;context-param/&gt; section
      (in the same file) that defines which set of Spring XML cpnfiguration files to load.
    </p><p>
      Find below the &lt;listener/&gt; configuration:
    </p><pre class="programlisting">&lt;listener&gt;
  &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
        Listeners were added to the Servlet API in version 2.3; listener startup order was
        finally clarified in Servlet 2.4. If you have a Servlet 2.3 container, you can use the
        <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/context/ContextLoaderServlet.html" target="_top"><tt class="classname">ContextLoaderServlet</tt></a>
        to achieve the same functionality in a 100% portable fashion (with respect to startup order).
      </p></td></tr></table></div><p>
      Find below the &lt;context-param/&gt; configuration:
    </p><pre class="programlisting">&lt;context-param&gt;
  &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
  &lt;param-value&gt;/WEB-INF/applicationContext*.xml&lt;/param-value&gt;
&lt;/context-param&gt;</pre><p>
      If you don't specify the <tt class="literal">contextConfigLocation</tt>
      context parameter, the <tt class="classname">ContextLoaderListener</tt> will look
      for a file called <tt class="literal">/WEB-INF/applicationContext.xml</tt> to load.
      Once the context files are loaded, Spring creates a
      <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/context/WebApplicationContext.html" target="_top"><tt class="classname">WebApplicationContext</tt></a>
      object based on the bean definitions and stores it in the
      <span class="interface">ServletContext</span> of one's web application.
    </p><p>
      All Java web frameworks are built on top of the Servlet API, and so one can
      use the following code snippet to get access to this 'business context'
      <span class="interface">ApplicationContext</span> created by the
      <tt class="classname">ContextLoaderListener</tt>.
    </p><pre class="programlisting">WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext);</pre><p>
      The <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/context/support/WebApplicationContextUtils.html" target="_top"><tt class="classname">WebApplicationContextUtils</tt></a>
      class is for convenience, so you don't have to remember the name of the
      <span class="interface">ServletContext</span> attribute. Its <span class="emphasis"><em>getWebApplicationContext()</em></span>
      method will return <tt class="literal">null</tt> if an object doesn't exist under the
      <tt class="literal">WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</tt> key. Rather
      than risk getting <tt class="classname">NullPointerExceptions</tt> in your application, it's
      better to use the <tt class="literal">getRequiredWebApplicationContext()</tt> method. This
      method throws an exception when the <span class="interface">ApplicationContext</span> is missing.
    </p><p>
      Once you have a reference to the <tt class="classname">WebApplicationContext</tt>,
      you can retrieve beans by their name or type. Most developers retrieve beans
      by name, then cast them to one of their implemented interfaces.
    </p><p>
      Fortunately, most of the frameworks in this section have simpler ways of looking up
      beans. Not only do they make it easy to get beans from a Spring container, but they
      also allow you to use dependency injection on their controllers. Each web framework
      section has more detail on its specific integration strategies.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jsf"></a>15.3.&nbsp;JavaServer Faces 1.1 and 1.2</h2></div></div><div></div></div><p>
      JavaServer Faces (JSF) is the JCP's standard component-based, event-driven
      web user interface framework. As of Java EE 5, it is an official part of
      the Java EE umbrella.
    </p><p>
      For a popular JSF runtime as well as for popular JSF component libraries, check
      out the <a href="http://myfaces.apache.org/" target="_top">Apache MyFaces project</a>.
      The MyFaces project also provides common JSF extensions such as
      <a href="http://myfaces.apache.org/orchestra/" target="_top">MyFaces Orchestra</a>:
      a Spring-based JSF extension that provides rich conversation scope support.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
        Spring Web Flow 2.0 provides rich JSF support through its newly
        established Spring Faces module, both for JSF-centric usage
        (as described in this section) and for Spring-centric usage
        (using JSF views within a Spring MVC dispatcher). Check out the
        <a href="http://www.springframework.org/webflow" target="_top">Spring Web Flow website</a>
        for details!
      </p></td></tr></table></div><p>
      The key element in Spring's JSF integration is the JSF 1.1
      <tt class="classname">VariableResolver</tt> mechanism. On JSF 1.2,
      Spring supports the <tt class="classname">ELResolver</tt> mechanism
      as a next-generation version of JSF EL integration.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jsf-delegatingvariableresolver"></a>15.3.1.&nbsp;DelegatingVariableResolver (JSF 1.1/1.2)</h3></div></div><div></div></div><p>
        The easiest way to integrate one's Spring middle-tier with one's
        JSF web layer is to use the
        <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/jsf/DelegatingVariableResolver.html" target="_top">
        <tt class="classname">DelegatingVariableResolver</tt></a> class. To configure
        this variable resolver in one's application, one will need to edit one's
        <span class="emphasis"><em>faces-context.xml</em></span> file. After the opening
        <tt class="literal">&lt;faces-config/&gt;</tt> element, add an <tt class="literal">&lt;application/&gt;</tt>
        element and a <tt class="literal">&lt;variable-resolver/&gt;</tt> element within it.
        The value of the variable resolver should reference Spring's
        <tt class="classname">DelegatingVariableResolver</tt>; for example:</p><pre class="programlisting">&lt;faces-config&gt;
  &lt;application&gt;
    &lt;variable-resolver&gt;org.springframework.web.jsf.DelegatingVariableResolver&lt;/variable-resolver&gt;
    &lt;locale-config&gt;
      &lt;default-locale&gt;en&lt;/default-locale&gt;
      &lt;supported-locale&gt;en&lt;/supported-locale&gt;
      &lt;supported-locale&gt;es&lt;/supported-locale&gt;
    &lt;/locale-config&gt;
    &lt;message-bundle&gt;messages&lt;/message-bundle&gt;
  &lt;/application&gt;
&lt;/faces-config&gt;</pre><p>
        The <tt class="classname">DelegatingVariableResolver</tt> will first delegate value
        lookups to the default resolver of the underlying JSF implementation, and
        then to Spring's 'business context' <tt class="classname">WebApplicationContext</tt>.
        This allows one to easily inject dependencies into one's JSF-managed beans.
      </p><p>
        Managed beans are defined in one's <tt class="literal">faces-config.xml</tt>
        file. Find below an example where <tt class="literal">#{userManager}</tt> is a bean
        that is retrieved from the Spring 'business context'.
      </p><pre class="programlisting">&lt;managed-bean&gt;
  &lt;managed-bean-name&gt;userList&lt;/managed-bean-name&gt;
  &lt;managed-bean-class&gt;com.whatever.jsf.UserList&lt;/managed-bean-class&gt;
  &lt;managed-bean-scope&gt;request&lt;/managed-bean-scope&gt;
  &lt;managed-property&gt;
    &lt;property-name&gt;userManager&lt;/property-name&gt;
    &lt;value&gt;#{userManager}&lt;/value&gt;
  &lt;/managed-property&gt;
&lt;/managed-bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jsf-springbeanvariableresolver"></a>15.3.2.&nbsp;SpringBeanVariableResolver (JSF 1.1/1.2)</h3></div></div><div></div></div><p>
        <tt class="classname">SpringBeanVariableResolver</tt> is a variant of
        <tt class="classname">DelegatingVariableResolver</tt>. It delegates to the
        Spring's 'business context' <tt class="classname">WebApplicationContext</tt>
        <span class="emphasis"><em>first</em></span>, then to the default resolver of the
        underlying JSF implementation. This is useful in particular when
        using request/session-scoped beans with special Spring resolution rules,
        e.g. Spring <tt class="interfacename">FactoryBean</tt> implementations.
      </p><p>
        Configuration-wise, simply define <tt class="classname">SpringBeanVariableResolver</tt>
        in your <span class="emphasis"><em>faces-context.xml</em></span> file:
      </p><pre class="programlisting">&lt;faces-config&gt;
  &lt;application&gt;
    &lt;variable-resolver&gt;org.springframework.web.jsf.SpringBeanVariableResolver&lt;/variable-resolver&gt;
    ...
  &lt;/application&gt;
&lt;/faces-config&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jsf-springbeanfaceselresolver"></a>15.3.3.&nbsp;SpringBeanFacesELResolver (JSF 1.2+)</h3></div></div><div></div></div><p>
        <tt class="classname">SpringBeanFacesELResolver</tt> is a JSF 1.2 compliant
        <tt class="classname">ELResolver</tt> implementation, integrating with
        the standard Unified EL as used by JSF 1.2 and JSP 2.1. Like
        <tt class="classname">SpringBeanVariableResolver</tt>, it delegates to the
        Spring's 'business context' <tt class="classname">WebApplicationContext</tt>
        <span class="emphasis"><em>first</em></span>, then to the default resolver of the
        underlying JSF implementation.
      </p><p>
        Configuration-wise, simply define <tt class="classname">SpringBeanFacesELResolver</tt>
        in your JSF 1.2 <span class="emphasis"><em>faces-context.xml</em></span> file:
      </p><pre class="programlisting">&lt;faces-config&gt;
  &lt;application&gt;
    &lt;el-resolver&gt;org.springframework.web.jsf.el.SpringBeanFacesELResolver&lt;/el-resolver&gt;
    ...
  &lt;/application&gt;
&lt;/faces-config&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jsf-facescontextutils"></a>15.3.4.&nbsp;FacesContextUtils</h3></div></div><div></div></div><p>
        A custom <tt class="interfacename">VariableResolver</tt> works well when mapping
        one's properties to beans in <span class="emphasis"><em>faces-config.xml</em></span>, but at times
        one may need to grab a bean explicitly.  The
        <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/jsf/FacesContextUtils.html" target="_top">
        <tt class="classname">FacesContextUtils</tt></a> class makes this easy. It is
        similar to <tt class="classname">WebApplicationContextUtils</tt>, except that it
        takes a <tt class="classname">FacesContext</tt> parameter rather than a
        <span class="interface">ServletContext</span> parameter.
      </p><pre class="programlisting">ApplicationContext ctx = FacesContextUtils.getWebApplicationContext(FacesContext.getCurrentInstance());</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="struts"></a>15.4.&nbsp;Apache Struts 1.x and 2.x</h2></div></div><div></div></div><p>
      <a href="http://struts.apache.org" target="_top">Struts</a> is the
      <span class="emphasis"><em>de facto</em></span> web framework for Java applications, mainly
      because it was one of the first to be released (June 2001). Invented by
      Craig McClanahan, Struts is an open source project hosted by the Apache
      Software Foundation. At the time, it greatly simplified the JSP/Servlet
      programming paradigm and won over many developers who were using
      proprietary frameworks. It simplified the programming model, it was open
      source (and thus free as in beer), and it had a large community, which allowed
      the project to grow and become popular among Java web developers.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
        <span class="emphasis"><em>The following section discusses Struts 1 a.k.a. "Struts Classic".</em></span>
      </p><p>
        Struts 2 is effectively a different product - a successor of
        WebWork 2.2 (as discussed in <a href="#webwork" title="15.5.&nbsp;WebWork 2.x">Section&nbsp;15.5, &#8220;WebWork 2.x&#8221;</a>),
        carrying the Struts brand now. Check out the Struts 2
        <a href="http://struts.apache.org/2.x/docs/spring-plugin.html" target="_top">Spring Plugin</a>
        for the built-in Spring integration shipped with Struts 2.
        In general, Struts 2 is closer to WebWork 2.2 than to Struts 1
        in terms of its Spring integration implications.
      </p></td></tr></table></div><p>
      To integrate your Struts 1.x application with Spring, you have two options:
    </p><div class="itemizedlist"><ul type="disc"><li><p>
          Configure Spring to manage your Actions as beans, using the
          <tt class="classname">ContextLoaderPlugin</tt>, and set their
          dependencies in a Spring context file.
        </p></li><li><p>
          Subclass Spring's <tt class="classname">ActionSupport</tt>
          classes and grab your Spring-managed beans explicitly using
          a <span class="emphasis"><em>getWebApplicationContext()</em></span> method.
        </p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="struts-contextloaderplugin"></a>15.4.1.&nbsp;ContextLoaderPlugin</h3></div></div><div></div></div><p>
        The <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/ContextLoaderPlugIn.html" target="_top"><tt class="classname">ContextLoaderPlugin</tt></a>
        is a Struts 1.1+ plug-in that loads a Spring context file for the Struts
        <tt class="classname">ActionServlet</tt>. This context refers to the root
        <tt class="classname">WebApplicationContext</tt> (loaded by the
        <tt class="classname">ContextLoaderListener</tt>) as its parent. The default
        name of the context file is the name of the mapped servlet, plus
        <span class="emphasis"><em>-servlet.xml</em></span>. If <tt class="classname">ActionServlet</tt>
        is defined in web.xml as
        <tt class="literal">&lt;servlet-name&gt;action&lt;/servlet-name&gt;</tt>, the
        default is <span class="emphasis"><em>/WEB-INF/action-servlet.xml</em></span>.
      </p><p>
        To configure this plug-in, add the following XML to the plug-ins section near
        the bottom of your <span class="emphasis"><em>struts-config.xml</em></span> file:
      </p><pre class="programlisting">&lt;plug-in className="org.springframework.web.struts.ContextLoaderPlugIn"/&gt;</pre><p>
        The location of the context configuration files can be customized using the
        '<tt class="literal">contextConfigLocation</tt>' property.
      </p><pre class="programlisting">&lt;plug-in className="org.springframework.web.struts.ContextLoaderPlugIn"&gt;
  &lt;set-property property="contextConfigLocation"
      value="/WEB-INF/action-servlet.xml,/WEB-INF/applicationContext.xml"/&gt;
&lt;/plug-in&gt;</pre><p>
        It is possible to use this plugin to load all your context files, which can be
        useful when using testing tools like StrutsTestCase. StrutsTestCase's
        <tt class="classname">MockStrutsTestCase</tt> won't initialize Listeners on startup
        so putting all your context files in the plugin is a workaround. (A
        <a href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=1088866&amp;group_id=39190&amp;atid=424562" target="_top">
        bug has been filed</a> for this issue, but has been closed as 'Wont Fix').
      </p><p>
        After configuring this plug-in in <span class="emphasis"><em>struts-config.xml</em></span>, you can
        configure your <tt class="classname">Action</tt> to be managed by Spring. Spring (1.1.3+)
        provides two ways to do this:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
            Override Struts' default <tt class="classname">RequestProcessor</tt>
            with Spring's <tt class="classname">DelegatingRequestProcessor</tt>.
          </p></li><li><p>
            Use the <tt class="classname">DelegatingActionProxy</tt> class
            in the <tt class="literal">type</tt> attribute of your
            <tt class="literal">&lt;action-mapping&gt;</tt>.
          </p></li></ul></div><p>
        Both of these methods allow you to manage your Actions and
        their dependencies in the <span class="emphasis"><em>action-servlet.xml</em></span> file.
        The bridge between the Action in <span class="emphasis"><em>struts-config.xml</em></span>
        and <span class="emphasis"><em>action-servlet.xml</em></span> is built with the
        action-mapping's "path" and the bean's "name". If you have the
        following in your <span class="emphasis"><em>struts-config.xml</em></span> file:
      </p><pre class="programlisting">&lt;action path="/users" .../&gt;</pre><p>
        You must define that Action's bean with the "/users" name in
        <span class="emphasis"><em>action-servlet.xml</em></span>:
      </p><pre class="programlisting">&lt;bean name="/users" .../&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="struts-delegatingrequestprocessor"></a>15.4.1.1.&nbsp;DelegatingRequestProcessor</h4></div></div><div></div></div><p>
          To configure the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/DelegatingRequestProcessor.html" target="_top">
          <tt class="literal">DelegatingRequestProcessor</tt></a> in your
          <span class="emphasis"><em>struts-config.xml</em></span> file, override the "processorClass"
          property in the &lt;controller&gt; element. These lines follow the
          &lt;action-mapping&gt; element.
        </p><pre class="programlisting">&lt;controller&gt;
  &lt;set-property property="processorClass"
      value="org.springframework.web.struts.DelegatingRequestProcessor"/&gt;
&lt;/controller&gt;</pre><p>
          After adding this setting, your Action will automatically be
          looked up in Spring's context file, no matter what the type. In fact,
          you don't even need to specify a type. Both of the following snippets
          will work:
        </p><pre class="programlisting">&lt;action path="/user" type="com.whatever.struts.UserAction"/&gt;
&lt;action path="/user"/&gt;</pre><p>
          If you're using Struts' <span class="emphasis"><em>modules</em></span> feature,
          your bean names must contain the module prefix. For example, an action
          defined as <tt class="literal">&lt;action path="/user"/&gt;</tt> with module
          prefix "admin" requires a bean name with
          <tt class="literal">&lt;bean name="/admin/user"/&gt;</tt>.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
            If you are using Tiles in your Struts application, you must configure your
            &lt;controller&gt; with the
            <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/DelegatingTilesRequestProcessor.html" target="_top"><tt class="classname">DelegatingTilesRequestProcessor</tt></a>
            instead.
          </p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="struts-delegatingactionproxy"></a>15.4.1.2.&nbsp;DelegatingActionProxy</h4></div></div><div></div></div><p>
          If you have a custom <tt class="classname">RequestProcessor</tt> and
          can't use the <tt class="classname">DelegatingRequestProcessor</tt> or
          <tt class="classname">DelegatingTilesRequestProcessor</tt> approaches, you can
          use the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/DelegatingActionProxy.html" target="_top">
          <tt class="classname">DelegatingActionProxy</tt></a> as the type in your
          action-mapping.
        </p><pre class="programlisting">&lt;action path="/user" type="org.springframework.web.struts.DelegatingActionProxy"
    name="userForm" scope="request" validate="false" parameter="method"&gt;
  &lt;forward name="list" path="/userList.jsp"/&gt;
  &lt;forward name="edit" path="/userForm.jsp"/&gt;
&lt;/action&gt;</pre><p>
          The bean definition in <span class="emphasis"><em>action-servlet.xml</em></span>
          remains the same, whether you use a custom <tt class="literal">RequestProcessor</tt>
          or the <tt class="classname">DelegatingActionProxy</tt>.
        </p><p>
          If you define your <tt class="classname">Action</tt> in a context file, the
          full feature set of Spring's bean container will be available for it:
          dependency injection as well as the option to instantiate a new
          <tt class="classname">Action</tt> instance for each request. To activate the latter,
          add <span class="emphasis"><em>scope="prototype"</em></span> to your Action's bean definition.
        </p><pre class="programlisting">&lt;bean name="/user" scope="prototype" autowire="byName"
    class="org.example.web.UserAction"/&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="struts-actionsupport"></a>15.4.2.&nbsp;ActionSupport Classes</h3></div></div><div></div></div><p>
        As previously mentioned, you can retrieve the
        <tt class="classname">WebApplicationContext</tt> from the <span class="interface">ServletContext</span>
        using the <tt class="classname">WebApplicationContextUtils</tt> class. An
        easier way is to extend  Spring's <tt class="classname">Action</tt> classes for
        Struts. For example, instead of subclassing Struts'
        <tt class="classname">Action</tt> class, you can subclass Spring's
        <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/ActionSupport.html" target="_top">
        <tt class="classname">ActionSupport</tt></a> class.
      </p><p>
        The <tt class="classname">ActionSupport</tt> class provides additional
        convenience methods, like <span class="emphasis"><em>getWebApplicationContext()</em></span>.
        Below is an example of how you might use this in an Action:
      </p><pre class="programlisting">public class UserAction extends DispatchActionSupport {

    public ActionForward execute(ActionMapping mapping,
                                 ActionForm form,
                                 HttpServletRequest request,
                                 HttpServletResponse response) throws Exception {
        if (log.isDebugEnabled()) {
            log.debug("entering 'delete' method...");
        }
        WebApplicationContext ctx = getWebApplicationContext();
        UserManager mgr = (UserManager) ctx.getBean("userManager");
        // talk to manager for business logic
        return mapping.findForward("success");
    }
}</pre><p>
      Spring includes subclasses for all of the standard Struts Actions
      - the Spring versions merely have <span class="emphasis"><em>Support</em></span> appended to the name:
      </p><div class="itemizedlist"><ul type="disc" compact><li><p><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/ActionSupport.html" target="_top"><tt class="classname">ActionSupport</tt></a>,</p></li><li><p><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/DispatchActionSupport.html" target="_top"><tt class="literal">DispatchActionSupport</tt></a>,</p></li><li><p><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/LookupDispatchActionSupport.html" target="_top"><tt class="literal">LookupDispatchActionSupport</tt></a> and</p></li><li><p><a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/web/struts/MappingDispatchActionSupport.html" target="_top"><tt class="literal">MappingDispatchActionSupport</tt></a>.</p></li></ul></div><p>
    </p><p>
      The recommended strategy is to use the approach that best suits
      your project. Subclassing makes your code more readable, and you know
      exactly how your dependencies are resolved. However, using the
      <tt class="classname">ContextLoaderPlugin</tt> allow you to easily add new
      dependencies in your context XML file. Either way, Spring provides some
      nice options for integrating the two frameworks.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="webwork"></a>15.5.&nbsp;WebWork 2.x</h2></div></div><div></div></div><p>
      From the <a href="http://www.opensymphony.com/webwork/" target="_top">WebWork homepage</a>...
    </p>&#8220;<span class="quote">
      <span class="emphasis"><em>
        WebWork is a Java web-application development framework. It is built
        specifically with developer productivity and code simplicity in mind,
        providing robust support for building reusable UI templates, such as form
        controls, UI themes, internationalization, dynamic form parameter mapping
        to JavaBeans, robust client and server side validation, and much more.
      </em></span>
    </span>&#8221;<p>
      WebWork is (in the opinion of this author) a very clean, elegant web framework.
      Its architecture and key concepts are not only very easy to understand, it has
      a rich tag library, nicely decoupled validation, and it is (again, in the opinion
      of this author) quite easy to be productive in next to no time at all (the
      documentation and tutorials are pretty good too).
    </p><p>
      One of the key enablers in WebWork's technology stack is
      <a href="http://www.opensymphony.com/webwork/wikidocs/IoC%20Overview.html" target="_top">an IoC container</a>
      to manage Webwork Actions, handle the "wiring" of business objects, etc.
      Prior to WebWork version 2.2, WebWork used its own proprietary IoC container
      (and provided integration points so that one could integrate an IoC container
      such as Springs into the mix). However, as of WebWork version 2.2, the default
      IoC container that is used within WebWork <span class="emphasis"><em>is</em></span> Spring. This
      is obviously great news if one is a Spring developer, because it means that one
      is immediately familiar with the basics of IoC configuration, idioms and suchlike
      within WebWork.
    </p><p>
      Now in the interests of adhering to the DRY (Dont Repeat Yourself) principle, it
      would be foolish to writeup the Spring-WebWork integration in light of the fact that
      the WebWork team have already written such a writeup. Please do consult the
      <a href="http://www.opensymphony.com/webwork/wikidocs/Spring.html" target="_top">Spring-WebWork integration page</a>
      on the
      <a href="http://wiki.opensymphony.com/display/WW/WebWork" target="_top">WebWork wiki</a>
      for the full lowdown.
    </p><p>
      Note that the Spring-WebWork integration code was developed (and continues
      to be maintained and improved) by the WebWork developers themselves, so in the
      first instance please do refer to the WebWork site and forums if you are having
      issues with the integration. Do feel free to post comments and queries regarding
      the Spring-WebWork integration on the
      <a href="http://forum.springframework.org/forumdisplay.php?f=25" target="_top">Spring support forums</a>
      too.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="tapestry"></a>15.6.&nbsp;Tapestry 3.x and 4.x</h2></div></div><div></div></div><p>
      From the <a href="http://tapestry.apache.org/" target="_top">Tapestry homepage</a>...
    </p>&#8220;<span class="quote">
      <span class="emphasis"><em>
        Tapestry is an open-source framework for creating dynamic, robust, highly
        scalable web applications in Java. Tapestry complements and builds upon
        the standard Java Servlet API, and so it works in any servlet container or
        application server.
      </em></span>
    </span>&#8221;<p>
      While Spring has its own <a href="#mvc" title="Chapter&nbsp;13.&nbsp;Web MVC framework">powerful web layer</a>, there
      are a number of unique advantages to building a J2EE application using a
      combination of Tapestry for the web  user interface and the Spring container
      for the lower layers. This section of the web integration chapter attempts
      to detail a few best practices for combining these two frameworks.
    </p><p>
      A <span class="emphasis"><em>typical</em></span> layered J2EE application built with Tapestry
      and Spring will consist of a top user interface (UI) layer built with Tapestry,
      and a number of lower layers, all wired together by one or more Spring containers.
      Tapestry's own reference documentation contains the following snippet of best
      practice advice. (Text that the author of this Spring section has added is
      contained within <tt class="literal">[]</tt> brackets.)
    </p>&#8220;<span class="quote">
      <span class="emphasis"><em>
        A very succesful design pattern in Tapestry is to keep pages and components
        very simple, and <span class="bold"><b>delegate</b></span> as much logic as
        possible out to HiveMind [or Spring, or whatever] services. Listener methods
        should ideally do little more than marshall together the correct information
        and pass it over to a service.
      </em></span>
    </span>&#8221;<p>
      The key question then is... how does one supply Tapestry pages with collaborating
      services? The answer, ideally, is that one would want to dependency inject those
      services directly into one's Tapestry pages. In Tapestry, one can effect this
      dependency injection by a variety of means...
      This section is only going to enumerate the dependency injection means afforded
      by Spring. The real beauty of the rest of this Spring-Tapestry integration is that
      the elegant and flexible design of Tapestry itself makes doing this dependency
      injection of Spring-managed beans a cinch. (Another nice thing is that this
      Spring-Tapestry integration code was written - and continues to be maintained -
      by the Tapestry creator
      <a href="http://howardlewisship.com/blog/" target="_top">Howard M. Lewis Ship</a>,
      so hats off to him for what is really some silky smooth integration).
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="tapestry-di"></a>15.6.1.&nbsp;Injecting Spring-managed beans</h3></div></div><div></div></div><p>
        Assume we have the following simple Spring container definition (in the
        ubiquitous XML format):
      </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" 
        "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;
 
&lt;beans&gt;
    &lt;!-- the DataSource --&gt;
    &lt;bean id="dataSource" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
        &lt;property name="jndiName" value="java:DefaultDS"/&gt;
    &lt;/bean&gt;

    &lt;bean id="hibSessionFactory" 
          class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="transactionManager" 
          class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;

    &lt;bean id="mapper" 
          class="com.whatever.dataaccess.mapper.hibernate.MapperImpl"&gt;
        &lt;property name="sessionFactory" ref="hibSessionFactory"/&gt;
    &lt;/bean&gt;

    &lt;!-- (transactional) AuthenticationService --&gt;
    &lt;bean id="authenticationService" 
          class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager" ref="transactionManager"/&gt;
        &lt;property name="target"&gt;
            &lt;bean class="com.whatever.services.service.user.AuthenticationServiceImpl"&gt;
                &lt;property name="mapper" ref="mapper"/&gt;
            &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name="proxyInterfacesOnly" value="true"/&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;value&gt;
                *=PROPAGATION_REQUIRED
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;  
 
    &lt;!-- (transactional) UserService --&gt;
    &lt;bean id="userService" 
          class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"&gt;
        &lt;property name="transactionManager" ref="transactionManager"/&gt;
        &lt;property name="target"&gt;
             &lt;bean class="com.whatever.services.service.user.UserServiceImpl"&gt;
                 &lt;property name="mapper" ref="mapper"/&gt;
             &lt;/bean&gt;
        &lt;/property&gt;
        &lt;property name="proxyInterfacesOnly" value="true"/&gt;
        &lt;property name="transactionAttributes"&gt;
            &lt;value&gt;
                *=PROPAGATION_REQUIRED
            &lt;/value&gt;
        &lt;/property&gt;
    &lt;/bean&gt;  
 
 &lt;/beans&gt;</pre><p>
        Inside the Tapestry application, the above bean definitions need to
        be <a href="#web-integration-common" title="15.2.&nbsp;Common configuration">loaded into a Spring container</a>,
        and any relevant Tapestry pages need to be supplied (injected) with the
        <tt class="literal">authenticationService</tt> and
        <tt class="literal">userService</tt> beans, which implement the
        <tt class="interfacename">AuthenticationService</tt> and
        <tt class="interfacename">UserService</tt> interfaces, respectively.
      </p><p>
        At this point, the application context is available to a web
        application by calling Spring's static utility function
        <tt class="literal">WebApplicationContextUtils.getApplicationContext(servletContext)</tt>,
        where servletContext is the standard <span class="interface">ServletContext</span>
        from the J2EE Servlet specification. As such, one simple mechanism for
        a page to get an instance of the <tt class="interfacename">UserService</tt>,
        for example, would be with code such as:
      </p><pre class="programlisting">WebApplicationContext appContext = WebApplicationContextUtils.getApplicationContext(
    getRequestCycle().getRequestContext().getServlet().getServletContext());
UserService userService = (UserService) appContext.getBean("userService");
<i class="lineannotation"><span class="lineannotation">... some code which uses UserService</span></i></pre><p>
        This mechanism does work... having said that, it can be made a
        lot less verbose by encapsulating most of the functionality in a
        method in the base class for the page or component. However, in
        some respects it goes against the IoC principle; ideally you would like the page to
        not have to ask the context for a specific bean by name, and in
        fact, the page would ideally not know about the context at all.
      </p><p>
        Luckily, there is a mechanism to allow this. We rely upon the
        fact that Tapestry already has a mechanism to declaratively add
        properties to a page, and it is in fact the preferred approach to
        manage all properties on a page in this declarative fashion, so that
        Tapestry can properly manage their lifecycle as part of the page and
        component lifecycle.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
          This next section is applicable to Tapestry 3.x.
          If you are using Tapestry version 4.x, please consult the section
          entitled <a href="#tapestry-4-style-di" title="15.6.1.4.&nbsp;Dependency Injecting Spring Beans into Tapestry pages - Tapestry 4.x style">Section&nbsp;15.6.1.4, &#8220;Dependency Injecting Spring Beans into Tapestry pages - Tapestry 4.x style&#8221;</a>.
        </p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="tapestry-pre4-style-di"></a>15.6.1.1.&nbsp;Dependency Injecting Spring Beans into Tapestry pages</h4></div></div><div></div></div><p>
          First we need to make the <span class="interface">ApplicationContext</span>
          available to the Tapestry page or Component without having to have the
          <span class="interface">ServletContext</span>; this is because at the stage in the
          page's/component's lifecycle when we need to access the
          <span class="interface">ApplicationContext</span>, the
          <span class="interface">ServletContext</span> won't be easily available to the
          page, so we can't use
          <tt class="literal">WebApplicationContextUtils.getApplicationContext(servletContext)</tt>
          directly. One way is by defining a custom version of the Tapestry
          <tt class="interfacename">IEngine</tt> which exposes this for us:
        </p><pre class="programlisting">package com.whatever.web.xportal;

import ...

public class MyEngine extends org.apache.tapestry.engine.BaseEngine {
 
    public static final String APPLICATION_CONTEXT_KEY = "appContext";
 
    /**
     * @see org.apache.tapestry.engine.AbstractEngine#setupForRequest(org.apache.tapestry.request.RequestContext)
     */
    protected void setupForRequest(RequestContext context) {
        super.setupForRequest(context);
     
        // insert ApplicationContext in global, if not there
        Map global = (Map) getGlobal();
        ApplicationContext ac = (ApplicationContext) global.get(APPLICATION_CONTEXT_KEY);
        if (ac == null) {
            ac = WebApplicationContextUtils.getWebApplicationContext(
                context.getServlet().getServletContext()
            );
            global.put(APPLICATION_CONTEXT_KEY, ac);
        }
    }
}</pre><p>
          This engine class places the Spring Application Context as
          an attribute called "appContext" in this Tapestry app's 'Global'
          object. Make sure to register the fact that this special IEngine
          instance should be used for this Tapestry application, with an entry
          in the Tapestry application definition file. For example:
        </p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">file: xportal.application:</span></i>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE application PUBLIC 
    "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
    "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd"&gt;
&lt;application
    name="Whatever xPortal"
    engine-class="com.whatever.web.xportal.MyEngine"&gt;
&lt;/application&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="tapestry-componentdefs"></a>15.6.1.2.&nbsp;Component definition files</h4></div></div><div></div></div><p>
          Now in our page or component definition file (*.page or *.jwc),
          we simply add property-specification elements to grab the beans we
          need out of the <tt class="interfacename">ApplicationContext</tt>,
          and create page or component properties for them. For example:
        </p><pre class="programlisting">    &lt;property-specification name="userService"
                            type="com.whatever.services.service.user.UserService"&gt;
        global.appContext.getBean("userService")
    &lt;/property-specification&gt;
    &lt;property-specification name="authenticationService"
                            type="com.whatever.services.service.user.AuthenticationService"&gt;
        global.appContext.getBean("authenticationService")
    &lt;/property-specification&gt;</pre><p>
          The OGNL expression  inside the property-specification specifies the
          initial value for the property, as a bean obtained from the context.
          The entire page definition might look like this:
        </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE page-specification PUBLIC 
    "-//Apache Software Foundation//Tapestry Specification 3.0//EN" 
    "http://jakarta.apache.org/tapestry/dtd/Tapestry_3_0.dtd"&gt;
     
&lt;page-specification class="com.whatever.web.xportal.pages.Login"&gt;
 
    &lt;property-specification name="username" type="java.lang.String"/&gt;
    &lt;property-specification name="password" type="java.lang.String"/&gt;
    &lt;property-specification name="error" type="java.lang.String"/&gt;
    &lt;property-specification name="callback" type="org.apache.tapestry.callback.ICallback" persistent="yes"/&gt;
    &lt;property-specification name="userService"
                            type="com.whatever.services.service.user.UserService"&gt;
        global.appContext.getBean("userService")
    &lt;/property-specification&gt;
    &lt;property-specification name="authenticationService"
                            type="com.whatever.services.service.user.AuthenticationService"&gt;
        global.appContext.getBean("authenticationService")
    &lt;/property-specification&gt;
   
    &lt;bean name="delegate" class="com.whatever.web.xportal.PortalValidationDelegate"/&gt;
 
    &lt;bean name="validator" class="org.apache.tapestry.valid.StringValidator" lifecycle="page"&gt;
        &lt;set-property name="required" expression="true"/&gt;
        &lt;set-property name="clientScriptingEnabled" expression="true"/&gt;
    &lt;/bean&gt;
 
    &lt;component id="inputUsername" type="ValidField"&gt;
        &lt;static-binding name="displayName" value="Username"/&gt;
        &lt;binding name="value" expression="username"/&gt;
        &lt;binding name="validator" expression="beans.validator"/&gt;
    &lt;/component&gt;
   
    &lt;component id="inputPassword" type="ValidField"&gt;
        &lt;binding name="value" expression="password"/&gt;
       &lt;binding name="validator" expression="beans.validator"/&gt;
       &lt;static-binding name="displayName" value="Password"/&gt;
       &lt;binding name="hidden" expression="true"/&gt;
    &lt;/component&gt;
 
&lt;/page-specification&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="tapestry-getters"></a>15.6.1.3.&nbsp;Adding abstract accessors</h4></div></div><div></div></div><p>
          Now in the Java class definition for the page or component
          itself, all we need to do is add an abstract getter method
          for the properties we have defined (in order to be able to
          access the properties).
        </p><pre class="programlisting">// our UserService implementation; will come from page definition
public abstract UserService getUserService();
// our AuthenticationService implementation; will come from page definition
public abstract AuthenticationService getAuthenticationService();</pre><p>
          For the sake of completeness, the entire Java class, for a
          login page in this example, might look like this:
        </p><pre class="programlisting">package com.whatever.web.xportal.pages;
 
/**
 *  Allows the user to login, by providing username and password.
 *  After successfully logging in, a cookie is placed on the client browser
 *  that provides the default username for future logins (the cookie
 *  persists for a week).
 */
public abstract class Login extends BasePage implements ErrorProperty, PageRenderListener {
 
    /** the key under which the authenticated user object is stored in the visit as */
    public static final String USER_KEY = "user";
   
    /** The name of the cookie that identifies a user **/
    private static final String COOKIE_NAME = Login.class.getName() + ".username";  
    private final static int ONE_WEEK = 7 * 24 * 60 * 60;
 
    public abstract String getUsername();
    public abstract void setUsername(String username);
 
    public abstract String getPassword();
    public abstract void setPassword(String password);
 
    public abstract ICallback getCallback();
    public abstract void setCallback(ICallback value);
    
    public abstract UserService getUserService();
    public abstract AuthenticationService getAuthenticationService();
 
    protected IValidationDelegate getValidationDelegate() {
        return (IValidationDelegate) getBeans().getBean("delegate");
    }
 
    protected void setErrorField(String componentId, String message) {
        IFormComponent field = (IFormComponent) getComponent(componentId);
        IValidationDelegate delegate = getValidationDelegate();
        delegate.setFormComponent(field);
        delegate.record(new ValidatorException(message));
    }
 
    /**
     *  Attempts to login. 
     * &lt;p&gt;
     *  If the user name is not known, or the password is invalid, then an error
     *  message is displayed.
     **/
    public void attemptLogin(IRequestCycle cycle) {
     
        String password = getPassword();
 
        // Do a little extra work to clear out the password.
        setPassword(null);
        IValidationDelegate delegate = getValidationDelegate();
 
        delegate.setFormComponent((IFormComponent) getComponent("inputPassword"));
        delegate.recordFieldInputValue(null);
 
        // An error, from a validation field, may already have occurred.
        if (delegate.getHasErrors()) {
            return;
        }

        try {
            User user = getAuthenticationService().login(getUsername(), getPassword());
           loginUser(user, cycle);
        }
        catch (FailedLoginException ex) {
            this.setError("Login failed: " + ex.getMessage());
            return;
        }
    }
 
    /**
     *  Sets up the {@link User} as the logged in user, creates
     *  a cookie for their username (for subsequent logins),
     *  and redirects to the appropriate page, or
     *  a specified page).
     **/
    public void loginUser(User user, IRequestCycle cycle) {
     
        String username = user.getUsername();
 
        // Get the visit object; this will likely force the
        // creation of the visit object and an HttpSession
        Map visit = (Map) getVisit();
        visit.put(USER_KEY, user);
 
        // After logging in, go to the MyLibrary page, unless otherwise specified
        ICallback callback = getCallback();
 
        if (callback == null) {
            cycle.activate("Home");
        }
        else {
            callback.performCallback(cycle);
        }

        IEngine engine = getEngine();
        Cookie cookie = new Cookie(COOKIE_NAME, username);
        cookie.setPath(engine.getServletPath());
        cookie.setMaxAge(ONE_WEEK);
 
        // Record the user's username in a cookie
        cycle.getRequestContext().addCookie(cookie);
        engine.forgetPage(getPageName());
    }
   
    public void pageBeginRender(PageEvent event) {
        if (getUsername() == null) {
            setUsername(getRequestCycle().getRequestContext().getCookieValue(COOKIE_NAME));
        }
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="tapestry-4-style-di"></a>15.6.1.4.&nbsp;Dependency Injecting Spring Beans into Tapestry pages - Tapestry 4.x style</h4></div></div><div></div></div><p>
          Effecting the dependency injection of Spring-managed beans into Tapestry
          pages in Tapestry version 4.x is <span class="emphasis"><em>so</em></span> much simpler.
          All that is needed is a single
          <a href="http://howardlewisship.com/tapestry-javaforge/tapestry-spring/" target="_top">add-on library</a>,
          and some (small) amount of (essentially boilerplate) configuration.
          Simply package and deploy this library with the (any of the) other
          libraries required by your web application (typically in
          <tt class="literal">WEB-INF/lib</tt>).
        </p><p>
          You will then need to create and expose the Spring container using the
          <a href="#web-integration-common" title="15.2.&nbsp;Common configuration">method detailed previously</a>.
          You can then inject Spring-managed beans into Tapestry very easily; if
          we are using Java 5, consider the <tt class="classname">Login</tt> page from above:
          we simply need to annotate the appropriate getter methods
          in order to dependency inject the Spring-managed <tt class="literal">userService</tt>
          and <tt class="literal">authenticationService</tt> objects (lots of the class
          definition has been elided for clarity)...
        </p><pre class="programlisting">package com.whatever.web.xportal.pages;

public abstract class Login extends BasePage implements ErrorProperty, PageRenderListener {
    
    @InjectObject("spring:userService")
    public abstract UserService getUserService();
    
    @InjectObject("spring:authenticationService")
    public abstract AuthenticationService getAuthenticationService();

}</pre><p>
        We are almost done... all that remains is the HiveMind configuration that exposes the
        Spring container stored in the <tt class="interfacename">ServletContext</tt> as a
        HiveMind service; for example:</p><pre class="programlisting">&lt;?xml version="1.0"?&gt;
&lt;module id="com.javaforge.tapestry.spring" version="0.1.1"&gt;

    &lt;service-point id="SpringApplicationInitializer"
        interface="org.apache.tapestry.services.ApplicationInitializer"
        visibility="private"&gt;
        &lt;invoke-factory&gt;
            &lt;construct class="com.javaforge.tapestry.spring.SpringApplicationInitializer"&gt;
                &lt;set-object property="beanFactoryHolder"
                    value="service:hivemind.lib.DefaultSpringBeanFactoryHolder" /&gt;
            &lt;/construct&gt;
        &lt;/invoke-factory&gt;
    &lt;/service-point&gt;

    &lt;!-- Hook the Spring setup into the overall application initialization. --&gt;
    &lt;contribution
        configuration-id="tapestry.init.ApplicationInitializers"&gt;
        &lt;command id="spring-context"
            object="service:SpringApplicationInitializer" /&gt;
    &lt;/contribution&gt;

&lt;/module&gt;</pre><p>
          If you are using Java 5 (and thus have access to annotations), then
          that really is it.
        </p><p>
          If you are not using Java 5, then one obviously doesn't annotate one's
          Tapestry page classes with annotations; instead, one simply uses
          good old fashioned XML to declare the dependency injection; for example,
          inside the <tt class="literal">.page</tt> or <tt class="literal">.jwc</tt> file
          for the <tt class="classname">Login</tt> page (or component):
        </p><pre class="programlisting">&lt;inject property="userService" object="spring:userService"/&gt;
&lt;inject property="authenticationService" object="spring:authenticationService"/&gt;</pre></div></div><p>
      In this example, we've managed to allow service beans defined in
      a Spring container to be provided to the Tapestry page in a declarative
      fashion. The page class does not know where the service implementations
      are coming from, and in fact it is easy to slip in another implementation,
      for example, during testing. This inversion  of control is one of the
      prime goals and benefits of the Spring Framework, and we have managed
      to extend it all the way up the J2EE stack in this Tapestry application.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="web-integration-resources"></a>15.7.&nbsp;Further Resources</h2></div></div><div></div></div><p>
      Find below links to further resources about the various web frameworks
      described in this chapter.
    </p><div class="itemizedlist"><ul type="disc"><li><p>The <a href="http://java.sun.com/javaee/javaserverfaces/" target="_top">JSF</a> homepage</p></li><li><p>The <a href="http://struts.apache.org/" target="_top">Struts</a> homepage</p></li><li><p>The <a href="http://www.opensymphony.com/webwork/" target="_top">WebWork</a> homepage</p></li><li><p>The <a href="http://tapestry.apache.org/" target="_top">Tapestry</a> homepage</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="portlet"></a>Chapter&nbsp;16.&nbsp;Portlet MVC Framework</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-introduction"></a>16.1.&nbsp;Introduction</h2></div></div><div></div></div><div class="sidebar"><p class="title"><b>JSR-168 The Java Portlet Specification</b></p><p>For more general information about portlet development, please
      review a whitepaper from Sun entitled
      <a href="http://developers.sun.com/prodtech/portalserver/reference/techart/jsr168/" target="_top">"Introduction to JSR 168"</a>,
      and of course the
      <a href="http://jcp.org/aboutJava/communityprocess/final/jsr168/" target="_top">JSR-168 Specification</a> itself.</p></div><p>In addition to supporting conventional (servlet-based) Web development,
    Spring also supports JSR-168 Portlet development. As much as possible, the
    Portlet MVC framework is a mirror image of the Web MVC framework, and also
    uses the same underlying view abstractions and integration technology. So, be
    sure to review the chapters entitled <a href="#mvc" title="Chapter&nbsp;13.&nbsp;Web MVC framework">Chapter&nbsp;13, <i>Web MVC framework</i></a> and
    <a href="#view" title="Chapter&nbsp;14.&nbsp;View technologies">Chapter&nbsp;14, <i>View technologies</i></a> before continuing with this chapter.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Bear in mind that while the concepts of Spring MVC are the
      same in Spring Portlet MVC, there are some notable differences
      created by the unique workflow of JSR-168 portlets.</p></td></tr></table></div><p>The main way in which portlet workflow differs from servlet
    workflow is that the request to the portlet can have two distinct
    phases: the action phase and the render phase. The action phase is
    executed only once and is where any 'backend' changes or actions occur,
    such as making changes in a database. The render phase then produces
    what is displayed to the user each time the display is refreshed.
    The critical point here is that for a single overall request, the action
    phase is executed only once, but the render phase may be executed
    multiple times. This provides (and requires) a clean separation between
    the activities that modify the persistent state of your system and the
    activities that generate what is displayed to the user.</p><div class="sidebar"><p class="title"><b>Spring Web Flow</b></p><p>Spring Web Flow (SWF) aims to be the best solution for the management
  of web application page flow.</p><p>SWF integrates with existing frameworks like Spring MVC, Struts, and
  JSF, in both servlet and portlet environments. If you have a business
  process (or processes) that would benefit from a conversational model as
  opposed to a purely request model, then SWF may be the solution.</p><p>SWF allows you to capture logical page flows as self-contained modules
  that are reusable in different situations, and as such is ideal for building
  web application modules that guide the user through controlled navigations
  that drive business processes.</p><p>For more information about SWF, consult the
  <a href="http://www.springframework.org/webflow" target="_top">Spring Web Flow website</a>.
  </p></div><p>The dual phases of portlet requests are one of the real strengths
    of the JSR-168 specification. For example, dynamic search results can be
    updated routinely on the display without the user explicitly rerunning
    the search. Most other portlet MVC frameworks attempt to completely
    hide the two phases from the developer and make it look as much like
    traditional servlet development as possible - we think this
    approach removes one of the main benefits of using portlets. So, the
    separation of the two phases is preserved throughout the Spring Portlet
    MVC framework. The primary manifestation of this approach is that where
    the servlet version of the MVC classes will have one method that deals
    with the request, the portlet version of the MVC classes will have two
    methods that deal with the request: one for the action phase and one for
    the render phase. For example, where the servlet version of
    <tt class="classname">AbstractController</tt> has the
    <tt class="methodname">handleRequestInternal(..)</tt> method, the portlet
    version of <tt class="classname">AbstractController</tt> has
    <tt class="methodname">handleActionRequestInternal(..)</tt> and
    <tt class="methodname">handleRenderRequestInternal(..)</tt> methods.</p><p>The framework is designed around a
    <tt class="classname">DispatcherPortlet</tt> that dispatches requests to
    handlers, with configurable handler mappings and view resolution, just
    as the <tt class="classname">DispatcherServlet</tt> in the web framework
    does. File upload is also supported in the same way.</p><p>Locale resolution and theme resolution are not supported in
    Portlet MVC - these areas are in the purview of the
    portal/portlet container and are not appropriate at the Spring level.
    However, all mechanisms in Spring that depend on the locale (such as
    internationalization of messages) will still function properly because
    <tt class="classname">DispatcherPortlet</tt> exposes the current locale in
    the same way as <tt class="classname">DispatcherServlet</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-introduction-controller"></a>16.1.1.&nbsp;Controllers - The C in MVC</h3></div></div><div></div></div><p>The default handler is still a very simple
      <tt class="interfacename">Controller</tt> interface, offering just two
      methods:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="methodname">void handleActionRequest(request,response)</tt> </p></li><li><p><tt class="methodname">ModelAndView handleRenderRequest(request,response)</tt> </p></li></ul></div><p>The framework also includes most of the same controller
      implementation hierarchy, such as <tt class="classname">AbstractController</tt>,
      <tt class="classname">SimpleFormController</tt>, and so on. Data binding,
      command object usage, model handling, and view resolution are all the
      same as in the servlet framework.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-introduction-view"></a>16.1.2.&nbsp;Views - The V in MVC</h3></div></div><div></div></div><p>All the view rendering capabilities of the servlet framework are
      used directly via a special bridge servlet named
      <tt class="classname">ViewRendererServlet</tt>. By using this servlet, the
      portlet request is converted into a servlet request and the view can be
      rendered using the entire normal servlet infrastructure. This means all
      the existing renderers, such as JSP, Velocity, etc., can still be used
      within the portlet.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-introduction-scope"></a>16.1.3.&nbsp;Web-scoped beans</h3></div></div><div></div></div><p>Spring Portlet MVC supports beans whose lifecycle is scoped to the
      current HTTP request or HTTP <tt class="interfacename">Session</tt> (both
      normal and global). This is not a specific feature of Spring Portlet MVC
      itself, but rather of the <tt class="interfacename">WebApplicationContext</tt>
      container(s) that Spring Portlet MVC uses. These bean scopes are described
      in detail in the section entitled <a href="#beans-factory-scopes-other" title="3.4.4.&nbsp;The other scopes">Section&nbsp;3.4.4, &#8220;The other scopes&#8221;</a></p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The Spring distribution ships with a complete Spring Portlet MVC
      sample application that demonstrates all of the features and functionality
      of the Spring Portlet MVC framework. This 'petportal' application can be found
      in the <tt class="filename">'samples/petportal'</tt> directory of
      the full Spring distribution.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-dispatcher"></a>16.2.&nbsp;The <tt class="classname">DispatcherPortlet</tt></h2></div></div><div></div></div><p>Portlet MVC is a request-driven web MVC framework, designed around
    a portlet that dispatches requests to controllers and offers other
    functionality facilitating the development of portlet applications.
    Spring's <tt class="classname">DispatcherPortlet</tt> however, does more
    than just that. It is completely integrated with the Spring
    <tt class="interfacename">ApplicationContext</tt> and allows you to use
    every other feature Spring has.</p><p>Like ordinary portlets, the
    <tt class="classname">DispatcherPortlet</tt> is declared in the
    <tt class="literal">portlet.xml</tt> of your web application:</p><pre class="programlisting">&lt;portlet&gt;
    &lt;portlet-name&gt;sample&lt;/portlet-name&gt;
    &lt;portlet-class&gt;org.springframework.web.portlet.DispatcherPortlet&lt;/portlet-class&gt;
    &lt;supports&gt;
        &lt;mime-type&gt;text/html&lt;/mime-type&gt;
        &lt;portlet-mode&gt;view&lt;/portlet-mode&gt;
    &lt;/supports&gt;
    &lt;portlet-info&gt;
        &lt;title&gt;Sample Portlet&lt;/title&gt;
    &lt;/portlet-info&gt;
&lt;/portlet&gt;</pre><p>The <tt class="classname">DispatcherPortlet</tt> now needs to be
    configured.</p><p>In the Portlet MVC framework, each
    <tt class="classname">DispatcherPortlet</tt> has its own
    <tt class="interfacename">WebApplicationContext</tt>, which inherits all
    the beans already defined in the Root
    <tt class="interfacename">WebApplicationContext</tt>. These inherited
    beans can be overridden in the portlet-specific scope, and new scope-
    specific beans can be defined local to a given portlet instance.</p><p>The framework will, on initialization of a
    <tt class="classname">DispatcherPortlet</tt>, look for a file named
    <tt class="literal">[portlet-name]-portlet.xml</tt> in the <tt class="literal">WEB-INF</tt>
    directory of your web application and create the beans defined there
    (overriding the definitions of any beans defined with the same name in
    the global scope).</p><p>The config location used by the
    <tt class="classname">DispatcherPortlet</tt> can be modified through a
    portlet initialization parameter (see below for details).</p><p>The Spring <tt class="classname">DispatcherPortlet</tt> has a few
    special beans it uses, in order to be able to process requests and
    render the appropriate views. These beans are included in the Spring
    framework and can be configured in the
    <tt class="interfacename">WebApplicationContext</tt>, just as any other
    bean would be configured. Each of those beans is described in more
    detail below. Right now, we'll just mention them, just to let you know
    they exist and to enable us to go on talking about the
    <tt class="classname">DispatcherPortlet</tt>. For most of the beans,
    defaults are provided so you don't have to worry about configuring
    them.</p><div class="table"><a name="portlet-webappctx-special-beans-tbl"></a><p class="title"><b>Table&nbsp;16.1.&nbsp;Special beans in the <tt class="interfacename">WebApplicationContext</tt></b></p><table summary="Special beans in the WebApplicationContext" border="1"><colgroup><col align="left"><col></colgroup><thead><tr><th align="left">Expression</th><th>Explanation</th></tr></thead><tbody><tr><td align="left">handler mapping(s)</td><td>(<a href="#portlet-handlermapping" title="16.5.&nbsp;Handler mappings">Section&nbsp;16.5, &#8220;Handler mappings&#8221;</a>) a
            list of pre- and post-processors and controllers that
            will be executed if they match certain criteria (for
            instance a matching portlet mode specified with the
            controller)</td></tr><tr><td align="left">controller(s)</td><td>(<a href="#portlet-controller" title="16.4.&nbsp;Controllers">Section&nbsp;16.4, &#8220;Controllers&#8221;</a>) the beans
            providing the actual functionality (or at least, access
            to the functionality) as part of the MVC triad</td></tr><tr><td align="left">view resolver</td><td>(<a href="#portlet-viewresolver" title="16.6.&nbsp;Views and resolving them">Section&nbsp;16.6, &#8220;Views and resolving them&#8221;</a>) capable
            of resolving view names to view definitions</td></tr><tr><td align="left">multipart resolver</td><td>(<a href="#portlet-multipart" title="16.7.&nbsp;Multipart (file upload) support">Section&nbsp;16.7, &#8220;Multipart (file upload) support&#8221;</a>) offers
            functionality to process file uploads from HTML
            forms</td></tr><tr><td align="left">handler exception resolver</td><td>(<a href="#portlet-exceptionresolver" title="16.8.&nbsp;Handling exceptions">Section&nbsp;16.8, &#8220;Handling exceptions&#8221;</a>)
            offers functionality to map exceptions to views or
            implement other more complex exception handling
            code</td></tr></tbody></table></div><p>When a <tt class="classname">DispatcherPortlet</tt> is setup for use
    and a request comes in for that specific
    <tt class="classname">DispatcherPortlet</tt>, it starts processing the
    request. The list below describes the complete process a request goes
    through if handled by a <tt class="classname">DispatcherPortlet</tt>:</p><div class="orderedlist"><ol type="1"><li><p>The locale returned by
      <tt class="literal">PortletRequest.getLocale()</tt> is bound to the
      request to let elements in the process resolve the locale to use
      when processing the request (rendering the view, preparing data,
      etc.).</p></li><li><p>If a multipart resolver is specified and this is an
      <tt class="interfacename">ActionRequest</tt>, the request is
      inspected for multiparts and if they are found, it is wrapped in a
      <tt class="interfacename">MultipartActionRequest</tt> for further
      processing by other elements in the process. (See <a href="#portlet-multipart" title="16.7.&nbsp;Multipart (file upload) support">Section&nbsp;16.7, &#8220;Multipart (file upload) support&#8221;</a> for further information about
      multipart handling).</p></li><li><p>An appropriate handler is searched for. If a handler
      is found, the execution chain associated with the handler (pre-
      processors, post-processors, controllers) will be executed in order
      to prepare a model.</p></li><li><p>If a model is returned, the view is rendered, using
      the view resolver that has been configured with the
      <tt class="interfacename">WebApplicationContext</tt>. If no model is
      returned (which could be due to a pre- or post-processor
      intercepting the request, for example, for security reasons), no
      view is rendered, since the request could already have been
      fulfilled.</p></li></ol></div><p>Exceptions that might be thrown during processing of the request
    get picked up by any of the handler exception resolvers that are
    declared in the <tt class="interfacename">WebApplicationContext</tt>.
    Using these exception resolvers you can define custom behavior in case
    such exceptions get thrown.</p><p>You can customize Spring's <tt class="classname">DispatcherPortlet</tt>
    by adding context parameters in the <tt class="literal">portlet.xml</tt> file or
    portlet init-parameters. The possibilities are listed below.</p><div class="table"><a name="portlet-dpp-init-params"></a><p class="title"><b>Table&nbsp;16.2.&nbsp;<tt class="classname">DispatcherPortlet</tt> initialization parameters</b></p><table summary="DispatcherPortlet initialization parameters" border="1"><colgroup><col align="left"><col></colgroup><thead><tr><th align="left">Parameter</th><th>Explanation</th></tr></thead><tbody><tr><td align="left"><tt class="literal">contextClass</tt></td><td>Class that implements
            <tt class="interfacename">WebApplicationContext</tt>,
            which will be used to instantiate the context used by
            this portlet. If this parameter isn't specified, the
            <tt class="classname">XmlPortletApplicationContext</tt> will
            be used.</td></tr><tr><td align="left"><tt class="literal">contextConfigLocation</tt></td><td>String which is passed to the context instance
            (specified by <tt class="literal">contextClass</tt>) to
            indicate where context(s) can be found. The String is
            potentially split up into multiple Strings (using a
            comma as a delimiter) to support multiple contexts (in
            case of multiple context locations, of beans that are
            defined twice, the latest takes precedence).</td></tr><tr><td align="left"><tt class="literal">namespace</tt></td><td>The namespace of the
            <tt class="interfacename">WebApplicationContext</tt>.
            Defaults to <tt class="literal">[portlet-name]-
            portlet</tt>.</td></tr><tr><td align="left"><tt class="literal">viewRendererUrl</tt></td><td>The URL at which
            <tt class="classname">DispatcherPortlet</tt> can access an
            instance of <tt class="classname">ViewRendererServlet</tt>
            (see <a href="#portlet-viewservlet" title="16.3.&nbsp;The ViewRendererServlet">Section&nbsp;16.3, &#8220;The ViewRendererServlet&#8221;</a>).</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-viewservlet"></a>16.3.&nbsp;The <tt class="classname">ViewRendererServlet</tt></h2></div></div><div></div></div><p>The rendering process in Portlet MVC is a bit more complex than in
    Web MVC. In order to reuse all the <a href="#view" title="Chapter&nbsp;14.&nbsp;View technologies">view technologies</a>
    from Spring Web MVC), we must convert the
    <tt class="interfacename">PortletRequest</tt> /
    <tt class="interfacename">PortletResponse</tt> to
    <tt class="interfacename">HttpServletRequest</tt> /
    <tt class="interfacename">HttpServletResponse</tt> and then call the
    <tt class="literal">render</tt> method of the
    <tt class="interfacename">View</tt>. To do this,
    <tt class="classname">DispatcherPortlet</tt> uses a special servlet that
    exists for just this purpose: the
    <tt class="classname">ViewRendererServlet</tt>.</p><p>In order for <tt class="classname">DispatcherPortlet</tt> rendering to
    work, you must declare an instance of the
    <tt class="classname">ViewRendererServlet</tt> in the
    <tt class="literal">web.xml</tt> file for your web application as
    follows:</p><pre class="programlisting">&lt;servlet&gt;
    &lt;servlet-name&gt;ViewRendererServlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.ViewRendererServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;ViewRendererServlet&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/WEB-INF/servlet/view&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre><p>To perform the actual rendering, <tt class="classname">DispatcherPortlet</tt>
    does the following:</p><div class="orderedlist"><ol type="1"><li><p>Binds the
      <tt class="interfacename">WebApplicationContext</tt> to the request
      as an attribute under the same
      <tt class="literal">WEB_APPLICATION_CONTEXT_ATTRIBUTE</tt> key that
      <tt class="classname">DispatcherServlet</tt> uses.</p></li><li><p>Binds the <tt class="interfacename">Model</tt> and
      <tt class="interfacename">View</tt> objects to the request to make
      them available to the
      <tt class="classname">ViewRendererServlet</tt>.</p></li><li><p>Constructs a
      <tt class="interfacename">PortletRequestDispatcher</tt> and performs
      an <tt class="literal">include</tt> using the <tt class="literal">/WEB-
      INF/servlet/view</tt> URL that is mapped to the
      <tt class="classname">ViewRendererServlet</tt>.</p></li></ol></div><p>The <tt class="classname">ViewRendererServlet</tt> is then able to
    call the <tt class="literal">render</tt> method on the
    <tt class="interfacename">View</tt> with the appropriate
    arguments.</p><p>The actual URL for the <tt class="classname">ViewRendererServlet</tt>
    can be changed using <tt class="classname">DispatcherPortlet</tt>&#8217;s
    <tt class="literal">viewRendererUrl</tt> configuration parameter.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-controller"></a>16.4.&nbsp;Controllers</h2></div></div><div></div></div><p>The controllers in Portlet MVC are very similar to the Web MVC
    Controllers and porting code from one to the other should be
    simple.</p><p>The basis for the Portlet MVC controller architecture is the
    <tt class="interfacename">org.springframework.web.portlet.mvc.Controller</tt>
    interface, which is listed below.</p><pre class="programlisting">public interface Controller {

    /**
     * Process the render request and return a ModelAndView object which the
     * DispatcherPortlet will render.
     */
    ModelAndView handleRenderRequest(RenderRequest request, RenderResponse response)
        throws Exception;

    /**
     * Process the action request. There is nothing to return.
     */
    void handleActionRequest(ActionRequest request, ActionResponse response)
        throws Exception;
}</pre><p>As you can see, the Portlet
    <tt class="interfacename">Controller</tt> interface requires two methods
    that handle the two phases of a portlet request: the action request and
    the render request. The action phase should be capable of handling an
    action request and the render phase should be capable of handling a
    render request and returning an appropriate model and view. While the
    <tt class="interfacename">Controller</tt> interface is quite abstract,
    Spring Portlet MVC offers a lot of controllers that already contain a
    lot of the functionality you might need &#8211; most of these are very similar
    to controllers from Spring Web MVC. The
    <tt class="interfacename">Controller</tt> interface just defines the
    most common functionality required of every controller - handling an
    action request, handling a render request, and returning a model and a
    view.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-controller-abstractcontroller"></a>16.4.1.&nbsp;<tt class="classname">AbstractController</tt> and <tt class="classname">PortletContentGenerator</tt></h3></div></div><div></div></div><p>Of course, just a <tt class="interfacename">Controller</tt>
      interface isn't enough. To provide a basic infrastructure, all of
      Spring Portlet MVC's <tt class="interfacename">Controller</tt>s
      inherit from <tt class="classname">AbstractController</tt>, a class
      offering access to Spring's
      <tt class="interfacename">ApplicationContext</tt> and control over
      caching.</p><div class="table"><a name="portlet-ac-features"></a><p class="title"><b>Table&nbsp;16.3.&nbsp;Features offered by the <tt class="classname">AbstractController</tt></b></p><table summary="Features offered by the AbstractController" border="1"><colgroup><col align="left"><col></colgroup><thead><tr><th align="left">Parameter</th><th>Explanation</th></tr></thead><tbody><tr><td align="left"><tt class="literal">requireSession</tt></td><td>Indicates whether or not this
              <tt class="interfacename">Controller</tt> requires a
              session to do its work. This feature is offered to
              all controllers. If a session is not present when
              such a controller receives a request, the user is
              informed using a
              <tt class="classname">SessionRequiredException</tt>.</td></tr><tr><td align="left"><tt class="literal">synchronizeSession</tt></td><td>Use this if you want handling by this
              controller to be synchronized on the user's session.
              To be more specific, the extending controller will
              override the <tt class="methodname">handleRenderRequestInternal(..)</tt> and
              <tt class="methodname">handleActionRequestInternal(..)</tt> methods, which will be
              synchronized on the user&#8217;s session if you specify
              this variable.</td></tr><tr><td align="left"><tt class="literal">renderWhenMinimized</tt></td><td>If you want your controller to actually
              render the view when the portlet is in a minimized
              state, set this to true. By default, this is set to
              false so that portlets that are in a minimized state
              don&#8217;t display any content.</td></tr><tr><td align="left"><tt class="literal">cacheSeconds</tt></td><td>When you want a controller to override the
              default cache expiration defined for the portlet,
              specify a positive integer here. By default it is
              set to <tt class="literal">-1</tt>, which does not change
              the default caching. Setting it to <tt class="literal">0</tt>
              will ensure the result is never cached.</td></tr></tbody></table></div><p>The <tt class="literal">requireSession</tt> and
      <tt class="literal">cacheSeconds</tt> properties are declared on the
      <tt class="classname">PortletContentGenerator</tt> class, which is the
      superclass of <tt class="classname">AbstractController</tt>) but are
      included here for completeness.</p><p>When using the <tt class="classname">AbstractController</tt> as a
      baseclass for your controllers (which is not recommended since there
      are a lot of other controllers that might already do the job for
      you) you only have to override either the
      <tt class="methodname">handleActionRequestInternal(ActionRequest,
      ActionResponse)</tt> method or the
      <tt class="methodname">handleRenderRequestInternal(RenderRequest,
      RenderResponse)</tt> method (or both), implement your logic,
      and return a <tt class="classname">ModelAndView</tt> object (in the case
      of <tt class="literal">handleRenderRequestInternal</tt>).</p><p>The default implementations of both
      <tt class="methodname">handleActionRequestInternal(..)</tt> and
      <tt class="methodname">handleRenderRequestInternal(..)</tt> throw a
      <tt class="classname">PortletException</tt>. This is consistent with
      the behavior of <tt class="classname">GenericPortlet</tt> from the JSR-
      168 Specification API. So you only need to override the method that
      your controller is intended to handle.</p><p>Here is short example consisting of a class and a declaration
      in the web application context.</p><pre class="programlisting">package samples;

import javax.portlet.RenderRequest;
import javax.portlet.RenderResponse;

import org.springframework.web.portlet.mvc.AbstractController;
import org.springframework.web.portlet.ModelAndView;

public class SampleController extends AbstractController {

    public ModelAndView handleRenderRequestInternal(RenderRequest request, RenderResponse response) {
        ModelAndView mav = new ModelAndView("foo");
        mav.addObject("message", "Hello World!");
        return mav;
    }
}

&lt;bean id="sampleController" class="samples.SampleController"&gt;
    &lt;property name="cacheSeconds" value="120"/&gt;
&lt;/bean&gt;</pre><p>The class above and the declaration in the web application
      context is all you need besides setting up a handler mapping (see
      <a href="#portlet-handlermapping" title="16.5.&nbsp;Handler mappings">Section&nbsp;16.5, &#8220;Handler mappings&#8221;</a>) to get this very simple
      controller working.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-controller-simple"></a>16.4.2.&nbsp;Other simple controllers</h3></div></div><div></div></div><p>Although you can extend <tt class="classname">AbstractController</tt>,
      Spring Portlet MVC provides a number of concrete implementations which offer
      functionality that is commonly used in simple MVC applications.</p><p>The <tt class="classname">ParameterizableViewController</tt> is
      basically the same as the example above, except for the fact that
      you can specify the view name that it will return in the web
      application context (no need to hard-code the view name).</p><p>The <tt class="classname">PortletModeNameViewController</tt> uses
      the current mode of the portlet as the view name. So, if your
      portlet is in View mode (i.e. <tt class="literal">PortletMode.VIEW</tt>)
      then it uses "view" as the view name.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-controller-command"></a>16.4.3.&nbsp;Command Controllers</h3></div></div><div></div></div><p>Spring Portlet MVC has the exact same hierarchy of
      <span class="emphasis"><em>command controllers</em></span> as Spring Web MVC. They
      provide a way to interact with data objects and dynamically bind
      parameters from the <tt class="interfacename">PortletRequest</tt> to
      the data object specified. Your data objects don't have to
      implement a framework-specific interface, so you can directly
      manipulate your persistent objects if you desire. Let's examine what
      command controllers are available, to get an overview of what you can do
      with them:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="classname">AbstractCommandController</tt>
        - a command controller you can use to create your own command
        controller, capable of binding request parameters to a data
        object you specify. This class does not offer form
        functionality, it does however offer validation features and
        lets you specify in the controller itself what to do with the
        command object that has been filled with the parameters from the
        request.</p></li><li><p><tt class="classname">AbstractFormController</tt> -
        an abstract controller offering form submission support. Using
        this controller you can model forms and populate them using a
        command object you retrieve in the controller. After a user has
        filled the form, <tt class="classname">AbstractFormController</tt>
        binds the fields, validates, and hands the object back to the
        controller to take appropriate action. Supported features are:
        invalid form submission (resubmission), validation, and normal
        form workflow. You implement methods to determine which views
        are used for form presentation and success. Use this controller
        if you need forms, but don't want to specify what views you're
        going to show the user in the application
        context.</p></li><li><p><tt class="classname">SimpleFormController</tt> - a
        concrete <tt class="classname">AbstractFormController</tt> that
        provides even more support when creating a form with a
        corresponding command object. The
        <tt class="classname">SimpleFormController</tt> lets you specify a
        command object, a viewname for the form, a viewname for the page you
        want to show the user when form submission has succeeded, and
        more.</p></li><li><p><tt class="classname">AbstractWizardFormController</tt> &#8211;
        a concrete <tt class="classname">AbstractFormController</tt> that
        provides a wizard-style interface for editing the contents of a
        command object across multiple display pages. Supports multiple
        user actions: finish, cancel, or page change, all of which are
        easily specified in request parameters from the
        view.</p></li></ul></div><p>These command controllers are quite powerful, but they do
      require a detailed understanding of how they operate in order to use
      them efficiently. Carefully review the Javadocs for this entire
      hierarchy and then look at some sample implementations before you
      start using them.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-controller-wrapping"></a>16.4.4.&nbsp;<tt class="classname">PortletWrappingController</tt></h3></div></div><div></div></div><p>Instead of developing new controllers, it is possible to use
      existing portlets and map requests to them from a
      <tt class="classname">DispatcherPortlet</tt>. Using the
      <tt class="classname">PortletWrappingController</tt>, you can
      instantiate an existing <tt class="interfacename">Portlet</tt> as a
      <tt class="interfacename">Controller</tt> as follows:</p><pre class="programlisting">&lt;bean id="myPortlet" class="org.springframework.web.portlet.mvc.PortletWrappingController"&gt;
    &lt;property name="portletClass" value="sample.MyPortlet"/&gt;
    &lt;property name="portletName" value="my-portlet"/&gt;
    &lt;property name="initParameters"&gt;
        &lt;value&gt;config=/WEB-INF/my-portlet-config.xml&lt;/value&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>This can be very valuable since you can then use interceptors
      to pre-process and post-process requests going to these portlets.
      Since JSR-168 does not support any kind of filter mechanism, this is
      quite handy. For example, this can be used to wrap the Hibernate
      <tt class="classname">OpenSessionInViewInterceptor</tt> around a MyFaces
      JSF Portlet.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-handlermapping"></a>16.5.&nbsp;Handler mappings</h2></div></div><div></div></div><p>Using a handler mapping you can map incoming portlet requests to
    appropriate handlers. There are some handler mappings you can use out
    of the box, for example, the
    <tt class="classname">PortletModeHandlerMapping</tt>, but let's first
    examine the general concept of a
    <tt class="interfacename">HandlerMapping</tt>.</p><p>Note: We are intentionally using the term &#8220;Handler&#8221; here instead
    of &#8220;Controller&#8221;. <tt class="classname">DispatcherPortlet</tt> is designed
    to be used with other ways to process requests than just Spring Portlet
    MVC&#8217;s own Controllers. A Handler is any Object that can handle portlet
    requests. Controllers are an example of Handlers, and they are of
    course the default. To use some other framework with
    <tt class="classname">DispatcherPortlet</tt>, a corresponding implementation
    of <tt class="interfacename">HandlerAdapter</tt> is all that is needed.</p><p>The functionality a basic
    <tt class="interfacename">HandlerMapping</tt> provides is the delivering
    of a <tt class="classname">HandlerExecutionChain</tt>, which must contain
    the handler that matches the incoming request, and may also contain a
    list of handler interceptors that are applied to the request. When a
    request comes in, the <tt class="classname">DispatcherPortlet</tt> will hand
    it over to the handler mapping to let it inspect the request and come up
    with an appropriate <tt class="classname">HandlerExecutionChain</tt>. Then
    the <tt class="classname">DispatcherPortlet</tt> will execute the handler
    and interceptors in the chain (if any). These concepts are all exactly
    the same as in Spring Web MVC.</p><p>The concept of configurable handler mappings that can optionally
    contain interceptors (executed before or after the actual handler was
    executed, or both) is extremely powerful. A lot of supporting
    functionality can be built into a custom
    <tt class="interfacename">HandlerMapping</tt>. Think of a custom handler
    mapping that chooses a handler not only based on the portlet mode of the
    request coming in, but also on a specific state of the session
    associated with the request.</p><p>In Spring Web MVC, handler mappings are commonly based on URLs.
    Since there is really no such thing as a URL within a Portlet, we must
    use other mechanisms to control mappings. The two most common are the
    portlet mode and a request parameter, but anything available to the
    portlet request can be used in a custom handler mapping.</p><p>The rest of this section describes three of Spring Portlet MVC's
    most commonly used handler mappings. They all extend
    <tt class="classname">AbstractHandlerMapping</tt> and share the following
    properties:</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">interceptors</tt>: The list of
      interceptors to use.
      <tt class="interfacename">HandlerInterceptor</tt>s are discussed in
      <a href="#portlet-handlermapping-interceptor" title="16.5.4.&nbsp;Adding HandlerInterceptors">Section&nbsp;16.5.4, &#8220;Adding HandlerInterceptors&#8221;</a>.</p></li><li><p><tt class="literal">defaultHandler</tt>: The default
      handler to use, when this handler mapping does not result in a
      matching handler.</p></li><li><p><tt class="literal">order</tt>: Based on the value of the
      order property (see the
      <tt class="interfacename">org.springframework.core.Ordered</tt>
      interface), Spring will sort all handler mappings available in the
      context and apply the first matching handler.</p></li><li><p><tt class="literal">lazyInitHandlers</tt>: Allows for lazy
      initialization of singleton handlers (prototype handlers are always
      lazily initialized). Default value is false. This property is
      directly implemented in the three concrete
      Handlers.</p></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-handlermapping-portletmode"></a>16.5.1.&nbsp;<tt class="classname">PortletModeHandlerMapping</tt></h3></div></div><div></div></div><p>This is a simple handler mapping that maps incoming requests
      based on the current mode of the portlet (e.g. &#8216;view&#8217;, &#8216;edit&#8217;,
      &#8216;help&#8217;). An example:</p><pre class="programlisting">&lt;bean class="org.springframework.web.portlet.handler.PortletModeHandlerMapping"&gt;
    &lt;property name="portletModeMap"&gt;
        &lt;map&gt;
            &lt;entry key="view" value-ref="viewHandler"/&gt;
            &lt;entry key="edit" value-ref="editHandler"/&gt;
            &lt;entry key="help" value-ref="helpHandler"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-handlermapping-parameter"></a>16.5.2.&nbsp;<tt class="classname">ParameterHandlerMapping</tt></h3></div></div><div></div></div><p>If we need to navigate around to multiple controllers without
      changing portlet mode, the simplest way to do this is with a request
      parameter that is used as the key to control the mapping.</p><p><tt class="classname">ParameterHandlerMapping</tt> uses the value
      of a specific request parameter to control the mapping. The default
      name of the parameter is <tt class="literal">'action'</tt>, but can be changed
      using the <tt class="literal">'parameterName'</tt> property.</p><p>The bean configuration for this mapping will look something
      like this:</p><pre class="programlisting">&lt;bean class="org.springframework.web.portlet.handler.ParameterHandlerMapping&#8221;&gt;
    &lt;property name="parameterMap"&gt;
        &lt;map&gt;
            &lt;entry key="add" value-ref="addItemHandler"/&gt;
            &lt;entry key="edit" value-ref="editItemHandler"/&gt;
            &lt;entry key="delete" value-ref="deleteItemHandler"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-handlermapping-portletmodeparameter"></a>16.5.3.&nbsp;<tt class="classname">PortletModeParameterHandlerMapping</tt></h3></div></div><div></div></div><p>The most powerful built-in handler mapping,
      <tt class="classname">PortletModeParameterHandlerMapping</tt> combines
      the capabilities of the two previous ones to allow different
      navigation within each portlet mode.</p><p>Again the default name of the parameter is "action", but can
      be changed using the <tt class="literal">parameterName</tt>
      property.</p><p>By default, the same parameter value may not be used in two
      different portlet modes. This is so that if the portal itself
      changes the portlet mode, the request will no longer be valid in the
      mapping. This behavior can be changed by setting the
      <tt class="literal">allowDupParameters</tt> property to true. However,
      this is not recommended.</p><p>The bean configuration for this mapping will look something
      like this:</p><pre class="programlisting">&lt;bean class="org.springframework.web.portlet.handler.PortletModeParameterHandlerMapping"&gt;
    &lt;property name="portletModeParameterMap"&gt;
        &lt;map&gt;
            &lt;entry key="view"&gt; <i class="lineannotation"><span class="lineannotation">&lt;!-- 'view' portlet mode --&gt;</span></i>
                &lt;map&gt;
                    &lt;entry key="add" value-ref="addItemHandler"/&gt;
                    &lt;entry key="edit" value-ref="editItemHandler"/&gt;
                    &lt;entry key="delete" value-ref="deleteItemHandler"/&gt;
                &lt;/map&gt;
            &lt;/entry&gt;
            &lt;entry key="edit"&gt; <i class="lineannotation"><span class="lineannotation">&lt;!-- 'edit' portlet mode --&gt;</span></i>
                &lt;map&gt;
                    &lt;entry key="prefs" value-ref="prefsHandler"/&gt;
                    &lt;entry key="resetPrefs" value-ref="resetPrefsHandler"/&gt;
                &lt;/map&gt;
            &lt;/entry&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>This mapping can be chained ahead of a
      <tt class="classname">PortletModeHandlerMapping</tt>, which can then provide
      defaults for each mode and an overall default as well.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-handlermapping-interceptor"></a>16.5.4.&nbsp;Adding <tt class="interfacename">HandlerInterceptor</tt>s</h3></div></div><div></div></div><p>Spring's handler mapping mechanism has a notion of handler
      interceptors, which can be extremely useful when you want to apply
      specific functionality to certain requests, for example, checking
      for a principal. Again Spring Portlet MVC implements these concepts
      in the same way as Web MVC.</p><p>Interceptors located in the handler mapping must implement
      <tt class="interfacename">HandlerInterceptor</tt> from the
      <tt class="literal">org.springframework.web.portlet</tt> package. Just
      like the servlet version, this interface defines three methods: one
      that will be called before the actual handler will be executed
      (<tt class="literal">preHandle</tt>), one that will be called after the
      handler is executed (<tt class="literal">postHandle</tt>), and one that is
      called after the complete request has finished
      (<tt class="literal">afterCompletion</tt>). These three methods should
      provide enough flexibility to do all kinds of pre- and post-
      processing.</p><p>The <tt class="literal">preHandle</tt> method returns a boolean
      value. You can use this method to break or continue the processing
      of the execution chain. When this method returns
      <tt class="literal">true</tt>, the handler execution chain will continue.
      When it returns <tt class="literal">false</tt>, the
      <tt class="classname">DispatcherPortlet</tt> assumes the interceptor
      itself has taken care of requests (and, for example, rendered an
      appropriate view) and does not continue executing the other
      interceptors and the actual handler in the execution chain.</p><p>The <tt class="literal">postHandle</tt> method is only called on a
      <tt class="interfacename">RenderRequest</tt>. The
      <tt class="literal">preHandle</tt> and <tt class="literal">afterCompletion</tt>
      methods are called on both an
      <tt class="interfacename">ActionRequest</tt> and a
      <tt class="interfacename">RenderRequest</tt>. If you need to
      execute logic in these methods for just one type of request, be sure
      to check what kind of request it is before processing it.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-handlermapping-interceptoradapter"></a>16.5.5.&nbsp;<tt class="classname">HandlerInterceptorAdapter</tt></h3></div></div><div></div></div><p>As with the servlet package, the portlet package has a
      concrete implementation of
      <tt class="interfacename">HandlerInterceptor</tt> called
      <tt class="classname">HandlerInterceptorAdapter</tt>. This class has
      empty versions of all the methods so that you can inherit from this
      class and implement just one or two methods when that is all you
      need.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-handlermapping-parameterinterceptor"></a>16.5.6.&nbsp;<tt class="classname">ParameterMappingInterceptor</tt></h3></div></div><div></div></div><p>The portlet package also has a concrete interceptor named
      <tt class="classname">ParameterMappingInterceptor</tt> that is meant to
      be used directly with <tt class="classname">ParameterHandlerMapping</tt>
      and <tt class="classname">PortletModeParameterHandlerMapping</tt>. This
      interceptor will cause the parameter that is being used to control
      the mapping to be forwarded from an
      <tt class="interfacename">ActionRequest</tt> to the subsequent
      <tt class="interfacename">RenderRequest</tt>. This will help ensure
      that the <tt class="interfacename">RenderRequest</tt> is mapped to
      the same Handler as the
      <tt class="interfacename">ActionRequest</tt>. This is done in the
      <tt class="literal">preHandle</tt> method of the interceptor, so you can
      still modify the parameter value in your handler to change where the
      <tt class="interfacename">RenderRequest</tt> will be mapped.</p><p>Be aware that this interceptor is calling
      <tt class="literal">setRenderParameter</tt> on the
      <tt class="interfacename">ActionResponse</tt>, which means that you
      cannot call <tt class="literal">sendRedirect</tt> in your handler when
      using this interceptor. If you need to do external redirects then
      you will either need to forward the mapping parameter manually or
      write a different interceptor to handle this for you.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-viewresolver"></a>16.6.&nbsp;Views and resolving them</h2></div></div><div></div></div><p>As mentioned previously, Spring Portlet MVC directly reuses all
    the view technologies from Spring Web MVC. This includes not only the
    various <tt class="interfacename">View</tt> implementations themselves,
    but also the <tt class="interfacename">ViewResolver</tt> implementations.
    For more information, refer to the sections entitled
    <a href="#view" title="Chapter&nbsp;14.&nbsp;View technologies">Chapter&nbsp;14, <i>View technologies</i></a> and <a href="#mvc-viewresolver" title="13.5.&nbsp;Views and resolving them">Section&nbsp;13.5, &#8220;Views and resolving them&#8221;</a> respectively.</p><p>A few items on using the existing <tt class="interfacename">View</tt> and
    <tt class="interfacename">ViewResolver</tt> implementations  are worth mentioning:</p><div class="itemizedlist"><ul type="disc"><li><p>Most portals expect the result of rendering a
      portlet to be an HTML fragment. So, things like JSP/JSTL, Velocity,
      FreeMarker, and XSLT all make sense. But it is unlikely that views
      that return other document types will make any sense in a portlet
      context.</p></li><li><p>There is no such thing as an HTTP redirect from
      within a portlet (the <tt class="literal">sendRedirect(..)</tt> method of
      <tt class="interfacename">ActionResponse</tt> cannot
      be used to stay within the portal). So, <tt class="classname">RedirectView</tt>
      and use of the <tt class="literal">'redirect:'</tt> prefix will
      <span class="bold"><b>not</b></span> work correctly from within Portlet MVC.</p></li><li><p>It may be possible to use the <tt class="literal">'forward:'</tt> prefix from
      within Portlet MVC. However, remember that since you are in a
      portlet, you have no idea what the current URL looks like. This
      means you cannot use a relative URL to access other resources in
      your web application and that you will have to use an absolute
      URL.</p></li></ul></div><p>Also, for JSP development, the new Spring Taglib and the new
    Spring Form Taglib both work in portlet views in exactly the same way
    that they work in servlet views.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-multipart"></a>16.7.&nbsp;Multipart (file upload) support</h2></div></div><div></div></div><p>Spring Portlet MVC has built-in multipart support to handle file
    uploads in portlet applications, just like Web MVC does. The design for
    the multipart support is done with pluggable
    <tt class="interfacename">PortletMultipartResolver</tt> objects, defined
    in the <tt class="literal">org.springframework.web.portlet.multipart</tt>
    package. Spring provides a <tt class="interfacename">PortletMultipartResolver</tt>
    for use with
    <a href="http://jakarta.apache.org/commons/fileupload" target="_top">Commons FileUpload</a>.
    How uploading files is supported will be described in the rest of this section.</p><p>By default, no multipart handling will be done by Spring Portlet
    MVC, as some developers will want to handle multiparts themselves. You
    will have to enable it yourself by adding a multipart resolver to the
    web application's context. After you have done that,
    <tt class="classname">DispatcherPortlet</tt> will inspect each request to
    see if it contains a multipart. If no multipart is found, the request
    will continue as expected. However, if a multipart is found in the
    request, the <tt class="interfacename">PortletMultipartResolver</tt>
    that has been declared in your context will be used. After that, the
    multipart attribute in your request will be treated like any other
    attribute.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Any configured <tt class="interfacename">PortletMultipartResolver</tt>
      bean <span class="emphasis"><em>must</em></span> have the following id (or name):
      "<tt class="literal">portletMultipartResolver</tt>". If you have defined your
      <tt class="interfacename">PortletMultipartResolver</tt> with any other name,
      then the <tt class="classname">DispatcherPortlet</tt> will <span class="emphasis"><em>not</em></span>
      find your <tt class="interfacename">PortletMultipartResolver</tt>, and
      consequently no multipart support will be in effect.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-multipart-resolver"></a>16.7.1.&nbsp;Using the <tt class="interfacename">PortletMultipartResolver</tt></h3></div></div><div></div></div><p>The following example shows how to use the
      <tt class="classname">CommonsPortletMultipartResolver</tt>:</p><pre class="programlisting">&lt;bean id="portletMultipartResolver"
        class="org.springframework.web.portlet.multipart.CommonsPortletMultipartResolver"&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- one of the properties available; the maximum file size in bytes --&gt;</span></i>
    &lt;property name="maxUploadSize" value="100000"/&gt;
&lt;/bean&gt;</pre><p>Of course you also need to put the appropriate jars in your
      classpath for the multipart resolver to work. In the case of the
      <tt class="classname">CommonsMultipartResolver</tt>, you need to use
      <tt class="literal">commons-fileupload.jar</tt>. Be sure to use at least
      version 1.1 of Commons FileUpload as previous versions do not
      support JSR-168 Portlet applications.</p><p>Now that you have seen how to set Portlet MVC up to handle
      multipart requests, let's talk about how to actually use it. When
      <tt class="classname">DispatcherPortlet</tt> detects a multipart
      request, it activates the resolver that has been declared in your
      context and hands over the request. What the resolver then does is
      wrap the current <tt class="interfacename">ActionRequest</tt> into a
      <tt class="interfacename">MultipartActionRequest</tt> that has
      support for multipart file uploads. Using the
      <tt class="interfacename">MultipartActionRequest</tt> you can get
      information about the multiparts contained by this request and
      actually get access to the multipart files themselves in your
      controllers.</p><p>Note that you can only receive multipart file uploads as part
      of an <tt class="interfacename">ActionRequest</tt>, not as part of a
      <tt class="interfacename">RenderRequest</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-multipart-forms"></a>16.7.2.&nbsp;Handling a file upload in a form</h3></div></div><div></div></div><p>After the
      <tt class="interfacename">PortletMultipartResolver</tt> has finished
      doing its job, the request will be processed like any other. To use
      it, you create a form with an upload field (see immediately below),
      then let Spring bind the file onto your form (backing object). To
      actually let the user upload a file, we have to create a (JSP/HTML)
      form:</p><pre class="programlisting">&lt;h1&gt;Please upload a file&lt;/h1&gt;
&lt;form method="post" action="&lt;portlet:actionURL/&gt;" enctype="multipart/form-data"&gt;
    &lt;input type="file" name="file"/&gt;
    &lt;input type="submit"/&gt;
&lt;/form&gt;</pre><p>As you can see, we've created a field named &#8220;file&#8221; after the
      property of the bean that holds the <tt class="literal">byte[]</tt>.
      Furthermore we've added the encoding attribute
      (<tt class="literal">enctype="multipart/form-data"</tt>), which is
      necessary to let the browser know how to encode the multipart fields
      (do not forget this!).</p><p>Just as with any other property that's not automagically
      convertible to a string or primitive type, to be able to put binary
      data in your objects you have to register a custom editor with the
      <tt class="classname">PortletRequestDataBinder</tt>. There are a couple
      of editors available for handling files and setting the results on
      an object. There's a
      <tt class="classname">StringMultipartFileEditor</tt> capable of
      converting files to Strings (using a user-defined character set) and
      there is a <tt class="classname">ByteArrayMultipartFileEditor</tt> which
      converts files to byte arrays. They function just as the
      <tt class="classname">CustomDateEditor</tt> does.</p><p>So, to be able to upload files using a form, declare the
      resolver, a mapping to a controller that will process the bean, and
      the controller itself.</p><pre class="programlisting">&lt;bean id="portletMultipartResolver"
        class="org.springframework.web.portlet.multipart.CommonsPortletMultipartResolver"/&gt;

&lt;bean class="org.springframework.web.portlet.handler.PortletModeHandlerMapping"&gt;
    &lt;property name="portletModeMap"&gt;
        &lt;map&gt;
            &lt;entry key="view" value-ref="fileUploadController"/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="fileUploadController" class="examples.FileUploadController"&gt;
    &lt;property name="commandClass" value="examples.FileUploadBean"/&gt;
    &lt;property name="formView" value="fileuploadform"/&gt;
    &lt;property name="successView" value="confirmation"/&gt;
&lt;/bean&gt;</pre><p>After that, create the controller and the actual class to hold
      the file property.</p><pre class="programlisting">public class FileUploadController extends SimpleFormController {

    public void onSubmitAction(ActionRequest request, ActionResponse response,
            Object command, BindException errors) throws Exception {

        <i class="lineannotation"><span class="lineannotation">// cast the bean</span></i>
        FileUploadBean bean = (FileUploadBean) command;

        <i class="lineannotation"><span class="lineannotation">// let's see if there's content there</span></i>
        byte[] file = bean.getFile();
        if (file == null) {
            <i class="lineannotation"><span class="lineannotation">// hmm, that's strange, the user did not upload anything</span></i>
        }

        // do something with the file here
    }

    protected void initBinder(
            PortletRequest request, PortletRequestDataBinder binder) throws Exception {
        // to actually be able to convert Multipart instance to byte[]
        // we have to register a custom editor
        binder.registerCustomEditor(byte[].class, new ByteArrayMultipartFileEditor());
        <i class="lineannotation"><span class="lineannotation">// now Spring knows how to handle multipart object and convert</span></i>
    }
}

public class FileUploadBean {

    private byte[] file;

    public void setFile(byte[] file) {
        this.file = file;
    }

    public byte[] getFile() {
        return file;
    }
}</pre><p>As you can see, the <tt class="classname">FileUploadBean</tt> has
      a property typed <tt class="literal">byte[]</tt> that holds the file. The
      controller registers a custom editor to let Spring know how to
      actually convert the multipart objects the resolver has found to
      properties specified by the bean. In this example, nothing is done
      with the <tt class="literal">byte[]</tt> property of the bean itself, but
      in practice you can do whatever you want (save it in a database,
      mail it to somebody, etc).</p><p>An equivalent example in which a file is bound straight to a
      String-typed property on a (form backing) object might look like
      this:</p><pre class="programlisting">public class FileUploadController extends SimpleFormController {

    public void onSubmitAction(ActionRequest request, ActionResponse response,
            Object command, BindException errors) throws Exception {

        // cast the bean
        FileUploadBean bean = (FileUploadBean) command;

        // let's see if there's content there
        String file = bean.getFile();
        if (file == null) {
            // hmm, that's strange, the user did not upload anything
        }

        // do something with the file here
    }

    protected void initBinder(
        PortletRequest request, PortletRequestDataBinder binder) throws Exception {

        // to actually be able to convert Multipart instance to a String
        // we have to register a custom editor
        binder.registerCustomEditor(String.class,
            new StringMultipartFileEditor());
        // now Spring knows how to handle multipart objects and convert
    }
}

public class FileUploadBean {

    private String file;

    public void setFile(String file) {
        this.file = file;
    }

    public String getFile() {
        return file;
    }
}</pre><p>Of course, this last example only makes (logical) sense in the
      context of uploading a plain text file (it wouldn't work so well in
      the case of uploading an image file).</p><p>The third (and final) option is where one binds directly to a
      <tt class="interfacename">MultipartFile</tt> property declared on
      the (form backing) object's class. In this case one does not need to
      register any custom property editor because there is no type
      conversion to be performed.</p><pre class="programlisting">public class FileUploadController extends SimpleFormController {

    public void onSubmitAction(ActionRequest request, ActionResponse response,
            Object command, BindException errors) throws Exception {

        // cast the bean
        FileUploadBean bean = (FileUploadBean) command;

        // let's see if there's content there
        MultipartFile file = bean.getFile();
        if (file == null) {
            // hmm, that's strange, the user did not upload anything
        }

        // do something with the file here
    }
}

public class FileUploadBean {

    private MultipartFile file;

    public void setFile(MultipartFile file) {
        this.file = file;
    }

    public MultipartFile getFile() {
        return file;
    }
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-exceptionresolver"></a>16.8.&nbsp;Handling exceptions</h2></div></div><div></div></div><p>Just like Web MVC, Portlet MVC provides
    <tt class="interfacename">HandlerExceptionResolver</tt>s to ease the
    pain of unexpected exceptions occurring while your request is being
    processed by a handler that matched the request. Portlet MVC also
    provides the same concrete
    <tt class="classname">SimpleMappingExceptionResolver</tt> that enables you
    to take the class name of any exception that might be thrown and map it
    to a view name.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-annotation"></a>16.9.&nbsp;Annotation-based controller configuration</h2></div></div><div></div></div><p>Spring 2.5 introduces an annotation-based programming model for MVC
    controllers, using annotations such as
    <tt class="interfacename">@RequestMapping</tt>,
    <tt class="interfacename">@RequestParam</tt>,
    <tt class="interfacename">@ModelAttribute</tt>, etc. This annotation
    support is available for both Servlet MVC and Portlet MVC. Controllers
    implemented in this style do not have to extend specific base classes or
    implement specific interfaces. Furthermore, they do not usually have
    direct dependencies on Servlet or Portlet API's, although they can easily
    get access to Servlet or Portlet facilities if desired.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>The Spring distribution ships with the
      <span class="emphasis"><em>PetPortal</em></span> sample, which is a portal application that takes
      advantage of the annotation support described in this section, in the context
      of simple form processing. You can find the <span class="emphasis"><em>PetPortal</em></span>
      application in the <tt class="literal">'samples/petportal'</tt> directory.</p></td></tr></table></div><p>The following sections document these annotations and how they are
    most commonly used in a Portlet environment.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-setup"></a>16.9.1.&nbsp;Setting up the dispatcher for annotation support</h3></div></div><div></div></div><p><span class="emphasis"><em><tt class="interfacename">@RequestMapping</tt> will only be processed
      if a corresponding <tt class="interfacename">HandlerMapping</tt> (for type level annotations)
      and/or <tt class="interfacename">HandlerAdapter</tt> (for method level annotations) is
      present in the dispatcher.</em></span> This is the case by default in both
      <tt class="classname">DispatcherServlet</tt> and <tt class="classname">DispatcherPortlet</tt>.</p><p>However, if you are defining custom <tt class="interfacename">HandlerMappings</tt> or
      <tt class="interfacename">HandlerAdapters</tt>, then you need to make sure that a
      corresponding custom <tt class="classname">DefaultAnnotationHandlerMapping</tt>
      and/or <tt class="classname">AnnotationMethodHandlerAdapter</tt> is defined as well
      - provided that you intend to use <tt class="interfacename">@RequestMapping</tt>.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

    &lt;bean class="org.springframework.web.portlet.mvc.annotation.DefaultAnnotationHandlerMapping"/&gt;

    &lt;bean class="org.springframework.web.portlet.mvc.annotation.AnnotationMethodHandlerAdapter"/&gt;

    <i class="lineannotation"><span class="lineannotation">// ... (controller bean definitions) ...</span></i>

&lt;/beans&gt;
</pre><p>Defining a <tt class="classname">DefaultAnnotationHandlerMapping</tt>
      and/or <tt class="classname">AnnotationMethodHandlerAdapter</tt> explicitly
      also makes sense if you would like to customize the mapping strategy, e.g.
      specifying a custom <tt class="interfacename">WebBindingInitializer</tt> (see below).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-controller"></a>16.9.2.&nbsp;Defining a controller with
      <tt class="interfacename">@Controller</tt></h3></div></div><div></div></div><p>The <tt class="interfacename">@Controller</tt> annotation indicates
      that a particular class serves the role of a <span class="emphasis"><em>controller</em></span>.
      There is no need to extend any controller base class or reference the
      Portlet API. You are of course still able to reference Portlet-specific
      features if you need to.</p><p>The basic purpose of the <tt class="interfacename">@Controller</tt>
      annotation is to act as a stereotype for the annotated class, indicating
      its role. The dispatcher will scan such annotated classes for mapped
      methods, detecting <tt class="interfacename">@RequestMapping</tt>
      annotations (see the next section).</p><p>Annotated controller beans may be defined explicitly,
      using a standard Spring bean definition in the dispatcher's context.
      However, the <tt class="interfacename">@Controller</tt> stereotype also
      allows for autodetection, aligned with Spring 2.5's general support for
      detecting component classes in the classpath and auto-registering bean
      definitions for them.</p><p>To enable autodetection of such annotated controllers, you have to add
      component scanning to your configuration. This is easily achieved by using
      the <span class="emphasis"><em>spring-context</em></span> schema as shown in the following
      XML snippet:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:p="http://www.springframework.org/schema/p"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-2.5.xsd"&gt;

    &lt;context:component-scan base-package="org.springframework.samples.petportal.portlet"/&gt;

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>

&lt;/beans&gt;
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-requestmapping"></a>16.9.3.&nbsp;Mapping requests with
      <tt class="interfacename">@RequestMapping</tt></h3></div></div><div></div></div><p>The <tt class="interfacename">@RequestMapping</tt> annotation is used
      to map portlet modes like 'VIEW'/'EDIT' onto an entire class or a particular
      handler method. Typically the type-level annotation maps a specific mode
      (or mode plus parameter condition) onto a form controller, with additional
      method-level annotations 'narrowing' the primary mapping for specific
      portlet request parameters.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p><tt class="interfacename">@RequestMapping</tt> at the type
        level may be used for plain implementations of the
        <tt class="interfacename">Controller</tt> interface as well.
        In this case, the request processing code would follow the
        traditional <tt class="literal">handle(Action|Render)Request</tt> signature,
        while the controller's mapping would be expressed through an
        <tt class="interfacename">@RequestMapping</tt> annotation.
        This works for pre-built <tt class="interfacename">Controller</tt>
        base classes, such as <tt class="classname">SimpleFormController</tt>,
        too.</p><p>In the following discussion, we'll focus on controllers
        that are based on annotated handler methods.</p></td></tr></table></div><p>The following is an example of a form controller from the
      PetPortal sample application using this annotation:</p><pre class="programlisting">@Controller
<span class="bold"><b>@RequestMapping("EDIT")</b></span>
@SessionAttributes("site")
public class PetSitesEditController {

    private Properties petSites;

    public void setPetSites(Properties petSites) {
        this.petSites = petSites;
    }

    @ModelAttribute("petSites")
    public Properties getPetSites() {
        return this.petSites;
    }

    <span class="bold"><b>@RequestMapping</b></span>  // default (action=list)
    public String showPetSites() {
        return "petSitesEdit";
    }

    <span class="bold"><b>@RequestMapping(params = "action=add")</b></span>  // render phase
    public String showSiteForm(Model model) {
        // Used for the initial form as well as for redisplaying with errors.
        if (!model.containsAttribute("site")) {
            model.addAttribute("site", new PetSite());
        }
        return "petSitesAdd";
    }

    <span class="bold"><b>@RequestMapping(params = "action=add")</b></span>  // action phase
    public void populateSite(
            @ModelAttribute("site") PetSite petSite, BindingResult result,
            SessionStatus status, ActionResponse response) {

        new PetSiteValidator().validate(petSite, result);
        if (!result.hasErrors()) {
            this.petSites.put(petSite.getName(), petSite.getUrl());
            status.setComplete();
            response.setRenderParameter("action", "list");
        }
    }

    <span class="bold"><b>@RequestMapping(params = "action=delete")</b></span>
    public void removeSite(@RequestParam("site") String site, ActionResponse response) {
        this.petSites.remove(site);
        response.setRenderParameter("action", "list");
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-requestmapping-arguments"></a>16.9.4.&nbsp;Supported handler method arguments</h3></div></div><div></div></div><p>Handler methods which are annotated with
      <tt class="classname">@RequestMapping</tt> are allowed to have very flexible
      signatures. They may have arguments of the following types, in arbitrary
      order (except for validation results, which need to follow right after
      the corresponding command object, if desired):

      </p><div class="itemizedlist"><ul type="disc"><li><p>Request and/or response objects (Portlet API).
          You may choose any specific request/response type, e.g. PortletRequest /
          ActionRequest / RenderRequest. An explicitly declared action/render
          argument is also used for mapping specific request types onto a handler
          method (in case of no other information given that differentiates
          between action and render requests).</p></li><li><p>Session object (Portlet API): of type PortletSession. An argument
          of this type will enforce the presence of a corresponding session.
          As a consequence, such an argument will never be <tt class="literal">null</tt>.</p></li><li><p><tt class="classname">org.springframework.web.context.request.WebRequest</tt>
          or <tt class="classname">org.springframework.web.context.request.NativeWebRequest</tt>.
          Allows for generic request parameter access as well as request/session
          attribute access, without ties to the native Servlet/Portlet API.</p></li><li><p><tt class="classname">java.util.Locale</tt> for the current request
          locale (the portal locale in a Portlet environment).</p></li><li><p><tt class="classname">java.io.InputStream</tt> /
          <tt class="classname">java.io.Reader</tt> for access to the request's content.
          This will be the raw InputStream/Reader as exposed by the Portlet API.</p></li><li><p><tt class="classname">java.io.OutputStream</tt> /
          <tt class="classname">java.io.Writer</tt> for generating the response's content.
          This will be the raw OutputStream/Writer as exposed by the Portlet API.</p></li><li><p><tt class="classname">@RequestParam</tt> annotated parameters
          for access to specific Portlet request parameters. Parameter values
          will be converted to the declared method argument type.</p></li><li><p><tt class="interfacename">java.util.Map</tt> /
          <tt class="interfacename">org.springframework.ui.Model</tt> /
          <tt class="classname">org.springframework.ui.ModelMap</tt> for
          enriching the implicit model that will be exposed to the web view.</p></li><li><p>Command/form objects to bind parameters to: as bean
          properties or fields, with customizable type conversion, depending
          on <tt class="classname">@InitBinder</tt> methods and/or the
          HandlerAdapter configuration - see the
          "<tt class="literal">webBindingInitializer</tt>" property on
          <tt class="classname">AnnotationMethodHandlerAdapter</tt>. Such
          command objects along with their validation results will be
          exposed as model attributes, by default using the non-qualified
          command class name in property notation (e.g. "orderAddress" for
          type "mypackage.OrderAddress"). Specify a parameter-level
          <tt class="classname">ModelAttribute</tt> annotation for declaring a
          specific model attribute name.</p></li><li><p><tt class="classname">org.springframework.validation.Errors</tt> /
          <tt class="classname">org.springframework.validation.BindingResult</tt>
          validation results for a preceding command/form object (the
          immediate preceding argument).</p></li><li><p><tt class="classname">org.springframework.web.bind.support.SessionStatus</tt>
          status handle for marking form processing as complete (triggering
          the cleanup of session attributes that have been indicated by the
          <tt class="classname">@SessionAttributes</tt> annotation at the
          handler type level).</p></li></ul></div><p>The following return types are supported for handler methods:

      </p><div class="itemizedlist"><ul type="disc"><li><p>A <tt class="classname">ModelAndView</tt> object, with the model implicitly
          enriched with command objects and the results of <tt class="literal">@ModelAttribute</tt>
          annotated reference data accessor methods.</p></li><li><p>A <tt class="interfacename">Model</tt> object, with the view name implicitly
          determined through a <tt class="interfacename">RequestToViewNameTranslator</tt>
          and the model implicitly enriched with command objects and the results of
          <tt class="literal">@ModelAttribute</tt> annotated reference data accessor methods.</p></li><li><p>A <tt class="interfacename">Map</tt> object for exposing a model, with the view name
          implicitly determined through a <tt class="interfacename">RequestToViewNameTranslator</tt>
          and the model implicitly enriched with command objects and the results of
          <tt class="literal">@ModelAttribute</tt> annotated reference data accessor methods.</p></li><li><p>A <tt class="interfacename">View</tt> object, with the model implicitly
          determined through command objects and <tt class="literal">@ModelAttribute</tt>
          annotated reference data accessor methods. The handler method may also
          programmatically enrich the model by declaring a <tt class="interfacename">Model</tt>
          argument (see above).</p></li><li><p>A <tt class="classname">String</tt> value which is interpreted as view name,
          with the model implicitly determined through command objects and
          <tt class="literal">@ModelAttribute</tt> annotated reference data accessor methods.
          The handler method may also programmatically enrich the model by declaring a
          <tt class="interfacename">Model</tt> argument (see above).</p></li><li><p><tt class="literal">void</tt> if the method handles the response itself
          (e.g. by writing the response content directly).</p></li><li><p>Any other return type will be considered as single model attribute
          to be exposed to the view, using the attribute name specified through
          <tt class="literal">@ModelAttribute</tt> at the method level (or the default
          attribute name based on the return type's class name otherwise). The model
          will be implicitly enriched with command objects and the results of
          <tt class="literal">@ModelAttribute</tt> annotated reference data accessor methods.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-requestparam"></a>16.9.5.&nbsp;Binding request parameters to method parameters with
      <tt class="classname">@RequestParam</tt></h3></div></div><div></div></div><p>The <tt class="classname">@RequestParam</tt> annotation is used to
      bind request parameters to a method parameter in your controller.</p><p>The following code snippet from the PetPortal sample application
      shows the usage:</p><pre class="programlisting">@Controller
@RequestMapping("EDIT")
@SessionAttributes("site")
public class PetSitesEditController {

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>

    public void removeSite(<span class="bold"><b>@RequestParam("site")</b></span> String site, ActionResponse response) {
        this.petSites.remove(site);
        response.setRenderParameter("action", "list");
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}
</pre><p>Parameters using this annotation are required by default, but you
      can specify that a parameter is optional by setting
      <tt class="interfacename">@RequestParam</tt>'s
      <tt class="literal">required</tt> attribute to <tt class="literal">false</tt> (e.g.,
      <tt class="literal">@RequestParam(value="id", required="false")</tt>).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-modelattrib"></a>16.9.6.&nbsp;Providing a link to data from the model with
      <tt class="classname">@ModelAttribute</tt></h3></div></div><div></div></div><p><tt class="classname">@ModelAttribute</tt> has two usage scenarios in
      controllers. When placed on a method parameter,
      <tt class="classname">@ModelAttribute</tt> is used to map a model attribute
      to the specific, annotated method parameter (see the
      <tt class="literal">processSubmit()</tt> method below). This is how the
      controller gets a reference to the object holding the data entered in
      the form. In addition, the parameter can be declared as the specific
      type of the form backing object rather than as a generic
      <tt class="classname">java.lang.Object</tt>, thus increasing type
      safety.</p><p><tt class="classname">@ModelAttribute</tt> is also used at the method
      level to provide <span class="emphasis"><em>reference data</em></span> for the model (see
      the <tt class="literal">populatePetTypes()</tt> method below). For this usage
      the method signature can contain the same types as documented above for
      the <tt class="classname">@RequestMapping</tt> annotation.</p><p><span class="emphasis"><em>Note:</em></span> <tt class="classname">@ModelAttribute</tt>
      annotated methods will be executed <span class="emphasis"><em>before</em></span> the
      chosen <tt class="classname">@RequestMapping</tt> annotated handler method.
      They effectively pre-populate the implicit model with specific attributes,
      often loaded from a database. Such an attribute can then already be
      accessed through <tt class="classname">@ModelAttribute</tt> annotated
      handler method parameters in the chosen handler method, potentially
      with binding and validation applied to it.</p><p>The following code snippet shows these two usages of this
      annotation:</p><pre class="programlisting">@Controller
@RequestMapping("EDIT")
@SessionAttributes("site")
public class PetSitesEditController {

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>

    <span class="bold"><b>@ModelAttribute("petSites")</b></span>
    public Properties getPetSites() {
        return this.petSites;
    }

    @RequestMapping(params = "action=add")  // action phase
    public void populateSite(
            <span class="bold"><b>@ModelAttribute("site")</b></span> PetSite petSite, BindingResult result,
            SessionStatus status, ActionResponse response) {

        new PetSiteValidator().validate(petSite, result);
        if (!result.hasErrors()) {
            this.petSites.put(petSite.getName(), petSite.getUrl());
            status.setComplete();
            response.setRenderParameter("action", "list");
        }
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-sessionattrib"></a>16.9.7.&nbsp;Specifying attributes to store in a Session with
      <tt class="classname">@SessionAttributes</tt></h3></div></div><div></div></div><p>The type-level <tt class="classname">@SessionAttributes</tt>
      annotation declares session attributes used by a specific handler. This
      will typically list the names of model attributes which should be
      transparently stored in the session or some conversational storage,
      serving as form-backing beans between subsequent requests.</p><p>The following code snippet shows the usage of this
      annotation:</p><pre class="programlisting">@Controller
@RequestMapping("EDIT")
<span class="bold"><b>@SessionAttributes("site")</b></span>
public class PetSitesEditController {
  <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="portlet-ann-webdatabinder"></a>16.9.8.&nbsp;Customizing <tt class="classname">WebDataBinder</tt>
      initialization</h3></div></div><div></div></div><p>To customize request parameter binding with PropertyEditors, etc.
      via Spring's <tt class="classname">WebDataBinder</tt>, you can either use
      <tt class="interfacename">@InitBinder</tt>-annotated methods within your
      controller or externalize your configuration by providing a custom
      <tt class="interfacename">WebBindingInitializer</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="portlet-ann-initbinder"></a>16.9.8.1.&nbsp;Customizing data binding with
        <tt class="interfacename">@InitBinder</tt></h4></div></div><div></div></div><p>Annotating controller methods with
        <tt class="interfacename">@InitBinder</tt> allows you to configure web
        data binding directly within your controller class.
        <tt class="interfacename">@InitBinder</tt> identifies methods which
        initialize the <tt class="classname">WebDataBinder</tt> which will be used
        for populating command and form object arguments of annotated handler
        methods.</p><p>Such init-binder methods support all arguments that
        <tt class="interfacename">@RequestMapping</tt> supports, except for
        command/form objects and corresponding validation result objects.
        Init-binder methods must not have a return value. Thus, they are
        usually declared as <tt class="literal">void</tt>. Typical arguments include
        <tt class="classname">WebDataBinder</tt> in combination with
        <tt class="interfacename">WebRequest</tt> or
        <tt class="classname">java.util.Locale</tt>, allowing code to register
        context-specific editors.</p><p>The following example demonstrates the use of
        <tt class="interfacename">@InitBinder</tt> for configuring a
        <tt class="classname">CustomDateEditor</tt> for all
        <tt class="classname">java.util.Date</tt> form properties.</p><pre class="programlisting">@Controller
public class MyFormController {

    <span class="bold"><b>@InitBinder</b></span>
    public void initBinder(WebDataBinder binder) {
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
        dateFormat.setLenient(false);
        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));
    }

    <i class="lineannotation"><span class="lineannotation">// ...</span></i>
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="portlet-ann-webbindinginitializer"></a>16.9.8.2.&nbsp;Configuring a custom
        <tt class="interfacename">WebBindingInitializer</tt></h4></div></div><div></div></div><p>To externalize data binding initialization, you can provide a
        custom implementation of the
        <tt class="interfacename">WebBindingInitializer</tt> interface, which
        you then enable by supplying a custom bean configuration for an
        <tt class="classname">AnnotationMethodHandlerAdapter</tt>, thus overriding
        the default configuration.</p></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="portlet-deployment"></a>16.10.&nbsp;Portlet application deployment</h2></div></div><div></div></div><p>The process of deploying a Spring Portlet MVC application is no
    different than deploying any JSR-168 Portlet application. However, this
    area is confusing enough in general that it is worth talking about here
    briefly.</p><p>Generally, the portal/portlet container runs in one webapp in your
    servlet container and your portlets run in another webapp in your
    servlet container. In order for the portlet container webapp to make
    calls into your portlet webapp it must make cross-context calls to a
    well-known servlet that provides access to the portlet services defined
    in your <tt class="literal">portlet.xml</tt> file.</p><p>The JSR-168 specification does not specify exactly how this should
    happen, so each portlet container has its own mechanism for this, which
    usually involves some kind of &#8220;deployment process&#8221; that makes changes to
    the portlet webapp itself and then registers the portlets within the
    portlet container.</p><p>At a minimum, the <tt class="literal">web.xml</tt> file in your portlet
    webapp is modified to inject the well-known servlet that the portlet
    container will call. In some cases a single servlet will service all
    portlets in the webapp, in other cases there will be an instance of the
    servlet for each portlet.</p><p>Some portlet containers will also inject libraries and/or
    configuration files into the webapp as well. The portlet container must
    also make its implementation of the Portlet JSP Tag Library available to
    your webapp.</p><p>The bottom line is that it is important to understand the
    deployment needs of your target portal and make sure they are met
    (usually by following the automated deployment process it provides).
    Be sure to carefully review the documentation from your portal for this
    process.</p><p>Once you have deployed your portlet, review the resulting
    <tt class="literal">web.xml</tt> file for sanity. Some older portals have
    been known to corrupt the definition of the
    <tt class="classname">ViewRendererServlet</tt>, thus breaking the rendering
    of your portlets.</p></div></div></div><div class="part" lang="en"><div class="titlepage"><div><div><h1 class="title"><a name="spring-integration"></a>Integration</h1></div></div><div></div></div><div class="partintro" lang="en"><div><div></div><div></div></div><p>
				This part of the reference documentation covers
				the Spring Framework's integration with a number of J2EE
				(and related) technologies.
			</p><div class="itemizedlist"><ul type="disc"><li><p><a href="#remoting" title="Chapter&nbsp;17.&nbsp;Remoting and web services using Spring">Chapter&nbsp;17, <i>Remoting and web services using Spring</i></a></p></li><li><p><a href="#ejb" title="Chapter&nbsp;18.&nbsp;Enterprise Java Beans (EJB) integration">Chapter&nbsp;18, <i>Enterprise Java Beans (EJB) integration</i></a></p></li><li><p><a href="#jms" title="Chapter&nbsp;19.&nbsp;JMS (Java Message Service)">Chapter&nbsp;19, <i>JMS (Java Message Service)</i></a></p></li><li><p><a href="#jmx" title="Chapter&nbsp;20.&nbsp;JMX">Chapter&nbsp;20, <i>JMX</i></a></p></li><li><p><a href="#cci" title="Chapter&nbsp;21.&nbsp;JCA CCI">Chapter&nbsp;21, <i>JCA CCI</i></a></p></li><li><p><a href="#mail" title="Chapter&nbsp;22.&nbsp;Email">Chapter&nbsp;22, <i>Email</i></a></p></li><li><p><a href="#scheduling" title="Chapter&nbsp;23.&nbsp;Scheduling and Thread Pooling">Chapter&nbsp;23, <i>Scheduling and Thread Pooling</i></a></p></li><li><p><a href="#dynamic-language" title="Chapter&nbsp;24.&nbsp;Dynamic language support">Chapter&nbsp;24, <i>Dynamic language support</i></a></p></li><li><p><a href="#metadata" title="Chapter&nbsp;25.&nbsp;Annotations and Source Level Metadata Support">Chapter&nbsp;25, <i>Annotations and Source Level Metadata Support</i></a></p></li></ul></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="remoting"></a>Chapter&nbsp;17.&nbsp;Remoting and web services using Spring</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remoting-introduction"></a>17.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Spring features integration classes for remoting support using various
    technologies. The remoting support eases the development of remote-enabled
    services, implemented by your usual (Spring) POJOs. Currently, Spring supports
    four remoting technologies:
    </p><div class="itemizedlist"><ul type="disc"><li><p><span class="emphasis"><em>Remote Method Invocation (RMI)</em></span>. Through the use
        of the <tt class="classname">RmiProxyFactoryBean</tt> and the
        <tt class="classname">RmiServiceExporter</tt> Spring supports both traditional
        RMI (with <tt class="interfacename">java.rmi.Remote</tt> interfaces and
        <tt class="exceptionname">java.rmi.RemoteException</tt>) and
        transparent remoting via RMI invokers (with any Java interface).</p></li><li><p><span class="emphasis"><em>Spring's HTTP invoker</em></span>. Spring provides a special
        remoting strategy which allows for Java serialization via HTTP,
        supporting any Java interface (just like the RMI invoker). The corresponding
        support classes are <tt class="classname">HttpInvokerProxyFactoryBean</tt> and
        <tt class="classname">HttpInvokerServiceExporter</tt>.</p></li><li><p><span class="emphasis"><em>Hessian</em></span>. By using Spring's
        <tt class="classname">HessianProxyFactoryBean</tt> and the
        <tt class="classname">HessianServiceExporter</tt> you can transparently
        expose your services using the lightweight binary HTTP-based protocol
        provided by Caucho.</p></li><li><p><span class="emphasis"><em>Burlap</em></span>. Burlap is Caucho's XML-based
        alternative to Hessian. Spring provides support classes such
        as <tt class="classname">BurlapProxyFactoryBean</tt> and
        <tt class="classname">BurlapServiceExporter</tt>.</p></li><li><p><span class="emphasis"><em>JAX-RPC</em></span>. Spring provides remoting support
        for web services via JAX-RPC (J2EE 1.4's web service API).</p></li><li><p><span class="emphasis"><em>JAX-WS</em></span>. Spring provides remoting support
        for web services via JAX-WS (the successor of JAX-RPC, as introduced
        in Java EE 5 and Java 6).</p></li><li><p><span class="emphasis"><em>JMS</em></span>. Remoting using JMS as the underlying protocol
        is supported via the <tt class="classname">JmsInvokerServiceExporter</tt> and
        <tt class="classname">JmsInvokerProxyFactoryBean</tt> classes.</p></li></ul></div><p>While discussing the remoting capabilities of Spring, we'll use the following domain
    model and corresponding services:</p><pre class="programlisting">public class Account implements Serializable{

    private String name;

    public String getName();

    public void setName(String name) {
      this.name = name;
    }
}</pre><pre class="programlisting">public interface AccountService {

    public void insertAccount(Account account);

    public List getAccounts(String name);
}</pre><pre class="programlisting">public interface RemoteAccountService extends Remote {

    public void insertAccount(Account account) throws RemoteException;

    public List getAccounts(String name) throws RemoteException;
}</pre><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// the implementation doing nothing at the moment</span></i>
public class AccountServiceImpl implements AccountService {

    public void insertAccount(Account acc) {
        <i class="lineannotation"><span class="lineannotation">// do something...</span></i>
    }
  
    public List getAccounts(String name) {
        <i class="lineannotation"><span class="lineannotation">// do something...</span></i>
    }
}</pre><p>We will start exposing the service to a remote client by using RMI and 
		talk a bit about the drawbacks of using RMI. We'll then continue to show
		an example using Hessian as the protocol.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remoting-rmi"></a>17.2.&nbsp;Exposing services using RMI</h2></div></div><div></div></div><p>Using Spring's support for RMI, you can transparently expose your services through
    the RMI infrastructure. After having this set up, you basically have a configuration
    similar to remote EJBs, except for the fact that there is no standard support for
    security context propagation or remote transaction propagation. Spring does provide
    hooks for such additional invocation context when using the RMI invoker, so you can
    for example plug in security frameworks or custom security credentials here.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-rmi-server"></a>17.2.1.&nbsp;Exporting the service using the <tt class="classname">RmiServiceExporter</tt></h3></div></div><div></div></div><p>Using the <tt class="classname">RmiServiceExporter</tt>, we can expose the interface
      of our AccountService object as RMI object. The interface can be accessed by using
      <tt class="classname">RmiProxyFactoryBean</tt>, or via plain RMI in case of a traditional
      RMI service. The <tt class="classname">RmiServiceExporter</tt> explicitly supports the
      exposing of any non-RMI services via RMI invokers.
      </p><p>Of course, we first have to set up our service in the Spring container:</p><pre class="programlisting">&lt;bean id="accountService" class="example.AccountServiceImpl"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- any additional properties, maybe a DAO? --&gt;</span></i>
&lt;/bean&gt;</pre><p>Next we'll have to expose our service using the <tt class="classname">RmiServiceExporter</tt>:</p><pre class="programlisting">&lt;bean class="org.springframework.remoting.rmi.RmiServiceExporter"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- does not necessarily have to be the same name as the bean to be exported --&gt;</span></i>
    &lt;property name="serviceName" value="AccountService"/&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- defaults to <tt class="literal">1099</tt> --&gt;</span></i>
    &lt;property name="registryPort" value="1199"/&gt;
&lt;/bean&gt;</pre><p>As you can see, we're overriding the port for the RMI registry. Often,
      your application server also maintains an RMI registry and it is wise
      to not interfere with that one. Furthermore, the service name is used to bind the
      service under. So right now, the service will be bound at
      <tt class="literal">'rmi://HOST:1199/AccountService'</tt>. We'll use the URL later on to
      link in the service at the client side.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The <tt class="literal">servicePort</tt> property has been omitted (it defaults to 0).
        This means that an anonymous port will be used to communicate with the service.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-rmi-client"></a>17.2.2.&nbsp;Linking in the service at the client</h3></div></div><div></div></div><p>Our client is a simple object using the <tt class="interfacename">AccountService</tt>
      to manage accounts:</p><pre class="programlisting">public class SimpleObject {

    private AccountService accountService;

    public void setAccountService(AccountService accountService) {
        this.accountService = accountService;
    }
}</pre><p>To link in the service on the client, we'll create a separate Spring container,
			containing the simple object and the service linking configuration bits:</p><pre class="programlisting">&lt;bean class="example.SimpleObject"&gt;
    &lt;property name="accountService" ref="accountService"/&gt;
&lt;/bean&gt;

&lt;bean id="accountService" class="org.springframework.remoting.rmi.RmiProxyFactoryBean"&gt;
    &lt;property name="serviceUrl" value="rmi://HOST:1199/AccountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</pre><p>That's all we need to do to support the remote account service on the client.
      Spring will transparently create an invoker and remotely enable the account
      service through the <tt class="classname">RmiServiceExporter</tt>. At the client
      we're linking it in using the <tt class="classname">RmiProxyFactoryBean</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remoting-caucho-protocols"></a>17.3.&nbsp;Using Hessian or Burlap to remotely call services via HTTP</h2></div></div><div></div></div><p>Hessian offers a binary HTTP-based remoting protocol. It is developed by
    Caucho and more information about Hessian itself can be found at
    <a href="http://www.caucho.com" target="_top">http://www.caucho.com</a>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-caucho-protocols-hessian"></a>17.3.1.&nbsp;Wiring up the <tt class="classname">DispatcherServlet</tt> for Hessian and co.</h3></div></div><div></div></div><p>Hessian communicates via HTTP and does so using a custom servlet.
			Using Spring's <tt class="classname">DispatcherServlet</tt> principles, as known
      from Spring Web MVC usage, you can easily  wire up such a servlet exposing
      your services. First we'll have to create a new servlet in your application
      (this an excerpt from <tt class="filename">'web.xml'</tt>):</p><pre class="programlisting">&lt;servlet&gt;
    &lt;servlet-name&gt;remoting&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;remoting&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/remoting/*&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre><p>You're probably familiar with Spring's <tt class="classname">DispatcherServlet</tt>
      principles and if so, you know that now you'll have to create a Spring container
      configuration resource named <tt class="filename">'remoting-servlet.xml'</tt> (after
      the name of your servlet) in the <tt class="filename">'WEB-INF'</tt>
      directory. The application context will be used	in the next section.</p><p>Alternatively, consider the use of Spring's simpler
      <tt class="classname">HttpRequestHandlerServlet</tt>.
      This allows you to embed the remote exporter definitions in your root application
      context (by default in <tt class="filename">'WEB-INF/applicationContext.xml'</tt>),
      with individual servlet definitions pointing to specific exporter beans.
      Each servlet name needs to match the bean name of its target exporter in this case.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-caucho-protocols-hessian-server"></a>17.3.2.&nbsp;Exposing your beans by using the <tt class="classname">HessianServiceExporter</tt></h3></div></div><div></div></div><p>In the newly created application context called <tt class="literal">remoting-servlet.xml</tt>,
      we'll create a <tt class="classname">HessianServiceExporter</tt> exporting your services:</p><pre class="programlisting">&lt;bean id="accountService" class="example.AccountServiceImpl"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- any additional properties, maybe a DAO? --&gt;</span></i>
&lt;/bean&gt;

&lt;bean name="/AccountService" class="org.springframework.remoting.caucho.HessianServiceExporter"&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</pre><p>Now we're ready to link in the service at the client. No explicit handler mapping
      is specified, mapping request URLs onto services, so <tt class="classname">BeanNameUrlHandlerMapping</tt>
      will be used: Hence, the service will be exported at the URL indicated through
      its bean name within the containing <tt class="classname">DispatcherServlet</tt>'s
      mapping (as defined above): <tt class="literal">'http://HOST:8080/remoting/AccountService'</tt>.
      </p><p>Alternatively, create a <tt class="classname">HessianServiceExporter</tt> in your
      root application context (e.g. in <tt class="filename">'WEB-INF/applicationContext.xml'</tt>):</p><pre class="programlisting">&lt;bean name="accountExporter" class="org.springframework.remoting.caucho.HessianServiceExporter"&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</pre><p>In the latter case, define a corresponding servlet for this exporter
      in <tt class="filename">'web.xml'</tt>, with the same end result: The exporter
      getting mapped to the request path <tt class="literal">/remoting/AccountService</tt>.
      Note that the servlet name needs to match the bean name of the target exporter.</p><pre class="programlisting">&lt;servlet&gt;
    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.context.support.HttpRequestHandlerServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/remoting/AccountService&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-caucho-protocols-hessian-client"></a>17.3.3.&nbsp;Linking in the service on the client</h3></div></div><div></div></div><p>Using the <tt class="classname"></tt> we can link in the service
      at the client. The same principles apply as with the RMI example. We'll create
      a separate bean factory or application context and mention the following beans
      where the <tt class="classname">SimpleObject</tt> is using the
      <tt class="interfacename">AccountService</tt> to manage accounts:</p><pre class="programlisting">&lt;bean class="example.SimpleObject"&gt;
    &lt;property name="accountService" ref="accountService"/&gt;
&lt;/bean&gt;

&lt;bean id="accountService" class="org.springframework.remoting.caucho.HessianProxyFactoryBean"&gt;
    &lt;property name="serviceUrl" value="http://remotehost:8080/remoting/AccountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-caucho-protocols-burlap"></a>17.3.4.&nbsp;Using Burlap</h3></div></div><div></div></div><p>We won't discuss Burlap, the XML-based equivalent of Hessian, in detail here,
      since it is configured and set up in exactly the same way as the Hessian
      variant explained above. Just replace the word <tt class="literal">Hessian</tt>
      with <tt class="literal">Burlap</tt> and you're all set to go.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-caucho-protocols-security"></a>17.3.5.&nbsp;Applying HTTP basic authentication to a service exposed through Hessian or Burlap</h3></div></div><div></div></div><p>One of the advantages of Hessian and Burlap is that we can easily apply HTTP basic
      authentication, because both protocols are HTTP-based. Your normal HTTP server security
      mechanism can easily be applied through using the <tt class="literal">web.xml</tt> security
      features, for example. Usually, you don't use per-user security credentials here, but
      rather shared credentials defined at the <tt class="literal">Hessian/BurlapProxyFactoryBean</tt> level
      (similar to a JDBC <tt class="interfacename">DataSource</tt>).</p><pre class="programlisting">&lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;
    &lt;property name="interceptors" ref="authorizationInterceptor"/&gt;
&lt;/bean&gt;

&lt;bean id="authorizationInterceptor" 
      class="org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor"&gt;
    &lt;property name="authorizedRoles" value="administrator,operator"/&gt;
&lt;/bean&gt;</pre><p>This an example where we explicitly mention the <tt class="classname">BeanNameUrlHandlerMapping</tt>
      and set an interceptor allowing only administrators and operators to call
      the beans mentioned in this application context.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Of course, this example doesn't show a flexible kind of security
        infrastructure. For more options as far as security is concerned,
        have a look at the Acegi Security System for Spring, to be found at
        <a href="http://acegisecurity.sourceforge.net" target="_top">http://acegisecurity.sourceforge.net</a>.</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remoting-httpinvoker"></a>17.4.&nbsp;Exposing services using HTTP invokers</h2></div></div><div></div></div><p>As opposed to Burlap and Hessian, which are both lightweight protocols using their
		own slim serialization mechanisms, Spring Http invokers use the standard
		Java serialization mechanism to expose services through HTTP. This has a huge
		advantage if your arguments and return types are complex types that cannot be
		serialized using the serialization mechanisms Hessian and Burlap use (refer to the
		next section for more considerations when choosing a remoting technology).</p><p>Under the hood, Spring uses either the standard facilities provided by J2SE to
		perform HTTP calls or Commons <tt class="classname">HttpClient</tt>. Use the latter if you need more advanced
		and easy-to-use functionality. Refer to 
		<a href="http://jakarta.apache.org/commons/httpclient" target="_top">jakarta.apache.org/commons/httpclient</a>
		for more info.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-httpinvoker-server"></a>17.4.1.&nbsp;Exposing the service object</h3></div></div><div></div></div><p>Setting up the HTTP invoker infrastructure for a service objects much resembles
			the way you would do using Hessian or Burlap. Just as Hessian support provides
			the <tt class="classname">HessianServiceExporter</tt>, Spring's HttpInvoker support provides
			the <tt class="classname">org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter</tt>.
      </p><p>To expose the <tt class="literal">AccountService</tt> (mentioned above) within a
      Spring Web MVC <tt class="classname">DispatcherServlet</tt>, the following configuration
      needs to be in place in the dispatcher's application context:</p><pre class="programlisting">&lt;bean name="/AccountService" class="org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter"&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;
</pre><p>Such an exporter definition will be exposed through the
      <tt class="classname">DispatcherServlet</tt>'s standard mapping facilities,
      as explained in the section on Hessian.</p><p>Alternatively, create an <tt class="classname">HttpInvokerServiceExporter</tt> in your
      root application context (e.g. in <tt class="filename">'WEB-INF/applicationContext.xml'</tt>):</p><pre class="programlisting">&lt;bean name="accountExporter" class="org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter"&gt;
    &lt;property name="service" ref="accountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;</pre><p>In addition, define a corresponding servlet for this exporter in
      <tt class="filename">'web.xml'</tt>, with the servlet name matching the bean
      name of the target exporter:</p><pre class="programlisting">&lt;servlet&gt;
    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.context.support.HttpRequestHandlerServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;accountExporter&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/remoting/AccountService&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-httpinvoker-client"></a>17.4.2.&nbsp;Linking in the service at the client</h3></div></div><div></div></div><p>Again, linking in the service from the client much resembles the way you would
      do it when using Hessian or Burlap. Using a proxy, Spring will be able to
      translate your calls to HTTP POST requests to the URL pointing to the exported
      service.</p><pre class="programlisting">&lt;bean id="httpInvokerProxy" class="org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"&gt;
    &lt;property name="serviceUrl" value="http://remotehost:8080/remoting/AccountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
&lt;/bean&gt;
</pre><p>As mentioned before, you can choose what HTTP client you want to use.
      By default, the <tt class="classname">HttpInvokerProxy</tt> uses the J2SE HTTP functionality, but
      you can also use the Commons <tt class="classname">HttpClient</tt> by setting the
      <tt class="literal">httpInvokerRequestExecutor</tt> property:</p><pre class="programlisting">&lt;property name="httpInvokerRequestExecutor"&gt;
    &lt;bean class="org.springframework.remoting.httpinvoker.CommonsHttpInvokerRequestExecutor"/&gt;
&lt;/property&gt;
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remoting-web-services"></a>17.5.&nbsp;Web services</h2></div></div><div></div></div><p>Spring provides full support for standard Java web services APIs:</p><div class="itemizedlist"><ul type="disc"><li><p>Exposing web services using JAX-RPC</p></li><li><p>Accessing web services using JAX-RPC</p></li><li><p>Exposing web services using JAX-WS</p></li><li><p>Accessing web services using JAX-WS</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Why two standard Java web services APIs?</p><p>JAX-RPC 1.1 is the standard web service API in J2EE 1.4.
      As its name indicates, it focuses on on RPC bindings, which became
      less and less popular in the past couple of years. As a consequence,
      it has been superseded by JAX-WS 2.0 in Java EE 5, being more flexible
      in terms of bindings but also being heavily annotation-based. JAX-WS 2.1
      is also included in Java 6 (or more specifically, in Sun's JDK 1.6.0_04
      and above; previous Sun JDK 1.6.0 releases included JAX-WS 2.0),
      integrated with the JDK's built-in HTTP server.</p><p>Spring can work with both standard Java web services APIs.
      The choice is effectively dependent on the runtime platform:
      On JDK 1.4 / J2EE 1.4, the only option is JAX-RPC. On Java EE 5 / Java 6,
      the obvious choice is JAX-WS. On J2EE 1.4 environments that run on Java 5,
      you might have the option to plug in a JAX-WS provider; check your J2EE
      server's documentation.</p></td></tr></table></div><p>In addition to stock support for JAX-RPC and JAX-WS in Spring Core, the Spring portfolio also
    features <a href="http://www.springframework.org/spring-ws" target="_top">Spring Web Services</a>, a solution
    for contract-first, document-driven web services - highly recommended for building modern, future-proof
    web services. Last but not least, <a href="http://xfire.codehaus.org" target="_top">XFire</a> also allows
    you to export Spring-managed beans as a web service, through built-in Spring support.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-web-services-jaxrpc-export"></a>17.5.1.&nbsp;Exposing servlet-based web services using JAX-RPC</h3></div></div><div></div></div><p>Spring provides a convenience base class for JAX-RPC servlet endpoint implementations -
      <tt class="classname">ServletEndpointSupport</tt>. To expose our
      <tt class="interfacename">AccountService</tt> we extend Spring's
      <tt class="classname">ServletEndpointSupport</tt> class and implement our business
      logic here, usually delegating the call to the business layer.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">/**
 * JAX-RPC compliant RemoteAccountService implementation that simply delegates
 * to the AccountService implementation in the root web application context.
 *
 * This wrapper class is necessary because JAX-RPC requires working with dedicated
 * endpoint classes. If an existing service needs to be exported, a wrapper that
 * extends ServletEndpointSupport for simple application context access is
 * the simplest JAX-RPC compliant way.
 *
 * This is the class registered with the server-side JAX-RPC implementation.
 * In the case of Axis, this happens in "server-config.wsdd" respectively via
 * deployment calls. The web service engine manages the lifecycle of instances
 * of this class: A Spring application context can just be accessed here.
 */</span></i>import org.springframework.remoting.jaxrpc.ServletEndpointSupport;

public class AccountServiceEndpoint extends ServletEndpointSupport implements RemoteAccountService {
    
    private AccountService biz;
	
    protected void onInit() {
        this.biz = (AccountService) getWebApplicationContext().getBean("accountService");
    }

    public void insertAccount(Account acc) throws RemoteException {
        biz.insertAccount(acc);
    }
  
    public Account[] getAccounts(String name) throws RemoteException {
        return biz.getAccounts(name);
    }
}</pre><p>Our <tt class="classname">AccountServletEndpoint</tt> needs to run in the same web
      application as the Spring context to allow for access to Spring's facilities. In case of
      Axis, copy the <tt class="classname">AxisServlet</tt> definition into your
      <tt class="filename">'web.xml'</tt>, and set up the endpoint in
      <tt class="filename">'server-config.wsdd'</tt> (or use the deploy tool).	See the sample
      application JPetStore where the <tt class="interfacename">OrderService</tt> is exposed as
      a web service using Axis.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-web-services-jaxrpc-access"></a>17.5.2.&nbsp;Accessing web services using JAX-RPC</h3></div></div><div></div></div><p>Spring provides two factory beans to create JAX-RPC web service proxies,
      namely <tt class="classname">LocalJaxRpcServiceFactoryBean</tt> and
      <tt class="classname">JaxRpcPortProxyFactoryBean</tt>. The former can only return a JAX-RPC
      service class for us to work with. The latter is the full-fledged version that can return
      a proxy that implements our business service interface. In this example we use the latter
      to create a proxy for the <tt class="interfacename">AccountService</tt> endpoint we exposed
      in the previous section. You will see that Spring has great support for web services
      requiring little coding efforts - most of the setup is done in the Spring configuration
      file as usual:</p><pre class="programlisting">&lt;bean id="accountWebService" class="org.springframework.remoting.jaxrpc.JaxRpcPortProxyFactoryBean"&gt;
    &lt;property name="serviceInterface" value="example.RemoteAccountService"/&gt;
    &lt;property name="wsdlDocumentUrl" value="http://localhost:8080/account/services/accountService?WSDL"/&gt;
    &lt;property name="namespaceUri" value="http://localhost:8080/account/services/accountService"/&gt;
    &lt;property name="serviceName" value="AccountService"/&gt;
    &lt;property name="portName" value="AccountPort"/&gt;
&lt;/bean&gt;</pre><p>Where <tt class="literal">serviceInterface</tt> is our remote business interface the clients will use.
      <tt class="literal">wsdlDocumentUrl</tt> is the URL for the WSDL file. Spring needs this a startup time to create the JAX-RPC Service.
      <tt class="literal">namespaceUri</tt> corresponds to the targetNamespace in the .wsdl file.
      <tt class="literal">serviceName</tt> corresponds to the service name in the .wsdl file.
      <tt class="literal">portName</tt> corresponds to the port name in the .wsdl file.
      </p><p>Accessing the web service is now very easy as we have a bean factory for it that will expose it
      as <tt class="literal">RemoteAccountService</tt> interface. We can wire this up in Spring:</p><pre class="programlisting">&lt;bean id="client" class="example.AccountClientImpl"&gt;
    ...
    &lt;property name="service" ref="accountWebService"/&gt;
&lt;/bean&gt;</pre><p>From the client code we can access the web service just as if it
      was a normal class, except that it throws <tt class="exceptionname">RemoteException</tt>.</p><pre class="programlisting">public class AccountClientImpl {

    private RemoteAccountService service;
    
    public void setService(RemoteAccountService service) {
        this.service = service;
    }
    
    public void foo() {
        try {
            service.insertAccount(...);
        }
        catch (RemoteException ex) {
            <i class="lineannotation"><span class="lineannotation">// ouch</span></i>
        }
    }
}
</pre><p>We can get rid of the checked <tt class="exceptionname">RemoteException</tt> since
      Spring supports automatic conversion to its corresponding unchecked
      <tt class="exceptionname">RemoteException</tt>. This requires that we provide a non-RMI
      interface also. Our configuration is now:</p><pre class="programlisting">&lt;bean id="accountWebService" class="org.springframework.remoting.jaxrpc.JaxRpcPortProxyFactoryBean"&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
    &lt;property name="portInterface" value="example.RemoteAccountService"/&gt;
&lt;/bean&gt;</pre><p>Where <tt class="literal">serviceInterface</tt> is changed to our non RMI interface. Our RMI
      interface is now defined using the property	<tt class="literal">portInterface</tt>. Our client
      code can now avoid handling <tt class="exceptionname">java.rmi.RemoteException</tt>:</p><pre class="programlisting">public class AccountClientImpl {

    private AccountService service;
    
    public void setService(AccountService service) {
        this.service = service;
    }
    
    public void foo() {
        service.insertAccount(...);
    }
}</pre><p>Note that you can also drop the "portInterface" part and specify a plain
      business interface as "serviceInterface". In this case,
      <tt class="classname">JaxRpcPortProxyFactoryBean</tt> will automatically switch
      to the JAX-RPC "Dynamic Invocation Interface", performing dynamic invocations
      without a fixed port stub. The advantage is that you don't even need to have
      an RMI-compliant Java port interface around (e.g. in case of a non-Java target
      web service); all you need is a matching business interface. Check out
      <tt class="classname">JaxRpcPortProxyFactoryBean</tt>'s javadoc for details
      on the runtime implications.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-web-services-jaxrpc-mapping-registration"></a>17.5.3.&nbsp;Registering JAX-RPC Bean Mappings</h3></div></div><div></div></div><p>To transfer complex objects over the wire such as <tt class="classname">Account</tt> we must
      register bean mappings on the client side.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>On the server side using Axis registering bean mappings is usually done in
        the <tt class="filename">'server-config.wsdd'</tt> file.</p></td></tr></table></div><p>We will use Axis to register bean mappings on the client side. To do this we need to
      register the bean mappings programmatically:</p><pre class="programlisting">public class AxisPortProxyFactoryBean extends JaxRpcPortProxyFactoryBean {

    protected void postProcessJaxRpcService(Service service) {
        TypeMappingRegistry registry = service.getTypeMappingRegistry();
        TypeMapping mapping = registry.createTypeMapping();
        registerBeanMapping(mapping, Account.class, "Account");
        registry.register("http://schemas.xmlsoap.org/soap/encoding/", mapping);
    }

    protected void registerBeanMapping(TypeMapping mapping, Class type, String name) {
        QName qName = new QName("http://localhost:8080/account/services/accountService", name);
        mapping.register(type, qName,
                new BeanSerializerFactory(type, qName),
                new BeanDeserializerFactory(type, qName));
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-web-services-jaxrpc-handler-registration"></a>17.5.4.&nbsp;Registering your own JAX-RPC Handler</h3></div></div><div></div></div><p>In this section we will register our own
      <tt class="interfacename">javax.rpc.xml.handler.Handler</tt> to the web service proxy
      where we can do custom code before the SOAP message is sent over the wire.
      The <tt class="interfacename">Handler</tt> is a callback interface. There is a convenience
      base class provided in <tt class="filename">jaxrpc.jar</tt>, namely
      <tt class="classname">javax.rpc.xml.handler.GenericHandler</tt> that we will extend:</p><pre class="programlisting">public class AccountHandler extends GenericHandler {

    public QName[] getHeaders() {
        return null;
    }

    public boolean handleRequest(MessageContext context) {
        SOAPMessageContext smc = (SOAPMessageContext) context;
        SOAPMessage msg = smc.getMessage();
        try {
            SOAPEnvelope envelope = msg.getSOAPPart().getEnvelope();
            SOAPHeader header = envelope.getHeader();
            ...
        }
        catch (SOAPException ex) {
            throw new JAXRPCException(ex);
        }
        return true;
    }
}</pre><p>What we need to do now is to register our AccountHandler to JAX-RPC Service so it would
      invoke <tt class="methodname">handleRequest(..)</tt> before the message is sent over the wire.
      Spring has at this time of writing no declarative support for registering handlers, so we must
      use the programmatic approach. However Spring has made it very easy for us to do this as we can
      override the <tt class="methodname">postProcessJaxRpcService(..)</tt> method that is designed for
      this:</p><pre class="programlisting">public class AccountHandlerJaxRpcPortProxyFactoryBean extends JaxRpcPortProxyFactoryBean {

    protected void postProcessJaxRpcService(Service service) {
        QName port = new QName(this.getNamespaceUri(), this.getPortName());
        List list = service.getHandlerRegistry().getHandlerChain(port);
        list.add(new HandlerInfo(AccountHandler.class, null, null));
        logger.info("Registered JAX-RPC AccountHandler on port " + port);
    }
}</pre><p>The last thing we must remember to do is to change the Spring configuration to use our
      factory bean:</p><pre class="programlisting">&lt;bean id="accountWebService" class="example.AccountHandlerJaxRpcPortProxyFactoryBean"&gt;
    ...
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-web-services-jaxws-export-servlet"></a>17.5.5.&nbsp;Exposing servlet-based web services using JAX-WS</h3></div></div><div></div></div><p>Spring provides a convenient base class for JAX-WS servlet endpoint implementations -
      <tt class="classname">SpringBeanAutowiringSupport</tt>. To expose our
      <tt class="interfacename">AccountService</tt> we extend Spring's
      <tt class="classname">SpringBeanAutowiringSupport</tt> class and implement our business
      logic here, usually delegating the call to the business layer.
      We'll simply use Spring 2.5's <tt class="literal">@Autowired</tt>
      annotation for expressing such dependencies on Spring-managed beans.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">/**
 * JAX-WS compliant AccountService implementation that simply delegates
 * to the AccountService implementation in the root web application context.
 *
 * This wrapper class is necessary because JAX-WS requires working with dedicated
 * endpoint classes. If an existing service needs to be exported, a wrapper that
 * extends SpringBeanAutowiringSupport for simple Spring bean autowiring (through
 * the @Autowired annotation) is the simplest JAX-WS compliant way.
 *
 * This is the class registered with the server-side JAX-WS implementation.
 * In the case of a Java EE 5 server, this would simply be defined as a servlet
 * in web.xml, with the server detecting that this is a JAX-WS endpoint and reacting
 * accordingly. The servlet name usually needs to match the specified WS service name.
 *
 * The web service engine manages the lifecycle of instances of this class.
 * Spring bean references will just be wired in here.
 */</span></i>import org.springframework.web.context.support.SpringBeanAutowiringSupport;

@WebService(serviceName="AccountService")
public class AccountServiceEndpoint extends SpringBeanAutowiringSupport {

    @Autowired
    private AccountService biz;

    @WebMethod
    public void insertAccount(Account acc) {
       biz.insertAccount(acc);
    }

    @WebMethod
    public Account[] getAccounts(String name) {
       return biz.getAccounts(name);
    }
}</pre><p>Our <tt class="classname">AccountServletEndpoint</tt> needs to run in the same web
      application as the Spring context to allow for access to Spring's facilities. This is
      the case by default in Java EE 5 environments, using the standard contract for JAX-WS
      servlet endpoint deployment. See Java EE 5 web service tutorials for details.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-web-services-jaxws-export-standalone"></a>17.5.6.&nbsp;Exporting standalone web services using JAX-WS</h3></div></div><div></div></div><p>The built-in JAX-WS provider that comes with Sun's JDK 1.6 supports exposure
      of web services using the built-in HTTP server that's included in JDK 1.6 as well.
      Spring's <tt class="classname">SimpleJaxWsServiceExporter</tt> detects all
      <tt class="literal">@WebService</tt> annotated beans in the Spring application context,
      exporting them through the default JAX-WS server (the JDK 1.6 HTTP server).</p><p>In this scenario, the endpoint instances are defined and managed as Spring beans
      themselves; they will be registered with the JAX-WS engine but their lifecycle
      will be up to the Spring application context. This means that Spring functionality
      like explicit dependency injection may be applied to the endpoint instances.
      Of course, annotation-driven injection through <tt class="literal">@Autowired</tt>
      will work as well.
      </p><pre class="programlisting">&lt;bean class="org.springframework.remoting.jaxws.SimpleJaxWsServiceExporter"&gt;
    &lt;property name="baseAddress" value="http://localhost:9999/"/&gt;
&lt;/bean&gt;

&lt;bean id="accountServiceEndpoint" class="example.AccountServiceEndpoint"&gt;
    ...
&lt;/bean&gt;

...</pre><p>The <tt class="classname">AccountServiceEndpoint</tt> may derive from
      Spring's <tt class="classname">SpringBeanAutowiringSupport</tt> but doesn't
      have to since the endpoint is a fully Spring-managed bean here.
      This means that the endpoint implementation may look like as follows,
      without any superclass declared - and Spring's <tt class="literal">@Autowired</tt>
			configuration annotation still being honored:</p><pre class="programlisting">@WebService(serviceName="AccountService")
public class AccountServiceEndpoint {

    @Autowired
    private AccountService biz;

    @WebMethod
    public void insertAccount(Account acc) {
       biz.insertAccount(acc);
    }

    @WebMethod
    public Account[] getAccounts(String name) {
       return biz.getAccounts(name);
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-web-services-jaxws-export-ri"></a>17.5.7.&nbsp;Exporting web services using the JAX-WS RI's Spring support</h3></div></div><div></div></div><p>Sun's JAX-WS RI, developed as part of the GlassFish project, ships Spring support
      as part of its JAX-WS Commons project. This allows for defining JAX-WS endpoints as
      Spring-managed beans, similar to the standalone mode discussed in the previous section
      - but this time in a Servlet environment. <span class="emphasis"><em>Note that this is not portable
      in a Java EE 5 environment; it is mainly intended for non-EE environments such as Tomcat,
      embedding the JAX-WS RI as part of the web application.</em></span></p><p>The difference to the standard style of exporting servlet-based endpoints is
      that the lifecycle of the endpoint instances themselves will be managed by Spring here,
      and that there will be only one JAX-WS servlet defined in <tt class="literal">web.xml</tt>.
      With the standard Java EE 5 style (as illustrated above), you'll have one servlet
      definition per service endpoint, with each endpoint typically delegating to Spring
      beans (through the use of <tt class="literal">@Autowired</tt>, as shown above).</p><p>Check out
      <a href="https://jax-ws-commons.dev.java.net/spring/" target="_top">https://jax-ws-commons.dev.java.net/spring/</a>
      for the details on setup and usage style.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-web-services-jaxws-access"></a>17.5.8.&nbsp;Accessing web services using JAX-WS</h3></div></div><div></div></div><p>Analogous to the JAX-RPC support, Spring provides two factory beans
      to create JAX-WS web service proxies, namely <tt class="classname">LocalJaxWsServiceFactoryBean</tt> and
      <tt class="classname">JaxWsPortProxyFactoryBean</tt>. The former can only return a JAX-WS
      service class for us to work with. The latter is the full-fledged version that can return
      a proxy that implements our business service interface. In this example we use the latter
      to create a proxy for the <tt class="interfacename">AccountService</tt> endpoint (again):
      </p><pre class="programlisting">&lt;bean id="accountWebService" class="org.springframework.remoting.jaxws.JaxWsPortProxyFactoryBean"&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt;
    &lt;property name="wsdlDocumentUrl" value="http://localhost:8080/account/services/accountService?WSDL"/&gt;
    &lt;property name="namespaceUri" value="http://localhost:8080/account/services/accountService"/&gt;
    &lt;property name="serviceName" value="AccountService"/&gt;
    &lt;property name="portName" value="AccountPort"/&gt;
&lt;/bean&gt;</pre><p>Where <tt class="literal">serviceInterface</tt> is our business interface the clients will use.
      <tt class="literal">wsdlDocumentUrl</tt> is the URL for the WSDL file. Spring needs this a startup time to create the JAX-WS Service.
      <tt class="literal">namespaceUri</tt> corresponds to the targetNamespace in the .wsdl file.
      <tt class="literal">serviceName</tt> corresponds to the service name in the .wsdl file.
      <tt class="literal">portName</tt> corresponds to the port name in the .wsdl file.
      </p><p>Accessing the web service is now very easy as we have a bean factory for it that will expose it
      as <tt class="literal">AccountService</tt> interface. We can wire this up in Spring:</p><pre class="programlisting">&lt;bean id="client" class="example.AccountClientImpl"&gt;
    ...
    &lt;property name="service" ref="accountWebService"/&gt;
&lt;/bean&gt;</pre><p>From the client code we can access the web service just as if it
      was a normal class:</p><pre class="programlisting">public class AccountClientImpl {

    private AccountService service;

    public void setService(AccountService service) {
        this.service = service;
    }

    public void foo() {
        service.insertAccount(...);
    }
}</pre><p><span class="emphasis"><em>NOTE:</em></span> The above is slightly simplified in that JAX-WS
      requires endpoint interfaces and implementation classes to be annotated with
      <tt class="literal">@WebService</tt>, <tt class="literal">@SOAPBinding</tt> etc annotations.
      This means that you cannot (easily) use plain Java interfaces and implementation
      classes as JAX-WS endpoint artifacts; you need to annotate them accordingly first.
      Check the JAX-WS documentation for details on those requirements.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-web-services-xfire"></a>17.5.9.&nbsp;Exposing web services using XFire</h3></div></div><div></div></div><p>XFire is a lightweight SOAP library, hosted by Codehaus. Exposing XFire is done using a
      XFire context that shipping with XFire itself in combination with a RemoteExporter-style bean
      you have to add to your <tt class="interfacename">WebApplicationContext</tt>. As with all
      methods that allow you to expose service, you have to create a
      <tt class="classname">DispatcherServlet</tt> with a corresponding
      <tt class="interfacename">WebApplicationContext</tt> containing the services you will be
      exposing:</p><pre class="programlisting">&lt;servlet&gt;
    &lt;servlet-name&gt;xfire&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;</pre><p>You also have to link in the XFire configuration. This is done by adding a context
      file to the <tt class="literal">contextConfigLocations</tt> context parameter picked up by the
      <tt class="classname">ContextLoaderListener</tt> (or <tt class="classname">ContextLoaderServlet</tt>
      for that matter).</p><pre class="programlisting">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath:org/codehaus/xfire/spring/xfire.xml&lt;/param-value&gt;
&lt;/context-param&gt;

&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;</pre><p>After you added a servlet mapping (mapping <tt class="literal">/*</tt> to the XFire servlet
      declared above) you only have to add one extra bean to expose the service using XFire.
      Add for example the following configuration in your <tt class="filename">'xfire-servlet.xml'</tt>
      file:</p><pre class="programlisting">&lt;beans&gt;

    &lt;bean name="/Echo" class="org.codehaus.xfire.spring.remoting.XFireExporter"&gt;
        &lt;property name="serviceInterface" value="org.codehaus.xfire.spring.Echo"/&gt;
        &lt;property name="serviceBean"&gt;
    	       &lt;bean class="org.codehaus.xfire.spring.EchoImpl"/&gt;
        &lt;/property&gt;
        <i class="lineannotation"><span class="lineannotation">&lt;!-- the XFire bean is defined in the <tt class="filename">xfire.xml</tt> file --&gt;</span></i>
        &lt;property name="xfire" ref="xfire"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>XFire handles the rest. It introspects your service interface and generates a WSDL from it.
      Parts of this documentation have been taken from the XFire site; for more detailed information
      on XFire Spring integration, navigate to
      <a href="http://docs.codehaus.org/display/XFIRE/Spring" target="_top">http://docs.codehaus.org/display/XFIRE/Spring</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remoting-jms"></a>17.6.&nbsp;JMS</h2></div></div><div></div></div><p>It is also possible to expose services transparently using JMS as the underlying
    communication protocol. The JMS remoting support in the Spring Framework is pretty basic -
    it sends and receives on the <tt class="interfacename">same thread</tt> and in the
    <span class="emphasis"><em>same non-transactional</em></span> <tt class="interfacename">Session</tt>, and as
    such throughput will be very implementation dependent.</p><p>The following interface is used on both the server and the client side.</p><pre class="programlisting">package com.foo;

public interface CheckingAccountService {

    public void cancelAccount(Long accountId);
}</pre><p>The following simple implementation of the above interface is used on the server-side.</p><pre class="programlisting">package com.foo;

public class SimpleCheckingAccountService implements CheckingAccountService {

    public void cancelAccount(Long accountId) {
        System.out.println("Cancelling account [" + accountId + "]");
    }
}</pre><p>This configuration file contains the JMS-infrastructure beans that are shared on both
    the client and server.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

    &lt;bean id="connectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
        &lt;property name="brokerURL" value="tcp://ep-t43:61616"/&gt;
    &lt;/bean&gt;

    &lt;bean id="queue" class="org.apache.activemq.command.ActiveMQQueue"&gt;
        &lt;constructor-arg value="mmm"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-jms-server"></a>17.6.1.&nbsp;Server-side configuration</h3></div></div><div></div></div><p>On the server, you just need to expose the service object using the
      <tt class="classname">JmsInvokerServiceExporter</tt>.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.springframework.org/schema/beans
         http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

    &lt;bean id="checkingAccountService"
          class="org.springframework.jms.remoting.JmsInvokerServiceExporter"&gt;
        &lt;property name="serviceInterface" value="com.foo.CheckingAccountService"/&gt;
        &lt;property name="service"&gt;
            &lt;bean class="com.foo.SimpleCheckingAccountService"/&gt;
        &lt;/property&gt;
   &lt;/bean&gt;

   &lt;bean class="org.springframework.jms.listener.SimpleMessageListenerContainer"&gt;
       &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
       &lt;property name="destination" ref="queue"/&gt;
       &lt;property name="concurrentConsumers" value="3"/&gt;
       &lt;property name="messageListener" ref="checkingAccountService"/&gt;
   &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">package com.foo;

import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Server {

    public static void main(String[] args) throws Exception {
        new ClassPathXmlApplicationContext(new String[]{"com/foo/server.xml", "com/foo/jms.xml"});
    }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="remoting-jms-client"></a>17.6.2.&nbsp;Client-side configuration</h3></div></div><div></div></div><p>The client merely needs to create a client-side proxy that will implement the agreed
      upon interface (<tt class="interfacename">CheckingAccountService</tt>). The resulting
      object created off the back of the following bean definition can be injected into other
      client side objects, and the proxy will take care of forwarding the call to the
      server-side object via JMS.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

    &lt;bean id="checkingAccountService"
          class="org.springframework.jms.remoting.JmsInvokerProxyFactoryBean"&gt;
        &lt;property name="serviceInterface" value="com.foo.CheckingAccountService"/&gt;
        &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
        &lt;property name="queue" ref="queue"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><pre class="programlisting">package com.foo;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Client {

    public static void main(String[] args) throws Exception {
        ApplicationContext ctx = new ClassPathXmlApplicationContext(
                new String[] {"com/foo/client.xml", "com/foo/jms.xml"});
        CheckingAccountService service = (CheckingAccountService) ctx.getBean("checkingAccountService");
        service.cancelAccount(new Long(10));
    }
}</pre></div><p>You may also wish to investigate the support provided by the
    <a href="http://lingo.codehaus.org/" target="_top">Lingo</a> project, which (to quote the
    homepage blurb) &#8220;<span class="quote"><span class="emphasis"><em>... is a lightweight POJO based remoting and messaging library
    based on the Spring Framework's remoting libraries which extends it to support JMS.</em></span></span>&#8221;</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remoting-autodection-remote-interfaces"></a>17.7.&nbsp;Auto-detection is not implemented for remote interfaces</h2></div></div><div></div></div><p>The main reason why auto-detection of implemented interfaces does not occur for
    remote interfaces is to avoid opening too many doors to remote callers. The target
    object might implement internal callback interfaces like <tt class="interfacename">InitializingBean</tt> or
    <tt class="interfacename">DisposableBean</tt> which one would not want to expose to callers.
    </p><p>Offering a proxy with all interfaces implemented by the target usually does not
    matter in the local case. But when exporting a remote service, you should expose
    a specific service interface, with specific operations intended for remote usage.
    Besides internal callback interfaces, the target might implement multiple business
    interfaces, with just one of them intended for remote exposure. For these reasons,
    we <span class="emphasis"><em>require</em></span> such a service interface to be specified.
    </p><p>This is a trade-off between configuration convenience and the risk of accidental
    exposure of internal methods. Always specifying a service interface is not too much
    effort, and puts you on the safe side regarding controlled exposure of specific methods.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="remoting-considerations"></a>17.8.&nbsp;Considerations when choosing a technology</h2></div></div><div></div></div><p>Each and every technology presented here has its drawbacks. You should carefully
    consider you needs, the services your exposing and the objects you'll be sending
    over the wire when choosing a technology.
    </p><p>When using RMI, it's not possible to access the objects through the HTTP protocol,
    unless you're tunneling the RMI traffic. RMI is a fairly heavy-weight protocol
    in that it support full-object serialization which is important when using a
    complex data model that needs serialization over the wire. However, RMI-JRMP
    is tied to Java clients: It is a Java-to-Java remoting solution.
    </p><p>Spring's HTTP invoker is a good choice if you need HTTP-based remoting but also
    rely on Java serialization. It shares the basic infrastructure with RMI invokers,
    just using HTTP as transport. Note that HTTP invokers are not only limited to
    Java-to-Java remoting but also to Spring on both the client and server side.
    (The latter also applies to Spring's RMI invoker for non-RMI interfaces.)
    </p><p>Hessian and/or Burlap might provide significant value when operating in a
    heterogeneous environment, because they explicitly allow for non-Java clients.
    However, non-Java support is still limited. Known issues include the serialization
    of Hibernate objects in combination with lazily-initialized collections. If you
    have such a data model, consider using RMI or HTTP invokers instead of Hessian.
    </p><p>JMS can be useful for providing clusters of services and allowing the JMS broker
    to take care of load balancing, discovery and auto-failover.
    By default: Java serialization is used when using JMS remoting but
    the JMS provider could use a different mechanism for the wire formatting,
    such as XStream to allow servers to be implemented in other technologies.
    </p><p>Last but not least, EJB has an advantage over RMI in that it supports standard
    role-based authentication and authorization and remote transaction propagation.
    It is possible to get RMI invokers or HTTP invokers to support security context
    propagation as well, although this is not provided by core Spring: There are
    just appropriate hooks for plugging in third-party or custom solutions here.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="ejb"></a>Chapter&nbsp;18.&nbsp;Enterprise Java Beans (EJB) integration</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ejb-introduction"></a>18.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
      As a lightweight container, Spring is often considered an EJB
      replacement. We do believe that for many if not most applications and use
      cases, Spring as a container, combined with its rich supporting
      functionality in the area of transactions, ORM and JDBC access, is a better
      choice than implementing equivalent functionality via an EJB container and
      EJBs.
      </p><p>
      However, it is important to note that using Spring does not prevent
      you from using EJBs. In fact, Spring makes it much easier to access EJBs and
      implement EJBs and functionality within them. Additionally, using Spring to
      access services provided by EJBs allows the implementation of those services
      to later transparently be switched between local EJB, remote EJB, or POJO
      (plain old Java object) variants, without the client code having to
      be changed.
      </p><p>
      In this chapter, we look at how Spring can help you access and
      implement EJBs. Spring provides particular value when accessing stateless
      session beans (SLSBs), so we'll begin by discussing this.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ejb-access"></a>18.2.&nbsp;Accessing EJBs</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ejb-access-concepts"></a>18.2.1.&nbsp;Concepts</h3></div></div><div></div></div><p>
				To invoke a method on a local or remote stateless session bean,
				client code must normally perform a JNDI lookup to obtain the (local or
				remote) EJB Home object, then use a 'create' method call on that object
				to obtain the actual (local or remote) EJB object. One or more methods
				are then invoked on the EJB.
      </p><p>
				To avoid repeated low-level code, many EJB applications use the
				Service Locator and Business Delegate patterns. These are better than
				spraying JNDI lookups throughout client code, but their usual
				implementations have significant disadvantages. For example:
            </p><div class="itemizedlist"><ul type="disc"><li><p>
						Typically code using EJBs depends on Service Locator or
						Business Delegate singletons, making it hard to test.
					</p></li><li><p>
						In the case of the Service Locator pattern used without a
						Business Delegate, application code still ends up having to invoke
						the create() method on an EJB home, and deal with the resulting
						exceptions. Thus it remains tied to the EJB API and the complexity
						of the EJB programming model.
					</p></li><li><p>
						Implementing the Business Delegate pattern typically results
						in significant code duplication, where we have to write numerous
						methods that simply call the same method on the EJB.
					</p></li></ul></div><p>
				The Spring approach is to allow the creation and use of proxy objects,
				normally configured inside a Spring container, which act as codeless
				business delegates. You do not need	to write another Service Locator, another
				JNDI lookup, or duplicate methods in a hand-coded Business Delegate unless
				you are actually adding real value in such code.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ejb-access-local"></a>18.2.2.&nbsp;Accessing local SLSBs</h3></div></div><div></div></div><p>
				Assume that we have a web controller that needs to use a local
				EJB. We&#8217;ll follow best practice and use the EJB Business Methods
				Interface pattern, so that the EJB&#8217;s local interface extends a non
				EJB-specific business methods interface. Let&#8217;s call this business
				methods interface <tt class="classname">MyComponent</tt>.
			</p><pre class="programlisting">public interface MyComponent {
    ...
}</pre><p>
				One of the main reasons to use the Business Methods Interface pattern
				is to ensure that synchronization between method signatures in local
				interface and bean implementation class is automatic. Another reason is
				that it later makes it much easier for us to switch to a POJO (plain old
				Java object) implementation of the service if it makes sense to do so.
				Of course we&#8217;ll also need to implement the local home interface and
				provide an implementation class that implements <tt class="classname">SessionBean</tt>
				and the <tt class="classname">MyComponent</tt> business methods interface. Now the
				only Java coding we&#8217;ll  need to do to hook up our web tier controller to the
				EJB implementation is to expose a setter method of type <tt class="classname">MyComponent</tt>
				on the controller. This will save the reference as an instance variable in the
				controller:
			</p><pre class="programlisting">private MyComponent myComponent;

public void setMyComponent(MyComponent myComponent) {
    this.myComponent = myComponent;
}</pre><p>
				We can subsequently use this instance variable in any business
				method in the controller. Now assuming we are obtaining our controller
				object out of a Spring container, we can (in the same context) configure a
				<tt class="classname">LocalStatelessSessionProxyFactoryBean</tt> instance, which
				will be the EJB proxy object. The configuration of the proxy, and setting of
				the <tt class="literal">myComponent</tt> property of the controller is done
				with a configuration entry such as:
			</p><pre class="programlisting">&lt;bean id="myComponent"
      class="org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean"&gt;
  &lt;property name="jndiName" value="ejb/myBean"/&gt;
  &lt;property name="businessInterface" value="com.mycom.MyComponent"/&gt;
&lt;/bean&gt;

&lt;bean id="myController" class="com.mycom.myController"&gt;
  &lt;property name="myComponent" ref="myComponent"/&gt;
&lt;/bean&gt;</pre><p>
				There&#8217;s a lot of work happening behind the scenes, courtesy of
				the Spring AOP framework, although you aren&#8217;t forced to work with AOP
				concepts to enjoy the results. The <tt class="literal">myComponent</tt> bean
				definition creates a proxy for the EJB, which implements the business
				method interface. The EJB local home is cached on startup, so there&#8217;s
				only a single JNDI lookup. Each time the EJB is invoked, the proxy
				invokes the <tt class="literal">classname</tt> method on the local EJB and
				invokes the	corresponding business method on the EJB.
			</p><p>
				The <tt class="literal">myController</tt> bean definition sets the
				<tt class="literal">myComponent</tt> property of the controller class to the
				EJB proxy.
			</p><p>
        Alternatively (and preferably in case of many such proxy definitions),
        consider using the <tt class="literal">&lt;jee:local-slsb&gt;</tt>
        configuration element in Spring's "jee" namespace:
      </p><pre class="programlisting">&lt;jee:local-slsb id="myComponent" jndi-name="ejb/myBean"
      business-interface="com.mycom.MyComponent"/&gt;

&lt;bean id="myController" class="com.mycom.myController"&gt;
  &lt;property name="myComponent" ref="myComponent"/&gt;
&lt;/bean&gt;</pre><p>
				This EJB access mechanism delivers huge simplification of
				application code: the web tier code (or other EJB client code) has no
				dependence on the use of EJB. If we want to replace this EJB reference
				with a POJO or a mock object or other test stub, we could simply change
				the <tt class="literal">myComponent</tt> bean definition without changing a
				line of Java code. Additionally, we haven&#8217;t had to write a single line of
				JNDI lookup or other EJB plumbing code as part of our application.
			</p><p>
				Benchmarks and experience in real applications indicate that the
				performance overhead of this approach (which involves reflective
				invocation of the target EJB) is minimal, and is typically undetectable
				in typical use. Remember that we don&#8217;t want to make fine-grained calls
				to EJBs anyway, as there&#8217;s a cost associated with the EJB infrastructure
				in the application server.
			</p><p>
				There is one caveat with regards to the JNDI lookup. In a bean
				container, this class is normally best used as a singleton (there simply
				is no reason to make it a prototype). However, if that bean container
				pre-instantiates singletons (as do the various XML
				<tt class="classname">ApplicationContext</tt> variants)
				you may have a problem if the bean container is loaded before the EJB
				container loads the target EJB. That is because the JNDI lookup will be
				performed in the <tt class="literal">init()</tt> method of this class and then
				cached, but the EJB will not have been bound at the target location yet.
				The solution is to not pre-instantiate this factory object, but allow it
				to be created on first use. In the XML containers, this is controlled via
				the <tt class="literal">lazy-init</tt> attribute.
			</p><p>
				Although this will not be of interest to the majority of Spring
				users, those doing programmatic AOP work with EJBs may want to look at
				<tt class="classname">LocalSlsbInvokerInterceptor</tt>.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ejb-access-remote"></a>18.2.3.&nbsp;Accessing remote SLSBs</h3></div></div><div></div></div><p>
				Accessing remote EJBs is essentially identical to accessing local
				EJBs, except that the
				<tt class="classname">SimpleRemoteStatelessSessionProxyFactoryBean</tt> or
        <tt class="literal">&lt;jee:remote-slsb&gt;</tt> configuration element is used.
				Of course, with or without Spring, remote invocation semantics apply; a
				call to a method on an object in another VM in another computer does
				sometimes have to be treated differently in terms of usage scenarios and
				failure handling.
			</p><p>
				Spring's EJB client support adds one more advantage over the
				non-Spring approach. Normally it is problematic for EJB client code to
				be easily switched back and forth between calling EJBs locally or
				remotely. This is because the remote interface methods must declare that
				they throw <tt class="classname">RemoteException</tt>, and client code must deal
				with this, while the local interface methods don't. Client code
				written for local EJBs which needs to be moved to remote EJBs
				typically has to be modified to add handling for the remote exceptions,
				and client code written for remote EJBs which needs to be moved to local
				EJBs, can either stay the same but do a lot of unnecessary handling of
				remote exceptions, or needs to be modified to remove that code. With the
				Spring remote EJB proxy, you can instead not declare any thrown
				<tt class="classname">RemoteException</tt> in your Business Method Interface and
				implementing EJB code, have a remote interface which is identical except
				that it does throw <tt class="classname">RemoteException</tt>, and rely on the
				proxy to dynamically treat the two interfaces as if they were the same.
				That is, client code does not have to deal with the checked
				<tt class="classname">RemoteException</tt> class. Any actual
				<tt class="classname">RemoteException</tt> that is thrown during the EJB
				invocation will be re-thrown as the non-checked
				<tt class="classname">RemoteAccessException</tt> class, which is a subclass of
				<tt class="classname">RuntimeException</tt>. The target service can then be
				switched at will between a local EJB or remote EJB (or even plain Java
				object) implementation, without the client code knowing or caring. Of
				course, this is optional; there is nothing stopping you from declaring
				<tt class="classname">RemoteExceptions</tt> in your business interface.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ejb-access-ejb2-ejb3"></a>18.2.4.&nbsp;Accessing EJB 2.x SLSBs versus EJB 3 SLSBs</h3></div></div><div></div></div><p>
        Accessing EJB 2.x Session Beans and EJB 3 Session Beans via Spring
        is largely transparent. Spring's EJB accessors, including the
        <tt class="literal">&lt;jee:local-slsb&gt;</tt> and <tt class="literal">&lt;jee:remote-slsb&gt;</tt>
        facilities, transparently adapt to the actual component at runtime.
        They handle a home interface if found (EJB 2.x style), or perform straight
        component invocations if no home interface is available (EJB 3 style).
      </p><p>
        Note: For EJB 3 Session Beans, you could effectively use a
        <tt class="classname">JndiObjectFactoryBean</tt> / <tt class="literal">&lt;jee:jndi-lookup&gt;</tt>
        as well, since fully usable component references are exposed for plain
        JNDI lookups there. Defining explicit <tt class="literal">&lt;jee:local-slsb&gt;</tt>
        / <tt class="literal">&lt;jee:remote-slsb&gt;</tt> lookups simply provides
        consistent and more explicit EJB access configuration.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ejb-implementation"></a>18.3.&nbsp;Using Spring's EJB implementation support classes</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ejb-implementation-ejb2"></a>18.3.1.&nbsp;EJB 2.x base classes</h3></div></div><div></div></div><p>
        Spring provides convenience classes to help you implement EJBs.
        These are designed to encourage the good practice of putting business
        logic behind EJBs in POJOs, leaving EJBs responsible for transaction
        demarcation and (optionally) remoting.
      </p><p>
        To implement a Stateless or Stateful session bean, or a Message Driven
        bean, you need only derive your implementation class from
        <tt class="classname">AbstractStatelessSessionBean</tt>,
        <tt class="classname">AbstractStatefulSessionBean</tt>, and
        <tt class="classname">AbstractMessageDrivenBean</tt>/<tt class="classname">AbstractJmsMessageDrivenBean</tt>,
        respectively.
      </p><p>
        Consider an example Stateless Session bean which actually delegates
        the implementation to a plain java service object. We have the business	interface:
      </p><pre class="programlisting">public interface MyComponent {
    public void myMethod(...);
    ...
}</pre><p>We also have the plain Java implementation object:</p><pre class="programlisting">public class MyComponentImpl implements MyComponent {
    public String myMethod(...) {
        ...
    }
    ...
}</pre><p>And finally the Stateless Session Bean itself:</p><pre class="programlisting">public class MyFacadeEJB extends AbstractStatelessSessionBean
        implements MyFacadeLocal {

    private MyComponent myComp;

    /**
     * Obtain our POJO service object from the BeanFactory/ApplicationContext
     * @see org.springframework.ejb.support.AbstractStatelessSessionBean#onEjbCreate()
     */
    protected void onEjbCreate() throws CreateException {
        myComp = (MyComponent) getBeanFactory().getBean(
            ServicesConstants.CONTEXT_MYCOMP_ID);
    }

    // for business method, delegate to POJO service impl.
    public String myFacadeMethod(...) {
        return myComp.myMethod(...);
    }
    ...
}</pre><p>
        The Spring EJB support base classes will by default create and load
        a Spring IoC container as part of their lifecycle, which is then available
        to the EJB (for example, as used in the code above to obtain the POJO
        service object). The loading is	done via a strategy object which is a subclass of
        <tt class="classname">BeanFactoryLocator</tt>. The actual implementation of
        <tt class="classname">BeanFactoryLocator</tt> used by default is
        <tt class="classname">ContextJndiBeanFactoryLocator</tt>, which creates the
        ApplicationContext from a resource locations specified as a JNDI
        environment variable (in the case of the EJB classes, at
        <tt class="literal">java:comp/env/ejb/BeanFactoryPath</tt>). If there is a need
        to change the BeanFactory/ApplicationContext loading strategy, the default
        <tt class="classname">BeanFactoryLocator</tt> implementation used may be overridden
        by calling the <tt class="literal">setBeanFactoryLocator()</tt> method, either
        in <tt class="literal">setSessionContext()</tt>, or in the actual constructor of
        the EJB. Please see the Javadocs for more details.
      </p><p>
        As described in the Javadocs, Stateful Session beans expecting to be
        passivated and reactivated as part of their lifecycle, and which use a
        non-serializable container instance (which is the normal case) will have
        to manually call <tt class="literal">unloadBeanFactory()</tt> and
        <tt class="literal">loadBeanFactory</tt> from <tt class="literal">ejbPassivate</tt>
        and <tt class="literal">ejbActivate</tt>, respectively, to unload and reload the
        BeanFactory on passivation and activation, since it can not be saved by
        the EJB container.
      </p><p>
        The default behavior of the <tt class="classname">ContextJndiBeanFactoryLocator</tt>
        classes which is to load an <tt class="classname">ApplicationContext</tt> for the
        use of the EJB is adequate for some situations. However, it is problematic when
        the <tt class="classname">ApplicationContext</tt> is loading a number
        of beans, or the initialization of those beans is time consuming or memory
        intensive (such as a Hibernate <tt class="classname">SessionFactory</tt> initialization, for
        example), since every EJB will have their own copy. In this case, the user
        may want to override the default <tt class="classname">ContextJndiBeanFactoryLocator</tt>
        usage and use another <tt class="classname">BeanFactoryLocator</tt> variant, such as the
        <tt class="classname">ContextSingletonBeanFactoryLocator</tt> which can load and use a
        shared container to be used by multiple EJBs or other clients. Doing this is relatively
        simple, by adding code similar to this to the EJB:
      </p><pre class="programlisting">   /**
    * Override default BeanFactoryLocator implementation
    * @see javax.ejb.SessionBean#setSessionContext(javax.ejb.SessionContext)
    */
   public void setSessionContext(SessionContext sessionContext) {
       super.setSessionContext(sessionContext);
       setBeanFactoryLocator(ContextSingletonBeanFactoryLocator.getInstance());
       setBeanFactoryLocatorKey(ServicesConstants.PRIMARY_CONTEXT_ID);
   }</pre><p>
        You would then need to create a bean definition file named <tt class="literal">beanRefContext.xml</tt>.
        This file defines all bean factories (usually in the form of application contexts) that may be used
        in the EJB. In many cases, this file will only contain a single bean definition such as this (where
        <tt class="literal">businessApplicationContext.xml</tt> contains the bean	definitions for all business
        service POJOs):
      </p><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="businessBeanFactory" class="org.springframework.context.support.ClassPathXmlApplicationContext"&gt;
        &lt;constructor-arg value="businessApplicationContext.xml" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre><p>
        In the above example, the <tt class="literal">ServicesConstants.PRIMARY_CONTEXT_ID</tt> constant
        would be defined as follows:
        </p><pre class="programlisting">public static final String ServicesConstants.PRIMARY_CONTEXT_ID = "businessBeanFactory";</pre><p>
        Please see the respective Javadocs for the <tt class="classname">BeanFactoryLocator</tt> and
        <tt class="classname">ContextSingletonBeanFactoryLocator</tt> classes for more information on
        their usage.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="ejb-implementation-ejb3"></a>18.3.2.&nbsp;EJB 3 injection interceptor</h3></div></div><div></div></div><p>
        For EJB 3 Session Beans and Message-Driven Beans, Spring provides a convenient
        interceptor that resolves Spring 2.5's <tt class="literal">@Autowired</tt> annotation
        in the EJB component class:
        <tt class="classname">org.springframework.ejb.interceptor.SpringBeanAutowiringInterceptor</tt>.
        This interceptor can be applied through an <font color="red">&lt;code&gt;@Interceptors&lt;/code&gt;</font> annotation
        in the EJB component class, or through an <tt class="literal">interceptor-binding</tt>
        XML element in the EJB deployment descriptor.
      </p><pre class="programlisting">@Stateless
@Interceptors(SpringBeanAutowiringInterceptor.class)
public class MyFacadeEJB implements MyFacadeLocal {

    // automatically injected with a matching Spring bean
    @Autowired
    private MyComponent myComp;

    // for business method, delegate to POJO service impl.
    public String myFacadeMethod(...) {
        return myComp.myMethod(...);
    }
    ...
}</pre><p>
        <tt class="classname">SpringBeanAutowiringInterceptor</tt> by default obtains target
        beans from a <tt class="classname">ContextSingletonBeanFactoryLocator</tt>, with the
        context defined in a bean definition file named <tt class="literal">beanRefContext.xml</tt>.
        By default, a single context definition is expected, which is obtained by type rather
        than by name. However, if you need to choose between multiple context definitions,
        a specific locator key is required. The locator key (i.e. the name of the context
        definition in <tt class="literal">beanRefContext.xml</tt>) can be explicitly specified
        either through overriding the <tt class="literal">getBeanFactoryLocatorKey</tt> method
        in a custom <tt class="classname">SpringBeanAutowiringInterceptor</tt> subclass.
      </p><p>
        Alternatively, consider overriding <tt class="classname">SpringBeanAutowiringInterceptor</tt>'s
        <tt class="literal">getBeanFactory</tt> method, e.g. obtaining a shared
        <tt class="interfacename">ApplicationContext</tt> from a custom holder class.
      </p></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jms"></a>Chapter&nbsp;19.&nbsp;JMS (Java Message Service)</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-introduction"></a>19.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Spring provides a JMS integration framework that simplifies the use
    of the JMS API and shields the user from differences between the JMS 1.0.2
    and 1.1 APIs.</p><p>JMS can be roughly divided into two areas of functionality, namely the
    production and consumption of messages. The <tt class="classname">JmsTemplate</tt>
    class is used for message production and synchronous message reception. For
    asynchronous reception similar to J2EE's message-driven bean style, Spring
    provides a number of message listener containers that are used to create
    Message-Driven POJOs (MDPs).</p><div class="sidebar"><p class="title"><b>Domain Unification</b></p><p>There are two major releases of the JMS specification, 1.0.2 and
			1.1.</p><p>JMS 1.0.2 defined two types of messaging domains, point-to-point
			(Queues) and publish/subscribe (Topics). The 1.0.2 API reflected these two
			messaging domains by providing a parallel class hierarchy for each domain.
			As a result, a client application became domain specific in its use of
			the JMS API. JMS 1.1 introduced the concept of domain unification that
			minimized both the functional differences and client API differences
			between the two domains. As an example of a functional difference that was
			removed, if you use a JMS 1.1 provider you can transactionally consume a
			message from one domain and produce a message on the other using the same
			<tt class="interfacename">Session</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The JMS 1.1 specification was released in April 2002 and
        incorporated as part of J2EE 1.4 in November 2003. As a result, common
        J2EE 1.3 application servers which are still in widespread use (such as
        BEA WebLogic 8.1 and IBM WebSphere 5.1) are based on JMS 1.0.2.</p></td></tr></table></div></div><p>The package <tt class="literal">org.springframework.jms.core</tt> provides
    the core functionality for using JMS. It contains JMS template classes
    that simplifies the use of the JMS by handling the creation and release of
    resources, much like the <tt class="classname">JdbcTemplate</tt> does for
    JDBC. The design principle common to Spring template classes is to provide
    helper methods to perform common operations and for more sophisticated
    usage, delegate the essence of the processing task to user implemented
    callback interfaces. The JMS template follows the same design. The classes
    offer various convenience methods for the sending of messages, consuming a
    message synchronously, and exposing the JMS session and message producer
    to the user.</p><p>The package <tt class="literal">org.springframework.jms.support</tt>
    provides JMSException translation functionality. The translation converts
    the checked <tt class="classname">JMSException</tt> hierarchy to a mirrored
    hierarchy of unchecked exceptions. If there are any provider specific
    subclasses of the checked <tt class="classname">javax.jms.JMSException</tt>,
    this exception is wrapped in the unchecked
    <tt class="classname">UncategorizedJmsException</tt>.</p><p>The package <tt class="literal">org.springframework.jms.support.converter</tt> provides a
    <tt class="interfacename">MessageConverter</tt> abstraction to convert between Java objects
    and JMS messages.</p><p>The package <tt class="literal">org.springframework.jms.support.destination</tt> provides
    various strategies for managing JMS destinations, such as providing a
    service locator for destinations stored in JNDI.</p><p>Finally, the package
    <tt class="literal">org.springframework.jms.connection</tt> provides an
    implementation of the <tt class="classname">ConnectionFactory</tt> suitable
    for use in standalone applications. It also contains an implementation of
    Spring's <tt class="interfacename">PlatformTransactionManager</tt> for
    JMS (the cunningly named <tt class="classname">JmsTransactionManager</tt>).
    This allows for seamless integration of JMS as a transactional resource into
    Spring's transaction management mechanisms.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-using"></a>19.2.&nbsp;Using Spring JMS</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-jmstemplate"></a>19.2.1.&nbsp;<tt class="classname">JmsTemplate</tt></h3></div></div><div></div></div><p>There are two variants of the functionality offered by the
			<tt class="classname">JmsTemplate</tt>: the <tt class="classname">JmsTemplate</tt>
			uses the JMS 1.1 API, and the subclass <tt class="classname">JmsTemplate102</tt>
			uses the JMS 1.0.2 API.</p><p>Code that uses the <tt class="classname">JmsTemplate</tt> only needs to
			implement callback interfaces giving them a clearly defined contract. The
			<tt class="classname">MessageCreator</tt> callback interface creates a message
			given a <tt class="interfacename">Session</tt> provided by the calling code
			in <tt class="classname">JmsTemplate</tt>. In order to allow for more complex
			usage of the JMS API, the callback <tt class="classname">SessionCallback</tt>
			provides the user with the JMS session and the callback
			<tt class="classname">ProducerCallback</tt> exposes a
			<tt class="interfacename">Session</tt> and
			<tt class="interfacename">MessageProducer</tt> pair.</p><p>The JMS API exposes two types of send methods, one that takes
			delivery mode, priority, and time-to-live as Quality of Service (QOS)
			parameters and one that takes no QOS parameters which uses default values.
			Since there are many send methods in <tt class="classname">JmsTemplate</tt>,
			the setting of the QOS parameters have been exposed as bean properties to
			avoid duplication in the number of send methods. Similarly, the timeout
			value for synchronous receive calls is set using the property
			<tt class="classname">setReceiveTimeout</tt>.</p><p>Some JMS providers allow the setting of default QOS values
			administratively through the configuration of the ConnectionFactory. This
			has the effect that a call to <tt class="classname">MessageProducer</tt>'s
			send method <tt class="methodname">send(Destination destination, Message
			message)</tt> will use different QOS default values than those
			specified in the JMS specification. In order to provide consistent
			management of QOS values, the <tt class="classname">JmsTemplate</tt> must
			therefore be specifically enabled to use its own QOS values by setting
			the boolean property <span class="property">isExplicitQosEnabled</span>
			to <tt class="literal">true</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Instances of the <tt class="classname">JmsTemplate</tt> class are
				<span class="emphasis"><em>thread-safe once configured</em></span>. This is important because
				it means that you can configure a single instance of a
				<tt class="classname">JmsTemplate</tt> and then safely inject this
				<span class="emphasis"><em>shared</em></span> reference into multiple collaborators. To be
				clear, the <tt class="classname">JmsTemplate</tt> is stateful, in that it
				maintains a reference to a <tt class="interfacename">ConnectionFactory</tt>,
				but this state is <span class="emphasis"><em>not</em></span> conversational state.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-connections"></a>19.2.2.&nbsp;Connections</h3></div></div><div></div></div><p>The <tt class="classname">JmsTemplate</tt> requires a reference to a
			<tt class="classname">ConnectionFactory</tt>. The
			<tt class="classname">ConnectionFactory</tt> is part of the JMS
			specification and serves as the entry point for working with JMS. It is
			used by the client application as a factory to create connections with
			the JMS provider and encapsulates various configuration parameters, many
			of which are vendor specific such as SSL configuration options.</p><p>When using JMS inside an EJB, the vendor provides implementations
			of the JMS interfaces so that they can participate in declarative
			transaction management and perform pooling of connections and session.
			In order to use this implementation, J2EE containers typically require
			that you declare a JMS connection factory as a
			<span class="property">resource-ref</span> inside the EJB or servlet deployment
			descriptors. To ensure the use of these features with the
     	<tt class="classname">JmsTemplate</tt> inside an EJB, the client application
			should ensure that it references the managed implementation of the
			<tt class="classname">ConnectionFactory</tt>.</p><p>Spring provides an implementation of the
			<tt class="classname">ConnectionFactory</tt> interface,
			<tt class="classname">SingleConnectionFactory</tt>, that will return the
			same <tt class="classname">Connection</tt> on all
			<tt class="methodname">createConnection</tt> calls and ignore calls to
			<tt class="methodname">close.</tt> This is useful for testing and
			standalone environments so that the same connection can be used for
			multiple <tt class="classname">JmsTemplate</tt> calls that may span any
			number of transactions. <tt class="classname">SingleConnectionFactory</tt>
			takes a reference to a standard <tt class="classname">ConnectionFactory</tt>
			that would typically come from JNDI.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-destinations"></a>19.2.3.&nbsp;Destination Management</h3></div></div><div></div></div><p>Destinations, like ConnectionFactories, are JMS administered
      	objects that can be stored and retrieved in JNDI. When configuring a
      	Spring application context you can use the JNDI factory class
      	<tt class="classname">JndiObjectFactoryBean</tt> to perform dependency
      	injection on your object's references to JMS destinations. However,
      	often this strategy is cumbersome if there are a large number of
      	destinations in the application or if there are advanced destination
      	management features unique to the JMS provider. Examples of such
      	advanced destination management would be the creation of dynamic
      	destinations or support for a hierarchical namespace of destinations.
      	The <tt class="classname">JmsTemplate</tt> delegates the resolution of a
      	destination name to a JMS destination object to an implementation of the
      	interface <tt class="classname">DestinationResolver</tt>.
      	<tt class="classname">DynamicDestinationResolver</tt> is the default
      	implementation used by <tt class="classname">JmsTemplate</tt> and
      	accommodates resolving dynamic destinations. A
      	<tt class="classname">JndiDestinationResolver</tt> is also provided that
      	acts as a service locator for destinations contained in JNDI and
      	optionally falls back to the behavior contained in
      	<tt class="classname">DynamicDestinationResolver</tt>.</p><p>Quite often the destinations used in a JMS application are only
      	known at runtime and therefore cannot be administratively created when
      	the application is deployed. This is often because there is shared
      	application logic between interacting system components that create
     	destinations at runtime according to a well-known naming convention.
     	Even though the creation of dynamic destinations are not part of the JMS
      	specification, most vendors have provided this functionality. Dynamic
      	destinations are created with a name defined by the user which
      	differentiates them from temporary destinations and are often not
      	registered in JNDI. The API used to create dynamic destinations varies
      	from provider to provider since the properties associated with the
      	destination are vendor specific. However, a simple implementation choice
      	that is sometimes made by vendors is to disregard the warnings in the
      	JMS specification and to use the <tt class="classname">TopicSession</tt>
      	method <tt class="methodname">createTopic(String topicName)</tt> or the
      	<tt class="classname">QueueSession</tt> method
      	<tt class="methodname">createQueue(String queueName)</tt> to create a new
      	destination with default destination properties. Depending on the vendor
      	implementation, <tt class="classname">DynamicDestinationResolver</tt> may
      	then also create a physical destination instead of only resolving
      	one.</p><p>The boolean property <span class="property">pubSubDomain</span> is used to
      	configure the <tt class="classname">JmsTemplate</tt> with knowledge of what
      	JMS domain is being used. By default the value of this property is
      	false, indicating that the point-to-point domain, Queues, will be used.
      	In the 1.0.2 implementation the value of this property determines if the
      	<tt class="classname">JmsTemplate</tt>'s send operations will send a message
      	to a <tt class="interfacename">Queue</tt> or to a <tt class="interfacename">Topic</tt>.
      	This flag has no effect on send operations for
      	the 1.1 implementation. However, in both implementations, this property
      	determines the behavior of dynamic destination resolution via
      	implementations of the <tt class="interfacename">DestinationResolver</tt> interface.</p><p>You can also configure the <tt class="classname">JmsTemplate</tt> with
      	a default destination via the property
      	<span class="property">defaultDestination</span>. The default destination will be
      	used with send and receive operations that do not refer to a specific
      	destination.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-mdp"></a>19.2.4.&nbsp;Message Listener Containers</h3></div></div><div></div></div><p>One of the most common uses of JMS messages in the EJB world is to
			drive message-driven beans (MDBs). Spring offers a solution to create
			message-driven POJOs (MDPs) in a way that does not tie a user to an EJB
			container. (See the section entitled <a href="#jms-asynchronousMessageReception" title="19.4.2.&nbsp;Asynchronous Reception - Message-Driven POJOs">Section&nbsp;19.4.2, &#8220;Asynchronous Reception - Message-Driven POJOs&#8221;</a>
			for detailed coverage of Spring's MDP support.)</p><p>A message listener container is used to receive messages
			from a JMS message queue and drive the MessageListener that is
			injected into it. The listener container is responsible for all
			threading of message reception and dispatches into the listener
			for processing. A message listener container is the intermediary between an
			MDP and a messaging provider, and takes care of registering to receive messages,
			participating in transactions, resource acquisition and release, exception
			conversion and suchlike. This allows you as an application developer to write
			the (possibly complex) business logic associated with receiving a message
			(and possibly responding to it), and delegates boilerplate JMS
			infrastructure concerns to the framework.</p><p>There are three standard JMS message listener containers packaged
			with Spring, each with its specialised feature set.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jms-mdp-simple"></a>19.2.4.1.&nbsp;SimpleMessageListenerContainer</h4></div></div><div></div></div><p>This message listener container is the simplest of the three
				standard flavors. It simply creates a fixed number of JMS sessions
				at startup and uses them throughout the lifespan of the container.
				This container doesn't allow for dynamic adaption to runtime demands
				or participate in externally managed transactions. However,
				it does have the fewest requirements on the JMS provider: This
				listener container only requires simple JMS API compliance.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jms-mdp-default"></a>19.2.4.2.&nbsp;DefaultMessageListenerContainer</h4></div></div><div></div></div><p>This message listener container is the one used in most cases.
				In contrast to <tt class="classname">SimpleMessageListenerContainer</tt>,
				this container variant does allow for dynamic adaption to runtime
				demands and is able to participate in externally managed transactions.
				Each received message is registered with an XA transaction
				(when configured with a <tt class="classname">JtaTransactionManager</tt>);
				processing can take advantage of XA transation semantics.
				This listener container strikes a good balance between low
				requirements on the JMS provider and good functionality including
				transaction participation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="jms-mdp-server-session"></a>19.2.4.3.&nbsp;ServerSessionMessageListenerContainer</h4></div></div><div></div></div><p>This listener container leverages the JMS ServerSessionPool SPI
				to allow for dynamic management of JMS sessions. The use of this variety
				of message listener container enables the provider to perform dynamic
				runtime tuning but, at the expense of requiring the JMS provider to support
				the ServerSessionPool SPI. If there is no need for provider-driven runtime
				tuning, look at the <tt class="classname">DefaultMessageListenerContainer</tt>
				or the <tt class="classname">SimpleMessageListenerContainer</tt> instead.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-tx"></a>19.2.5.&nbsp;Transaction management</h3></div></div><div></div></div><p>Spring provides a <tt class="classname">JmsTransactionManager</tt>
			that manages transactions for a single JMS
			<tt class="classname">ConnectionFactory</tt>. This allows JMS applications
			to leverage the managed transaction features of Spring as described in
			<a href="#transaction" title="Chapter&nbsp;9.&nbsp;Transaction management">Chapter&nbsp;9, <i>Transaction management</i></a>. The <tt class="classname">JmsTransactionManager</tt>
			performs local resource transactions, binding a JMS Connection/Session
			pair from the specified <tt class="classname">ConnectionFactory</tt> to the
			thread. <tt class="classname">JmsTemplate</tt> automatically detects such
			transactional resources and operates on them accordingly.</p><p>In a J2EE environment, the <tt class="classname">ConnectionFactory</tt>
			will pool Connections and Sessions, so those resources are efficiently
			reused across transactions. In a standalone environment, using Spring's
			<tt class="classname">SingleConnectionFactory</tt> will result in a shared
			JMS <tt class="classname">Connection</tt>, with each transaction having its
			own independent <tt class="classname">Session</tt>. Alternatively, consider
			the use of a provider-specific pooling adapter such as ActiveMQ's
			<tt class="classname">PooledConnectionFactory</tt> class.</p><p><tt class="classname">JmsTemplate</tt> can also be used with the
			<tt class="classname">JtaTransactionManager</tt> and an XA-capable JMS
			<tt class="classname">ConnectionFactory</tt> for performing distributed
			transactions. Note that this requires the use of a JTA transaction
			manager as well as a properly XA-configured ConnectionFactory!
			(Check your J2EE server's / JMS provider's documentation.)</p><p>Reusing code across a managed and unmanaged transactional
			environment can be confusing when using the JMS API to create a
			<tt class="classname">Session</tt> from a <tt class="classname">Connection</tt>.
			This is because the JMS API has only one factory method to create a
			<tt class="classname">Session</tt> and it requires values for the
			transaction and acknowledgement modes. In a managed environment, setting
			these values is the responsibility of the environment's transactional
			infrastructure, so these values are ignored by the vendor's wrapper to
			the JMS Connection. When using the <tt class="classname">JmsTemplate</tt> in
			an unmanaged environment you can specify these values through the use of
			the properties <tt class="literal">sessionTransacted</tt> and
			<tt class="literal">sessionAcknowledgeMode</tt>. When using a
			<tt class="classname">PlatformTransactionManager</tt> with
			<tt class="classname">JmsTemplate</tt>, the template will always be given a
			transactional JMS <tt class="classname">Session</tt>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-sending"></a>19.3.&nbsp;Sending a <tt class="interfacename">Message</tt></h2></div></div><div></div></div><p>The <tt class="classname">JmsTemplate</tt> contains many convenience
    methods to send a message. There are send methods that specify the
    destination using a <tt class="classname">javax.jms.Destination</tt> object
    and those that specify the destination using a string for use in a JNDI
    lookup. The send method that takes no destination argument uses the
    default destination. Here is an example that sends a message to a queue
    using the 1.0.2 implementation.</p><pre class="programlisting">import javax.jms.ConnectionFactory;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Queue;
import javax.jms.Session;

import org.springframework.jms.core.MessageCreator;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.JmsTemplate102;

public class JmsQueueSender {

    private JmsTemplate jmsTemplate;
    private Queue queue;

    public void setConnectionFactory(ConnectionFactory cf) {
        this.jmsTemplate = new JmsTemplate102(cf, false);
    }

    public void setQueue(Queue queue) {
        this.queue = queue;
    }

    public void simpleSend() {
        this.jmsTemplate.send(this.queue, new MessageCreator() {
            public Message createMessage(Session session) throws JMSException {
              return session.createTextMessage("hello queue world");
            }
        });
    }
}</pre><p>This example uses the <tt class="classname">MessageCreator</tt>
    callback to create a text message from the supplied
    <tt class="classname">Session</tt> object and the
    <tt class="classname">JmsTemplate</tt> is constructed by passing a reference
    to a <tt class="classname">ConnectionFactory</tt> and a boolean specifying
    the messaging domain. A zero argument constructor and
    <span class="property">connectionFactory</span> / <span class="property">queue</span> bean
    properties are provided and can be used for constructing the instance
    (using a BeanFactory or plain Java code). Alternatively, consider
    deriving from Spring's <tt class="classname">JmsGatewaySupport</tt>
    convenience base class, which provides pre-built bean properties for JMS
    configuration.</p><p>When configuring the JMS 1.0.2 support in an application context,
    it is important to remember setting the value of the boolean property
    <span class="property">pubSubDomain</span> property in order to indicate if you
    want to send to Queues or Topics.</p><p>The method <tt class="methodname">send(String destinationName, MessageCreator
    creator)</tt> lets you send to a message using the string name
    of the destination. If these names are registered in JNDI, you should
    set the <span class="property">destinationResolver</span> property of the
    template to an instance of
    <tt class="classname">JndiDestinationResolver</tt>.</p><p>If you created the <tt class="classname">JmsTemplate</tt> and
    specified a default destination, the <tt class="methodname">send(MessageCreator c)</tt>
    sends a message to that destination.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-msg-conversion"></a>19.3.1.&nbsp;Using Message Converters</h3></div></div><div></div></div><p>In order to facilitate the sending of domain model objects, the
      <tt class="classname">JmsTemplate</tt> has various send methods that take a
      Java object as an argument for a message's data content. The overloaded
      methods <tt class="methodname">convertAndSend</tt> and
      <tt class="methodname">receiveAndConvert</tt> in
      <tt class="classname">JmsTemplate</tt> delegate the conversion process to an
      instance of the <tt class="literal">MessageConverter</tt> interface. This
      interface defines a simple contract to convert between Java objects and
      JMS messages. The default implementation
      <tt class="classname">SimpleMessageConverter</tt> supports conversion
      between <tt class="classname">String</tt> and
      <tt class="classname">TextMessage</tt>, <tt class="classname">byte[]</tt> and
      <tt class="classname">BytesMesssage</tt>, and
      <tt class="classname">java.util.Map</tt> and
      <tt class="classname">MapMessage</tt>. By using the converter, you and your
      application code can focus on the business object that is being sent or
      received via JMS and not be concerned with the details of how it is
      represented as a JMS message.</p><p>The sandbox currently includes a
      <tt class="classname">MapMessageConverter</tt> which uses reflection to
      convert between a JavaBean and a <tt class="classname">MapMessage</tt>.
      Other popular implementations choices you might implement yourself are
      Converters that use an existing XML marshalling package, such as JAXB,
      Castor, XMLBeans, or XStream, to create a
      <tt class="interfacename">TextMessage</tt> representing the object.</p><p>To accommodate the setting of a message's properties, headers, and
      body that can not be generically encapsulated inside a converter class,
      the <tt class="interfacename">MessagePostProcessor</tt> interface gives you access
      to the message after it has been converted, but before it is sent. The
      example below demonstrates how to modify a message header and a property after
      a <tt class="interfacename">java.util.Map</tt> is converted to a message.</p><pre class="programlisting">public void sendWithConversion() {
    Map map = new HashMap();
    map.put("Name", "Mark");
    map.put("Age", new Integer(47));
    jmsTemplate.convertAndSend("testQueue", map, new MessagePostProcessor() {
        public Message postProcessMessage(Message message) throws JMSException {
            message.setIntProperty("AccountID", 1234);
            message.setJMSCorrelationID("123-00001");
            return message;
        }
    });
}</pre><p>This results in a message of the form:</p><pre class="programlisting">MapMessage={
    Header={
        ... standard headers ...
        CorrelationID={123-00001}
    }
    Properties={
        AccountID={Integer:1234}
    }
    Fields={
        Name={String:Mark}
        Age={Integer:47}
    } 
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-callbacks"></a>19.3.2.&nbsp;<tt class="interfacename">SessionCallback</tt> and <tt class="interfacename">ProducerCallback</tt></h3></div></div><div></div></div><p>While the send operations cover many common usage scenarios, there
      are cases when you want to perform multiple operations on a JMS
      <tt class="interfacename">Session</tt> or
      <tt class="interfacename">MessageProducer</tt>. The
      <tt class="interfacename">SessionCallback</tt> and
      <tt class="interfacename">ProducerCallback</tt> expose the JMS
      <tt class="interfacename">Session</tt> and
      <tt class="interfacename">Session</tt> / <tt class="interfacename">MessageProducer</tt>
      pair respectfully. The <tt class="methodname">execute()</tt> methods on
      <tt class="classname">JmsTemplate</tt> execute these callback
      methods.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-receiving"></a>19.4.&nbsp;Receiving a message</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-receiving-sync"></a>19.4.1.&nbsp;Synchronous Reception</h3></div></div><div></div></div><p>While JMS is typically associated with asynchronous processing, it
      is possible to consume messages synchronously. The overloaded
      <tt class="methodname">receive(..)</tt> methods provide this functionality.
      During a synchronous receive, the calling thread blocks until a message
      becomes available. This can be a dangerous operation since the calling
      thread can potentially be blocked indefinitely. The property
      <span class="property">receiveTimeout</span> specifies how long the receiver
      should wait before giving up waiting for a message.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-asynchronousMessageReception"></a>19.4.2.&nbsp;Asynchronous Reception - Message-Driven POJOs</h3></div></div><div></div></div><p>In a fashion similar to a Message-Driven Bean (MDB) in the EJB world,
  		the Message-Driven POJO (MDP) acts as a receiver for JMS messages. The one
  		restriction (but see also below for the discussion of the
  		<tt class="classname">MessageListenerAdapter</tt> class) on an MDP is that it
  		must implement the <tt class="interfacename">javax.jms.MessageListener</tt>
  		interface. Please also be aware that in the case where your POJO will be
  		receiving messages on multiple threads, it is important to ensure that your
  		implementation is thread-safe.</p><p>Below is a simple implementation of an MDP:</p><pre class="programlisting">import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

public class ExampleListener implements MessageListener {

    public void onMessage(Message message) {
        if (message instanceof TextMessage) {
            try {
                System.out.println(((TextMessage) message).getText());
            }
            catch (JMSException ex) {
                throw new RuntimeException(ex);
            }
        }
        else {
            throw new IllegalArgumentException("Message must be of type TextMessage");
        }
    }
}</pre><p>Once you've implemented your <tt class="interfacename">MessageListener</tt>, 
		it's time to create a message listener container.</p><p>Find below an example of how to define and configure one of the message listener
		containers that ships with Spring (in this case the 
		<tt class="classname">DefaultMessageListenerContainer</tt>).</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- this is the Message Driven POJO (MDP) --&gt;</span></i>
&lt;bean id="messageListener" class="jmsexample.ExampleListener" /&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- and this is the message listener container --&gt;</span></i>
&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    <span class="bold"><b>&lt;property name="messageListener" ref="messageListener" /&gt;</b></span>
&lt;/bean&gt;</pre><p>Please refer to the Spring Javadoc of the various message
        listener containers for a full description of the features supported by each implementation.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-receiving-async-session-aware-message-listener"></a>19.4.3.&nbsp;The <tt class="interfacename">SessionAwareMessageListener</tt> interface</h3></div></div><div></div></div><p>The <tt class="interfacename">SessionAwareMessageListener</tt> interface
  	    is a Spring-specific interface that provides a similar contract the JMS
  	    <tt class="interfacename">MessageListener</tt> interface, but also provides
  	    the message handling method with access to the JMS <tt class="interfacename">Session</tt>
  	    from which the <tt class="interfacename">Message</tt> was received.</p><pre class="programlisting">package org.springframework.jms.listener;

public interface SessionAwareMessageListener {

    void onMessage(Message message, Session session) <span class="bold"><b>throws JMSException</b></span>;
}</pre><p>You can choose to have your MDPs implement this interface (in preference to the
        standard JMS <tt class="interfacename">MessageListener</tt> interface) if you
        want your MDPs to be able to respond to any received messages (using the
        <tt class="interfacename">Session</tt> supplied in the
        <tt class="literal">onMessage(Message, Session)</tt> method). All of the message listener
        container implementations that ship wth Spring have support for MDPs that implement either
        the <tt class="interfacename">MessageListener</tt> or
        <tt class="interfacename">SessionAwareMessageListener</tt> interface. Classes
        that implement the <tt class="interfacename">SessionAwareMessageListener</tt> come
        with the caveat that they are then tied to Spring through the interface. The choice of whether
        or not to use it is left entirely up to you as an application developer or architect.</p><p>Please note that the <tt class="literal">'onMessage(..)'</tt> method of the
        <tt class="interfacename">SessionAwareMessageListener</tt> interface throws
        <tt class="classname">JMSException</tt>. In contrast to the standard JMS
        <tt class="interfacename">MessageListener</tt> interface, when using the
        <tt class="interfacename">SessionAwareMessageListener</tt> interface, it is the responsibility
        of the client code to handle any exceptions thrown.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-receiving-async-message-listener-adapter"></a>19.4.4.&nbsp;The <tt class="classname">MessageListenerAdapter</tt></h3></div></div><div></div></div><p>The <tt class="classname">MessageListenerAdapter</tt> class is the final component in
  	    Spring's asynchronous messaging support: in a nutshell, it allows you to 
  	    expose almost <span class="emphasis"><em>any</em></span> class as a MDP (there are of course some constraints).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>If you are using the JMS 1.0.2 API, you will want to use the
  	        <tt class="classname">MessageListenerAdapter102</tt> class which provides the exact
  	        same functionality and value add as the <tt class="classname">MessageListenerAdapter</tt>
  	        class, but for the JMS 1.0.2 API.</p></td></tr></table></div><p>Consider the following interface definition. Notice that although the interface extends
  	    neither the <tt class="interfacename">MessageListener</tt> nor
        <tt class="interfacename">SessionAwareMessageListener</tt> interfaces, it can still
        be used as a MDP via the use of the <tt class="classname">MessageListenerAdapter</tt> class.
        Notice also how the various message handling methods are strongly typed according to
        the <span class="emphasis"><em>contents</em></span> of the various <tt class="interfacename">Message</tt>
        types that they can receive and handle.</p><pre class="programlisting">public interface MessageDelegate {

    void handleMessage(String message);

    void handleMessage(Map message);

    void handleMessage(byte[] message);

    void handleMessage(Serializable message);
}</pre><pre class="programlisting">public class DefaultMessageDelegate implements MessageDelegate {
    <i class="lineannotation"><span class="lineannotation">// implementation elided for clarity...</span></i>
}</pre><p>In particular, note how the above implementation of the <tt class="interfacename">MessageDelegate</tt>
        interface (the above <tt class="classname">DefaultMessageDelegate</tt> class) has
        <span class="emphasis"><em>no</em></span> JMS dependencies at all. It truly is a POJO that we will
        make into an MDP via the following configuration.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- this is the Message Driven POJO (MDP) --&gt;</span></i>
<span class="bold"><b>&lt;bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="jmsexample.DefaultMessageDelegate"/&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;</b></span>

<i class="lineannotation"><span class="lineannotation">&lt;!-- and this is the message listener container... --&gt;</span></i>
&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    <span class="bold"><b>&lt;property name="messageListener" ref="messageListener" /&gt;</b></span>
&lt;/bean&gt;</pre><p>Below is an example of another MDP that can only handle the receiving of
        JMS <tt class="interfacename">TextMessage</tt> messages. Notice how the message handling
        method is actually called <tt class="literal">'receive'</tt> (the name of the message handling
        method in a <tt class="classname">MessageListenerAdapter</tt> defaults to
        <tt class="literal">'handleMessage'</tt>), but it is configurable (as you will see below).
        Notice also how the <tt class="literal">'receive(..)'</tt> method is strongly typed to
        receive and respond only to JMS <tt class="interfacename">TextMessage</tt> messages.</p><pre class="programlisting">public interface TextMessageDelegate {

    void receive(TextMessage message);
}</pre><pre class="programlisting">public class DefaultTextMessageDelegate implements TextMessageDelegate {
    <i class="lineannotation"><span class="lineannotation">// implementation elided for clarity...</span></i>
}</pre><p>The configuration of the attendant <tt class="classname">MessageListenerAdapter</tt> would
        look like this:</p><pre class="programlisting">&lt;bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="jmsexample.DefaultTextMessageDelegate"/&gt;
    &lt;/constructor-arg&gt;
    &lt;property name="defaultListenerMethod" value="receive"/&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- we <span class="bold"><b>don't</b></span> want automatic message context extraction --&gt;</span></i>
    &lt;property name="messageConverter"&gt;
        &lt;null/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Please note that if the above <tt class="literal">'messageListener'</tt> receives a
        JMS <tt class="interfacename">Message</tt> of a type other than
        <tt class="interfacename">TextMessage</tt>, an <tt class="classname">IllegalStateException</tt>
        will be thrown (and subsequently swallowed).
        Another of the capabilities of the <tt class="classname">MessageListenerAdapter</tt>
        class is the ability to automatically send back a response <tt class="interfacename">Message</tt>
        if a handler method returns a non-void value.
        Consider the interface and class:</p><pre class="programlisting">public interface ResponsiveTextMessageDelegate {

    <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>// notice the return type...</b></span></span></i>
    String receive(TextMessage message);
}</pre><pre class="programlisting">public class DefaultResponsiveTextMessageDelegate implements ResponsiveTextMessageDelegate {
    <i class="lineannotation"><span class="lineannotation">// implementation elided for clarity...</span></i>
}</pre><p>If the above <tt class="classname">DefaultResponsiveTextMessageDelegate</tt> is used in
        conjunction with a <tt class="classname">MessageListenerAdapter</tt> then any non-null
        value that is returned from the execution of the <tt class="literal">'receive(..)'</tt>
        method will (in the default configuration) be converted into a
        <tt class="interfacename">TextMessage</tt>. The resulting <tt class="interfacename">TextMessage</tt>
        will then be sent to the <tt class="interfacename">Destination</tt> (if one exists) 
        defined in the JMS Reply-To property of the original <tt class="interfacename">Message</tt>, or the
        default <tt class="interfacename">Destination</tt> set on the
        <tt class="classname">MessageListenerAdapter</tt> (if one has been configured); if no
        <tt class="interfacename">Destination</tt> is found then an
        <tt class="classname">InvalidDestinationException</tt> will be thrown (and please note
        that this exception <span class="emphasis"><em>will not</em></span> be swallowed and
        <span class="emphasis"><em>will</em></span> propagate up the call stack).</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jms-tx-participation"></a>19.4.5.&nbsp;Processing messages within transactions</h3></div></div><div></div></div><p>Invoking a message listener within a transaction only requires
			reconfiguration of the listener container.</p><p>Local resource transactions can simply be activated through the
			<tt class="literal">sessionTransacted</tt> flag on the listener container
			definition. Each message listener invocation will then operate within
			an active JMS transaction, with message reception rolled back in case
			of listener execution failure. Sending a response message
			(via <tt class="interfacename">SessionAwareMessageListener</tt>)
			will be part of the same local transaction, but any other resource
			operations (such as database access) will operate independently.
			This usually requires duplicate message detection in the listener
			implementation, covering the case where database processing has
			committed but message processing failed to commit.</p><pre class="programlisting">&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    &lt;property name="messageListener" ref="messageListener"/&gt;
    <span class="bold"><b>&lt;property name="sessionTransacted" value="true"/&gt;</b></span>
&lt;/bean&gt;</pre><p>For participating in an externally managed transaction,
			you will need to configure a transaction manager and use a listener
			container which supports externally managed transactions: typically
			<tt class="classname">DefaultMessageListenerContainer</tt>.</p><p>To configure a message listener container for XA transaction
			participation, you'll want to configure a <tt class="classname">JtaTransactionManager</tt>
			(which, by default, delegates to the J2EE server's transaction subsystem).
			Note that the underlying JMS ConnectionFactory needs to be XA-capable
			and properly registered with your JTA transaction coordinator!
			(Check your J2EE server's configuration of JNDI resources.)
			This allows message recepton as well as e.g. database access to be
			part of the same transaction (with unified commit semantics,
			at the expense of XA transaction log overhead).</p><pre class="programlisting">&lt;bean id="transactionManager" class="org.springframework.transaction.jta.JtaTransactionManager"/&gt;
</pre><p>Then you just need to add it to our earlier container configuration. The
			container will take care of the rest.</p><pre class="programlisting">&lt;bean id="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
    &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;property name="destination" ref="destination"/&gt;
    &lt;property name="messageListener" ref="messageListener"/&gt;
    <span class="bold"><b>&lt;property name="transactionManager" ref="transactionManager"/&gt;</b></span>
&lt;/bean&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-jca-message-endpoint-manager"></a>19.5.&nbsp;Support for JCA Message Endpoints</h2></div></div><div></div></div><p>Beginning with version 2.5, Spring also provides support for a JCA-based
    <tt class="interfacename">MessageListener</tt> container. The
    <tt class="classname">JmsMessageEndpointManager</tt> will attempt to automatically
    determine the <tt class="interfacename">ActivationSpec</tt> class name from the
    provider's <tt class="interfacename">ResourceAdapter</tt> class name. Therefore,
    it is typically possible to just provide Spring's generic
    <tt class="classname">JmsActivationSpecConfig</tt> as shown in the following example.
    </p><pre class="programlisting">&lt;bean class="org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"&gt;
    &lt;property name="resourceAdapter" ref="resourceAdapter"/&gt;
    &lt;property name="activationSpecConfig"&gt;
        &lt;bean class="org.springframework.jms.listener.endpoint.JmsActivationSpecConfig"&gt;
            &lt;property name="destinationName" value="myQueue"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="messageListener" ref="myMessageListener"/&gt;
&lt;/bean&gt;</pre><p>Alternatively, you may set up a <tt class="classname">JmsMessageEndpointManager</tt>
    with a given <tt class="interfacename">ActivationSpec</tt> object. The
    <tt class="interfacename">ActivationSpec</tt> object may also come
    from a JNDI lookup (using <tt class="literal">&lt;jee:jndi-lookup&gt;</tt>).</p><pre class="programlisting">&lt;bean class="org.springframework.jms.listener.endpoint.JmsMessageEndpointManager"&gt;
    &lt;property name="resourceAdapter" ref="resourceAdapter"/&gt;
    &lt;property name="activationSpec"&gt;
        &lt;bean class="org.apache.activemq.ra.ActiveMQActivationSpec"&gt;
            &lt;property name="destination" value="myQueue"/&gt;
            &lt;property name="destinationType" value="javax.jms.Queue"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="messageListener" ref="myMessageListener"/&gt;
&lt;/bean&gt;</pre><p>Using Spring's <tt class="classname">ResourceAdapterFactoryBean</tt>,
    the target <tt class="interfacename">ResourceAdapter</tt> may be
    configured locally as depicted in the following example.</p><pre class="programlisting">&lt;bean id="resourceAdapter" class="org.springframework.jca.support.ResourceAdapterFactoryBean"&gt;
    &lt;property name="resourceAdapter"&gt;
        &lt;bean class="org.apache.activemq.ra.ActiveMQResourceAdapter"&gt;
            &lt;property name="serverUrl" value="tcp://localhost:61616"/&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
    &lt;property name="workManager"&gt;
        &lt;bean class="org.springframework.jca.work.SimpleTaskWorkManager"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>The specified <tt class="interfacename">WorkManager</tt>
    may also point to an environment-specific thread pool - typically
    through <tt class="classname">SimpleTaskWorkManager's</tt>
    "asyncTaskExecutor" property. Consider defining a shared thread
    pool for all your <tt class="interfacename">ResourceAdapter</tt>
    instances if you happen to use multiple adapters.</p><p>In some environments (e.g. WebLogic 9 or above), the entire
    <tt class="interfacename">ResourceAdapter</tt> object may be obtained
    from JNDI instead (using <tt class="literal">&lt;jee:jndi-lookup&gt;</tt>).
    The Spring-based message listeners can then interact with the server-hosted
    <tt class="interfacename">ResourceAdapter</tt>, also using the server's
    built-in <tt class="interfacename">WorkManager</tt>.</p><p>Please consult the JavaDoc for <tt class="classname">JmsMessageEndpointManager</tt>,
    <tt class="classname">JmsActivationSpecConfig</tt>, and
    <tt class="classname">ResourceAdapterFactoryBean</tt> for more details.</p><p>Spring also provides a generic JCA message endpoint manager which is not tied to JMS:
    <tt class="classname">org.springframework.jca.endpoint.GenericMessageEndpointManager</tt>.
    This component allows for using any message listener type (e.g. a CCI MessageListener)
    and any provided-specific ActivationSpec object. Check out your JCA provider's
    documentation to find out about the actual capabilities of your connector,
    and consult <tt class="classname">GenericMessageEndpointManager</tt>'s JavaDoc
    for the Spring-specific configuration details.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>JCA-based message endpoint management is very analogous to EJB 2.1
      Message-Driven Beans; it uses the same underlying resource provider contract.
      Like with EJB 2.1 MDBs, any message listener interface supported by your JCA
      provider can be used in the Spring context as well. Spring nevertheless provides
      explicit 'convenience' support for JMS, simply because JMS is the most common
      endpoint API used with the JCA endpoint management contract.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jms-namespace"></a>19.6.&nbsp;JMS Namespace Support</h2></div></div><div></div></div><p>Spring 2.5 introduces an XML namespace for simplifying JMS configuration. To use the
	JMS namespace elements you will need to reference the JMS schema:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       <span class="bold"><b>xmlns:jms="http://www.springframework.org/schema/jms"</b></span>
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
<span class="bold"><b>http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-2.5.xsd"</b></span>&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="literal">&lt;bean/&gt;</tt> definitions here --&gt;</span></i>

&lt;/beans&gt;</pre><p>The namespace consists of two top-level elements: <tt class="literal">&lt;listener-container/&gt;</tt>
    and <tt class="literal">&lt;jca-listener-container/&gt;</tt> both of which may contain one or more 
    <tt class="literal">&lt;listener/&gt;</tt> child elements. Here is an example of a basic configuration
    for two listeners.</p><pre class="programlisting">&lt;jms:listener-container&gt;

    &lt;jms:listener destination="queue.orders" ref="orderService" method="placeOrder"/&gt;

    &lt;jms:listener destination="queue.confirmations" ref="confirmationLogger" method="log"/&gt;

&lt;/jms:listener-container&gt;</pre><p>The example above is equivalent to creating two distinct listener container bean
    definitions and two distinct <tt class="classname">MessageListenerAdapter</tt> bean 
    definitions as demonstrated in the section entitled
    <a href="#jms-receiving-async-message-listener-adapter" title="19.4.4.&nbsp;The MessageListenerAdapter">Section&nbsp;19.4.4, &#8220;The MessageListenerAdapter&#8221;</a>. In addition to the
    attributes shown above, the <tt class="literal">listener</tt> element may contain several
    optional ones. The following table describes all available attributes:</p><div class="table"><a name="jms-namespace-listener-tbl"></a><p class="title"><b>Table&nbsp;19.1.&nbsp;Attributes of the JMS <tt class="literal">&lt;listener&gt;</tt> element</b></p><table summary="Attributes of the JMS <listener&gt; element" border="1"><colgroup><col><col></colgroup><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td>id</td><td><p>A bean name for the hosting listener container. If not
              specified, a bean name will be automatically generated.</p></td></tr><tr><td>destination <span class="bold"><b>(required)</b></span></td><td><p>The destination name for this listener, resolved through the
              <tt class="interfacename">DestinationResolver</tt> strategy.</p></td></tr><tr><td>ref <span class="bold"><b>(required)</b></span></td><td><p>The bean name of the handler object.</p></td></tr><tr><td>method</td><td><p>The name of the handler method to invoke. If the
              <tt class="literal">ref</tt> points to a
              <tt class="interfacename">MessageListener</tt> or Spring
              <tt class="interfacename">SessionAwareMessageListener</tt>,
              this attribute may be omitted.</p></td></tr><tr><td>response-destination</td><td><p>The name of the default response destination to send
              response messages to. This will be applied in case of a
              request message that does not carry a "JMSReplyTo" field.
              The type of this destination will be determined by the
              listener-container's "destination-type" attribute. Note:
              This only applies to a listener method with a return
              value, for which each result object will be converted
              into a response message.</p></td></tr><tr><td>subscription</td><td><p>The name of the durable subscription, if any.</p></td></tr><tr><td>selector</td><td><p>An optional message selector for this listener.</p></td></tr></tbody></table></div><p>The <tt class="literal">&lt;listener-container/&gt;</tt> element also accepts several optional
    attributes. This allows for customization of the various strategies (for example,
    <span class="property">taskExecutor</span> and <span class="property">destinationResolver</span>) as well as
    basic JMS settings and resource references. Using these attributes, it is possible to define
    highly-customized listener containers while still benefiting from the convenience of the
    namespace.</p><pre class="programlisting">&lt;jms:listener-container connection-factory="myConnectionFactory"
                        task-executor="myTaskExecutor"
                        destination-resolver="myDestinationResolver"
                        transaction-manager="myTransactionManager"
                        concurrency="10"&gt;

    &lt;jms:listener destination="queue.orders" ref="orderService" method="placeOrder"/&gt;

    &lt;jms:listener destination="queue.confirmations" ref="confirmationLogger" method="log"/&gt;

&lt;/jms:listener-container&gt;</pre><p>The following table describes all available attributes. Consult the class-level
    Javadoc of the <tt class="classname">AbstractMessageListenerContainer</tt> and its
    concrete subclasses for more detail on the individual properties. The Javadoc also
    provides a discussion of transaction choices and message redelivery scenarios.</p><div class="table"><a name="jms-namespace-listener-container-tbl"></a><p class="title"><b>Table&nbsp;19.2.&nbsp;Attributes of the JMS <tt class="literal">&lt;listener-container&gt;</tt> element</b></p><table summary="Attributes of the JMS <listener-container&gt; element" border="1"><colgroup><col><col></colgroup><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td>container-type</td><td><p>The type of this listener container. Available options are:
              <tt class="literal">default</tt>, <tt class="literal">simple</tt>,
              <tt class="literal">default102</tt>, or <tt class="literal">simple102</tt>
              (the default value is <tt class="literal">'default'</tt>).</p></td></tr><tr><td>connection-factory</td><td><p>A reference to the JMS
              <tt class="interfacename">ConnectionFactory</tt> bean (the default bean
              name is <tt class="literal">'connectionFactory'</tt>).</p></td></tr><tr><td>task-executor</td><td><p>A reference to the Spring <tt class="interfacename">TaskExecutor</tt>
              for the JMS listener invokers.</p></td></tr><tr><td>destination-resolver</td><td><p>A reference to the <tt class="interfacename">DestinationResolver</tt>
              strategy for resolving JMS <tt class="interfacename">Destinations</tt>.</p></td></tr><tr><td>message-converter</td><td><p>A reference to the <tt class="interfacename">MessageConverter</tt>
              strategy for converting JMS Messages to listener method arguments. Default
              is a <tt class="classname">SimpleMessageConverter</tt>.</p></td></tr><tr><td>destination-type</td><td><p>The JMS destination type for this listener: <tt class="literal">queue</tt>,
              <tt class="literal">topic</tt> or <tt class="literal">durableTopic</tt>.
              The default is <tt class="literal">queue</tt>.</p></td></tr><tr><td>client-id</td><td><p>The JMS client id for this listener container.
              Needs to be specified when using durable subscriptions.</p></td></tr><tr><td>cache</td><td><p>The cache level for JMS resources: <tt class="literal">none</tt>,
              <tt class="literal">connection</tt>, <tt class="literal">session</tt>,
              <tt class="literal">consumer</tt> or <tt class="literal">auto</tt>.
              By default (<tt class="literal">auto</tt>), the cache level will
              effectively be "consumer", unless an external transaction manager
              has been specified - in which case the effective default will be
              <tt class="literal">none</tt> (assuming J2EE-style transaction management
              where the given ConnectionFactory is an XA-aware pool).</p></td></tr><tr><td>acknowledge</td><td><p>The native JMS acknowledge mode: <tt class="literal">auto</tt>,
              <tt class="literal">client</tt>, <tt class="literal">dups-ok</tt> or
              <tt class="literal">transacted</tt>. A value of <tt class="literal">transacted</tt>
              activates a locally transacted <tt class="interfacename">Session</tt>.
              As an alternative, specify the <tt class="literal">transaction-manager</tt>
              attribute described below. Default is <tt class="literal">auto</tt>.</p></td></tr><tr><td>transaction-manager</td><td><p>A reference to an external
              <tt class="interfacename">PlatformTransactionManager</tt>
              (typically an XA-based transaction coordinator, e.g. Spring's
              <tt class="classname">JtaTransactionManager</tt>). If not specified,
              native acknowledging will be used (see "acknowledge" attribute).</p></td></tr><tr><td>concurrency</td><td><p>The number of concurrent sessions/consumers to start for each
              listener. Can either be a simple number indicating the maximum number (e.g. "5")
              or a range indicating the lower as well as the upper limit (e.g. "3-5").
              Note that a specified minimum is just a hint and might be ignored at runtime.
              Default is 1; keep concurrency limited to 1 in case of a topic listener
              or if queue ordering is important; consider raising it for general queues.</p></td></tr><tr><td>prefetch</td><td><p>The maximum number of messages to load into a single session.
              Note that raising this number might lead to starvation of concurrent
              consumers!</p></td></tr></tbody></table></div><p>Configuring a JCA-based listener container with the "jms" schema support is very similar.</p><pre class="programlisting">&lt;jms:jca-listener-container resource-adapter="myResourceAdapter"
                            destination-resolver="myDestinationResolver"
                            transaction-manager="myTransactionManager"
                            concurrency="10"&gt;

    &lt;jms:listener destination="queue.orders" ref="myMessageListener"/&gt;

&lt;/jms:jca-listener-container&gt;</pre><p>The available configuration options for the JCA variant are described in the following table:</p><div class="table"><a name="jms-namespace-jca-listener-container-tbl"></a><p class="title"><b>Table&nbsp;19.3.&nbsp;Attributes of the JMS <tt class="literal">&lt;jca-listener-container/&gt;</tt> element</b></p><table summary="Attributes of the JMS <jca-listener-container/&gt; element" border="1"><colgroup><col><col></colgroup><thead><tr><th>Attribute</th><th>Description</th></tr></thead><tbody><tr><td>resource-adapter</td><td><p>A reference to the JCA
              <tt class="interfacename">ResourceAdapter</tt> bean (the default bean
              name is <tt class="literal">'resourceAdapter'</tt>).</p></td></tr><tr><td>activation-spec-factory</td><td><p>A reference to the <tt class="interfacename">JmsActivationSpecFactory</tt>.
              The default is to autodetect the JMS provider and its
              <tt class="interfacename">ActivationSpec</tt> class
              (see <tt class="classname">DefaultJmsActivationSpecFactory</tt>)</p></td></tr><tr><td>destination-resolver</td><td><p>A reference to the <tt class="interfacename">DestinationResolver</tt>
              strategy for resolving JMS <tt class="interfacename">Destinations</tt>.
              </p></td></tr><tr><td>message-converter</td><td><p>A reference to the <tt class="interfacename">MessageConverter</tt>
              strategy for converting JMS Messages to listener method arguments.
              Default is a <tt class="classname">SimpleMessageConverter</tt>.</p></td></tr><tr><td>destination-type</td><td><p>The JMS destination type for this listener: <tt class="literal">queue</tt>,
              <tt class="literal">topic</tt> or <tt class="literal">durableTopic</tt>.
              The default is <tt class="literal">queue</tt>.</p></td></tr><tr><td>client-id</td><td><p>The JMS client id for this listener container.
              Needs to be specified when using durable subscriptions.</p></td></tr><tr><td>acknowledge</td><td><p>The native JMS acknowledge mode: <tt class="literal">auto</tt>,
              <tt class="literal">client</tt>, <tt class="literal">dups-ok</tt> or
              <tt class="literal">transacted</tt>. A value of <tt class="literal">transacted</tt>
              activates a locally transacted <tt class="interfacename">Session</tt>.
              As an alternative, specify the <tt class="literal">transaction-manager</tt>
              attribute described below. Default is <tt class="literal">auto</tt>.</p></td></tr><tr><td>transaction-manager</td><td><p>A reference to a Spring <tt class="classname">JtaTransactionManager</tt>
              or a <tt class="interfacename">javax.transaction.TransactionManager</tt>
              for kicking off an XA transaction for each incoming message.
              If not specified, native acknowledging will be used (see
              the "acknowledge" attribute).</p></td></tr><tr><td>concurrency</td><td><p>The number of concurrent sessions/consumers to start for each
              listener. Can either be a simple number indicating the maximum number (e.g. "5")
              or a range indicating the lower as well as the upper limit (e.g. "3-5").
              Note that a specified minimum is just a hint and will typically be ignored
              at runtime when using a JCA listener container. Default is 1.</p></td></tr><tr><td>prefetch</td><td><p>The maximum number of messages to load into a single session.
              Note that raising this number might lead to starvation of concurrent
              consumers!</p></td></tr></tbody></table></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="jmx"></a>Chapter&nbsp;20.&nbsp;JMX</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-introduction"></a>20.1.&nbsp;Introduction</h2></div></div><div></div></div><p>The JMX support in Spring provides you with the features to easily
    and transparently integrate your Spring application into a JMX
    infrastructure.</p><div class="sidebar"><p class="title"><b>JMX?</b></p><p>This chapter is not an introduction to JMX... it doesn't try to
      explain the motivations of why one might want to use JMX (or indeed what
      the letters JMX actually stand for). If you are new to JMX, check out
      the section entitled <a href="#jmx-resources" title="20.8.&nbsp;Further Resources">Section&nbsp;20.8, &#8220;Further Resources&#8221;</a> at the end of this
      chapter.</p></div><p>Specifically, Spring's JMX support provides four core
    features:</p><div class="itemizedlist"><ul type="disc"><li><p>The automatic registration of <span class="emphasis"><em>any</em></span> Spring
        bean as a JMX MBean</p></li><li><p>A flexible mechanism for controlling the management interface of
        your beans</p></li><li><p>The declarative exposure of MBeans over remote, JSR-160
        connectors</p></li><li><p>The simple proxying of both local and remote MBean
        resources</p></li></ul></div><p>These features are designed to work without coupling your
    application components to either Spring or JMX interfaces and classes.
    Indeed, for the most part your application classes need not be aware of
    either Spring or JMX in order to take advantage of the Spring JMX
    features.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-exporting"></a>20.2.&nbsp;Exporting your beans to JMX</h2></div></div><div></div></div><p>The core class in Spring's JMX framework is the
    <tt class="classname">MBeanExporter</tt>. This class is responsible for taking
    your Spring beans and registering them with a JMX
    <tt class="interfacename">MBeanServer</tt>. For example, consider the following
    class:</p><pre class="programlisting">package org.springframework.jmx;

public class JmxTestBean implements IJmxTestBean {

    private String name;
    private int age;
    private boolean isSuperman;

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
    
    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public int add(int x, int y) {
        return x + y;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }
}</pre><p>To expose the properties and methods of this bean as attributes and
    operations of an MBean you simply configure an instance of the
    <tt class="classname">MBeanExporter</tt> class in your configuration file and
    pass in the bean as shown below:</p><pre class="programlisting">&lt;beans&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- this bean must <span class="bold"><b>not</b></span> be lazily initialized if the exporting is to happen --&gt;</span></i>
  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter" <span class="bold"><b>lazy-init="false"</b></span>&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The pertinent bean definition from the above configuration snippet
    is the <tt class="literal">exporter</tt> bean. The <tt class="literal">beans</tt>
    property tells the <tt class="classname">MBeanExporter</tt> exactly which of
    your beans must be exported to the JMX <tt class="interfacename">MBeanServer</tt>.
    In the default configuration, the key of each entry in the
    <tt class="literal">beans</tt> <tt class="interfacename">Map</tt> is used as the
    <tt class="classname">ObjectName</tt> for the bean referenced by the
    corresponding entry value. This behavior can be changed as described in
    the section entitled <a href="#jmx-naming" title="20.4.&nbsp;Controlling the ObjectNames for your beans">Section&nbsp;20.4, &#8220;Controlling the ObjectNames for your beans&#8221;</a>.</p><p>With this configuration the <tt class="literal">testBean</tt> bean is
    exposed as an MBean under the <tt class="classname">ObjectName</tt>
    <tt class="literal">bean:name=testBean1</tt>. By default, all
    <span class="emphasis"><em>public</em></span> properties of the bean are exposed as
    attributes and all <span class="emphasis"><em>public</em></span> methods (bar those
    inherited from the <tt class="classname">Object</tt> class) are exposed as
    operations.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-exporting-mbeanserver"></a>20.2.1.&nbsp;Creating an <tt class="interfacename">MBeanServer</tt></h3></div></div><div></div></div><p>The above configuration assumes that the application is running in
      an environment that has one (and only one)
      <tt class="interfacename">MBeanServer</tt> already running. In this case, Spring
      will attempt to locate the running <tt class="interfacename">MBeanServer</tt>
      and register your beans with that server (if any). This behavior is
      useful when your application is running inside a container such as
      Tomcat or IBM WebSphere that has itss own
      <tt class="interfacename">MBeanServer</tt>.</p><p>However, this approach is of no use in a standalone environment,
      or when running inside a container that does not provide an
      <tt class="interfacename">MBeanServer</tt>. To address this you can create an
      <tt class="interfacename">MBeanServer</tt> instance declaratively by adding an
      instance of the
      <tt class="classname">org.springframework.jmx.support.MBeanServerFactoryBean</tt>
      class to your configuration. You can also ensure that a specific
      <tt class="interfacename">MBeanServer</tt> is used by setting the value of the
      <tt class="classname">MBeanExporter</tt>'s <tt class="literal">server</tt>
      property to the <tt class="interfacename">MBeanServer</tt> value returned by an
      <tt class="classname">MBeanServerFactoryBean</tt>; for example:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"/&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!--
    this bean needs to be eagerly pre-instantiated in order for the exporting to occur;
    this means that it must <span class="bold"><b>not</b></span> be marked as lazily initialized
  --&gt;</span></i>
  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="server" ref="mbeanServer"/&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Here an instance of <tt class="interfacename">MBeanServer</tt> is created
      by the <tt class="classname">MBeanServerFactoryBean</tt> and is supplied to
      the <tt class="classname">MBeanExporter</tt> via the server property. When
      you supply your own <tt class="interfacename">MBeanServer</tt> instance, the
      <tt class="classname">MBeanExporter</tt> will not attempt to locate a
      running <tt class="interfacename">MBeanServer</tt> and will use the supplied
      <tt class="interfacename">MBeanServer</tt> instance. For this to work correctly,
      you must (of course) have a JMX implementation on your classpath.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-mbean-server"></a>20.2.2.&nbsp;Reusing an existing <tt class="interfacename">MBeanServer</tt></h3></div></div><div></div></div><p>If no server is specified, the <tt class="classname">MBeanExporter</tt>
      tries to automatically detect a running <tt class="interfacename">MBeanServer</tt>.
      This works in most environment where only one
      <tt class="interfacename">MBeanServer</tt> instance is used, however when multiple
      instances exist, the exporter might pick the wrong server. In such
      cases, one should use the <tt class="interfacename">MBeanServer</tt>
      <tt class="literal">agentId</tt> to indicate which instance to be used:</p><pre class="programlisting">&lt;beans&gt;
   &lt;bean id="mbeanServer" class="org.springframework.jmx.support.MBeanServerFactoryBean"&gt;
     <i class="lineannotation"><span class="lineannotation">&lt;!-- indicate to first look for a server --&gt;</span></i>
     &lt;property name="locateExistingServerIfPossible" value="true"/&gt;
     <i class="lineannotation"><span class="lineannotation">&lt;!-- search for the <tt class="interfacename">MBeanServer</tt> instance with the given agentId --&gt;</span></i>
     &lt;property name="agentId" value="<span class="emphasis"><em>&lt;MBeanServer instance agentId&gt;</em></span>"/&gt;
   &lt;/bean&gt;
   
   &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
     &lt;property name="server" ref="mbeanServer"/&gt;
   ...
   &lt;/bean&gt;
&lt;/beans&gt;</pre><p>For platforms/cases where the existing <tt class="interfacename">MBeanServer</tt>
      has a dynamic (or unknown) <tt class="literal">agentId</tt> which is retrieved through lookup
      methods, one should use <a href="#beans-factory-class-static-factory-method" title="3.2.3.2.2.&nbsp;Instantiation using a static factory method">factory-method</a>:</p><pre class="programlisting">&lt;beans&gt;
   &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
     &lt;property name="server"&gt;
       <i class="lineannotation"><span class="lineannotation">&lt;!-- Custom <tt class="literal">MBeanServerLocator</tt> --&gt;</span></i>
       &lt;bean class="platform.package.MBeanServerLocator" factory-method="locateMBeanServer"/&gt;
     &lt;/property&gt;
     
     <i class="lineannotation"><span class="lineannotation">&lt;!-- other beans here --&gt;</span></i>
     
   &lt;/bean&gt;
&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-exporting-lazy"></a>20.2.3.&nbsp;Lazy-initialized MBeans</h3></div></div><div></div></div><p>If you configure a bean with the
      <tt class="classname">MBeanExporter</tt> that is also configured for lazy
      initialization, then the <tt class="classname">MBeanExporter</tt> will
      <span class="bold"><b>not</b></span> break this contract and will avoid
      instantiating the bean. Instead, it will register a proxy with
      the <tt class="interfacename">MBeanServer</tt> and will defer obtaining the bean
      from the container until the first invocation on the proxy occurs.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-exporting-auto"></a>20.2.4.&nbsp;Automatic registration of MBeans</h3></div></div><div></div></div><p>Any beans that are exported through the
      <tt class="classname">MBeanExporter</tt> and are already valid MBeans are
      registered as-is with the <tt class="interfacename">MBeanServer</tt> without
      further intervention from Spring. MBeans can be automatically detected
      by the <tt class="classname">MBeanExporter</tt> by setting the
      <tt class="literal">autodetect</tt> property to <tt class="literal">true</tt>:</p><pre class="programlisting">&lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
  &lt;property name="autodetect" value="true"/&gt;
&lt;/bean&gt;

&lt;bean name="spring:mbean=true" class="org.springframework.jmx.export.TestDynamicMBean"/&gt;</pre><p>Here, the bean called <tt class="literal">spring:mbean=true</tt> is
      already a valid JMX MBean and will be automatically registered by
      Spring. By default, beans that are autodetected for JMX registration
      have their bean name used as the <tt class="classname">ObjectName</tt>. This
      behavior can be overridden as detailed in the section entitled
      <a href="#jmx-naming" title="20.4.&nbsp;Controlling the ObjectNames for your beans">Section&nbsp;20.4, &#8220;Controlling the ObjectNames for your beans&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-exporting-registration-behavior"></a>20.2.5.&nbsp;Controlling the registration behavior</h3></div></div><div></div></div><p>Consider the scenario where a Spring
      <tt class="classname">MBeanExporter</tt> attempts to register an
      <tt class="classname">MBean</tt> with an <tt class="interfacename">MBeanServer</tt>
      using the <tt class="classname">ObjectName</tt>
      <tt class="literal">'bean:name=testBean1'</tt>. If an
      <tt class="classname">MBean</tt> instance has already been registered under
      that same <tt class="classname">ObjectName</tt>, the default behavior is to
      fail (and throw an
      <tt class="exceptionname">InstanceAlreadyExistsException</tt>).</p><p>It is possible to control the behavior of exactly what happens
      when an <tt class="classname">MBean</tt> is registered with an
      <tt class="interfacename">MBeanServer</tt>. Spring's JMX support allows for
      three different registration behaviors to control the registration
      behavior when the registration process finds that an
      <tt class="classname">MBean</tt> has already been registered under the same
      <tt class="classname">ObjectName</tt>; these registration behaviors are
      summarized on the following table:</p><div class="table"><a name="jmx-registration-behaviors"></a><p class="title"><b>Table&nbsp;20.1.&nbsp;Registration Behaviors</b></p><table summary="Registration Behaviors" border="1"><colgroup><col align="left"><col></colgroup><thead><tr><th align="center">Registration behavior</th><th align="center">Explanation</th></tr></thead><tbody><tr><td align="left"><p><tt class="literal">REGISTRATION_FAIL_ON_EXISTING</tt></p></td><td><p> This is the default registration behavior. If an
                <tt class="classname">MBean</tt> instance has already been
                registered under the same <tt class="classname">ObjectName</tt>,
                the <tt class="classname">MBean</tt> that is being registered will
                not be registered and an
                <tt class="exceptionname">InstanceAlreadyExistsException</tt> will be
                thrown. The existing <tt class="classname">MBean</tt> is
                unaffected. </p></td></tr><tr><td align="left"><p><tt class="literal">REGISTRATION_IGNORE_EXISTING</tt></p></td><td><p> If an <tt class="classname">MBean</tt> instance has
                already been registered under the same
                <tt class="classname">ObjectName</tt>, the
                <tt class="classname">MBean</tt> that is being registered will
                <span class="emphasis"><em>not</em></span> be registered. The existing
                <tt class="classname">MBean</tt> is unaffected, and no
                <tt class="exceptionname">Exception</tt> will be thrown. </p><p> This is useful in settings where multiple applications
                want to share a common <tt class="classname">MBean</tt> in a
                shared <tt class="interfacename">MBeanServer</tt>. </p></td></tr><tr><td align="left"><p><tt class="literal">REGISTRATION_REPLACE_EXISTING</tt></p></td><td><p> If an <tt class="classname">MBean</tt> instance has
                already been registered under the same
                <tt class="classname">ObjectName</tt>, the existing
                <tt class="classname">MBean</tt> that was previously registered
                will be unregistered and the new <tt class="classname">MBean</tt>
                will be registered in its place (the new
                <tt class="classname">MBean</tt> effectively replaces the previous
                instance). </p></td></tr></tbody></table></div><p>The above values are defined as constants on the
      <tt class="classname">MBeanRegistrationSupport</tt> class (the
      <tt class="classname">MBeanExporter</tt> class derives from this
      superclass). If you want to change the default registration behavior,
      you simply need to set the value of the
      <tt class="literal">registrationBehaviorName</tt> property on your
      <tt class="classname">MBeanExporter</tt> definition to one of those
      values.</p><p>The following example illustrates how to effect a change from the
      default registration behavior to the
      <tt class="literal">REGISTRATION_REPLACE_EXISTING</tt> behavior:</p><pre class="programlisting">&lt;beans&gt;

    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="beans"&gt;
            &lt;map&gt;
                &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="registrationBehaviorName" value="REGISTRATION_REPLACE_EXISTING"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-interface"></a>20.3.&nbsp;Controlling the management interface of your beans</h2></div></div><div></div></div><p>In the previous example, you had little control over the management
    interface of your bean; <span class="emphasis"><em>all</em></span> of the
    <span class="emphasis"><em>public</em></span> properties and methods of each exported bean
    was exposed as JMX attributes and operations respectively. To exercise
    finer-grained control over exactly which properties and methods of your
    exported beans are actually exposed as JMX attributes and operations,
    Spring JMX provides a comprehensive and extensible mechanism for
    controlling the management interfaces of your beans.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-assembler"></a>20.3.1.&nbsp;The <tt class="interfacename">MBeanInfoAssembler</tt>
      Interface</h3></div></div><div></div></div><p>Behind the scenes, the <tt class="classname">MBeanExporter</tt>
      delegates to an implementation of the
      <tt class="classname">org.springframework.jmx.export.assembler.MBeanInfoAssembler</tt>
      interface which is responsible for defining the management interface of
      each bean that is being exposed. The default implementation,
      <tt class="classname">org.springframework.jmx.export.assembler.SimpleReflectiveMBeanInfoAssembler</tt>,
      simply defines a management interface that exposes all public properties
      and methods (as you saw in the previous examples). Spring provides two
      additional implementations of the
      <tt class="interfacename">MBeanInfoAssembler</tt> interface that allow
      you to control the generated management interface using either
      source-level metadata or any arbitrary interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-metadata"></a>20.3.2.&nbsp;Using source-Level metadata</h3></div></div><div></div></div><p>Using the <tt class="classname">MetadataMBeanInfoAssembler</tt> you
      can define the management interfaces for your beans using source level
      metadata. The reading of metadata is encapsulated by the
      <tt class="classname">org.springframework.jmx.export.metadata.JmxAttributeSource</tt>
      interface. Out of the box, Spring JMX provides support for two
      implementations of this interface:
      <tt class="classname">org.springframework.jmx.export.metadata.AttributesJmxAttributeSource</tt>
      for Commons Attributes and
      <tt class="classname">org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource</tt>
      for JDK 5.0 annotations. The
      <tt class="classname">MetadataMBeanInfoAssembler</tt>
      <span class="emphasis"><em>must</em></span> be configured with an implementation instance
      of the <tt class="classname">JmxAttributeSource</tt> interface for it to
      function correctly (there is <span class="emphasis"><em>no</em></span> default). For the
      following example, we will use the Commons Attributes metadata
      approach.</p><p>To mark a bean for export to JMX, you should annotate the bean
      class with the <tt class="classname">ManagedResource</tt> attribute. In the
      case of the Commons Attributes metadata approach this class can be found
      in the <tt class="literal">org.springframework.jmx.metadata</tt> package. Each
      method you wish to expose as an operation must be marked with the
      <tt class="classname">ManagedOperation</tt> attribute and each property you
      wish to expose must be marked with the
      <tt class="classname">ManagedAttribute</tt> attribute. When marking
      properties you can omit either the annotation of the getter or the
      setter to create a write-only or read-only attribute
      respectively.</p><p>The example below shows the <tt class="classname">JmxTestBean</tt>
      class that you saw earlier marked with Commons Attributes
      metadata:</p><pre class="programlisting">package org.springframework.jmx;

/**
 * @@org.springframework.jmx.export.metadata.ManagedResource
 *  (description="My Managed Bean", objectName="spring:bean=test",
 *  log=true, logFile="jmx.log", currencyTimeLimit=15, persistPolicy="OnUpdate",
 *  persistPeriod=200, persistLocation="foo", persistName="bar")
 */
public class JmxTestBean implements IJmxTestBean {

  private String name;

  private int age;


  /**
   * @@org.springframework.jmx.export.metadata.ManagedAttribute
   *   (description="The Age Attribute", currencyTimeLimit=15)
   */
  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  /**
   * @@org.springframework.jmx.export.metadata.ManagedAttribute
   *  (description="The Name Attribute",  currencyTimeLimit=20,
   *   defaultValue="bar", persistPolicy="OnUpdate")
   */
  public void setName(String name) {
    this.name = name;
  }

  /**
   * @@org.springframework.jmx.export.metadata.ManagedAttribute
   *   (defaultValue="foo", persistPeriod=300)
   */
  public String getName() {
    return name;
  }

  /**
   * @@org.springframework.jmx.export.metadata.ManagedOperation
   *  (description="Add Two Numbers Together")
   */
  public int add(int x, int y) {
    return x + y;
  }

  public void dontExposeMe() {
    throw new RuntimeException();
  }
}</pre><p>Here you can see that the <tt class="classname">JmxTestBean</tt> class
      is marked with the <tt class="classname">ManagedResource</tt> attribute and
      that this <tt class="classname">ManagedResource</tt> attribute is configured
      with a set of properties. These properties can be used to configure
      various aspects of the MBean that is generated by the
      <tt class="classname">MBeanExporter</tt>, and are explained in greater
      detail later in section entitled <a href="#jmx-interface-metadata-types" title="20.3.4.&nbsp;Source-Level Metadata Types">Section&nbsp;20.3.4, &#8220;Source-Level Metadata Types&#8221;</a>.</p><p>You will also notice that both the <tt class="literal">age</tt> and
      <tt class="literal">name</tt> properties are annotated with the
      <tt class="classname">ManagedAttribute</tt> attribute, but in the case of
      the <tt class="literal">age</tt> property, only the getter is marked. This
      will cause both of these properties to be included in the management
      interface as attributes, but the <tt class="literal">age</tt> attribute will
      be read-only.</p><p>Finally, you will notice that the <tt class="literal">add(int, int)</tt>
      method is marked with the <tt class="classname">ManagedOperation</tt>
      attribute whereas the <tt class="literal">dontExposeMe()</tt> method is not.
      This will cause the management interface to contain only one operation,
      <tt class="literal">add(int, int)</tt>, when using the
      <tt class="classname">MetadataMBeanInfoAssembler</tt>.</p><p>The code below shows how you configure the
      <tt class="classname">MBeanExporter</tt> to use the
      <tt class="classname">MetadataMBeanInfoAssembler</tt>:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="assembler" ref="assembler"/&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

  &lt;bean id="attributeSource"
        class="org.springframework.jmx.export.metadata.AttributesJmxAttributeSource"&gt;
    &lt;property name="attributes"&gt;
      &lt;bean class="org.springframework.metadata.commons.CommonsAttributes"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="assembler" class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"&gt;
    &lt;property name="attributeSource" ref="attributeSource"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Here you can see that an
      <tt class="classname">MetadataMBeanInfoAssembler</tt> bean has been
      configured with an instance of the
      <tt class="classname">AttributesJmxAttributeSource</tt> class and passed to
      the <tt class="classname">MBeanExporter</tt> through the assembler property.
      This is all that is required to take advantage of metadata-driven
      management interfaces for your Spring-exposed MBeans.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-annotations"></a>20.3.3.&nbsp;Using JDK 5.0 Annotations</h3></div></div><div></div></div><p>To enable the use of JDK 5.0 annotations for management interface
      definition, Spring provides a set of annotations that mirror the Commons
      Attribute attribute classes and an implementation of the
      <tt class="interfacename">JmxAttributeSource</tt> strategy interface,
      the <tt class="classname">AnnotationsJmxAttributeSource</tt> class, that
      allows the <tt class="interfacename">MBeanInfoAssembler</tt> to read
      them.</p><p>The example below shows a bean where the management interface is defined
      by the presence of JDK 5.0 annotation types:</p><pre class="programlisting">package org.springframework.jmx;

import org.springframework.jmx.export.annotation.ManagedResource;
import org.springframework.jmx.export.annotation.ManagedOperation;
import org.springframework.jmx.export.annotation.ManagedAttribute;

@ManagedResource(objectName="bean:name=testBean4", description="My Managed Bean", log=true,
    logFile="jmx.log", currencyTimeLimit=15, persistPolicy="OnUpdate", persistPeriod=200,
    persistLocation="foo", persistName="bar")
public class AnnotationTestBean implements IJmxTestBean {

  private String name;
  private int age;

  @ManagedAttribute(description="The Age Attribute", currencyTimeLimit=15)
  public int getAge() {
    return age;
  }

  public void setAge(int age) {
    this.age = age;
  }

  @ManagedAttribute(description="The Name Attribute",
      currencyTimeLimit=20,
      defaultValue="bar",
      persistPolicy="OnUpdate")
  public void setName(String name) {
    this.name = name;
  }

  @ManagedAttribute(defaultValue="foo", persistPeriod=300)
  public String getName() {
    return name;
  }

  @ManagedOperation(description="Add two numbers")
  @ManagedOperationParameters({
    @ManagedOperationParameter(name = "x", description = "The first number"),
    @ManagedOperationParameter(name = "y", description = "The second number")})
  public int add(int x, int y) {
    return x + y;
  }

  public void dontExposeMe() {
    throw new RuntimeException();
  }
}</pre><p>As you can see little has changed, other than the basic syntax of
      the metadata definitions.</p><pre class="programlisting">&lt;beans&gt;
    &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
        &lt;property name="assembler" ref="assembler"/&gt;
        &lt;property name="namingStrategy" ref="namingStrategy"/&gt;
        &lt;property name="autodetect" value="true"/&gt;
    &lt;/bean&gt;

    &lt;bean id="jmxAttributeSource"
          class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- will create management interface using annotation metadata --&gt;</span></i>
    &lt;bean id="assembler"
          class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"&gt;
        &lt;property name="attributeSource" ref="jmxAttributeSource"/&gt;
    &lt;/bean&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- will pick up the <tt class="classname">ObjectName</tt> from the annotation --&gt;</span></i>
    &lt;bean id="namingStrategy"
          class="org.springframework.jmx.export.naming.MetadataNamingStrategy"&gt;
        &lt;property name="attributeSource" ref="jmxAttributeSource"/&gt;
    &lt;/bean&gt;

    &lt;bean id="testBean" class="org.springframework.jmx.AnnotationTestBean"&gt;
        &lt;property name="name" value="TEST"/&gt;
        &lt;property name="age" value="100"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-metadata-types"></a>20.3.4.&nbsp;Source-Level Metadata Types</h3></div></div><div></div></div><p>The following source level metadata types are available for use in
      Spring JMX:</p><div class="table"><a name="jmx-metadata-types"></a><p class="title"><b>Table&nbsp;20.2.&nbsp;Source-Level Metadata Types</b></p><table summary="Source-Level Metadata Types" border="1"><colgroup><col align="left"><col><col><col></colgroup><thead><tr><th align="center">Purpose</th><th align="center">Commons Attributes Attribute</th><th align="center">JDK 5.0 Annotation</th><th align="center">Attribute / Annotation Type</th></tr></thead><tbody><tr><td align="left">Mark all instances of a <tt class="classname">Class</tt> as
                JMX managed resources</td><td><tt class="classname">ManagedResource</tt></td><td><tt class="literal">@ManagedResource</tt></td><td>Class</td></tr><tr><td align="left">Mark a method as a JMX operation</td><td><tt class="classname">ManagedOperation</tt></td><td><tt class="literal">@ManagedOperation</tt></td><td>Method</td></tr><tr><td align="left">Mark a getter or setter as one half of a JMX
                attribute</td><td><tt class="classname">ManagedAttribute</tt></td><td><tt class="classname">@ManagedAttribute</tt></td><td>Method (only getters and setters)</td></tr><tr><td align="left">Define descriptions for operation parameters</td><td><tt class="classname">ManagedOperationParameter</tt></td><td><tt class="classname">@ManagedOperationParameter</tt> and
                <tt class="classname">@ManagedOperationParameters</tt></td><td>Method</td></tr></tbody></table></div><p>The following configuration parameters are available for use on
      these source-level metadata types:</p><div class="table"><a name="jmx-metadata-parameters"></a><p class="title"><b>Table&nbsp;20.3.&nbsp;Source-Level Metadata Parameters</b></p><table summary="Source-Level Metadata Parameters" border="1"><colgroup><col align="left"><col><col></colgroup><thead><tr><th align="center">Parameter</th><th align="center">Description</th><th align="center">Applies to</th></tr></thead><tbody><tr><td align="left"><tt class="classname">ObjectName</tt></td><td>Used by <tt class="classname">MetadataNamingStrategy</tt>
                to determine the <tt class="classname">ObjectName</tt> of a
                managed resource</td><td><tt class="classname">ManagedResource</tt></td></tr><tr><td align="left"><tt class="literal">description</tt></td><td>Sets the friendly description of the resource,
                attribute or operation</td><td><tt class="classname">ManagedResource</tt>,
                <tt class="classname">ManagedAttribute</tt>,
                <tt class="classname">ManagedOperation</tt>,
                <tt class="classname">ManagedOperationParameter</tt></td></tr><tr><td align="left"><tt class="literal">currencyTimeLimit</tt></td><td>Sets the value of the
                <tt class="literal">currencyTimeLimit</tt> descriptor field</td><td><tt class="classname">ManagedResource</tt>,
                <tt class="classname">ManagedAttribute</tt></td></tr><tr><td align="left"><tt class="literal">defaultValue</tt></td><td>Sets the value of the <tt class="literal">defaultValue</tt>
                descriptor field</td><td><tt class="classname">ManagedAttribute</tt></td></tr><tr><td align="left"><tt class="literal">log</tt></td><td>Sets the value of the <tt class="literal">log</tt> descriptor
                field</td><td><tt class="classname">ManagedResource</tt></td></tr><tr><td align="left"><tt class="literal">logFile</tt></td><td>Sets the value of the <tt class="literal">logFile</tt>
                descriptor field</td><td><tt class="classname">ManagedResource</tt></td></tr><tr><td align="left"><tt class="literal">persistPolicy</tt></td><td>Sets the value of the <tt class="literal">persistPolicy</tt>
                descriptor field</td><td><tt class="classname">ManagedResource</tt></td></tr><tr><td align="left"><tt class="literal">persistPeriod</tt></td><td>Sets the value of the <tt class="literal">persistPeriod</tt>
                descriptor field</td><td><tt class="classname">ManagedResource</tt></td></tr><tr><td align="left"><tt class="literal">persistLocation</tt></td><td>Sets the value of the
                <tt class="literal">persistLocation</tt> descriptor field</td><td><tt class="classname">ManagedResource</tt></td></tr><tr><td align="left"><tt class="literal">persistName</tt></td><td>Sets the value of the <tt class="literal">persistName</tt>
                descriptor field</td><td><tt class="classname">ManagedResource</tt></td></tr><tr><td align="left"><tt class="literal">name</tt></td><td>Sets the display name of an operation parameter</td><td><tt class="literal">ManagedOperationParameter</tt></td></tr><tr><td align="left"><tt class="literal">index</tt></td><td>Sets the index of an operation parameter</td><td><tt class="literal">ManagedOperationParameter</tt></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-autodetect"></a>20.3.5.&nbsp;The <tt class="classname">AutodetectCapableMBeanInfoAssembler</tt>
      interface</h3></div></div><div></div></div><p>To simplify configuration even further, Spring introduces the
      <tt class="classname">AutodetectCapableMBeanInfoAssembler</tt> interface
      which extends the <tt class="interfacename">MBeanInfoAssembler</tt>
      interface to add support for autodetection of MBean resources. If you
      configure the <tt class="classname">MBeanExporter</tt> with an instance of
      <tt class="classname">AutodetectCapableMBeanInfoAssembler</tt> then it is
      allowed to "vote" on the inclusion of beans for exposure to JMX.</p><p>Out of the box, the only implementation of the
      <tt class="classname">AutodetectCapableMBeanInfo</tt> interface is the
      <tt class="classname">MetadataMBeanInfoAssembler</tt> which will vote to
      include any bean which is marked with the
      <tt class="classname">ManagedResource</tt> attribute. The default approach
      in this case is to use the bean name as the
      <tt class="classname">ObjectName</tt> which results in a configuration like
      this:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- notice how no <tt class="literal">'beans'</tt> are explicitly configured here --&gt;</span></i>
    &lt;property name="autodetect" value="true"/&gt;
    &lt;property name="assembler" ref="assembler"/&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

  <i class="lineannotation"><span class="lineannotation">&lt;!-- (for Commons Attributes-based metadata) --&gt;</span></i>
  &lt;bean id="attributeSource"
        class="org.springframework.jmx.export.metadata.AttributesJmxAttributeSource"&gt;
    &lt;property name="attributes"&gt;
      &lt;bean class="org.springframework.metadata.commons.CommonsAttributes"/&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- (for Java 5+ annotations-based metadata) --&gt;</span></i><span class="emphasis"><em>
  &lt;!--
  &lt;bean id="attributeSource"
        class="org.springframework.jmx.export.annotation.AnnotationJmxAttributeSource"/&gt;
  --&gt;</em></span>

  &lt;bean id="assembler" class="org.springframework.jmx.export.assembler.MetadataMBeanInfoAssembler"&gt;
    &lt;property name="attributeSource" ref="attributeSource"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Notice that in this configuration no beans are passed to the
      <tt class="classname">MBeanExporter</tt>; however, the
      <tt class="classname">JmxTestBean</tt> will still be registered since it is
      marked with the <tt class="classname">ManagedResource</tt> attribute and the
      <tt class="classname">MetadataMBeanInfoAssembler</tt> detects this and votes
      to include it. The only problem with this approach is that the name of
      the <tt class="classname">JmxTestBean</tt> now has business meaning. You can
      address this issue by changing the default behavior for
      <tt class="classname">ObjectName</tt> creation as defined in the section
      entitled <a href="#jmx-naming" title="20.4.&nbsp;Controlling the ObjectNames for your beans">Section&nbsp;20.4, &#8220;Controlling the ObjectNames for your beans&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-java"></a>20.3.6.&nbsp;Defining management interfaces using Java interfaces</h3></div></div><div></div></div><p>In addition to the
      <tt class="classname">MetadataMBeanInfoAssembler</tt>, Spring also includes
      the <tt class="classname">InterfaceBasedMBeanInfoAssembler</tt> which allows
      you to constrain the methods and properties that are exposed based on
      the set of methods defined in a collection of interfaces.</p><p>Although the standard mechanism for exposing MBeans is to use
      interfaces and a simple naming scheme, the
      <tt class="classname">InterfaceBasedMBeanInfoAssembler</tt> extends this
      functionality by removing the need for naming conventions, allowing you
      to use more than one interface and removing the need for your beans to
      implement the MBean interfaces.</p><p>Consider this interface that is used to define a management
      interface for the <tt class="classname">JmxTestBean</tt> class that you saw
      earlier:</p><pre class="programlisting">public interface IJmxTestBean {

  public int add(int x, int y);

  public long myOperation();

  public int getAge();

  public void setAge(int age);

  public void setName(String name);

  public String getName();
}</pre><p>This interface defines the methods and properties that will be
      exposed as operations and attributes on the JMX MBean. The code below
      shows how to configure Spring JMX to use this interface as the
      definition for the management interface:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean5" value-ref="testBean"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="assembler"&gt;
      &lt;bean class="org.springframework.jmx.export.assembler.InterfaceBasedMBeanInfoAssembler"&gt;
        &lt;property name="managedInterfaces"&gt;
          &lt;value&gt;org.springframework.jmx.IJmxTestBean&lt;/value&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>Here you can see that the
      <tt class="classname">InterfaceBasedMBeanInfoAssembler</tt> is configured to
      use the <tt class="interfacename">IJmxTestBean</tt> interface when
      constructing the management interface for any bean. It is important to
      understand that beans processed by the
      <tt class="classname">InterfaceBasedMBeanInfoAssembler</tt> are
      <span class="emphasis"><em>not</em></span> required to implement the interface used to
      generate the JMX management interface.</p><p>In the case above, the <tt class="interfacename">IJmxTestBean</tt>
      interface is used to construct all management interfaces for all beans.
      In many cases this is not the desired behavior and you may want to use
      different interfaces for different beans. In this case, you can pass
      <tt class="classname">InterfaceBasedMBeanInfoAssembler</tt> a
      <tt class="classname">Properties</tt> instance via the
      <tt class="literal">interfaceMappings</tt> property, where the key of each
      entry is the bean name and the value of each entry is a comma-separated
      list of interface names to use for that bean.</p><p>If no management interface is specified through either the
      <tt class="literal">managedInterfaces</tt> or
      <tt class="literal">interfaceMappings</tt> properties, then the
      <tt class="classname">InterfaceBasedMBeanInfoAssembler</tt> will reflect on
      the bean and use all of the interfaces implemented by that bean to
      create the management interface.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-interface-methodnames"></a>20.3.7.&nbsp;Using
      <tt class="classname">MethodNameBasedMBeanInfoAssembler</tt></h3></div></div><div></div></div><p>The <tt class="classname">MethodNameBasedMBeanInfoAssembler</tt>
      allows you to specify a list of method names that will be exposed to JMX
      as attributes and operations. The code below shows a sample
      configuration for this:</p><pre class="programlisting">&lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean5" value-ref="testBean"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="assembler"&gt;
      &lt;bean class="org.springframework.jmx.export.assembler.MethodNameBasedMBeanInfoAssembler"&gt;
        &lt;property name="managedMethods"&gt;
          &lt;value&gt;add,myOperation,getName,setName,getAge&lt;/value&gt;
        &lt;/property&gt;
      &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>Here you can see that the methods <tt class="literal">add</tt> and
      <tt class="literal">myOperation</tt> will be exposed as JMX operations and
      <tt class="literal">getName()</tt>, <tt class="literal">setName(String)</tt> and
      <tt class="literal">getAge()</tt> will be exposed as the appropriate half of a
      JMX attribute. In the code above, the method mappings apply to beans
      that are exposed to JMX. To control method exposure on a bean-by-bean
      basis, use the <tt class="literal">methodMappings</tt> property of
      <tt class="classname">MethodNameMBeanInfoAssembler</tt> to map bean names to
      lists of method names.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-naming"></a>20.4.&nbsp;Controlling the <tt class="classname">ObjectName</tt>s for your beans</h2></div></div><div></div></div><p>Behind the scenes, the <tt class="classname">MBeanExporter</tt>
    delegates to an implementation of the
    <tt class="classname">ObjectNamingStrategy</tt> to obtain
    <tt class="classname">ObjectName</tt>s for each of the beans it is
    registering. The default implementation,
    <tt class="classname">KeyNamingStrategy</tt>, will, by default, use the key of
    the <tt class="literal">beans</tt> <tt class="interfacename">Map</tt> as the
    <tt class="classname">ObjectName</tt>. In addition, the
    <tt class="classname">KeyNamingStrategy</tt> can map the key of the
    <tt class="literal">beans</tt> <tt class="interfacename">Map</tt> to an entry in a
    <tt class="classname">Properties</tt> file (or files) to resolve the
    <tt class="classname">ObjectName</tt>. In addition to the
    <tt class="classname">KeyNamingStrategy</tt>, Spring provides two additional
    <tt class="classname">ObjectNamingStrategy</tt> implementations: the
    <tt class="classname">IdentityNamingStrategy</tt> that builds an
    <tt class="classname">ObjectName</tt> based on the JVM identity of the bean
    and the <tt class="classname">MetadataNamingStrategy</tt> that uses source
    level metadata to obtain the <tt class="classname">ObjectName</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-naming-properties"></a>20.4.1.&nbsp;Reading <tt class="classname">ObjectName</tt>s from <tt class="classname">Properties</tt></h3></div></div><div></div></div><p>You can configure your own
      <tt class="classname">KeyNamingStrategy</tt> instance and configure it to
      read <tt class="classname">ObjectName</tt>s from a
      <tt class="classname">Properties</tt> instance rather than use bean key. The
      <tt class="classname">KeyNamingStrategy</tt> will attempt to locate an entry
      in the <tt class="classname">Properties</tt> with a key corresponding to the
      bean key. If no entry is found or if the
      <tt class="classname">Properties</tt> instance is <tt class="literal">null</tt>
      then the bean key itself is used.</p><p>The code below shows a sample configuration for the
      <tt class="classname">KeyNamingStrategy</tt>:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="testBean" value-ref="testBean"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="namingStrategy" ref="namingStrategy"/&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

  &lt;bean id="namingStrategy" class="org.springframework.jmx.export.naming.KeyNamingStrategy"&gt;
    &lt;property name="mappings"&gt;
      &lt;props&gt;
        &lt;prop key="testBean"&gt;bean:name=testBean1&lt;/prop&gt;
      &lt;/props&gt;
    &lt;/property&gt;
    &lt;property name="mappingLocations"&gt;
      &lt;value&gt;names1.properties,names2.properties&lt;/value&gt;
    &lt;/property&gt;
  &lt;/bean

&lt;/beans&gt;</pre><p>Here an instance of <tt class="classname">KeyNamingStrategy</tt> is
      configured with a <tt class="classname">Properties</tt> instance that is
      merged from the <tt class="classname">Properties</tt> instance defined by
      the mapping property and the properties files located in the paths
      defined by the mappings property. In this configuration, the
      <tt class="literal">testBean</tt> bean will be given the
      <tt class="classname">ObjectName</tt> <tt class="literal">bean:name=testBean1</tt>
      since this is the entry in the <tt class="classname">Properties</tt>
      instance that has a key corresponding to the bean key.</p><p>If no entry in the <tt class="classname">Properties</tt> instance can
      be found then the bean key name is used as the
      <tt class="classname">ObjectName</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-naming-metadata"></a>20.4.2.&nbsp;Using the <tt class="classname">MetadataNamingStrategy</tt></h3></div></div><div></div></div><p>The <tt class="classname">MetadataNamingStrategy</tt> uses
      the <tt class="literal">objectName</tt> property of the
      <tt class="classname">ManagedResource</tt> attribute on each bean to create
      the <tt class="classname">ObjectName</tt>. The code below shows the
      configuration for the
      <tt class="classname">MetadataNamingStrategy</tt>:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="testBean" value-ref="testBean"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="namingStrategy" ref="namingStrategy"/&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

  &lt;bean id="namingStrategy" class="org.springframework.jmx.export.naming.MetadataNamingStrategy"&gt;
    &lt;property name="attributeSource" ref="attributeSource"/&gt;
  &lt;/bean&gt;

  &lt;bean id="attributeSource"
      class="org.springframework.jmx.export.metadata.AttributesJmxAttributeSource"/&gt;

&lt;/beans&gt;</pre><p>If no <tt class="literal">objectName</tt> has been provided for
      the <tt class="classname">ManagedResource</tt> attribute, then an
      <tt class="classname">ObjectName</tt> will be created with the
      following format:
      <span class="emphasis"><em>[fully-qualified-package-name]:type=[short-classname],name=[bean-name]</em></span>.
      For example, the generated <tt class="classname">ObjectName</tt> for the
      following bean would be: <span class="emphasis"><em>com.foo:type=MyClass,name=myBean</em></span>.
      </p><pre class="programlisting">&lt;bean id="myBean" class="com.foo.MyClass"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-context-mbeanexport"></a>20.4.3.&nbsp;The <tt class="literal">&lt;context:mbean-export/&gt;</tt> element</h3></div></div><div></div></div><p>If you are using at least Java 5, then a convenience subclass of
      <tt class="classname">MBeanExporter</tt> is available:
      <tt class="classname">AnnotationMBeanExporter</tt>.
      When defining an instance of this subclass, the <tt class="literal">namingStrategy</tt>,
      <tt class="literal">assembler</tt>, and <tt class="literal">attributeSource</tt>
      configuration is no longer needed, since it will always use standard Java
      annotation-based metadata (autodetection is always enabled as well). In fact,
      an even simpler syntax is supported with the inclusion of Spring's
      '<tt class="literal">context</tt>' namespace in Spring 2.5. Rather than defining an
      <tt class="classname">MBeanExporter</tt> bean, provide this single element:</p><pre class="programlisting">&lt;context:mbean-export/&gt;</pre><p>You can provide a reference to a particular MBean server if
      necessary, and the <tt class="literal">defaultDomain</tt> attribute
      (a property of <tt class="classname">AnnotationMBeanExporter</tt>)
      accepts an alternate value for the generated MBean
      <tt class="classname">ObjectNames</tt>' domains. This would be used
      in place of the fully qualified package name as described in the
      previous section on
      <a href="#jmx-naming-metadata" title="20.4.2.&nbsp;Using the MetadataNamingStrategy"><tt class="classname">MetadataNamingStrategy</tt></a>.
      </p><pre class="programlisting">&lt;context:mbean-export server="myMBeanServer" default-domain="myDomain"/&gt;</pre>.

      <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Do not use interface-based AOP proxies in combination with autodetection of
        JMX annotations in your bean classes. Interface-based proxies 'hide' the target class,
        which also hides the JMX managed resource annotations. Hence, use target-class proxies
        in that case: through setting the 'proxy-target-class' flag on <tt class="literal">&lt;aop:config/&gt;</tt>,
        <tt class="literal">&lt;tx:annotation-driven/&gt;</tt>, etc. Otherwise, your JMX beans
        might be silently ignored at startup...</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-jsr160"></a>20.5.&nbsp;JSR-160 Connectors</h2></div></div><div></div></div><p>For remote access, Spring JMX module offers two
    <tt class="classname">FactoryBean</tt> implementations inside the
    <tt class="literal">org.springframework.jmx.support</tt> package for creating
    both server- and client-side connectors.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-jsr160-server"></a>20.5.1.&nbsp;Server-side Connectors</h3></div></div><div></div></div><p>To have Spring JMX create, start and expose a JSR-160
      <tt class="classname">JMXConnectorServer</tt> use the following
      configuration:</p><pre class="programlisting">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"/&gt;</pre><p>By default <tt class="literal">ConnectorServerFactoryBean</tt> creates a
      <tt class="classname">JMXConnectorServer</tt> bound to
      <tt class="literal">"service:jmx:jmxmp://localhost:9875"</tt>. The
      <tt class="literal">serverConnector</tt> bean thus exposes the local
      <tt class="interfacename">MBeanServer</tt> to clients through the JMXMP protocol
      on localhost, port 9875. Note that the JMXMP protocol is marked as
      optional by the JSR 160 specification: currently, the main open-source
      JMX implementation, MX4J, and the one provided with J2SE 5.0 do
      <span class="emphasis"><em>not</em></span> support JMXMP.</p><p>To specify another URL and register the
      <tt class="classname">JMXConnectorServer</tt> itself with the
      <tt class="interfacename">MBeanServer</tt> use the <tt class="literal">serviceUrl</tt>
      and <tt class="classname">ObjectName</tt> properties respectively:</p><pre class="programlisting">&lt;bean id="serverConnector"
      class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
  &lt;property name="objectName" value="connector:name=rmi"/&gt;
  &lt;property name="serviceUrl" 
            value="service:jmx:rmi://localhost/jndi/rmi://localhost:1099/myconnector"/&gt;
&lt;/bean&gt;</pre><p>If the <tt class="classname">ObjectName</tt> property is set Spring
      will automatically register your connector with the
      <tt class="interfacename">MBeanServer</tt> under that
      <tt class="classname">ObjectName</tt>. The example below shows the full set
      of parameters which you can pass to the
      <tt class="classname">ConnectorServerFactoryBean</tt> when creating a
      JMXConnector:</p><pre class="programlisting">&lt;bean id="serverConnector"
      class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
  &lt;property name="objectName" value="connector:name=iiop"/&gt;
  &lt;property name="serviceUrl" 
               value="service:jmx:iiop://localhost/jndi/iiop://localhost:900/myconnector"/&gt;
  &lt;property name="threaded" value="true"/&gt;
  &lt;property name="daemon" value="true"/&gt;
  &lt;property name="environment"&gt;
    &lt;map&gt;
      &lt;entry key="someKey" value="someValue"/&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>Note that when using a RMI-based connector you need the lookup
      service (tnameserv or rmiregistry) to be started in order for the name
      registration to complete. If you are using Spring to export remote
      services for you via RMI, then Spring will already have constructed an
      RMI registry. If not, you can easily start a registry using the
      following snippet of configuration:</p><pre class="programlisting">&lt;bean id="registry" class="org.springframework.remoting.rmi.RmiRegistryFactoryBean"&gt;
  &lt;property name="port" value="1099"/&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-jsr160-client"></a>20.5.2.&nbsp;Client-side Connectors</h3></div></div><div></div></div><p>To create an <tt class="classname">MBeanServerConnection</tt> to a
      remote JSR-160 enabled <tt class="interfacename">MBeanServer</tt> use the
      <tt class="classname">MBeanServerConnectionFactoryBean</tt> as shown
      below:</p><pre class="programlisting">&lt;bean id="clientConnector" class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean"&gt;
  &lt;property name="serviceUrl" value="service:jmx:rmi://localhost:9875"/&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-jsr160-protocols"></a>20.5.3.&nbsp;JMX over Burlap/Hessian/SOAP</h3></div></div><div></div></div><p>JSR-160 permits extensions to the way in which communication is
      done between the client and the server. The examples above are using the
      mandatory RMI-based implementation required by the JSR-160 specification
      (IIOP and JRMP) and the (optional) JMXMP. By using other providers or
      JMX implementations (such as <a href="http://mx4j.sourceforge.net" target="_top">MX4J</a>) you can take advantage
      of protocols like SOAP, Hessian, Burlap over simple HTTP or SSL and
      others:</p><pre class="programlisting">&lt;bean id="serverConnector" class="org.springframework.jmx.support.ConnectorServerFactoryBean"&gt;
  &lt;property name="objectName" value="connector:name=burlap"/&gt;
  &lt;property name="serviceUrl" value="service:jmx:burlap://localhost:9874"/&gt;
&lt;/bean&gt;</pre><p>In the case of the above example, MX4J 3.0.0 was used; see the
      official MX4J documentation for more information.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-proxy"></a>20.6.&nbsp;Accessing MBeans via Proxies</h2></div></div><div></div></div><p>Spring JMX allows you to create proxies that re-route calls to
    MBeans registered in a local or remote <tt class="interfacename">MBeanServer</tt>.
    These proxies provide you with a standard Java interface through which you
    can interact with your MBeans. The code below shows how to configure a
    proxy for an MBean running in a local
    <tt class="interfacename">MBeanServer</tt>:</p><pre class="programlisting">&lt;bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean"&gt;
    &lt;property name="objectName" value="bean:name=testBean"/&gt;
    &lt;property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/&gt;
&lt;/bean&gt;</pre><p>Here you can see that a proxy is created for the MBean registered
    under the <tt class="classname">ObjectName</tt>:
    <tt class="literal">bean:name=testBean</tt>. The set of interfaces that the
    proxy will implement is controlled by the
    <tt class="literal">proxyInterfaces</tt> property and the rules for mapping
    methods and properties on these interfaces to operations and attributes on
    the MBean are the same rules used by the
    <tt class="classname">InterfaceBasedMBeanInfoAssembler</tt>.</p><p>The <tt class="classname">MBeanProxyFactoryBean</tt> can create a proxy
    to any MBean that is accessible via an
    <tt class="classname">MBeanServerConnection</tt>. By default, the local
    <tt class="interfacename">MBeanServer</tt> is located and used, but you can
    override this and provide an <tt class="classname">MBeanServerConnection</tt>
    pointing to a remote <tt class="interfacename">MBeanServer</tt> to cater for
    proxies pointing to remote MBeans:</p><pre class="programlisting">&lt;bean id="clientConnector"
      class="org.springframework.jmx.support.MBeanServerConnectionFactoryBean"&gt;
  &lt;property name="serviceUrl" value="service:jmx:rmi://remotehost:9875"/&gt;
&lt;/bean&gt;

&lt;bean id="proxy" class="org.springframework.jmx.access.MBeanProxyFactoryBean"&gt;
  &lt;property name="objectName" value="bean:name=testBean"/&gt;
  &lt;property name="proxyInterface" value="org.springframework.jmx.IJmxTestBean"/&gt;
  &lt;property name="server" ref="clientConnector"/&gt;
&lt;/bean&gt;</pre><p>Here you can see that we create an
    <tt class="classname">MBeanServerConnection</tt> pointing to a remote machine
    using the <tt class="classname">MBeanServerConnectionFactoryBean</tt>. This
    <tt class="classname">MBeanServerConnection</tt> is then passed to the
    <tt class="classname">MBeanProxyFactoryBean</tt> via the
    <tt class="literal">server</tt> property. The proxy that is created will forward
    all invocations to the <tt class="interfacename">MBeanServer</tt> via this
    <tt class="classname">MBeanServerConnection</tt>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-notifications"></a>20.7.&nbsp;Notifications</h2></div></div><div></div></div><p>Spring's JMX offering includes comprehensive support for JMX
    notifications.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-notifications-listeners"></a>20.7.1.&nbsp;Registering Listeners for Notifications</h3></div></div><div></div></div><p>Spring's JMX support makes it very easy to register any number of
      <tt class="classname">NotificationListeners</tt> with any number of MBeans
      (this includes MBeans exported by Spring's
      <tt class="classname">MBeanExporter</tt> and MBeans registered via some
      other mechanism). By way of an example, consider the scenario where one
	  would like to be informed (via a <tt class="classname">Notification</tt>)
	  each and every time an attribute of a target MBean changes.</p><pre class="programlisting">package com.example;

import javax.management.AttributeChangeNotification;
import javax.management.Notification;
import javax.management.NotificationFilter;
import javax.management.NotificationListener;

public class ConsoleLoggingNotificationListener
               implements NotificationListener, NotificationFilter {

    public void handleNotification(Notification notification, Object handback) {
        System.out.println(notification);
        System.out.println(handback);
    }

    public boolean isNotificationEnabled(Notification notification) {
        return AttributeChangeNotification.class.isAssignableFrom(notification.getClass());
    }
}</pre><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="notificationListenerMappings"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean1"&gt;
          &lt;bean class="com.example.ConsoleLoggingNotificationListener"/&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>With the above configuration in place, every time a JMX
		<tt class="classname">Notification</tt> is broadcast from the target MBean
		(<tt class="literal">bean:name=testBean1</tt>), the
		<tt class="classname">ConsoleLoggingNotificationListener</tt> bean that was
		registered as a listener via the
		<tt class="literal">notificationListenerMappings</tt> property will be
		notified. The <tt class="classname">ConsoleLoggingNotificationListener</tt>
		bean can then take whatever action it deems appropriate in response to
		the <tt class="classname">Notification</tt>.</p><p>You can also use straight bean names as the link between exported beans
		and listeners:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="notificationListenerMappings"&gt;
      &lt;map&gt;
        &lt;entry key="<span class="bold"><b>testBean</b></span>"&gt;
          &lt;bean class="com.example.ConsoleLoggingNotificationListener"/&gt;
        &lt;/entry&gt;
      &lt;/map&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="<span class="bold"><b>testBean</b></span>" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>If one wants to register a single <tt class="classname">NotificationListener</tt>
		instance for all of the beans that the enclosing <tt class="classname">MBeanExporter</tt>
		is exporting, one can use the special wildcard <tt class="literal">'*'</tt> (sans quotes)
		as the key for an entry in the <tt class="literal">notificationListenerMappings</tt>
		property map; for example:</p><pre class="programlisting">&lt;property name="notificationListenerMappings"&gt;
  &lt;map&gt;
    &lt;entry key="*"&gt;
      &lt;bean class="com.example.ConsoleLoggingNotificationListener"/&gt;
    &lt;/entry&gt;
  &lt;/map&gt;
&lt;/property&gt;</pre><p>If one needs to do the inverse (that is, register a number of distinct
      listeners against an MBean), then one has to use the
      <tt class="literal">notificationListeners</tt> list property instead (and in
      preference to the <tt class="literal">notificationListenerMappings</tt>
      property). This time, instead of configuring simply a
      <tt class="classname">NotificationListener</tt> for a single MBean, one
      configures <tt class="classname">NotificationListenerBean</tt> instances...
      a <tt class="classname">NotificationListenerBean</tt> encapsulates a
      <tt class="classname">NotificationListener</tt> and the
      <tt class="classname">ObjectName</tt> (or
      <tt class="classname">ObjectNames</tt>) that it is to be registered against
      in an <tt class="interfacename">MBeanServer</tt>. The
      <tt class="classname">NotificationListenerBean</tt> also encapsulates a
      number of other properties such as a
      <tt class="classname">NotificationFilter</tt> and an arbitrary handback
      object that can be used in advanced JMX notification scenarios.</p><p>The configuration when using
      <tt class="classname">NotificationListenerBean</tt> instances is not wildly
      different to what was presented previously:</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean1" value-ref="testBean"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="notificationListeners"&gt;
        &lt;list&gt;
            &lt;bean class="org.springframework.jmx.export.NotificationListenerBean"&gt;
                &lt;constructor-arg&gt;
                    &lt;bean class="com.example.ConsoleLoggingNotificationListener"/&gt;
                &lt;/constructor-arg&gt;
                &lt;property name="mappedObjectNames"&gt;
                    &lt;list&gt;
                        &lt;value&gt;bean:name=testBean1&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre><p>The above example is equivalent to the first notification example.
      Lets assume then that we want to be given a handback object every time a
      <tt class="classname">Notification</tt> is raised, and that additionally we
      want to filter out extraneous <tt class="classname">Notifications</tt> by
      supplying a <tt class="classname">NotificationFilter</tt>. (For a full
      discussion of just what a handback object is, and indeed what a
      <tt class="classname">NotificationFilter</tt> is, please do consult that
      section of the JMX specification (1.2) entitled <tt class="literal">'The JMX
      Notification Model'</tt>.)</p><pre class="programlisting">&lt;beans&gt;

  &lt;bean id="exporter" class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
      &lt;map&gt;
        &lt;entry key="bean:name=testBean1" value-ref="testBean1"/&gt;
        &lt;entry key="bean:name=testBean2" value-ref="testBean2"/&gt;
      &lt;/map&gt;
    &lt;/property&gt;
    &lt;property name="notificationListeners"&gt;
        &lt;list&gt;
            &lt;bean class="org.springframework.jmx.export.NotificationListenerBean"&gt;
                &lt;constructor-arg ref="customerNotificationListener"/&gt;
                &lt;property name="mappedObjectNames"&gt;
                    &lt;list&gt;
                        <i class="lineannotation"><span class="lineannotation">&lt;!-- handles notifications from two distinct MBeans --&gt;</span></i>
                        &lt;value&gt;bean:name=testBean1&lt;/value&gt;
                        &lt;value&gt;bean:name=testBean2&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
                &lt;property name="handback"&gt;
                    &lt;bean class="java.lang.String"&gt;
                        &lt;constructor-arg value="This could be anything..."/&gt;
                    &lt;/bean&gt;
                &lt;/property&gt;
                &lt;property name="notificationFilter" ref="customerNotificationListener"/&gt;
            &lt;/bean&gt;
        &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
  
  <i class="lineannotation"><span class="lineannotation">&lt;!-- implements both the <tt class="interfacename">NotificationListener</tt> and <tt class="interfacename">NotificationFilter</tt> interfaces --&gt;</span></i>
  &lt;bean id="customerNotificationListener" class="com.example.ConsoleLoggingNotificationListener"/&gt;

  &lt;bean id="testBean1" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="TEST"/&gt;
    &lt;property name="age" value="100"/&gt;
  &lt;/bean&gt;

  &lt;bean id="testBean2" class="org.springframework.jmx.JmxTestBean"&gt;
    &lt;property name="name" value="ANOTHER TEST"/&gt;
    &lt;property name="age" value="200"/&gt;
  &lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="jmx-notifications-publishing"></a>20.7.2.&nbsp;Publishing Notifications</h3></div></div><div></div></div><p>Spring provides support not just for registering to receive
      <tt class="classname">Notifications</tt>, but also for publishing
      <tt class="classname">Notifications</tt>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Please note that this section is really only relevant to Spring
        managed beans that have been exposed as MBeans via an
        <tt class="classname">MBeanExporter</tt>; any existing, user-defined
        MBeans should use the standard JMX APIs for notification publication.</p></td></tr></table></div><p>The key interface in Spring's JMX notification publication support
      is the <tt class="classname">NotificationPublisher</tt> interface (defined
      in the <tt class="literal">org.springframework.jmx.export.notification</tt>
      package). Any bean that is going to be exported as an MBean via an
      <tt class="classname">MBeanExporter</tt> instance can implement the related
      <tt class="classname">NotificationPublisherAware</tt> interface to gain
      access to a <tt class="classname">NotificationPublisher</tt> instance. The
      <tt class="classname">NotificationPublisherAware</tt> interface simply
      supplies an instance of a <tt class="classname">NotificationPublisher</tt>
      to the implementing bean via a simple setter method, which the bean can
      then use to publish <tt class="classname">Notifications</tt>.</p><p>As stated in the Javadoc for the
      <tt class="classname">NotificationPublisher</tt> class, managed beans that
      are publishing events via the
      <tt class="classname">NotificationPublisher</tt> mechanism are
      <span class="emphasis"><em>not</em></span> responsible for the state management of any
      notification listeners and the like ... Spring's JMX support will take
      care of handling all the JMX infrastructure issues. All one need do as
      an application developer is implement the
      <tt class="classname">NotificationPublisherAware</tt> interface and start
      publishing events using the supplied
      <tt class="classname">NotificationPublisher</tt> instance. Note that the
      <tt class="classname">NotificationPublisher</tt> will be set
      <span class="emphasis"><em>after</em></span> the managed bean has been registered with an
      <tt class="interfacename">MBeanServer</tt>.</p><p>Using a <tt class="classname">NotificationPublisher</tt> instance is
      quite straightforward... one simply creates a JMX
      <tt class="classname">Notification</tt> instance (or an instance of an
      appropriate <tt class="classname">Notification</tt> subclass), populates
      the notification with the data pertinent to the event that is to be
      published, and one then invokes the
      <tt class="methodname">sendNotification(Notification)</tt> on the
      <tt class="classname">NotificationPublisher</tt> instance, passing in the
      <tt class="classname">Notification</tt>.</p><p>Find below a simple example... in this scenario, exported
      instances of the <tt class="classname">JmxTestBean</tt> are going to publish
      a <tt class="classname">NotificationEvent</tt> every time the
      <tt class="literal">add(int, int)</tt> operation is invoked.</p><pre class="programlisting">package org.springframework.jmx;
			
import org.springframework.jmx.export.notification.NotificationPublisherAware;
import org.springframework.jmx.export.notification.NotificationPublisher;
import javax.management.Notification;

public class JmxTestBean implements IJmxTestBean, NotificationPublisherAware {

    private String name;
    private int age;
    private boolean isSuperman;
    private NotificationPublisher publisher;

    <i class="lineannotation"><span class="lineannotation">// other getters and setters omitted for clarity</span></i>

    public int add(int x, int y) {
        int answer = x + y;
        this.publisher.sendNotification(new Notification("add", this, 0));
        return answer;
    }

    public void dontExposeMe() {
        throw new RuntimeException();
    }
    
    public void setNotificationPublisher(NotificationPublisher notificationPublisher) {
        this.publisher = notificationPublisher;
    }
}</pre><p>The <tt class="classname">NotificationPublisher</tt> interface and the
      machinery to get it all working is one of the nicer features of Spring's JMX support.
	  It does however come with the price tag of coupling your classes to both Spring and JMX; as
	  always, the advice here is to be pragmatic... if you need the functionality offered by the
      <tt class="classname">NotificationPublisher</tt> and you can accept the coupling to both Spring
	  and JMX, then do so.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="jmx-resources"></a>20.8.&nbsp;Further Resources</h2></div></div><div></div></div><p>This section contains links to further resources about JMX.</p><div class="itemizedlist"><ul type="disc"><li><p>The <a href="http://java.sun.com/products/JavaManagement/" target="_top">JMX homepage</a> at Sun</p></li><li><p>The <a href="http://jcp.org/aboutJava/communityprocess/final/jsr003/index3.html" target="_top">JMX specification</a> (JSR-000003)</p></li><li><p>The <a href="http://jcp.org/aboutJava/communityprocess/final/jsr160/index.html" target="_top">JMX Remote API specification</a> (JSR-000160)</p></li><li><p>The <a href="http://mx4j.sourceforge.net/" target="_top">MX4J
        homepage</a> (an Open Source implementation of various JMX
        specs)</p></li><li><p><a href="http://java.sun.com/developer/technicalArticles/J2SE/jmx.html" target="_top">Getting Started with JMX</a> - an introductory article from Sun.</p></li></ul></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="cci"></a>Chapter&nbsp;21.&nbsp;JCA CCI</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cci-introduction"></a>21.1.&nbsp;Introduction</h2></div></div><div></div></div><p>J2EE provides a specification to standardize access to enterprise information systems (EIS):
    the JCA (Java Connector Architecture). This specification is divided into several different parts:</p><div class="itemizedlist"><ul type="disc"><li><p>SPI (Service provider interfaces) that the connector provider
        must implement. These interfaces constitute a resource adapter which
        can be deployed on a J2EE application server. In such a scenario, the
        server manages connection pooling, transaction and security (managed
        mode). The application server is also responsible for managing the
        configuration, which is held outside the client application. A connector
        can be used without an application server as well; in this case, the
        application must configure it directly (non-managed mode).</p></li><li><p>CCI (Common Client Interface) that an application can use to
        interact with the connector and thus communicate with an EIS. An API
        for local transaction demarcation is provided as well.</p></li></ul></div><p>The aim of the Spring CCI support is to provide classes to access
    a CCI connector in typical Spring style, leveraging the Spring Framework's general
    resource and transaction management facilities.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The client side of connectors doesn't alway use CCI. Some
        connectors expose their own APIs, only providing JCA resource adapter to
        use the system contracts of a J2EE container (connection pooling, global
        transactions, security). Spring does not offer special support for such
        connector-specific APIs.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cci-config"></a>21.2.&nbsp;Configuring CCI</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-config-connector"></a>21.2.1.&nbsp;Connector configuration</h3></div></div><div></div></div><p>The base resource to use JCA CCI is the
      <tt class="interfacename">ConnectionFactory</tt> interface. The connector used
      must provide an implementation of this interface.</p><p>To use your connector, you can deploy it on your application
      server and fetch the <tt class="interfacename">ConnectionFactory</tt> from the
      server's JNDI environment (managed mode). The connector must be
      packaged as a RAR file (resource adapter archive) and contain a
      <tt class="filename">ra.xml</tt> file to describe its deployment
      characteristics. The actual name of the resource is specified when
      you deploy it. To access it within Spring, simply use Spring's
      <tt class="classname">JndiObjectFactoryBean</tt> to fetch the factory
      by its JNDI name.</p><p>Another way to use a connector is to embed it in your application
      (non-managed mode), not using an application server to deploy and
      configure it. Spring offers the possibility to configure a connector
      as a bean, through a provided <tt class="literal">FactoryBean</tt>
      (<tt class="classname">LocalConnectionFactoryBean</tt>). In this manner,
      you only need the connector library in the classpath (no RAR file and
      no <tt class="filename">ra.xml</tt> descriptor needed). The library must
      be extracted from the connector's RAR file, if necessary.</p><p>Once you have got access to your <tt class="interfacename">ConnectionFactory</tt>
      instance, you can inject it into your components. These components can
      either be coded against the plain CCI API or leverage Spring's support
      classes for CCI access (e.g. <tt class="classname">CciTemplate</tt>).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>When you use a connector in
        non-managed mode, you can't use global transactions because the resource
        is never enlisted / delisted in the current global transaction of the
        current thread. The resource is simply not aware of any global J2EE
	    transactions that might be running.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-config-connectionfactory"></a>21.2.2.&nbsp;<tt class="interfacename">ConnectionFactory</tt> configuration in Spring</h3></div></div><div></div></div><p>In order to make connections to the EIS, you need to obtain a
      <tt class="interfacename">ConnectionFactory</tt> from the application server if
      you are in a managed mode, or directly from Spring if you are in a
      non-managed mode.</p><p>In a managed mode, you access a <tt class="interfacename">ConnectionFactory</tt>
      from JNDI; its properties will be configured in the application server.</p><pre class="programlisting">&lt;bean id="eciConnectionFactory" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
  &lt;property name="jndiName" value="eis/cicseci"/&gt;
&lt;/bean&gt;</pre><p>In non-managed mode, you must configure the <tt class="interfacename">ConnectionFactory</tt>
      you want to use in the configuration of Spring as a JavaBean. The
      <tt class="classname">LocalConnectionFactoryBean</tt> class offers this
      setup style, passing in the <tt class="classname">ManagedConnectionFactory</tt>
      implementation of your connector, exposing the application-level
	  CCI <tt class="interfacename">ConnectionFactory</tt>.</p><pre class="programlisting">&lt;bean id="eciManagedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
  &lt;property name="serverName" value="TXSERIES"/&gt;
  &lt;property name="connectionURL" value="tcp://localhost/"/&gt;
  &lt;property name="portNumber" value="2006"/&gt;
&lt;/bean&gt;

&lt;bean id="eciConnectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory" ref="eciManagedConnectionFactory"/&gt;
&lt;/bean&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>You can't directly instantiate a specific
        <tt class="interfacename">ConnectionFactory</tt>. You need to go through
        the corresponding implementation of the
        <tt class="classname">ManagedConnectionFactory</tt> interface for your
        connector. This interface is part of the JCA SPI specification.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-config-cci-connections"></a>21.2.3.&nbsp;Configuring CCI connections</h3></div></div><div></div></div><p>JCA CCI allow the developer to configure the connections to the
      EIS using the <tt class="interfacename">ConnectionSpec</tt> implementation of your
      connector. In order to configure its properties, you need to wrap the
      target connection factory with a dedicated adapter,
      <tt class="classname">ConnectionSpecConnectionFactoryAdapter</tt>. So, the
      dedicated <tt class="interfacename">ConnectionSpec</tt> can be configured with the
      property <tt class="literal">connectionSpec</tt> (as an inner bean).</p><p>This property is not mandatory because the CCI
      <tt class="interfacename">ConnectionFactory</tt> interface defines two different
      methods to obtain a CCI connection. Some of the
      <tt class="interfacename">ConnectionSpec</tt> properties can often be configured
	  in the application server (in managed mode) or on the corresponding local
	  <tt class="classname">ManagedConnectionFactory</tt> implementation.</p><pre class="programlisting">public interface ConnectionFactory implements Serializable, Referenceable {
  ...
  Connection getConnection() throws ResourceException;
  Connection getConnection(ConnectionSpec connectionSpec) throws ResourceException;
  ...
}</pre><p>Spring provides a <tt class="classname">ConnectionSpecConnectionFactoryAdapter</tt>
      that allows for specifying a <tt class="interfacename">ConnectionSpec</tt> instance
      to use for all operations on a given factory. If the adapter's
	  <tt class="literal">connectionSpec</tt> property is specified, the adapter
      uses the <tt class="literal">getConnection</tt> variant without argument,
      else the one with the <tt class="interfacename">ConnectionSpec</tt> argument.</p><pre class="programlisting">&lt;bean id="managedConnectionFactory"
    class="com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory"&gt;
  &lt;property name="connectionURL" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
  &lt;property name="driverName" value="org.hsqldb.jdbcDriver"/&gt;
&lt;/bean&gt;

&lt;bean id="targetConnectionFactory"
    class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory" ref="managedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory"
    class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"&gt;
  &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt;
  &lt;property name="connectionSpec"&gt;
    &lt;bean class="com.sun.connector.cciblackbox.CciConnectionSpec"&gt;
      &lt;property name="user" value="sa"/&gt;
      &lt;property name="password" value=""/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-config-single-connection"></a>21.2.4.&nbsp;Using a single CCI connection</h3></div></div><div></div></div><p>If you want to use a single CCI connection, Spring provides a further
      <tt class="interfacename">ConnectionFactory</tt> adapter to manage this. The
      <tt class="classname">SingleConnectionFactory</tt> adapter class will open a single
      connection lazily and close it when this bean is destroyed at application
      shutdown. This class will expose special <tt class="interfacename">Connection</tt>
      proxies that behave accordingly, all sharing the same underlying physical
			connection.</p><pre class="programlisting">&lt;bean id="eciManagedConnectionFactory"
    class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
  &lt;property name="serverName" value="TEST"/&gt;
  &lt;property name="connectionURL" value="tcp://localhost/"/&gt;
  &lt;property name="portNumber" value="2006"/&gt;
&lt;/bean&gt;

&lt;bean id="targetEciConnectionFactory"
    class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory" ref="eciManagedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="eciConnectionFactory"
    class="org.springframework.jca.cci.connection.SingleConnectionFactory"&gt;
  &lt;property name="targetConnectionFactory" ref="targetEciConnectionFactory"/&gt;
&lt;/bean&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>This <tt class="interfacename">ConnectionFactory</tt> adapter cannot directly be
        configured with a <tt class="interfacename">ConnectionSpec</tt>. Use an
        intermediary <tt class="classname">ConnectionSpecConnectionFactoryAdapter</tt>
        that the <tt class="classname">SingleConnectionFactory</tt> talks to
        if you require a single connection for a specific
        <tt class="interfacename">ConnectionSpec</tt>.</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cci-using"></a>21.3.&nbsp;Using Spring's CCI access support</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-record-creator"></a>21.3.1.&nbsp;Record conversion</h3></div></div><div></div></div><p>One of the aims of the JCA CCI support is to provide convenient
			facilities for manipulating CCI records. The developer can specify the
      strategy to create records and extract datas from records, for use
      with Spring's <tt class="classname">CciTemplate</tt>. The following interfaces will configure the
      strategy to use input and output records if you don't want to work
      with records directly in your application.</p><p>In order to create an input <tt class="interfacename">Record</tt>, the
      developer can use a dedicated implementation of the
      <tt class="interfacename">RecordCreator</tt> interface.</p><pre class="programlisting">public interface RecordCreator {

  Record createRecord(RecordFactory recordFactory) throws ResourceException, DataAccessException;
}</pre><p>As you can see, the <tt class="literal">createRecord(..)</tt> method
      receives a <tt class="interfacename">RecordFactory</tt> instance as parameter,
			which corresponds to the <tt class="interfacename">RecordFactory</tt> of the
		  <tt class="interfacename">ConnectionFactory</tt> used. This reference can be
			used to create <tt class="interfacename">IndexedRecord</tt> or
      <tt class="interfacename">MappedRecord</tt> instances. The following sample
      shows how to use the <tt class="interfacename">RecordCreator</tt> interface
      and indexed/mapped records.</p><pre class="programlisting">public class MyRecordCreator implements RecordCreator {

  public Record createRecord(RecordFactory recordFactory) throws ResourceException {
    IndexedRecord input = recordFactory.createIndexedRecord("input");
    input.add(new Integer(id));
    return input;
  }
}</pre><p>An output <tt class="interfacename">Record</tt> can be used to receive
      data back from the EIS. Hence, a specific implementation of the
      <tt class="interfacename">RecordExtractor</tt> interface can be passed to
      Spring's <tt class="classname">CciTemplate</tt> for extracting data from the output
      <tt class="interfacename">Record</tt>.</p><pre class="programlisting">public interface RecordExtractor {

  Object extractData(Record record) throws ResourceException, SQLException, DataAccessException;
}</pre><p>The following sample shows how to use the <tt class="interfacename">RecordExtractor</tt> interface.</p><pre class="programlisting">public class MyRecordExtractor implements RecordExtractor {

  public Object extractData(Record record) throws ResourceException {
    CommAreaRecord commAreaRecord = (CommAreaRecord) record;
    String str = new String(commAreaRecord.toByteArray());
    String field1 = string.substring(0,6);
    String field2 = string.substring(6,1);
    return new OutputObject(Long.parseLong(field1), field2);
  }
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-using-template"></a>21.3.2.&nbsp;The <tt class="classname">CciTemplate</tt></h3></div></div><div></div></div><p>The <tt class="classname">CciTemplate</tt> is the central class of the core CCI support package
      (<tt class="literal">org.springframework.jca.cci.core</tt>). It simplifies
      the use of CCI since it handles the creation and release of resources.
      This helps to avoid common errors like forgetting to always close the
      connection. It cares for the lifecycle of connection and interaction
			objects, letting application code focus on generating input records
      from application data and extracting application data from output
      records.</p><p>The JCA CCI specification defines two distinct methods to call
      operations on an EIS. The CCI <tt class="interfacename">Interaction</tt>
      interface provides two execute method signatures:</p><pre class="programlisting">public interface javax.resource.cci.Interaction {
  ...
  boolean execute(InteractionSpec spec, Record input, Record output) throws ResourceException;

  Record execute(InteractionSpec spec, Record input) throws ResourceException;
  ...
}</pre><p>Depending on the template method called, <tt class="classname">CciTemplate</tt>
      will know which <tt class="literal">execute</tt> method to call on the interaction.
      In any case, a correctly initialized <tt class="interfacename">InteractionSpec</tt>
      instance is mandatory.</p><p><tt class="literal">CciTemplate.execute(..)</tt> can be used in two ways:</p><div class="itemizedlist"><ul type="disc"><li><p>With direct <tt class="interfacename">Record</tt> arguments. In this case,
          you simply need to pass the CCI input record in, and the returned object
          be the corresponding CCI output record.</p></li><li><p>With application objects, using record mapping. In this case,
          you need to provide corresponding <tt class="interfacename">RecordCreator</tt>
				  and <tt class="interfacename">RecordExtractor</tt> instances.
          </p></li></ul></div><p>With the first approach, the following methods of the template
      will be used. These methods directly correspond to those on the
      <tt class="interfacename">Interaction</tt> interface.</p><pre class="programlisting">public class CciTemplate implements CciOperations {

  public Record execute(InteractionSpec spec, Record inputRecord)
      throws DataAccessException { ... }

  public void execute(InteractionSpec spec, Record inputRecord, Record outputRecord)
      throws DataAccessException { ... }

}</pre><p>With the second approach, we need to specify the record creation
      and record extraction strategies as arguments. The interfaces used
      are those describe in the previous section on record conversion.
      The corresponding <tt class="classname">CciTemplate</tt> methods are the
      following:</p><pre class="programlisting">public class CciTemplate implements CciOperations {

  public Record execute(InteractionSpec spec, RecordCreator inputCreator)
      throws DataAccessException { ... }

  public Object execute(InteractionSpec spec, Record inputRecord, RecordExtractor outputExtractor)
      throws DataAccessException { ... }

  public Object execute(InteractionSpec spec, RecordCreator creator, RecordExtractor extractor)
      throws DataAccessException { ... }

}</pre><p>Unless the <tt class="literal">outputRecordCreator</tt> property is
      set on the template (see the following section), every method will call
      the corresponding <tt class="literal">execute</tt> method of the CCI
      <tt class="interfacename">Interaction</tt> with two parameters:
      <tt class="interfacename">InteractionSpec</tt> and input <tt class="interfacename">Record</tt>,
			receiving an output <tt class="interfacename">Record</tt> as return value.
			</p><p><tt class="classname">CciTemplate</tt> also provides methods to create
			<tt class="literal">IndexRecord</tt> and <tt class="literal">MappedRecord</tt>
      outside a <tt class="interfacename">RecordCreator</tt> implementation, through
      its <tt class="literal">createIndexRecord(..)</tt> and
      <tt class="literal">createMappedRecord(..)</tt> methods. This can be used
			within DAO implementations to create <tt class="interfacename">Record</tt>
			instances to pass into corresponding
      <tt class="literal">CciTemplate.execute(..)</tt> methods.</p><pre class="programlisting">public class CciTemplate implements CciOperations {

  public IndexedRecord createIndexedRecord(String name) throws DataAccessException { ... }

  public MappedRecord createMappedRecord(String name) throws DataAccessException { ... }

}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-using-dao"></a>21.3.3.&nbsp;DAO support</h3></div></div><div></div></div><p>Spring's CCI support provides a abstract class for DAOs,
      supporting injection of a <tt class="interfacename">ConnectionFactory</tt>
      or a <tt class="classname">CciTemplate</tt> instances. The name of the
      class is <tt class="classname">CciDaoSupport</tt>: It provides simple
      <tt class="literal">setConnectionFactory</tt> and
      <tt class="literal">setCciTemplate</tt> methods. Internally, this
      class will create a <tt class="classname">CciTemplate</tt> instance
      for a passed-in <tt class="interfacename">ConnectionFactory</tt>, exposing
      it to concrete data access implementations in subclasses.</p><pre class="programlisting">public abstract class CciDaoSupport {

  public void setConnectionFactory(ConnectionFactory connectionFactory) { ... }
  public ConnectionFactory getConnectionFactory() { ... }

  public void setCciTemplate(CciTemplate cciTemplate) { ... }
  public CciTemplate getCciTemplate() { ... }

}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="automatic-output-generation"></a>21.3.4.&nbsp;Automatic output record generation</h3></div></div><div></div></div><p>If the connector used only supports the
	  <tt class="methodname">Interaction.execute(..)</tt> method with input and output
      records as parameters (that is, it requires the desired output record
      to be passed in instead of returning an appropriate output record),
      you can set the <tt class="literal">outputRecordCreator</tt> property of the
      <tt class="classname">CciTemplate</tt> to automatically generate an output
      record to be filled by the JCA connector when the response is received.
      This record will be then returned to the caller of the template.</p><p>This property simply holds an implementation of the
      <tt class="interfacename">RecordCreator</tt> interface, used for that purpose.
      The <tt class="interfacename">RecordCreator</tt> interface has already been
      discussed in the section entitled <a href="#cci-record-creator" title="21.3.1.&nbsp;Record conversion">Section&nbsp;21.3.1, &#8220;Record conversion&#8221;</a>.
      The <tt class="literal">outputRecordCreator</tt>
      property must be directly specified on the <tt class="classname">CciTemplate</tt>.
      This could be done in the application code like so:</p><pre class="programlisting">cciTemplate.setOutputRecordCreator(new EciOutputRecordCreator());</pre><p>Or (recommended) in the Spring configuration, if the <tt class="classname">CciTemplate</tt>
      is configured as a dedicated bean instance:</p><pre class="programlisting">&lt;bean id="eciOutputRecordCreator" class="eci.EciOutputRecordCreator"/&gt;

&lt;bean id="cciTemplate" class="org.springframework.jca.cci.core.CciTemplate"&gt;
  &lt;property name="connectionFactory" ref="eciConnectionFactory"/&gt;
  &lt;property name="outputRecordCreator" ref="eciOutputRecordCreator"/&gt;
&lt;/bean&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>As the <tt class="classname">CciTemplate</tt> class is thread-safe, it will
        usually be configured as a shared instance.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="template-summary"></a>21.3.5.&nbsp;Summary</h3></div></div><div></div></div><p>The following table summarizes the mechanisms of the
      <tt class="classname">CciTemplate</tt> class and the corresponding methods
      called on the CCI <tt class="interfacename">Interaction</tt> interface:</p><div class="table"><a name="cci-interaction-execute-methods"></a><p class="title"><b>Table&nbsp;21.1.&nbsp;Usage of <tt class="interfacename">Interaction</tt> execute methods</b></p><table summary="Usage of Interaction execute methods" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center">CciTemplate method signature</th><th align="center">CciTemplate outputRecordCreator
                property</th><th align="center">execute method called on the CCI
                Interaction</th></tr></thead><tbody><tr><td align="center">Record execute(InteractionSpec,
                Record)</td><td align="center">not set</td><td align="center">Record execute(InteractionSpec,
                Record)</td></tr><tr><td align="center">Record execute(InteractionSpec,
                Record)</td><td align="center">set</td><td align="center">boolean execute(InteractionSpec, Record,
                Record)</td></tr><tr><td align="center">void execute(InteractionSpec, Record,
                Record)</td><td align="center">not set</td><td align="center">void execute(InteractionSpec, Record,
                Record)</td></tr><tr><td align="center">void execute(InteractionSpec, Record,
                Record)</td><td align="center">set</td><td align="center">void execute(InteractionSpec, Record,
                Record)</td></tr><tr><td align="center">Record execute(InteractionSpec,
                RecordCreator)</td><td align="center">not set</td><td align="center">Record execute(InteractionSpec,
                Record)</td></tr><tr><td align="center">Record execute(InteractionSpec,
                RecordCreator)</td><td align="center">set</td><td align="center">void execute(InteractionSpec, Record,
                Record)</td></tr><tr><td align="center">Record execute(InteractionSpec, Record,
                RecordExtractor)</td><td align="center">not set</td><td align="center">Record execute(InteractionSpec,
                Record)</td></tr><tr><td align="center">Record execute(InteractionSpec, Record,
                RecordExtractor)</td><td align="center">set</td><td align="center">void execute(InteractionSpec, Record,
                Record)</td></tr><tr><td align="center">Record execute(InteractionSpec,
                RecordCreator, RecordExtractor)</td><td align="center">not set</td><td align="center">Record execute(InteractionSpec,
                Record)</td></tr><tr><td align="center">Record execute(InteractionSpec,
                RecordCreator, RecordExtractor)</td><td align="center">set</td><td align="center">void execute(InteractionSpec, Record,
                Record)</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-straight"></a>21.3.6.&nbsp;Using a CCI <tt class="interfacename">Connection</tt> and <tt class="interfacename">Interaction</tt> directly</h3></div></div><div></div></div><p><tt class="classname">CciTemplate</tt> also offers the possibility to
      work directly with CCI connections and interactions, in the same manner
      as <tt class="classname">JdbcTemplate</tt> and <tt class="classname">JmsTemplate</tt>.
      This is useful when you want to perform multiple operations on a CCI
      connection or interaction, for example.</p><p>The interface <tt class="interfacename">ConnectionCallback</tt> provides a
      CCI <tt class="interfacename">Connection</tt> as argument, in order to perform
      custom operations on it, plus the CCI <tt class="interfacename">ConnectionFactory</tt>
      which the <tt class="interfacename">Connection</tt> was created with. The latter
      can be useful for example to get an associated <tt class="interfacename">RecordFactory</tt>
      instance and create indexed/mapped records, for example.</p><pre class="programlisting">public interface ConnectionCallback {

  Object doInConnection(Connection connection, ConnectionFactory connectionFactory)
      throws ResourceException, SQLException, DataAccessException;
}</pre><p>The interface <tt class="interfacename">InteractionCallback</tt> provides
      the CCI <tt class="interfacename">Interaction</tt>, in order to perform custom
      operations on it, plus the corresponding CCI <tt class="interfacename">ConnectionFactory</tt>.
			</p><pre class="programlisting">public interface InteractionCallback {

  Object doInInteraction(Interaction interaction, ConnectionFactory connectionFactory)
      throws ResourceException, SQLException, DataAccessException;
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p><tt class="interfacename">InteractionSpec</tt> objects
        can either be shared across multiple template calls or newly created
        inside every callback method. This is completely up to the DAO implementation.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-template-example"></a>21.3.7.&nbsp;Example for <tt class="classname">CciTemplate</tt> usage</h3></div></div><div></div></div><p>In this section, the usage of the <tt class="classname">CciTemplate</tt>
      will be shown to acces to a CICS with ECI mode, with the IBM CICS ECI
      connector.</p><p>Firstly, some initializations on the CCI
      <tt class="interfacename">InteractionSpec</tt> must be done to specify which CICS
      program to access and how to interact with it.</p><pre class="programlisting">ECIInteractionSpec interactionSpec = new ECIInteractionSpec();
interactionSpec.setFunctionName("MYPROG");
interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);</pre><p>Then the program can use CCI via Spring's template and specify
      mappings between custom objects and CCI <tt class="literal">Records</tt>.</p><pre class="programlisting">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public OutputObject getData(InputObject input) {
    ECIInteractionSpec interactionSpec = ...;

    OutputObject output = (ObjectOutput) getCciTemplate().execute(interactionSpec,
        new RecordCreator() {
          public Record createRecord(RecordFactory recordFactory) throws ResourceException {
            return new CommAreaRecord(input.toString().getBytes());
          }
        },
        new RecordExtractor() {
          public Object extractData(Record record) throws ResourceException {
            CommAreaRecord commAreaRecord = (CommAreaRecord)record;
            String str = new String(commAreaRecord.toByteArray());
            String field1 = string.substring(0,6);
            String field2 = string.substring(6,1);
            return new OutputObject(Long.parseLong(field1), field2);
          }
        });

    return output;
  }
}</pre><p>As discussed previously, callbacks can be used to work
      directly on CCI connections or interactions.</p><pre class="programlisting">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public OutputObject getData(InputObject input) {
    ObjectOutput output = (ObjectOutput) getCciTemplate().execute(
        new ConnectionCallback() {
          public Object doInConnection(Connection connection, ConnectionFactory factory)
              throws ResourceException {
              
            <i class="lineannotation"><span class="lineannotation">// do something...</span></i>
          }
        });
    }
    return output;
  }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>With a <tt class="interfacename">ConnectionCallback</tt>,
      the <tt class="interfacename">Connection</tt> used will be managed and closed by
			the <tt class="classname">CciTemplate</tt>, but any interactions created
      on the connection must be managed by the callback implementation.</p></td></tr></table></div><p>For a more specific callback, you can implement an
			<tt class="interfacename">InteractionCallback</tt>. The passed-in
			<tt class="interfacename">Interaction</tt> will be managed and closed by the
			<tt class="classname">CciTemplate</tt> in this case.</p><pre class="programlisting">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public String getData(String input) {
    ECIInteractionSpec interactionSpec = ...;

    String output = (String) getCciTemplate().execute(interactionSpec,
        new InteractionCallback() {
          public Object doInInteraction(Interaction interaction, ConnectionFactory factory)
              throws ResourceException {
            Record input = new CommAreaRecord(inputString.getBytes());
            Record output = new CommAreaRecord();
            interaction.execute(holder.getInteractionSpec(), input, output);
            return new String(output.toByteArray());
          }
        });

    return output;
  }
}</pre><p>For the examples above, the corresponding configuration of the
      involved Spring beans could look like this in non-managed mode:</p><pre class="programlisting">&lt;bean id="managedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
  &lt;property name="serverName" value="TXSERIES"/&gt;
  &lt;property name="connectionURL" value="local:"/&gt;
  &lt;property name="userName" value="CICSUSER"/&gt;
  &lt;property name="password" value="CICS"/&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory" ref="managedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="component" class="mypackage.MyDaoImpl"&gt;
  &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</pre><p>In managed mode (that is, in a J2EE environment), the configuration
			could look as follows:</p><pre class="programlisting">&lt;bean id="connectionFactory" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
  &lt;property name="jndiName" value="eis/cicseci"/&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cci-object"></a>21.4.&nbsp;Modeling CCI access as operation objects</h2></div></div><div></div></div><p>The <tt class="literal">org.springframework.jca.cci.object</tt> package
    contains support classes that allow you to access the EIS in a different
    style: through reusable operation objects, analogous to Spring's JDBC
    operation objects (see JDBC chapter). This will usually encapsulate the
    CCI API: an application-level input object will be passed to the operation
    object, so it can construct the input record and then convert the received
    record data to an application-level output object and return it.</p><p><span class="emphasis"><em>Note</em></span>: This approach is internally based on the
		<tt class="classname">CciTemplate</tt> class and the <tt class="interfacename">RecordCreator</tt>
     / <tt class="interfacename">RecordExtractor</tt> interfaces, reusing the machinery of
     Spring's core CCI support.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-object-mapping-record"></a>21.4.1.&nbsp;<tt class="classname">MappingRecordOperation</tt></h3></div></div><div></div></div><p><tt class="classname">MappingRecordOperation</tt> essentially performs the
      same work as <tt class="classname">CciTemplate</tt>, but represents a specific,
      pre-configured operation as an object. It provides two template methods
      to specify how to convert an input object to a input record, and how to
      convert an output record to an output object (record mapping):</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">createInputRecord(..)</tt> to specify how to
          convert an input object to an input <tt class="interfacename">Record</tt></p></li><li><p><tt class="literal">extractOutputData(..)</tt> to specify how to
          extract an output object from an output <tt class="interfacename">Record</tt></p></li></ul></div><p>Here are the signatures of these methods:</p><pre class="programlisting">public abstract class MappingRecordOperation extends EisOperation {
  ...
  protected abstract Record createInputRecord(RecordFactory recordFactory, Object inputObject)
      throws ResourceException, DataAccessException { ... }

  protected abstract Object extractOutputData(Record outputRecord)
      throws ResourceException, SQLException, DataAccessException { ... }
  ...
}</pre><p>Thereafter, in order to execute an EIS operation, you need to use
      a single execute method, passing in an application-level input object
			and receiving an application-level output object as result:</p><pre class="programlisting">public abstract class MappingRecordOperation extends EisOperation {
  ...
  public Object execute(Object inputObject) throws DataAccessException {
  ...
}</pre><p>As you can see, contrary to the <tt class="classname">CciTemplate</tt> class,
			this <tt class="methodname">execute(..)</tt> method does not have an
			<tt class="interfacename">InteractionSpec</tt> as argument. Instead, the
			<tt class="interfacename">InteractionSpec</tt> is global to the operation.
			The following constructor must be used to instantiate an operation
      object with a specific <tt class="interfacename">InteractionSpec</tt>:</p><pre class="programlisting">InteractionSpec spec = ...;
MyMappingRecordOperation eisOperation = new MyMappingRecordOperation(getConnectionFactory(), spec);
...</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-object-mapping-comm-area"></a>21.4.2.&nbsp;<tt class="classname">MappingCommAreaOperation</tt></h3></div></div><div></div></div><p>Some connectors use records based on a COMMAREA which represents
      an array of bytes containing parameters to send to the EIS and data
      returned by it. Spring provides a special operation class for working
      directly on COMMAREA rather than on records. The
      <tt class="classname">MappingCommAreaOperation</tt> class extends the
      <tt class="classname">MappingRecordOperation</tt> class to provide such special
      COMMAREA support. It implicitly uses the <tt class="classname">CommAreaRecord</tt>
      class as input and output record type, and provides two new methods to
      convert an input object into an input COMMAREA and the output COMMAREA
      into an output object.</p><pre class="programlisting">public abstract class MappingCommAreaOperation extends MappingRecordOperation {
  ...
  protected abstract byte[] objectToBytes(Object inObject)
      throws IOException, DataAccessException;

  protected abstract Object bytesToObject(byte[] bytes)
      throws IOException, DataAccessException;
  ...
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-automatic-record-gen"></a>21.4.3.&nbsp;Automatic output record generation</h3></div></div><div></div></div><p>As every <tt class="classname">MappingRecordOperation</tt> subclass is
      based on CciTemplate internally, the same way to automatically generate
      output records as with <tt class="classname">CciTemplate</tt> is available.
			Every operation object provides a corresponding
      <tt class="literal">setOutputRecordCreator(..)</tt> method. For further information,
			see  the section entitled <a href="#automatic-output-generation" title="21.3.4.&nbsp;Automatic output record generation">Section&nbsp;21.3.4, &#8220;Automatic output record generation&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-object-summary"></a>21.4.4.&nbsp;Summary</h3></div></div><div></div></div><p>The operation object approach uses records in the same manner
      as the <tt class="classname">CciTemplate</tt> class.</p><div class="table"><a name="cci-interaction-methods"></a><p class="title"><b>Table&nbsp;21.2.&nbsp;Usage of Interaction execute methods</b></p><table summary="Usage of Interaction execute methods" border="1"><colgroup><col><col><col></colgroup><thead><tr><th align="center"><tt class="classname">MappingRecordOperation</tt> method
                signature</th><th align="center"><tt class="classname">MappingRecordOperation</tt><tt class="literal">outputRecordCreator</tt> property</th><th align="center">execute method called on the CCI
                <tt class="interfacename">Interaction</tt></th></tr></thead><tbody><tr><td align="center">Object execute(Object)</td><td align="center">not set</td><td align="center">Record execute(InteractionSpec,
                Record)</td></tr><tr><td align="center">Object execute(Object)</td><td align="center">set</td><td align="center">boolean execute(InteractionSpec, Record,
                Record)</td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-objects-mappring-record-example"></a>21.4.5.&nbsp;Example for <tt class="classname">MappingRecordOperation</tt> usage</h3></div></div><div></div></div><p>In this section, the usage of the
      <tt class="classname">MappingRecordOperation</tt> will be shown to access a
      database with the Blackbox CCI connector.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The original version of this connector is provided by the J2EE SDK
        (version 1.3), available from Sun.</p></td></tr></table></div><p>Firstly, some initializations on the CCI
      <tt class="interfacename">InteractionSpec</tt> must be done to specify which SQL
      request to execute. In this sample, we directly define the way to
      convert the parameters of the request to a CCI record and the way to
      convert the CCI result record to an instance of the
      <tt class="classname">Person</tt> class.</p><pre class="programlisting">public class PersonMappingOperation extends MappingRecordOperation {

  public PersonMappingOperation(ConnectionFactory connectionFactory) {
    setConnectionFactory(connectionFactory);
    CciInteractionSpec interactionSpec = new CciConnectionSpec();
    interactionSpec.setSql("select * from person where person_id=?");
    setInteractionSpec(interactionSpec);
  }

  protected Record createInputRecord(RecordFactory recordFactory, Object inputObject)
      throws ResourceException {
    Integer id = (Integer) inputObject;
    IndexedRecord input = recordFactory.createIndexedRecord("input");
    input.add(new Integer(id));
    return input;
  }

  protected Object extractOutputData(Record outputRecord)
      throws ResourceException, SQLException {
    ResultSet rs = (ResultSet) outputRecord;
    Person person = null;
    if (rs.next()) {
      Person person = new Person();
      person.setId(rs.getInt("person_id"));
      person.setLastName(rs.getString("person_last_name"));
      person.setFirstName(rs.getString("person_first_name"));
    }
    return person;
  }
}</pre><p>Then the application can execute the operation object, with the
      person identifier as argument. Note that operation object could be
			set up as shared instance, as it is thread-safe.</p><pre class="programlisting">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public Person getPerson(int id) {
    PersonMappingOperation query = new PersonMappingOperation(getConnectionFactory());
    Person person = (Person) query.execute(new Integer(id));
    return person;
  }
}</pre><p>The corresponding configuration of Spring beans could look
      as follows in non-managed mode:</p><pre class="programlisting">&lt;bean id="managedConnectionFactory"
    class="com.sun.connector.cciblackbox.CciLocalTxManagedConnectionFactory"&gt;
  &lt;property name="connectionURL" value="jdbc:hsqldb:hsql://localhost:9001"/&gt;
  &lt;property name="driverName" value="org.hsqldb.jdbcDriver"/&gt;
&lt;/bean&gt;

&lt;bean id="targetConnectionFactory"
    class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory" ref="managedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory"
    class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"&gt;
  &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt;
  &lt;property name="connectionSpec"&gt;
    &lt;bean class="com.sun.connector.cciblackbox.CciConnectionSpec"&gt;
      &lt;property name="user" value="sa"/&gt;
      &lt;property name="password" value=""/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</pre><p>In managed mode (that is, in a J2EE environment), the configuration
			could look as follows:</p><pre class="programlisting">&lt;bean id="targetConnectionFactory" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
  &lt;property name="jndiName" value="eis/blackbox"/&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory"
    class="org.springframework.jca.cci.connection.ConnectionSpecConnectionFactoryAdapter"&gt;
  &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt;
  &lt;property name="connectionSpec"&gt;
    &lt;bean class="com.sun.connector.cciblackbox.CciConnectionSpec"&gt;
      &lt;property name="user" value="sa"/&gt;
      &lt;property name="password" value=""/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="cci-objects-mapping-comm-area-example"></a>21.4.6.&nbsp;Example for <tt class="classname">MappingCommAreaOperation</tt> usage</h3></div></div><div></div></div><p>In this section, the usage of the
      <tt class="classname">MappingCommAreaOperation</tt> will be shown: accessing
      a CICS with ECI mode with the IBM CICS ECI connector.</p><p>Firstly, the CCI <tt class="interfacename">InteractionSpec</tt> needs to be
      initialized to specify which CICS program to access and how to interact
      with it.</p><pre class="programlisting">public abstract class EciMappingOperation extends MappingCommAreaOperation {

  public EciMappingOperation(ConnectionFactory connectionFactory, String programName) {
    setConnectionFactory(connectionFactory);
    ECIInteractionSpec interactionSpec = new ECIInteractionSpec(),
    interactionSpec.setFunctionName(programName);
    interactionSpec.setInteractionVerb(ECIInteractionSpec.SYNC_SEND_RECEIVE);
    interactionSpec.setCommareaLength(30);
    setInteractionSpec(interactionSpec);
    setOutputRecordCreator(new EciOutputRecordCreator());
  }

  private static class EciOutputRecordCreator implements RecordCreator {
    public Record createRecord(RecordFactory recordFactory) throws ResourceException {
      return new CommAreaRecord();
    }
  }
}</pre><p>The abstract <tt class="classname">EciMappingOperation</tt> class can
      then be subclassed to specify mappings between custom objects and
			<tt class="literal">Records</tt>.</p><pre class="programlisting">public class MyDaoImpl extends CciDaoSupport implements MyDao {

  public OutputObject getData(Integer id) {
    EciMappingOperation query = new EciMappingOperation(getConnectionFactory(), "MYPROG") {
      protected abstract byte[] objectToBytes(Object inObject) throws IOException {
        Integer id = (Integer) inObject;
        return String.valueOf(id);
      }
      protected abstract Object bytesToObject(byte[] bytes) throws IOException;
        String str = new String(bytes);
        String field1 = str.substring(0,6);
        String field2 = str.substring(6,1);
        String field3 = str.substring(7,1);
        return new OutputObject(field1, field2, field3);
      }
    });

    return (OutputObject) query.execute(new Integer(id));
  }
}</pre><p>The corresponding configuration of Spring beans could look
			as follows in non-managed mode:</p><pre class="programlisting">&lt;bean id="managedConnectionFactory" class="com.ibm.connector2.cics.ECIManagedConnectionFactory"&gt;
  &lt;property name="serverName" value="TXSERIES"/&gt;
  &lt;property name="connectionURL" value="local:"/&gt;
  &lt;property name="userName" value="CICSUSER"/&gt;
  &lt;property name="password" value="CICS"/&gt;
&lt;/bean&gt;

&lt;bean id="connectionFactory" class="org.springframework.jca.support.LocalConnectionFactoryBean"&gt;
  &lt;property name="managedConnectionFactory" ref="managedConnectionFactory"/&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</pre><p>In managed mode (that is, in a J2EE environment), the configuration
			could look as follows:</p><pre class="programlisting">&lt;bean id="connectionFactory" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
  &lt;property name="jndiName" value="eis/cicseci"/&gt;
&lt;/bean&gt;

&lt;bean id="component" class="MyDaoImpl"&gt;
  &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
&lt;/bean&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cci-tx"></a>21.5.&nbsp;Transactions</h2></div></div><div></div></div><p>JCA specifies several levels of transaction support for resource adapters.
    The kind of transactions that your resource adapter supports is specified
    in its <tt class="filename">ra.xml</tt> file. There are essentially three options:
    none (for example with CICS EPI connector), local transactions (for
    example with a CICS ECI connector), global transactions (for example with an
    IMS connector).</p><pre class="programlisting">&lt;connector&gt;

  &lt;resourceadapter&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- &lt;transaction-support&gt;NoTransaction&lt;/transaction-support&gt; --&gt;</span></i>
    <i class="lineannotation"><span class="lineannotation">&lt;!-- &lt;transaction-support&gt;LocalTransaction&lt;/transaction-support&gt; --&gt;</span></i>
    &lt;transaction-support&gt;XATransaction&lt;/transaction-support&gt;

  &lt;resourceadapter&gt;

&lt;connector&gt;</pre><p>For global transactions, you can use Spring's generic transaction
		infrastructure to demarcate transactions, with <tt class="classname">JtaTransactionManager</tt> as
		backend (delegating to the J2EE server's distributed transaction coordinator
		underneath).</p><p>For local transactions on a single CCI <tt class="interfacename">ConnectionFactory</tt>,
    Spring provides a specific transaction management strategy for CCI, analogous
    to the <tt class="classname">DataSourceTransactionManager</tt> for JDBC. The CCI API
    defines a local transaction object and corresponding local transaction
		demarcation methods. Spring's <tt class="classname">CciLocalTransactionManager</tt>
    executes such local CCI transactions, fully compliant with Spring's generic
    <tt class="interfacename">PlatformTransactionManager</tt> abstraction.</p><pre class="programlisting">&lt;bean id="eciConnectionFactory" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
  &lt;property name="jndiName" value="eis/cicseci"/&gt;
&lt;/bean&gt;

&lt;bean id="eciTransactionManager"
    class="org.springframework.jca.cci.connection.CciLocalTransactionManager"&gt;
  &lt;property name="connectionFactory" ref="eciConnectionFactory"/&gt;
&lt;/bean&gt;</pre><p>Both transaction strategies can be used with any of Spring's
        transaction demarcation facilities, be it declarative or programmatic.
        This is a consequence of Spring's generic
        <tt class="interfacename">PlatformTransactionManager</tt> abstraction, which
		decouples transaction demarcation from the actual execution strategy.
		Simply switch between <tt class="classname">JtaTransactionManager</tt> and
		<tt class="classname">CciLocalTransactionManager</tt> as needed, keeping
		your transaction demarcation as-is.</p><p>For more information on Spring's transaction facilities, see the
		chapter entitled <a href="#transaction" title="Chapter&nbsp;9.&nbsp;Transaction management">Chapter&nbsp;9, <i>Transaction management</i></a>.</p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="mail"></a>Chapter&nbsp;22.&nbsp;Email</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mail-introduction"></a>22.1.&nbsp;Introduction</h2></div></div><div></div></div><div class="sidebar"><p class="title"><b>Library dependencies</b></p><p>The following additional jars to be on the classpath of your
		application in order to be able to use the Spring Framework's email library.</p><div class="itemizedlist"><ul type="disc"><li><p>The <a href="http://java.sun.com/products/javamail/" target="_top">JavaMail</a> <tt class="filename">mail.jar</tt> library</p></li><li><p>The <a href="http://java.sun.com/products/javabeans/jaf/downloads/index.html" target="_top">JAF</a> <tt class="filename">activation.jar</tt> library</p></li></ul></div><p>All of these libraries are available in the Spring-with-dependencies
		distribution of the Spring Framework (in addition to also being freely
		available on the web).</p></div><p>The Spring Framework provides a helpful utility library for sending
	email that shields the user from the specifics of the underlying mailing
	system and is responsible for low level resource handling on behalf of
    the client.</p><p>The <tt class="literal">org.springframework.mail</tt> package is the root level package
	for the Spring Framework's email support. The central interface for sending
	emails is the <tt class="interfacename">MailSender</tt> interface; a simple value object
	encapsulating the properties of a simple mail such as <span class="emphasis"><em>from</em></span> and
	<span class="emphasis"><em>to</em></span> (plus many others) is the <tt class="classname">SimpleMailMessage</tt> class.
    This package also contains a hierarchy of checked exceptions which provide
    a higher level of abstraction over the lower level mail system exceptions
    with the root exception being <tt class="exceptionname">MailException</tt>. Please
    refer to the Javadocs for more information on the rich mail exception hierarchy.</p><p>The <tt class="interfacename">org.springframework.mail.javamail.JavaMailSender</tt>
	interface adds specialized <span class="emphasis"><em>JavaMail</em></span> features such as MIME
    message support to the <tt class="interfacename">MailSender</tt> interface
	(from which it inherits). <tt class="interfacename">JavaMailSender</tt> also provides a
	callback interface for preparation of JavaMail MIME messages, called
    <tt class="interfacename">org.springframework.mail.javamail.MimeMessagePreparator</tt></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mail-usage"></a>22.2.&nbsp;Usage</h2></div></div><div></div></div><p>Let's assume there is a business interface called <tt class="interfacename">OrderManager</tt>:</p><pre class="programlisting">public interface OrderManager {

    void placeOrder(Order order);
}</pre><p>Let us also assume that there is a requirement stating that an email message
		with an order number needs to be generated and sent to a customer placing the
		relevant order.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mail-usage-simple"></a>22.2.1.&nbsp;Basic <tt class="interfacename">MailSender</tt> and <tt class="classname">SimpleMailMessage</tt> usage</h3></div></div><div></div></div><pre class="programlisting">import org.springframework.mail.MailException;
import org.springframework.mail.MailSender;
import org.springframework.mail.SimpleMailMessage;

public class SimpleOrderManager implements OrderManager {

    private MailSender mailSender;
    private SimpleMailMessage templateMessage;

    public void setMailSender(MailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void setTemplateMessage(SimpleMailMessage templateMessage) {
        this.templateMessage = templateMessage;
    }

    public void placeOrder(Order order) {

        <i class="lineannotation"><span class="lineannotation">// Do the business calculations...</span></i>

        <i class="lineannotation"><span class="lineannotation">// Call the collaborators to persist the order...</span></i>

        <i class="lineannotation"><span class="lineannotation">// Create a thread safe "copy" of the template message and customize it</span></i>
        SimpleMailMessage msg = new SimpleMailMessage(this.templateMessage);
        msg.setTo(order.getCustomer().getEmailAddress());
        msg.setText(
            "Dear " + order.getCustomer().getFirstName()
                + order.getCustomer().getLastName()
                + ", thank you for placing order. Your order number is "
                + order.getOrderNumber());
        try{
            this.mailSender.send(msg);
        }
        catch(MailException ex) {
            <i class="lineannotation"><span class="lineannotation">// simply log it and go on...</span></i>
            System.err.println(ex.getMessage());            
        }
    }
}</pre><p>Find below the bean definitions for the above code:</p><pre class="programlisting">&lt;bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl"&gt;
  &lt;property name="host" value="mail.mycompany.com"/&gt;
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- this is a template message that we can pre-load with default state --&gt;</span></i>
&lt;bean id="templateMessage" class="org.springframework.mail.SimpleMailMessage"&gt;
  &lt;property name="from" value="customerservice@mycompany.com"/&gt;
  &lt;property name="subject" value="Your order"/&gt;
&lt;/bean&gt;

&lt;bean id="orderManager" class="com.mycompany.businessapp.support.SimpleOrderManager"&gt;
  &lt;property name="mailSender" ref="mailSender"/&gt;
  &lt;property name="templateMessage" ref="templateMessage"/&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mail-usage-mime"></a>22.2.2.&nbsp;Using the <tt class="interfacename">JavaMailSender</tt> and the <tt class="classname">MimeMessagePreparator</tt></h3></div></div><div></div></div><p>Here is another implementation of <tt class="interfacename">OrderManager</tt> using
			the <tt class="interfacename">MimeMessagePreparator</tt> callback interface. Please note
			in this case that the <tt class="literal">mailSender</tt> property is of type
			<tt class="interfacename">JavaMailSender</tt> so that we are able to use the JavaMail
			<tt class="classname">MimeMessage</tt> class:</p><pre class="programlisting">import javax.mail.Message;
import javax.mail.MessagingException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

import javax.mail.internet.MimeMessage;
import org.springframework.mail.MailException;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessagePreparator;

public class SimpleOrderManager implements OrderManager {

    private JavaMailSender mailSender;
    
    public void setMailSender(JavaMailSender mailSender) {
        this.mailSender = mailSender;
    }

    public void placeOrder(final Order order) {

        <i class="lineannotation"><span class="lineannotation">// Do the business calculations...</span></i>

        <i class="lineannotation"><span class="lineannotation">// Call the collaborators to persist the order...</span></i>
        
        MimeMessagePreparator preparator = new MimeMessagePreparator() {
        
            public void prepare(MimeMessage mimeMessage) throws Exception {
        
                mimeMessage.setRecipient(Message.RecipientType.TO, 
                        new InternetAddress(order.getCustomer().getEmailAddress()));
                mimeMessage.setFrom(new InternetAddress("mail@mycompany.com"));
                mimeMessage.setText(
                    "Dear " + order.getCustomer().getFirstName() + " "
                        + order.getCustomer().getLastName()
                        + ", thank you for placing order. Your order number is "
                        + order.getOrderNumber());
            }
        };
        try {
            this.mailSender.send(preparator);
        }
        catch (MailException ex) {
            <i class="lineannotation"><span class="lineannotation">// simply log it and go on...</span></i>
            System.err.println(ex.getMessage());            
        }
    }
}</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The mail code is a crosscutting concern and could well be a candidate
				for refactoring into a <a href="#aop" title="Chapter&nbsp;6.&nbsp;Aspect Oriented Programming with Spring">custom Spring AOP aspect</a>,
				which then could be executed at appropriate joinpoints on the
				<tt class="interfacename">OrderManager</tt> target.</p></td></tr></table></div><p>The Spring Framework's mail support ships with two
			<tt class="interfacename">MailSender</tt> implementations. The standard JavaMail
			implementation and the implementation on top of Jason Hunter's
			<tt class="classname">MailMessage</tt> class that is included in
			<a href="http://servlets.com/cos" target="_top">the <tt class="literal">com.oreilly.servlet</tt>
			package</a>. Please refer to the relevant Javadocs for more information.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="mail-javamail-mime"></a>22.3.&nbsp;Using the JavaMail <tt class="classname">MimeMessageHelper</tt></h2></div></div><div></div></div><p>A class that comes in pretty handy when dealing with JavaMail messages is
		the <tt class="classname">org.springframework.mail.javamail.MimeMessageHelper</tt> class,
		which shields you from having to use the verbose JavaMail API. Using
		the <tt class="classname">MimeMessageHelper</tt> it is pretty easy to
		create a <tt class="classname">MimeMessage</tt>:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// of course you would use DI in any real-world cases</span></i>
JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMessage();
MimeMessageHelper helper = new MimeMessageHelper(message);
helper.setTo("test@host.com");
helper.setText("Thank you for ordering!");

sender.send(message);</pre><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mail-javamail-mime-attachments"></a>22.3.1.&nbsp;Sending attachments and inline resources</h3></div></div><div></div></div><p>Multipart email messages allow for both attachments and inline resources.
			Examples of inline resources would be be images or a stylesheet you want to use
			in your message, but that you don't want displayed as an attachment.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mail-javamail-mime-attachments-attachment"></a>22.3.1.1.&nbsp;Attachments</h4></div></div><div></div></div><p>The following example shows you how to use the
				<tt class="classname">MimeMessageHelper</tt> to send an email along with a
				single JPEG image attachment.</p><pre class="programlisting">JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMessage();

<i class="lineannotation"><span class="lineannotation">// use the true flag to indicate you need a multipart message</span></i>
MimeMessageHelper helper = new MimeMessageHelper(message, true);
helper.setTo("test@host.com");

helper.setText("Check out this image!");

<i class="lineannotation"><span class="lineannotation">// let's attach the infamous windows Sample file (this time copied to c:/)</span></i>
FileSystemResource file = new FileSystemResource(new File("c:/Sample.jpg"));
helper.addAttachment("CoolImage.jpg", file);

sender.send(message);</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mail-javamail-mime-attachments-inline"></a>22.3.1.2.&nbsp;Inline resources</h4></div></div><div></div></div><p>The following example shows you how to use the
				<tt class="classname">MimeMessageHelper</tt> to send an email along with an
				inline image.</p><pre class="programlisting">JavaMailSenderImpl sender = new JavaMailSenderImpl();
sender.setHost("mail.host.com");

MimeMessage message = sender.createMimeMessage();

<i class="lineannotation"><span class="lineannotation">// use the true flag to indicate you need a multipart message</span></i>
MimeMessageHelper helper = new MimeMessageHelper(message, true);
helper.setTo("test@host.com");

<i class="lineannotation"><span class="lineannotation">// use the true flag to indicate the text included is HTML</span></i>
helper.setText("&lt;html&gt;&lt;body&gt;&lt;img src='cid:identifier1234'&gt;&lt;/body&gt;&lt;/html&gt;", true);

<i class="lineannotation"><span class="lineannotation">// let's include the infamous windows Sample file (this time copied to c:/)</span></i>
FileSystemResource res = new FileSystemResource(new File("c:/Sample.jpg"));
helper.addInline("identifier1234", res);

sender.send(message);</pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="../images/admons/warning.png"></td><th align="left">Warning</th></tr><tr><td colspan="2" align="left" valign="top"><p>Inline resources are added to the mime message using the
					specified <tt class="literal">Content-ID</tt> (<tt class="literal">identifier1234</tt>
					in the above example). The order in which you are adding the text and the
					resource are <span class="bold"><b>very</b></span> important. Be sure to
					<span class="emphasis"><em>first add the text</em></span> and after that the resources. If
					you are doing it the other way around, it won't work!</p></td></tr></table></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="mail-templates"></a>22.3.2.&nbsp;Creating email content using a templating library</h3></div></div><div></div></div><p>The code in the previous examples explicitly has been creating the
			content of the email message, using methods calls such as
			<tt class="methodname">message.setText(..)</tt>. This is fine for
			simple cases, and it is okay in the context of the aforementioned
			examples, where the intent was to show you the very basics of the API.</p><p>In your typical enterprise application though, you are not going
			to create the content of your emails using the above approach for a number
			of reasons.</p><p>
				</p><div class="itemizedlist"><ul type="disc"><li><p>Creating HTML-based email content in Java code is tedious and error prone</p></li><li><p>There is no clear separation between display logic and business logic</p></li><li><p>Changing the display structure of the email content requires writing Java code, recompiling, redeploying...</p></li></ul></div><p>
			</p><p>Typically the approach taken to address these issues is to use a template library
			such as FreeMarker or Velocity to define the display structure of email content. This leaves
			your code tasked only with creating the data that is to be rendered in the email
			template and sending the email. It is definitely a best practice for when
			the content of your emails becomes even moderately complex, and with
			the Spring Framework's support classes for FreeMarker and Velocity becomes
			quite easy to do. Find below an example of using the Velocity template library
			to create email content.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="mail-templates-example"></a>22.3.2.1.&nbsp;A Velocity-based example</h4></div></div><div></div></div><p>To use <a href="http://velocity.apache.org" target="_top">Velocity</a> to
				create your email template(s), you will need to have the Velocity libraries
				available on your classpath. You will also need to create one or more Velocity templates
				for the email content that your application needs. Find below the Velocity
				template that this example will be using... as you can see it is HTML-based,
				and since it is plain text it can be created using your favorite HTML editor
				without recourse to having to know Java.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation"># in the <tt class="literal">com/foo/package</tt></span></i>
&lt;html&gt;
&lt;body&gt;
&lt;h3&gt;Hi ${user.userName}, welcome to the Chipping Sodbury On-the-Hill message boards!&lt;/h3&gt;

&lt;div&gt;
   Your email address is &lt;a href="mailto:${user.emailAddress}"&gt;${user.emailAddress}&lt;/a&gt;.
&lt;/div&gt;
&lt;/body&gt;

&lt;/html&gt;</pre><p>Find below some simple code and Spring XML configuration that
				makes use of the above Velocity template to create email content and
				send email(s).</p><pre class="programlisting">package com.foo;

import org.apache.velocity.app.VelocityEngine;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.mail.javamail.MimeMessagePreparator;
import org.springframework.ui.velocity.VelocityEngineUtils;

import javax.mail.internet.MimeMessage;
import java.util.HashMap;
import java.util.Map;

public class SimpleRegistrationService implements RegistrationService {

   private JavaMailSender mailSender;
   private VelocityEngine velocityEngine;

   public void setMailSender(JavaMailSender mailSender) {
      this.mailSender = mailSender;
   }

   public void setVelocityEngine(VelocityEngine velocityEngine) {
      this.velocityEngine = velocityEngine;
   }

   public void register(User user) {

      <i class="lineannotation"><span class="lineannotation">// Do the registration logic...</span></i>

      sendConfirmationEmail(user);
   }

   private void sendConfirmationEmail(final User user) {
      MimeMessagePreparator preparator = new MimeMessagePreparator() {
         public void prepare(MimeMessage mimeMessage) throws Exception {
            MimeMessageHelper message = new MimeMessageHelper(mimeMessage);
            message.setTo(user.getEmailAddress());
            message.setFrom("webmaster@csonth.gov.uk"); <i class="lineannotation"><span class="lineannotation">// could be parameterized...</span></i>
            Map model = new HashMap();
            model.put("user", user);
            String text = VelocityEngineUtils.mergeTemplateIntoString(
               velocityEngine, "com/dns/registration-confirmation.vm", model);
            message.setText(text, true);
         }
      };
      this.mailSender.send(preparator);
   }
}</pre><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans
   http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

   &lt;bean id="mailSender" class="org.springframework.mail.javamail.JavaMailSenderImpl"&gt;
      &lt;property name="host" value="mail.csonth.gov.uk"/&gt;
   &lt;/bean&gt;

   &lt;bean id="registrationService" class="com.foo.SimpleRegistrationService"&gt;
      &lt;property name="mailSender" ref="mailSender"/&gt;
      &lt;property name="velocityEngine" ref="velocityEngine"/&gt;
   &lt;/bean&gt;
   
   &lt;bean id="velocityEngine" class="org.springframework.ui.velocity.VelocityEngineFactoryBean"&gt;
      &lt;property name="velocityProperties"&gt;
         &lt;value&gt;
            resource.loader=class
            class.resource.loader.class=org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader
         &lt;/value&gt;
      &lt;/property&gt;
   &lt;/bean&gt;

&lt;/beans&gt;</pre></div></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="scheduling"></a>Chapter&nbsp;23.&nbsp;Scheduling and Thread Pooling</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scheduling-introduction"></a>23.1.&nbsp;Introduction</h2></div></div><div></div></div><p>
		The Spring Framework features integration classes for scheduling support. Currently, Spring
		supports the <tt class="classname">Timer</tt>, part of the JDK since 1.3, and the
		Quartz Scheduler (<a href="http://www.opensymphony.com/quartz/" target="_top">http://www.opensymphony.com/quartz/</a>). Both schedulers
		are set up using a <tt class="interfacename">FactoryBean</tt> with optional references
		to <tt class="classname">Timer</tt> or <tt class="classname">Trigger</tt> instances, respectively.
		Furthermore, a convenience class for both the Quartz Scheduler and the <tt class="classname">Timer</tt> is
		available that allows you to invoke a method of an existing target object
		(analogous to the normal <tt class="classname">MethodInvokingFactoryBean</tt> operation).
		Spring also features classes for thread pooling that abstract
		away differences between Java SE 1.4, Java SE 5 and Java EE environments.
  	</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scheduling-quartz"></a>23.2.&nbsp;Using the OpenSymphony Quartz Scheduler</h2></div></div><div></div></div><p>Quartz uses <tt class="classname">Trigger</tt>, <tt class="classname">Job</tt> and 
		<tt class="classname">JobDetail</tt> objects to realize scheduling of all kinds of jobs.
		For the basic concepts behind Quartz, have a look at
		<a href="http://www.opensymphony.com/quartz" target="_top">http://www.opensymphony.com/quartz</a>. For convenience purposes,
		Spring offers a couple of classes that simplify the usage of Quartz within
		Spring-based applications.
		</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="scheduling-quartz-jobdetail"></a>23.2.1.&nbsp;Using the JobDetailBean</h3></div></div><div></div></div><p>
			<tt class="classname">JobDetail</tt> objects contain all information needed to
			run a job. The Spring Framework provides a <tt class="classname">JobDetailBean</tt>
			that makes the <tt class="classname">JobDetail</tt> more of an actual JavaBean
			with sensible defaults. Let's have a look at an example:
			</p><pre class="programlisting">
&lt;bean name="exampleJob" class="org.springframework.scheduling.quartz.JobDetailBean"&gt;
  &lt;property name="jobClass" value="example.ExampleJob" /&gt;
  &lt;property name="jobDataAsMap"&gt;
    &lt;map&gt;
      &lt;entry key="timeout" value="5" /&gt;
    &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The job detail bean has all information it needs to run the job (<tt class="classname">ExampleJob</tt>).
			The timeout is specified in the job data map. The job data map is
			available through the <tt class="classname">JobExecutionContext</tt>
			(passed to you at execution time), but the <tt class="classname">JobDetailBean</tt>
			also maps the properties from the job data map to properties of the actual job.
			So in this case, if the <tt class="classname">ExampleJob</tt> contains a property
			named <tt class="literal">timeout</tt>, the <tt class="classname">JobDetailBean</tt> will
			automatically apply it:</p><pre class="programlisting">package example;

public class ExampleJob extends QuartzJobBean {

  private int timeout;
  
  /**
   * Setter called after the ExampleJob is instantiated
   * with the value from the JobDetailBean (5)
   */ 
  public void setTimeout(int timeout) {
    this.timeout = timeout;
  }
  
  protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException {
      <i class="lineannotation"><span class="lineannotation">// do the actual work</span></i>
  }
}</pre><p>All additional settings from the job detail bean are of course available to you as well.</p><p><span class="emphasis"><em>Note: Using the <tt class="literal">name</tt> and <tt class="literal">group</tt> properties,
			you can modify the name and the group of the job, respectively. By default, the name of
			the job matches the bean name of the job detail bean (in the example above, this is
			<tt class="literal">exampleJob</tt>).</em></span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="scheduling-quartz-method-invoking-job"></a>23.2.2.&nbsp;Using the <tt class="classname">MethodInvokingJobDetailFactoryBean</tt></h3></div></div><div></div></div><p>Often you just need to invoke a method on a specific object. Using the
			<tt class="classname">MethodInvokingJobDetailFactoryBean</tt> you can do exactly this:</p><pre class="programlisting">&lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt;
  &lt;property name="targetObject" ref="exampleBusinessObject" /&gt;
  &lt;property name="targetMethod" value="doIt" /&gt;
&lt;/bean&gt;</pre><p>The above example will result in the <tt class="literal">doIt</tt> method being called on the
			<tt class="literal">exampleBusinessObject</tt> method (see below):</p><pre class="programlisting">public class ExampleBusinessObject {
  
  <i class="lineannotation"><span class="lineannotation">// properties and collaborators</span></i>
  
  public void doIt() {
    <i class="lineannotation"><span class="lineannotation">// do the actual work</span></i>
  }
}</pre><pre class="programlisting">
&lt;bean id="exampleBusinessObject" class="examples.ExampleBusinessObject"/&gt;</pre><p>Using the <tt class="classname">MethodInvokingJobDetailFactoryBean</tt>, you don't need to
			create one-line jobs that just invoke a method, and you only need to create the actual
			business object and wire up the detail object.</p><p>By default, Quartz Jobs are stateless, resulting in the possibility of jobs interfering
			with each other. If you specify two triggers for the same <tt class="classname">JobDetail</tt>,
			it might be possible that before the first job has finished, the second one will start.
			If <tt class="classname">JobDetail</tt> classes implement the
			<tt class="interfacename">Stateful</tt> interface, this won't happen. The second job
			will not start before the first one has finished. To make jobs resulting from the
			<tt class="classname">MethodInvokingJobDetailFactoryBean</tt> non-concurrent, set the
			<tt class="literal">concurrent</tt> flag to <tt class="literal">false</tt>.</p><pre class="programlisting">
&lt;bean id="jobDetail" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt;
  &lt;property name="targetObject" ref="exampleBusinessObject" /&gt;
  &lt;property name="targetMethod" value="doIt" /&gt;
  &lt;property name="concurrent" value="false" /&gt;
&lt;/bean&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>By default, jobs will run in a concurrent fashion.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="scheduling-quartz-cron"></a>23.2.3.&nbsp;Wiring up jobs using triggers and the <tt class="classname">SchedulerFactoryBean</tt></h3></div></div><div></div></div><p>
				We've created job details and jobs. We've also reviewed the convenience bean
				that allows to you invoke a method on a specific object. Of course, we still need
				to schedule the jobs themselves. This is done using triggers and a 
				<tt class="classname">SchedulerFactoryBean</tt>. Several triggers are available
				within Quartz. Spring offers two subclassed triggers with convenient defaults:
				<tt class="classname">CronTriggerBean</tt> and <tt class="classname">SimpleTriggerBean</tt>.
			</p><p>
				Triggers need to be scheduled. Spring offers a <tt class="classname">SchedulerFactoryBean</tt>
				that exposes triggers to be set as properties. <tt class="classname">SchedulerFactoryBean</tt>
				schedules the actual jobs with those triggers.
			</p><p>Find below a couple of examples:</p><pre class="programlisting">&lt;bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerBean"&gt;
    &lt;!-- see the example of method invoking job above --&gt;
    &lt;property name="jobDetail" ref="jobDetail" /&gt;
    &lt;!-- 10 seconds --&gt;
    &lt;property name="startDelay" value="10000" /&gt;
    &lt;!-- repeat every 50 seconds --&gt;
    &lt;property name="repeatInterval" value="50000" /&gt;
&lt;/bean&gt;

&lt;bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerBean"&gt;
    &lt;property name="jobDetail" ref="exampleJob" /&gt;
    &lt;!-- run every morning at 6 AM --&gt;
    &lt;property name="cronExpression" value="0 0 6 * * ?" /&gt;
&lt;/bean&gt;</pre><p>Now we've set up two triggers, one running every 50 seconds with a starting delay of
			10 seconds and one every morning at 6 AM. To finalize everything, we need to set up the
			<tt class="classname">SchedulerFactoryBean</tt>:</p><pre class="programlisting">&lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt;
    &lt;property name="triggers"&gt;
        &lt;list&gt;
            &lt;ref bean="cronTrigger" /&gt;
            &lt;ref bean="simpleTrigger" /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>
				More properties are available for the <tt class="classname">SchedulerFactoryBean</tt> for you
				to set, such as the	calendars used by the job details, properties to customize Quartz with,
				etc. Have a look at the
				<a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/scheduling/quartz/SchedulerFactoryBean.html" target="_top">SchedulerFactoryBean Javadoc</a>
				for more information.
			</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scheduling-jdk-timer"></a>23.3.&nbsp;Using JDK Timer support</h2></div></div><div></div></div><p>
  			The other way to schedule jobs in Spring is to use JDK
			<tt class="classname">Timer</tt> objects. You can create custom timers or
			use the timer that invokes methods. Wiring timers is done using the
			<tt class="classname">TimerFactoryBean</tt>.
  		</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="scheduling-jdk-timer-creating"></a>23.3.1.&nbsp;Creating custom timers</h3></div></div><div></div></div><p>
  				Using the <tt class="classname">TimerTask</tt> you can create customer
				timer tasks, similar to Quartz jobs:
			</p><pre class="programlisting">public class CheckEmailAddresses extends TimerTask {

  private List emailAddresses;
  
  public void setEmailAddresses(List emailAddresses) {
    this.emailAddresses = emailAddresses;
  }
  
  public void run() {
    <i class="lineannotation"><span class="lineannotation">// iterate over all email addresses and archive them</span></i>
  }
}</pre><p>
				Wiring it up is simple:
			</p><pre class="programlisting">&lt;bean id="checkEmail" class="examples.CheckEmailAddress"&gt;
    &lt;property name="emailAddresses"&gt;
        &lt;list&gt;
            &lt;value&gt;test@springframework.org&lt;/value&gt;
            &lt;value&gt;foo@bar.com&lt;/value&gt;
            &lt;value&gt;john@doe.net&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="scheduledTask" class="org.springframework.scheduling.timer.ScheduledTimerTask"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- wait 10 seconds before starting repeated execution --&gt;</span></i>
    &lt;property name="delay" value="10000" /&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- run every 50 seconds --&gt;</span></i>
    &lt;property name="period" value="50000" /&gt;
    &lt;property name="timerTask" ref="checkEmail" /&gt;
&lt;/bean&gt;</pre><p>
				<span class="emphasis"><em>
					Note that letting the task only run once can be done by changing the
					<tt class="literal">period</tt> property to 0 (or a negative value).
				</em></span>
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="scheduling-jdk-timer-method-invoking-task"></a>23.3.2.&nbsp;Using the <tt class="classname">MethodInvokingTimerTaskFactoryBean</tt></h3></div></div><div></div></div><p>
				Similar to the Quartz support, the <tt class="classname">Timer</tt> support also features
				a component that allows you to periodically invoke a method:
			</p><pre class="programlisting">&lt;bean id="doIt" class="org.springframework.scheduling.timer.MethodInvokingTimerTaskFactoryBean"&gt;
    &lt;property name="targetObject" ref="exampleBusinessObject" /&gt;
    &lt;property name="targetMethod" value="doIt" /&gt;
&lt;/bean&gt;</pre><p>
				The above example will result in the <tt class="literal">doIt</tt> method being called on the
				<tt class="literal">exampleBusinessObject</tt> (see below):
			</p><pre class="programlisting">public class BusinessObject {
  
  <i class="lineannotation"><span class="lineannotation">// properties and collaborators</span></i>
  
  public void doIt() {
    <i class="lineannotation"><span class="lineannotation">// do the actual work</span></i>
  }
}</pre><p>Changing the <tt class="literal">timerTask</tt> reference of the
			<tt class="classname">ScheduledTimerTask</tt> example to the bean <tt class="literal">doIt</tt>
			will result in the <tt class="literal">doIt</tt> method being executed on a fixed schedule.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="scheduling-jdk-timer-factory-bean"></a>23.3.3.&nbsp;Wrapping up: setting up the tasks using the <tt class="classname">TimerFactoryBean</tt></h3></div></div><div></div></div><p>The <tt class="classname">TimerFactoryBean</tt> is similar to the Quartz
			<tt class="classname">SchedulerFactoryBean</tt> in that it serves the same
			purpose: setting up the actual scheduling. The <tt class="classname">TimerFactoryBean</tt>
			sets up an actual <tt class="classname">Timer</tt> and schedules the tasks it has
			references to. You can specify whether or not daemon threads should be used.</p><pre class="programlisting">&lt;bean id="timerFactory" class="org.springframework.scheduling.timer.TimerFactoryBean"&gt;
    &lt;property name="scheduledTimerTasks"&gt;
        &lt;list&gt;
            <i class="lineannotation"><span class="lineannotation">&lt;!-- see the example above --&gt;</span></i>
            &lt;ref bean="scheduledTask" /&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="scheduling-task-executor"></a>23.4.&nbsp;The Spring <tt class="interfacename">TaskExecutor</tt> abstraction</h2></div><div><h2 class="title" style="clear: both"><a name="scheduling-task-executor"></a>23.4.&nbsp;The Spring <tt class="interfacename">TaskExecutor</tt> abstraction</h2></div></div><div></div></div><p>Spring 2.0 introduces a new abstraction for dealing with
		executors. Executors are the Java 5 name for the concept of
		thread pools. The "executor" naming is due to the fact that there
		is no guarantee that the underlying implementation is actually a
		pool; an executor may be single-threaded or even synchronous.
		Spring's abstraction hides implementation details between
		Java SE 1.4, Java SE 5 and Java EE environments.</p><p>Spring's <tt class="interfacename">TaskExecutor</tt> interface is
		identical to the <tt class="classname">java.util.concurrent.Executor</tt>
		interface. In fact, its primary reason for existence is to abstract away
		the need for Java 5 when using thread pools. The interface has a single
		method <tt class="classname">execute(Runnable task)</tt> that accepts a task
		for execution based on the semantics and configuration of the thread pool.</p><p>The <tt class="interfacename">TaskExecutor</tt> was originally
		created to give other Spring components an abstraction for thread pooling where
		needed. Components such as the <tt class="classname">ApplicationEventMulticaster</tt>,
		JMS's <tt class="classname">AbstractMessageListenerContainer</tt>,
		and Quartz integration all use the <tt class="interfacename">TaskExecutor</tt>
		abstraction to pool threads. However, if your beans need thread pooling behavior,
		it is possible to use this abstraction for your own needs.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="scheduling-task-executor-types"></a>23.4.1.&nbsp;<tt class="interfacename">TaskExecutor</tt> types</h3></div></div><div></div></div><p>There are a number of pre-built implementations of
			<tt class="interfacename">TaskExecutor</tt> included with the
			Spring distribution. In all likelihood, you shouldn't ever
			need to implement your own.</p><div class="itemizedlist"><ul type="disc"><li><p>
						<tt class="classname">SimpleAsyncTaskExecutor</tt>
					</p><p>
						This implementation does not reuse any threads,
						rather it starts up a new thread for each
						invocation. However, it does support a
						concurrency limit which will block any
						invocations that are over the limit until a slot
						has been freed up. If you're looking for true
						pooling, keep scrolling further down the page.
					</p></li><li><p><a name="syncTaskExecutor"></a>
						<tt class="classname">SyncTaskExecutor</tt>
					</p><p>
						This implementation doesn't execute
						invocations asynchronously. Instead, each
						invocation takes place in the calling thread. It
						is primarily used in situations where
						mutlithreading isn't necessary such as simple
						test cases.
					</p></li><li><p><a name="concurrentTaskExecutor"></a>
						<tt class="classname">ConcurrentTaskExecutor</tt>
					</p><p>
						This implementation is a wrapper for a Java 5
						<tt class="classname">java.util.concurrent.Executor</tt>.
						There is an alternative,
						<tt class="classname">ThreadPoolTaskExecutor</tt>,
						that exposes the <tt class="classname">Executor</tt>
						configuration parameters as bean properties. It
						is rare to need to use the <tt class="classname">ConcurrentTaskExecutor</tt>
						but if the
						<a href="#threadPoolTaskExecutor"><tt class="classname">ThreadPoolTaskExecutor</tt></a>
						isn't robust enough for your needs, the
						<tt class="classname">ConcurrentTaskExecutor</tt>
						is an alternative.
					</p></li><li><p><a name="simpleThreadPoolTaskExecutor"></a>
						<tt class="classname">SimpleThreadPoolTaskExecutor</tt>
					</p><p>
						This implementation is actually a subclass of
						Quartz's <tt class="classname">SimpleThreadPool</tt>
						which listens to Spring's lifecycle callbacks.
						This is typically used when you have a
						threadpool that may need to be shared by both
						Quartz and non-Quartz components.
					</p></li><li><p><a name="threadPoolTaskExecutor"></a>
						<tt class="classname">ThreadPoolTaskExecutor</tt>
					</p><div class="sidebar"><p>
							It is not possible to use any backport or
							alternate versions of the
							<tt class="classname">java.util.concurrent</tt>
							package with this implementation. Both Doug
							Lea's and Dawid Kurzyniec's implementations
							use different package structures which will
							prevent them from working correctly.
						</p></div><p>
						This implementation can only be used in a Java 5
						environment but is also the most commonly used
						one in that environment. It exposes bean properties for
						configuring a 
						<tt class="classname">java.util.concurrent.ThreadPoolExecutor</tt>
						and wraps it in a <tt class="interfacename">TaskExecutor</tt>.
						If you need something advanced such as a
						<tt class="classname">ScheduledThreadPoolExecutor</tt>,
						it is recommended that you use a
						<a href="#concurrentTaskExecutor"><tt class="classname">ConcurrentTaskExecutor</tt></a>
						instead.
                    </p></li><li><p>
						<tt class="classname">TimerTaskExecutor</tt>
					</p><p>
						This implementation uses a single
						<tt class="classname">TimerTask</tt>
						as its backing implementation. It's different
						from the
						<a href="#syncTaskExecutor"><tt class="classname">SyncTaskExecutor</tt></a>
						in that the method invocations are executed in a
						separate thread, although they are synchronous
						in that thread.
					</p></li><li><p>
						<tt class="classname">WorkManagerTaskExecutor</tt>
					</p><div class="sidebar"><p>
							CommonJ is a set of specifications jointly
							developed between BEA and IBM. These
							specifications are not Java EE standards, but
							are standard across BEA's and IBM's
							Application Server implementations.
						</p></div><p>
						This implementation uses the CommonJ WorkManager
						as its backing implementation and is the central
						convenience class for setting up a CommonJ
						WorkManager reference in a Spring context.
						Similar to the
						<a href="#simpleThreadPoolTaskExecutor"><tt class="classname">SimpleThreadPoolTaskExecutor</tt></a>,
						this class implements the WorkManager
						interface and therefore can be used directly as
						a WorkManager as well.
					</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="scheduling-task-executor-usage"></a>23.4.2.&nbsp;Using a <tt class="interfacename">TaskExecutor</tt></h3></div></div><div></div></div><p>Spring's <tt class="interfacename">TaskExecutor</tt> implementations
			are used as simple JavaBeans.  In the example below, we define
			a bean that uses the <tt class="classname">ThreadPoolTaskExecutor</tt>
			to asynchronously print out a set of messages.</p><pre class="programlisting">import org.springframework.core.task.TaskExecutor;

public class TaskExecutorExample {

  private class MessagePrinterTask implements Runnable {

    private String message;

    public MessagePrinterTask(String message) {
      this.message = message;
    }

    public void run() {
      System.out.println(message);
    }

  }

  private TaskExecutor taskExecutor;

  public TaskExecutorExample(TaskExecutor taskExecutor) {
    this.taskExecutor = taskExecutor;
  }

  public void printMessages() {
    for(int i = 0; i &lt; 25; i++) {
      taskExecutor.execute(new MessagePrinterTask("Message" + i));
    }
  }
}</pre><p>As you can see, rather than retrieving a thread from the
			pool and executing yourself, you add your <tt class="classname">Runnable</tt>
			to the queue and the <tt class="interfacename">TaskExecutor</tt>
			uses its internal rules to decide when the task gets executed.</p><p>To configure the rules that the <tt class="interfacename">TaskExecutor</tt>
			will use, simple bean properties have been exposed.</p><pre class="programlisting">&lt;bean id="taskExecutor" class="org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor"&gt;
  &lt;property name="corePoolSize" value="5" /&gt;
  &lt;property name="maxPoolSize" value="10" /&gt;
  &lt;property name="queueCapacity" value="25" /&gt;
&lt;/bean&gt;

&lt;bean id="taskExecutorExample" class="TaskExecutorExample"&gt;
  &lt;constructor-arg ref="taskExecutor" /&gt;
&lt;/bean&gt;</pre></div></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="dynamic-language"></a>Chapter&nbsp;24.&nbsp;Dynamic language support</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dynamic-language-introduction"></a>24.1.&nbsp;Introduction</h2></div></div><div></div></div><div class="sidebar"><p class="title"><b>Why only these languages?</b></p><p>
        The supported languages were chosen because a) the languages
        have a lot of traction in the Java enterprise community, b) no requests were made
        for other languages within the Spring 2.0 development timeframe, and
        c) the Spring developers were most familiar with them.
      </p><p>
        There is nothing stopping the inclusion of further languages though. If you want
        to see support for &lt;<span class="emphasis"><em>insert your favourite dynamic language here</em></span>&gt;,
        you can always raise an issue on Spring's
        <a href="http://opensource.atlassian.com/projects/spring/secure/Dashboard.jspa" target="_top">JIRA</a>
        page (or implement such support yourself).
      </p></div><p>Spring 2.0 introduces comprehensive support for using classes and objects that have
    been defined using a dynamic language (such as JRuby) with Spring.
    This support allows you to write any number of classes in a supported dynamic language,
    and have the Spring container transparently instantiate, configure and dependency inject the
    resulting objects.</p><p>The dynamic languages currently supported are:</p><div class="itemizedlist"><ul type="disc"><li><p>JRuby 0.9 / 1.0</p></li><li><p>Groovy 1.0 / 1.5</p></li><li><p>BeanShell 2.0</p></li></ul></div><p>
      Fully working examples of where this dynamic language support can be immediately useful
      are described in the section entitled <a href="#dynamic-language-scenarios" title="24.4.&nbsp;Scenarios">Section&nbsp;24.4, &#8220;Scenarios&#8221;</a>.
    </p><p>
      <span class="emphasis"><em>Note:</em></span> Only the specific versions as listed above are supported
      in Spring 2.5. In particular, JRuby 1.1 (which introduced many incompatible API
      changes) is <span class="emphasis"><em>not</em></span> supported at this point of time.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dynamic-language-a-first-example"></a>24.2.&nbsp;A first example</h2></div></div><div></div></div><p>
      This bulk of this chapter is concerned with describing the dynamic language support
      in detail. Before diving into all of the ins and outs of the dynamic language support,
      let's look at a quick example of a bean defined in a dynamic language.
      The dynamic language for this first bean is Groovy (the basis of this example
      was taken from the Spring test suite, so if you want to see equivalent examples
      in any of the other supported languages, take a look at the source code).
    </p><p>
      Find below the <tt class="interfacename">Messenger</tt> interface that the
      Groovy bean is going to be implementing, and note that this interface is defined
      in plain Java. Dependent objects that are injected with a reference to the
      <tt class="interfacename">Messenger</tt> won't know that the underlying
      implementation is a Groovy script.
    </p><pre class="programlisting">package org.springframework.scripting;

public interface Messenger {

    String getMessage();
}</pre><p>
      Here is the definition of a class that has a dependency on the
      <tt class="interfacename">Messenger</tt> interface.
    </p><pre class="programlisting">package org.springframework.scripting;

public class DefaultBookingService implements BookingService {

    private Messenger messenger;

    public void setMessenger(Messenger messenger) {
        this.messenger = messenger;
    }

    public void processBooking() {
        // use the injected Messenger object...
    }
}</pre><p>Here is an implementation of the <tt class="interfacename">Messenger</tt> interface
    in Groovy.</p><pre class="programlisting">// from the file 'Messenger.groovy'
package org.springframework.scripting.groovy;

// import the Messenger interface (written in Java) that is to be implemented
import org.springframework.scripting.Messenger

// define the implementation in Groovy
class GroovyMessenger implements Messenger {

    String message
}</pre><p>
      Finally, here are the bean definitions that will effect the injection of the
      Groovy-defined <tt class="interfacename">Messenger</tt> implementation into
      an instance of the <tt class="classname">DefaultBookingService</tt> class.
    </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
        To use the custom dynamic language tags to define dynamic-language-backed beans,
        you need to have the XML Schema preamble at the top of your Spring XML
        configuration file. You also need to be using a Spring
        <tt class="interfacename">ApplicationContext</tt> implementation as your
        IoC container. Using the dynamic-language-backed beans with a plain
        <tt class="interfacename">BeanFactory</tt> implementation is supported,
        but you have to manage the plumbing of the Spring internals to do so.
      </p><p>For more information on schema-based configuration, see <a href="#xsd-config" title="Appendix&nbsp;A.&nbsp;XML Schema-based configuration">Appendix&nbsp;A, <i>XML Schema-based configuration</i></a>.</p></td></tr></table></div><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:lang="http://www.springframework.org/schema/lang"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-2.5.xsd"&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- this is the bean definition for the Groovy-backed <tt class="interfacename">Messenger</tt> implementation --&gt;</span></i>
    &lt;lang:groovy id="messenger" script-source="classpath:Messenger.groovy"&gt;
        &lt;lang:property name="message" value="I Can Do The Frug" /&gt;
    &lt;/lang:groovy&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- an otherwise normal bean that will be injected by the Groovy-backed <tt class="interfacename">Messenger</tt> --&gt;</span></i>
    &lt;bean id="bookingService" class="x.y.DefaultBookingService"&gt;
        &lt;property name="messenger" ref="messenger" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>
      The <tt class="literal">bookingService</tt> bean (a
      <tt class="classname">DefaultBookingService</tt>) can now use its private
      <tt class="literal">messenger</tt> member variable as normal because the
      <tt class="interfacename">Messenger</tt> instance that was injected
      into it <span class="emphasis"><em>is</em></span> a <tt class="interfacename">Messenger</tt>
      instance. There is nothing special going on here, just plain Java and
      plain Groovy.
    </p><p>
      Hopefully the above XML snippet is self-explanatory, but don't worry
      unduly if it isn't. Keep reading for the in-depth detail on the whys
      and wherefores of the above configuration.
    </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dynamic-language-beans"></a>24.3.&nbsp;Defining beans that are backed by dynamic languages</h2></div></div><div></div></div><p>
      This section describes exactly how you define Spring managed beans in
      any of the supported dynamic languages.
    </p><p>
      Please note that this chapter does not attempt to explain the syntax and
      idioms of the supported dynamic languages. For example, if you want to
      use Groovy to write certain of the classes in your application, then the
      assumption is that you already know Groovy. If you need further details
      about the dynamic languages themselves, please consult the section
      entitled <a href="#dynamic-language-resources" title="24.6.&nbsp;Further Resources">Section&nbsp;24.6, &#8220;Further Resources&#8221;</a> at the end of this chapter.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamic-language-beans-concepts"></a>24.3.1.&nbsp;Common concepts</h3></div></div><div></div></div><p>The steps involved in using dynamic-language-backed beans are as follows:</p><div class="orderedlist"><ol type="1"><li><p>Write the test for the dynamic language source code (naturally)</p></li><li><p><span class="emphasis"><em>Then</em></span> write the dynamic language source code itself :)</p></li><li><p>
            Define your dynamic-language-backed beans using the appropriate
            <tt class="literal">&lt;lang:language/&gt;</tt> element in the XML
            configuration (you can of course define such beans programmatically
            using the Spring API - although you will have to consult the source
            code for directions on how to do this as this type of advanced
            configuration is not covered in this chapter). Note this is an iterative
            step. You will need at least one bean definition per dynamic
            language source file (although the same dynamic language source
            file can of course be referenced by multiple bean definitions).
          </p></li></ol></div><p>
        The first two steps (testing and writing your dynamic language source files)
        are beyond the scope of this chapter. Refer to the language specification
        and / or reference manual for your chosen dynamic language and crack on with
        developing your dynamic language source files. You <span class="emphasis"><em>will</em></span>
        first want to read the rest of this chapter though, as Spring's dynamic language
        support does make some (small) assumptions about the contents of your dynamic
        language source files.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-language-beans-concepts-xml-language-element"></a>24.3.1.1.&nbsp;The <tt class="literal">&lt;lang:language/&gt;</tt> element</h4></div></div><div></div></div><div class="sidebar"><p class="title"><b>XML Schema</b></p><p>
            All of the configuration examples in this chapter make use of the
            new XML Schema support that was added in Spring 2.0.
          </p><p>It is possible to forego the use of XML Schema and stick with the old-style
          DTD based validation of your Spring XML files, but then you lose out
          on the convenience offered by the <tt class="literal">&lt;lang:language/&gt;</tt>
          element. See the Spring test suite for examples of the older style
          configuration that doesn't require XML Schema-based validation
          (it is quite verbose and doesn't hide any of the underlying Spring
          implementation from you).</p></div><p>
          The final step involves defining dynamic-language-backed bean definitions,
          one for each bean that you want to configure (this is no different to
          normal Java bean configuration). However, instead of specifying the
          fully qualified classname of the class that is to be instantiated and
          configured by the container, you use the <tt class="literal">&lt;lang:language/&gt;</tt>
          element to define the dynamic language-backed bean.
        </p><p>
          Each of the supported languages has a corresponding
          <tt class="literal">&lt;lang:language/&gt;</tt> element:
        </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="literal">&lt;lang:jruby/&gt;</tt> (JRuby)</p></li><li><p><tt class="literal">&lt;lang:groovy/&gt;</tt> (Groovy)</p></li><li><p><tt class="literal">&lt;lang:bsh/&gt;</tt> (BeanShell)</p></li></ul></div><p>
          The exact attributes and child elements that are available for
          configuration depends on exactly which language the bean has been
          defined in (the language-specific sections below provide the full
          lowdown on this).
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-language-refreshable-beans"></a>24.3.1.2.&nbsp;Refreshable beans</h4></div></div><div></div></div><p>
          One of the (if not <span class="emphasis"><em>the</em></span>) most compelling value adds
          of the dynamic language support in Spring is the
          <i class="firstterm">'refreshable bean'</i> feature.
        </p><p>
          A refreshable bean is a dynamic-language-backed bean that with a small
          amount of configuration, a dynamic-language-backed bean can monitor
          changes in its underlying source file resource, and then reload itself
          when the dynamic language source file is changed (for example when a
          developer edits and saves changes to the file on the filesystem).
        </p><p>
          This allows a developer to deploy any number of dynamic language source
          files as part of an application, configure the Spring container to create
          beans backed by dynamic language source files (using the mechanisms
          described in this chapter), and then later, as requirements change or
          some other external factor comes into play, simply edit a dynamic language
          source file and have any change they make reflected in the bean that is
          backed by the changed dynamic language source file. There is no need to
          shut down a running application (or redeploy in the case of a web application).
          The dynamic-language-backed bean so amended will pick up the new state
          and logic from the changed dynamic language source file.
        </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Please note that this feature is <span class="emphasis"><em>off</em></span> by default.</p></td></tr></table></div><p>
          Let's take a look at an example to see just how easy it is to start using
          refreshable beans. To <span class="emphasis"><em>turn on</em></span> the refreshable beans
          feature, you simply have to specify exactly <span class="emphasis"><em>one</em></span>
          additional attribute on the <tt class="literal">&lt;lang:language/&gt;</tt> element
          of your bean definition. So if we stick with
          <a href="#dynamic-language-a-first-example" title="24.2.&nbsp;A first example">the example</a> from earlier
          in this chapter, here's what we would change in the Spring XML configuration
          to effect refreshable beans:
        </p><pre class="programlisting">&lt;beans&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- this bean is now 'refreshable' due to the presence of the 'refresh-check-delay' attribute --&gt;</span></i>
    &lt;lang:groovy id="messenger"
          refresh-check-delay="5000" <i class="lineannotation"><span class="lineannotation">&lt;!-- switches refreshing on with 5 seconds between checks --&gt;</span></i>
          script-source="classpath:Messenger.groovy"&gt;
        &lt;lang:property name="message" value="I Can Do The Frug" /&gt;
    &lt;/lang:groovy&gt;

    &lt;bean id="bookingService" class="x.y.DefaultBookingService"&gt;
        &lt;property name="messenger" ref="messenger" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>
          That really is all you have to do. The <tt class="literal">'refresh-check-delay'</tt>
          attribute defined on the <tt class="literal">'messenger'</tt> bean definition
          is the number of milliseconds after which the bean will be refreshed with
          any changes made to the underlying dynamic language source file.
          You can turn off the refresh behavior by assigning a negative value
          to the <tt class="literal">'refresh-check-delay'</tt> attribute.
          Remember that, by default, the refresh behavior is disabled. If you don't
          want the refresh behavior, then simply don't define the attribute.
        </p><p>
          If we then run the following application we can exercise the refreshable feature;
          please do excuse the <span class="emphasis"><em>'jumping-through-hoops-to-pause-the-execution'</em></span>
          shenanigans in this next slice of code. The <tt class="literal">System.in.read()</tt>
          call is only there so that the execution of the program pauses while I (the author)
          go off and edit the underlying dynamic language source file so that the refresh will
          trigger on the dynamic-language-backed bean when the program resumes execution.</p><pre class="programlisting">import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.scripting.Messenger;

public final class Boot {

    public static void main(final String[] args) throws Exception {

        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
        Messenger messenger = (Messenger) ctx.getBean("messenger");
        System.out.println(messenger.getMessage());
        // pause execution while I go off and make changes to the source file...
        System.in.read();
        System.out.println(messenger.getMessage());
    }
}</pre><p>
          Let's assume then, for the purposes of this example, that all
          calls to the <tt class="literal">getMessage()</tt> method of
          <tt class="interfacename">Messenger</tt> implementations have to be
          changed such that the message is surrounded by quotes.
          Below are the changes that I (the author) make to the
          <tt class="filename">Messenger.groovy</tt> source file when the execution of
          the program is paused.
        </p><pre class="programlisting">package org.springframework.scripting

class GroovyMessenger implements Messenger {

    private String message = "Bingo"

    public String getMessage() {
        // change the implementation to surround the message in quotes
        return "'" + this.message + "'"
    }

    public void setMessage(String message) {
        this.message = message
    }
}</pre><p>
          When the program executes, the output before the input pause will be
          <tt class="computeroutput">I Can Do The Frug</tt>. After the change
          to the source file is made and saved, and the program resumes execution,
          the result of calling the <tt class="literal">getMessage()</tt> method on the
          dynamic-language-backed <tt class="interfacename">Messenger</tt> implementation
          will be <tt class="computeroutput">'I Can Do The Frug'</tt> (notice
          the inclusion of the additional quotes).
        </p><p>
          It is important to understand that changes to a script will
          <span class="emphasis"><em>not</em></span> trigger a refresh if the changes occur
          within the window of the <tt class="literal">'refresh-check-delay'</tt> value.
          It is equally important to understand that changes to the script are
          <span class="emphasis"><em>not</em></span> actually 'picked up' until a method is called
          on the dynamic-language-backed bean. It is only when a method is called on a
          dynamic-language-backed bean that it checks to see if its underlying script
          source has changed. Any exceptions relating to refreshing the script
          (such as encountering a compilation error, or finding that the script
          file has been deleted) will result in a <span class="emphasis"><em>fatal</em></span>
          exception being propagated to the calling code.
        </p><p>
          The refreshable bean behavior described above does
          <span class="emphasis"><em>not</em></span> apply to dynamic language source files
          defined using the <tt class="literal">&lt;lang:inline-script/&gt;</tt> element
          notation (see the section entitled <a href="#dynamic-language-beans-inline" title="24.3.1.3.&nbsp;Inline dynamic language source files">Section&nbsp;24.3.1.3, &#8220;Inline dynamic language source files&#8221;</a>).
          Additionally, it <span class="emphasis"><em>only</em></span> applies to beans where
          changes to the underlying source file can actually be detected;
          for example, by code that checks the last modified date of a
          dynamic language source file that exists on the filesystem.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-language-beans-inline"></a>24.3.1.3.&nbsp;Inline dynamic language source files</h4></div></div><div></div></div><p>
          The dynamic language support can also cater for dynamic language
          source files that are embedded directly in Spring bean definitions.
          More specifically, the <tt class="literal">&lt;lang:inline-script/&gt;</tt>
          element allows you to define dynamic language source immediately
          inside a Spring configuration file. An example will perhaps make the
          inline script feature crystal clear:
        </p><pre class="programlisting">&lt;lang:groovy id="messenger"&gt;
    &lt;lang:inline-script&gt;
package org.springframework.scripting.groovy;

import org.springframework.scripting.Messenger

class GroovyMessenger implements Messenger {

    String message
}
    &lt;/lang:inline-script&gt;
    &lt;lang:property name="message" value="I Can Do The Frug" /&gt;
&lt;/lang:groovy&gt;</pre><p>
          If we put to one side the issues surrounding whether it is good practice
          to define dynamic language source inside a Spring configuration file, the
          <tt class="literal">&lt;lang:inline-script/&gt;</tt> element can be useful in
          some scenarios. For instance, we might want to quickly add a Spring
          <tt class="interfacename">Validator</tt> implementation to a Spring MVC
          <tt class="interfacename">Controller</tt>. This is but a moment's work
          using inline source. (See the section entitled
          <a href="#dynamic-language-scenarios-validators" title="24.4.2.&nbsp;Scripted Validators">Section&nbsp;24.4.2, &#8220;Scripted Validators&#8221;</a>  for such an example.)
        </p><p>
          Find below an example of defining the source for a JRuby-based bean
          directly in a Spring XML configuration file using the
          <tt class="literal">inline:</tt> notation. (Notice the use of the &amp;lt;
          characters to denote a <tt class="literal">'&lt;'</tt> character. In such a case
          surrounding the inline source in a <tt class="literal">&lt;![CDATA[]]&gt;</tt> region might be better.)
        </p><pre class="programlisting">&lt;lang:jruby id="messenger" script-interfaces="org.springframework.scripting.Messenger"&gt;
    &lt;lang:inline-script&gt;
require 'java'

include_class 'org.springframework.scripting.Messenger'

class RubyMessenger &amp;lt; Messenger

 def setMessage(message)
  @@message = message
 end

 def getMessage
  @@message
 end
 
end
    &lt;/lang:inline-script&gt;
    &lt;lang:property name="message" value="Hello World!" /&gt;
&lt;/lang:jruby&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-language-beans-ctor-injection"></a>24.3.1.4.&nbsp;Understanding Constructor Injection in the context of dynamic-language-backed beans</h4></div></div><div></div></div><p>
          There is one <span class="emphasis"><em>very</em></span> important thing to be aware of
          with regard to Spring's dynamic language support. Namely, it is not (currently)
          possible to supply constructor arguments to dynamic-language-backed beans (and hence
          constructor-injection is not available for dynamic-language-backed beans).
          In the interests of making this special handling of constructors and
          properties 100% clear, the following mixture of code and configuration
          will <span class="emphasis"><em>not</em></span> work.
        </p><pre class="programlisting">// from the file 'Messenger.groovy'
package org.springframework.scripting.groovy;

import org.springframework.scripting.Messenger

class GroovyMessenger implements Messenger {

    GroovyMessenger() {}

    // this constructor is not available for Constructor Injection
    GroovyMessenger(String message) {
        this.message = message;
    }

    String message

    String anotherMessage
}</pre><pre class="programlisting">&lt;lang:groovy id="badMessenger"
    script-source="classpath:Messenger.groovy"&gt;

    <i class="lineannotation"><span class="lineannotation">&lt;!-- this next constructor argument will *not* be injected into the <tt class="classname">GroovyMessenger</tt> --&gt;</span></i>
    <i class="lineannotation"><span class="lineannotation">&lt;!--     in fact, this isn't even allowed according to the schema --&gt;</span></i>
    &lt;constructor-arg value="<i class="lineannotation"><span class="lineannotation"><span class="bold"><b>This will *not* work</b></span></span></i>" /&gt;
    
    <i class="lineannotation"><span class="lineannotation">&lt;!-- <span class="bold"><b>only</b></span> property values are injected into the dynamic-language-backed object --&gt;</span></i>
    &lt;lang:property name="anotherMessage" value="Passed straight through to the dynamic-language-backed object" /&gt;

&lt;/lang&gt;</pre><p>
          In practice this limitation is not as significant as it first appears since
          setter injection is the injection style favored by the overwhelming majority
          of developers anyway (let's leave the discussion as to whether that is a good
          thing to another day).
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamic-language-beans-jruby"></a>24.3.2.&nbsp;JRuby beans</h3></div></div><div></div></div><div class="sidebar"><p class="title"><b>The JRuby library dependencies</b></p><p>
          The JRuby scripting support in Spring requires the following
          libraries to be on the classpath of your application.
          (The  versions listed just happen to be the versions that the
          Spring team used in the development of the JRuby scripting support;
          you may well be able to use another version of a specific library.)
        </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="filename">jruby.jar</tt></p></li><li><p><tt class="filename">cglib-nodep-2.1_3.jar</tt></p></li></ul></div></div><p>From the JRuby homepage...</p>&#8220;<span class="quote">
        <span class="emphasis"><em>JRuby is an 100% pure-Java implementation of the Ruby programming language.</em></span>
      </span>&#8221;<p>
        In keeping with the Spring philosophy of offering choice, Spring's
        dynamic language support also supports beans defined in the JRuby
        language. The JRuby language is based on the quite intuitive
        Ruby language, and has support for inline regular expressions, blocks
        (closures), and a whole host of other features that do make solutions
        for some domain problems a whole lot easier to develop.
      </p><p>
        The implementation of the JRuby dynamic language support in Spring is
        interesting in that what happens is this: Spring creates a JDK dynamic
        proxy implementing all of the interfaces that are specified in the
        <tt class="literal">'script-interfaces'</tt> attribute value of the
        <tt class="literal">&lt;lang:ruby&gt;</tt> element (this is why
        you <span class="emphasis"><em>must</em></span> supply at least one interface in the value
        of the attribute, and (accordingly) program to interfaces when using
        JRuby-backed beans).
      </p><p>
        Let us look at a fully working example of using a JRuby-based bean. Here is
        the JRuby implementation of the <tt class="interfacename">Messenger</tt>
        interface that was defined earlier in this chapter (for your convenience it
        is repeated below).
      </p><pre class="programlisting">package org.springframework.scripting;

public interface Messenger {

    String getMessage();
}</pre><pre class="programlisting">require 'java'

class RubyMessenger
    include org.springframework.scripting.Messenger

    def setMessage(message)
        @@message = message
    end

    def getMessage
        @@message
    end
end

# this last line is not essential (but see below)
RubyMessenger.new</pre><p>
        And here is the Spring XML that defines an instance of the
        <tt class="classname">RubyMessenger</tt> JRuby bean.
      </p><pre class="programlisting">&lt;lang:jruby id="messageService"
            script-interfaces="org.springframework.scripting.Messenger"
            script-source="classpath:RubyMessenger.rb"&gt;
    
    &lt;lang:property name="message" value="Hello World!" /&gt;

&lt;/lang:jruby&gt;</pre><p>
        Take note of the last line of that JRuby source (<tt class="literal">'RubyMessenger.new'</tt>).
        When using JRuby in the context of Spring's dynamic language support, you are encouraged
        to instantiate and return a new instance of the JRuby class that you want to use as a
        dynamic-language-backed bean as the result of the execution of your JRuby source. You
        can achieve this by simply instantiating a new instance of your JRuby class on the last
        line of the source file like so:
      </p><pre class="programlisting">require 'java'

include_class 'org.springframework.scripting.Messenger'

# class definition same as above...

# instantiate and return a new instance of the RubyMessenger class
RubyMessenger.new</pre><p>
        If you forget to do this, it is not the end of the world; this will however result in
        Spring having to trawl (reflectively) through the type representation of your JRuby class
        looking for a class to instantiate. In the grand scheme of things this will be so fast
        that you'll never notice it, but it is something that can be avoided by simply
        having a line such as the one above as the last line of your JRuby script. If you don't
        supply such a line, or if Spring cannot find a JRuby class in your script to instantiate
        then an opaque <tt class="classname">ScriptCompilationException</tt>
        will be thrown immediately after the source is executed by the JRuby
        interpreter. The key text that identifies this as the root cause of an
        exception can be found immediately below (so if your Spring container
        throws the following exception when creating your dynamic-language-backed bean
        and the following text is there in the corresponding stacktrace, this will hopefully
        allow you to identify and then easily rectify the issue):
      </p><tt class="computeroutput">org.springframework.scripting.ScriptCompilationException: Compilation of JRuby script returned ''</tt><p>
        To rectify this, simply instantiate a new instance of whichever class
        you want to expose as a JRuby-dynamic-language-backed bean (as shown above). Please
        also note that you can actually define as many classes and objects
        as you want in your JRuby script; what is important is that the
        source file as a whole must return an object (for Spring to configure).
      </p><p>
        See the section entitled <a href="#dynamic-language-scenarios" title="24.4.&nbsp;Scenarios">Section&nbsp;24.4, &#8220;Scenarios&#8221;</a> for some
        scenarios where you might want to use JRuby-based beans.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamic-language-beans-groovy"></a>24.3.3.&nbsp;Groovy beans</h3></div></div><div></div></div><div class="sidebar"><p class="title"><b>The Groovy library dependencies</b></p><p>
          The Groovy scripting support in Spring requires the following
          libraries to be on the classpath of your application.
        </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="filename">groovy-1.5.5.jar</tt></p></li><li><p><tt class="filename">asm-2.2.2.jar</tt></p></li><li><p><tt class="filename">antlr-2.7.6.jar</tt></p></li></ul></div></div><p>From the Groovy homepage...</p>&#8220;<span class="quote">
        <span class="emphasis"><em>Groovy is an agile dynamic language for the Java 2 Platform that has
        many of the  features that people like so much in languages like Python, Ruby
        and Smalltalk, making them available to Java developers using a Java-like syntax.
        </em></span>
      </span>&#8221;<p>
        If you have read this chapter straight from the top, you will already have
        <a href="#dynamic-language-a-first-example" title="24.2.&nbsp;A first example">seen an example</a> of a
        Groovy-dynamic-language-backed bean. Let's look at another example (again
        using an example from the Spring test suite).
      </p><pre class="programlisting">package org.springframework.scripting;

public interface Calculator {

    int add(int x, int y);
}</pre><p>
        Here is an implementation of the <tt class="interfacename">Calculator</tt>
        interface in Groovy.
      </p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">// from the file 'calculator.groovy'</span></i>
package org.springframework.scripting.groovy

class GroovyCalculator implements Calculator {

    int add(int x, int y) {
        x + y
    }
}</pre><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;-- from the file 'beans.xml' --&gt;</span></i>
&lt;beans&gt;
    &lt;lang:groovy id="calculator" script-source="classpath:calculator.groovy"/&gt;
&lt;/beans&gt;</pre><p>
        Lastly, here is a small application to exercise the above configuration.
      </p><pre class="programlisting">package org.springframework.scripting;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Main {

    public static void Main(String[] args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml");
        Calculator calc = (Calculator) ctx.getBean("calculator");
        System.out.println(calc.add(2, 8));
    }
}</pre><p>
        The resulting output from running the above program will be
        (unsurprisingly) <tt class="computeroutput">10</tt>.
        (Exciting example, huh? Remember that the intent is to illustrate the
        concept. Please consult the dynamic language showcase project for a
        more complex example, or indeed the section entitled
        <a href="#dynamic-language-scenarios" title="24.4.&nbsp;Scenarios">Section&nbsp;24.4, &#8220;Scenarios&#8221;</a> later in this chapter).
      </p><p>
        It is important that you <span class="emphasis"><em>do not</em></span> define more than one
        class per Groovy source file. While this is perfectly legal in Groovy, it
        is (arguably) a bad practice: in the interests of a consistent approach,
        you should (in the opinion of this author) respect the standard Java
        conventions of one (public) class per source file.
      </p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="dynamic-language-beans-groovy-customizer"></a>24.3.3.1.&nbsp;Customising Groovy objects via a callback</h4></div></div><div></div></div><p>
          The <tt class="interfacename">GroovyObjectCustomizer</tt>
          interface is a callback that allows you to hook additional
          creation logic into the process of creating a Groovy-backed bean.
          For example, implementations of this interface could invoke
          any required initialization method(s), or set some default property
          values, or specify a custom <tt class="classname">MetaClass</tt>.
        </p><pre class="programlisting">public interface GroovyObjectCustomizer {

   void customize(GroovyObject goo);
}</pre><p>
          The Spring Framework will instantiate an instance of your Groovy-backed
          bean, and will then pass the created <tt class="interfacename">GroovyObject</tt>
          to the specified <tt class="interfacename">GroovyObjectCustomizer</tt>
          if one has been defined. You can do whatever you like with the supplied
          <tt class="interfacename">GroovyObject</tt> reference: it is expected
          that the setting of a custom <tt class="classname">MetaClass</tt> is what most
          folks will want to do with this callback, and you can see an example
          of doing that below.
        </p><pre class="programlisting">public final class SimpleMethodTracingCustomizer implements GroovyObjectCustomizer {

   public void customize(GroovyObject goo) {
      DelegatingMetaClass metaClass = new DelegatingMetaClass(goo.getMetaClass()) {

         public Object invokeMethod(Object object, String methodName, Object[] arguments) {
            System.out.println("Invoking '" + methodName + "'.");
            return super.invokeMethod(object, methodName, arguments);
         }
      };
      metaClass.initialize();
      goo.setMetaClass(metaClass);
   }
}</pre><p>
          A full discussion of meta-programming in Groovy is beyond the scope of the
          Spring reference manual. Consult the relevant section of the Groovy
          reference manual, or do a search online: there are plenty of articles
          concerning this topic.
          Actually making use of a <tt class="interfacename">GroovyObjectCustomizer</tt>
          is easy if you are using the Spring 2.0 namespace support.
        </p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- define the <tt class="interfacename">GroovyObjectCustomizer</tt> just like any other bean --&gt;</span></i>
&lt;bean id="tracingCustomizer" class="example.SimpleMethodTracingCustomizer" /&gt;

   <i class="lineannotation"><span class="lineannotation">&lt;!-- ... and plug it into the desired Groovy bean via the '<tt class="literal">customizer-ref</tt>' attribute --&gt;</span></i>
   &lt;lang:groovy id="calculator"
      script-source="classpath:org/springframework/scripting/groovy/Calculator.groovy"
      customizer-ref="tracingCustomizer" /&gt;</pre><p>
          If you are not using the Spring 2.0 namespace support, you can still
          use the <tt class="interfacename">GroovyObjectCustomizer</tt> functionality.
        </p><pre class="programlisting">&lt;bean id="calculator" class="org.springframework.scripting.groovy.GroovyScriptFactory"&gt;
      &lt;constructor-arg value="classpath:org/springframework/scripting/groovy/Calculator.groovy"/&gt;
      <i class="lineannotation"><span class="lineannotation">&lt;!-- define the <tt class="interfacename">GroovyObjectCustomizer</tt> (as an inner bean) --&gt;</span></i>
      &lt;constructor-arg&gt;
         &lt;bean id="tracingCustomizer" class="example.SimpleMethodTracingCustomizer" /&gt;
      &lt;/constructor-arg&gt;
&lt;/bean&gt;

&lt;bean class="org.springframework.scripting.support.ScriptFactoryPostProcessor"/&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamic-language-beans-bsh"></a>24.3.4.&nbsp;BeanShell beans</h3></div></div><div></div></div><div class="sidebar"><p class="title"><b>The BeanShell library dependencies</b></p><p>
          The BeanShell scripting support in Spring requires the following
          libraries to be on the classpath of your application.
        </p><div class="itemizedlist"><ul type="disc"><li><p><tt class="filename">bsh-2.0b4.jar</tt></p></li><li><p><tt class="filename">cglib-nodep-2.1_3.jar</tt></p></li></ul></div><p>
          All of these libraries are available in the Spring-with-dependencies
          distribution of Spring (in addition to also being freely available
          on the web).
        </p></div><p>From the BeanShell homepage...</p>&#8220;<span class="quote">
        <span class="emphasis"><em>BeanShell is a small, free, embeddable Java source interpreter
        with dynamic language features, written in Java. BeanShell dynamically
        executes standard Java syntax and extends it with common scripting
        conveniences such as loose types, commands, and method closures like those
        in Perl and JavaScript.</em></span>
      </span>&#8221;<p>
        In contrast to Groovy, BeanShell-backed bean definitions require some (small)
        additional configuration. The implementation of the BeanShell dynamic language
        support in Spring is interesting in that what happens is this: Spring creates
        a JDK dynamic proxy implementing all of the interfaces that are specified in the
        <tt class="literal">'script-interfaces'</tt> attribute value of the
        <tt class="literal">&lt;lang:bsh&gt;</tt> element (this is why
        you <span class="emphasis"><em>must</em></span> supply at least one interface in the value
        of the attribute, and (accordingly) program to interfaces when using
        BeanShell-backed beans). This means that every method call on a BeanShell-backed
        object is going through the JDK dynamic proxy invocation mechanism.
      </p><p>
        Let's look at a fully working example of using a BeanShell-based bean
        that implements the <tt class="interfacename">Messenger</tt> interface
        that was defined earlier in this chapter (repeated below for your
        convenience).
      </p><pre class="programlisting">package org.springframework.scripting;

public interface Messenger {

    String getMessage();
}</pre><p>Here is the BeanShell 'implementation' (the term is used loosely here) of the
          <tt class="interfacename">Messenger</tt> interface.</p><pre class="programlisting">String message;

String getMessage() {
    return message;
}

void setMessage(String aMessage) {
    message = aMessage;
}</pre><p>
        And here is the Spring XML that defines an 'instance' of the above 'class'
        (again, the term is used very loosely here).
      </p><pre class="programlisting">&lt;lang:bsh id="messageService" script-source="classpath:BshMessenger.bsh"
    script-interfaces="org.springframework.scripting.Messenger"&gt;

    &lt;lang:property name="message" value="Hello World!" /&gt;
&lt;/lang:bsh&gt;</pre><p>See the section entitled <a href="#dynamic-language-scenarios" title="24.4.&nbsp;Scenarios">Section&nbsp;24.4, &#8220;Scenarios&#8221;</a> for some
      scenarios where you might want to use BeanShell-based beans.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dynamic-language-scenarios"></a>24.4.&nbsp;Scenarios</h2></div></div><div></div></div><p>
      The possible scenarios where defining Spring managed beans in a scripting
      language would be beneficial are, of course, many and varied. This section
      describes two possible use cases for the dynamic language support in Spring.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamic-language-scenarios-controllers"></a>24.4.1.&nbsp;Scripted Spring MVC Controllers</h3></div></div><div></div></div><p>
        One group of classes that may benefit from using dynamic-language-backed
        beans is that of Spring MVC controllers. In pure Spring MVC applications,
        the  navigational flow through a web application is to a large extent
        determined by code encapsulated within your Spring MVC controllers.
        As the navigational flow and other presentation layer logic of a web
        application needs to be updated to respond to support issues or changing
        business requirements, it may well be easier to effect any such required
        changes  by editing one or more dynamic language source files and seeing
        those changes being immediately reflected in the state of a running
        application.
      </p><p>
        Remember that in the lightweight architectural model espoused by projects
        such as Spring, you are typically aiming to have a really
        <span class="emphasis"><em>thin</em></span> presentation layer, with all the meaty business
        logic of an application being contained in the domain and service layer
        classes. Developing Spring MVC controllers as dynamic-language-backed beans
        allows you to change presentation layer logic by simply editing and saving
        text files; any changes to such dynamic language source files will (depending
        on the configuration) automatically be reflected in the beans that are backed
              by dynamic language source files.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
          In order to effect this automatic 'pickup' of any changes
          to dynamic-language-backed beans, you will have had to enable the
          'refreshable beans' functionality. See the section entitle
           <a href="#dynamic-language-refreshable-beans" title="24.3.1.2.&nbsp;Refreshable beans">Section&nbsp;24.3.1.2, &#8220;Refreshable beans&#8221;</a> for a full treatment
           of this feature.
        </p></td></tr></table></div><p>
        Find below an example of an
        <tt class="interfacename">org.springframework.web.servlet.mvc.Controller</tt>
        implemented using the Groovy dynamic language.
      </p><pre class="programlisting">// from the file '/WEB-INF/groovy/FortuneController.groovy'
package org.springframework.showcase.fortune.web

import org.springframework.showcase.fortune.service.FortuneService
import org.springframework.showcase.fortune.domain.Fortune
import org.springframework.web.servlet.ModelAndView
import org.springframework.web.servlet.mvc.Controller

import javax.servlet.http.HttpServletRequest
import javax.servlet.http.HttpServletResponse

class FortuneController implements Controller {

    @Property FortuneService fortuneService

    ModelAndView handleRequest(
            HttpServletRequest request, HttpServletResponse httpServletResponse) {

        return new ModelAndView("tell", "fortune", this.fortuneService.tellFortune())
    }
}</pre><pre class="programlisting">&lt;lang:groovy id="fortune"
             refresh-check-delay="3000"
             script-source="/WEB-INF/groovy/FortuneController.groovy"&gt;
    &lt;lang:property name="fortuneService" ref="fortuneService"/&gt;
&lt;/lang:groovy&gt;
</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamic-language-scenarios-validators"></a>24.4.2.&nbsp;Scripted Validators</h3></div></div><div></div></div><p>
        Another area of application development with Spring that may benefit
        from the flexibility afforded by dynamic-language-backed beans is that of
        validation. It <span class="emphasis"><em>may</em></span> be easier to express complex validation
        logic using a loosely typed dynamic language (that may also have support
        for inline regular expressions) as opposed to regular Java.
      </p><p>
        Again, developing validators as dynamic-language-backed beans allows you to change
        validation logic by simply editing and saving a simple text file; any such
        changes will (depending on the configuration) automatically be reflected
        in the execution of a running application and would not require the restart
        of an application.
      </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>
          Please note that in order to effect the automatic 'pickup' of any changes
          to dynamic-language-backed beans, you will have had to enable the
          'refreshable beans' feature. See the section entitled
          <a href="#dynamic-language-refreshable-beans" title="24.3.1.2.&nbsp;Refreshable beans">Section&nbsp;24.3.1.2, &#8220;Refreshable beans&#8221;</a> for a full and
          detailed treatment of this feature.
        </p></td></tr></table></div><p>
        Find below an example of a Spring
        <tt class="interfacename">org.springframework.validation.Validator</tt>
        implemented using the Groovy dynamic language. (See the section entitled
        <a href="#validator" title="5.2.&nbsp;Validation using Spring's Validator interface">Section&nbsp;5.2, &#8220;Validation using Spring's Validator interface&#8221;</a> for a discussion of the
        <tt class="interfacename">Validator</tt> interface.)
      </p><pre class="programlisting">import org.springframework.validation.Validator
import org.springframework.validation.Errors
import org.springframework.beans.TestBean

class TestBeanValidator implements Validator {

    boolean supports(Class clazz) {
        return TestBean.class.isAssignableFrom(clazz)
    }
    
    void validate(Object bean, Errors errors) {
        if(bean.name?.trim()?.size() &gt; 0) {
            return
        }
        errors.reject("whitespace", "Cannot be composed wholly of whitespace.")
    }
}</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dynamic-language-final-notes"></a>24.5.&nbsp;Bits and bobs</h2></div></div><div></div></div><p>
      This last section contains some bits and bobs related to the dynamic language
      support.
    </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamic-language-final-notes-aop"></a>24.5.1.&nbsp;AOP - advising scripted beans</h3></div></div><div></div></div><p>
        It is possible to use the Spring AOP framework to advise scripted beans.
        The Spring AOP framework actually is unaware that a bean that is being
        advised might be a scripted bean, so all of the AOP use cases and functionality
        that you may be using or aim to use will work with scripted beans. There is
        just one (small) thing that you need to be aware of when advising scripted
        beans... you cannot use class-based proxies, you must use
        <a href="#aop-proxying" title="6.6.&nbsp;Proxying mechanisms">interface-based proxies</a>.
      </p><p>
        You are of course not just limited to advising scripted beans... you can
        also write aspects themselves in a supported dynamic language and use such
        beans to advise other Spring beans. This really would be an advanced use of
        the dynamic language support though.
      </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="dynamic-language-final-notes-scopes"></a>24.5.2.&nbsp;Scoping</h3></div></div><div></div></div><p>
        In case it is not immediately obvious, scripted beans can of course be scoped
        just like any other bean. The <tt class="literal">scope</tt> attribute on the
        various <tt class="literal">&lt;lang:language/&gt;</tt> elements allows you to
        control the scope of the underlying scripted bean, just as it does with a
        regular bean. (The default scope is
        <a href="#beans-factory-scopes-singleton" title="3.4.1.&nbsp;The singleton scope">singleton</a>, just as it
        is with 'regular' beans.)
      </p><p>
        Find below an example of using the <tt class="literal">scope</tt> attribute
        to define a Groovy bean scoped as a
        <a href="#beans-factory-scopes-prototype" title="3.4.2.&nbsp;The prototype scope">prototype</a>.
      </p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:lang="http://www.springframework.org/schema/lang"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-2.5.xsd"&gt;

    &lt;lang:groovy id="messenger" script-source="classpath:Messenger.groovy" <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>scope="prototype"</b></span></span></i>&gt;
        &lt;lang:property name="message" value="I Can Do The RoboCop" /&gt;
    &lt;/lang:groovy&gt;

    &lt;bean id="bookingService" class="x.y.DefaultBookingService"&gt;
        &lt;property name="messenger" ref="messenger" /&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>
        See the section entitled <a href="#beans-factory-scopes" title="3.4.&nbsp;Bean scopes">Section&nbsp;3.4, &#8220;Bean scopes&#8221;</a> in <a href="#beans" title="Chapter&nbsp;3.&nbsp;The IoC container">Chapter&nbsp;3, <i>The IoC container</i></a>
        for a fuller discussion of the scoping support in the Spring Framework.
      </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="dynamic-language-resources"></a>24.6.&nbsp;Further Resources</h2></div></div><div></div></div><p>
      Find below links to further resources about the various dynamic languages described
      in this chapter.
    </p><div class="itemizedlist"><ul type="disc"><li><p>The <a href="http://jruby.codehaus.org/" target="_top">JRuby</a> homepage</p></li><li><p>The <a href="http://groovy.codehaus.org/" target="_top">Groovy</a> homepage</p></li><li><p>The <a href="http://www.beanshell.org/" target="_top">BeanShell</a> homepage</p></li></ul></div><p>
      Some of the more active members of the Spring community have also added support for
      a number of additional dynamic languages above and beyond the ones covered in this
      chapter. While it is possible that such third party contributions may be added to the
      list of languages supported by the main Spring distribution, your best bet for seeing
      if your favourite scripting language is supported is the
      <a href="https://springmodules.dev.java.net/" target="_top">Spring Modules project</a>.
    </p></div></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="metadata"></a>Chapter&nbsp;25.&nbsp;Annotations and Source Level Metadata Support</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metadata-introduction"></a>25.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Source-level metadata is the addition of <span class="emphasis"><em>attributes</em></span> or
		<span class="emphasis"><em>annotations</em></span> to program elements - usually, classes
		and/or methods.</p><p>For example, we might add metadata to a class as follows:</p><pre class="programlisting">/**
 * Normal comments here
 * @@org.springframework.transaction.interceptor.DefaultTransactionAttribute()
 */
public class PetStoreImpl implements PetStoreFacade, OrderService {</pre><p>We could add metadata to a method as follows:</p><pre class="programlisting">/**
 * Normal comments here
 * @@org.springframework.transaction.interceptor.RuleBasedTransactionAttribute()
 * @@org.springframework.transaction.interceptor.RollbackRuleAttribute(Exception.class)
 * @@org.springframework.transaction.interceptor.NoRollbackRuleAttribute("ServletException")
 */
public void echoException(Exception ex) throws Exception {
    ....
}</pre><p>Both of these examples use Jakarta Commons Attributes syntax.</p><p>
			Source-level metadata was introduced to the mainstream by XDoclet
			(in the Java world) and by the release of Microsoft's .NET platform, which
			uses source-level attributes to control transactions, pooling and other
			behavior.
		</p><p>
			The value in this approach has been recognized in the J2EE
			community. For example, it's much less verbose than the traditional XML
			deployment descriptors used exclusively by EJB. While it is desirable to
			externalize some things from program source code, some important
			enterprise settings - notably transaction characteristics - arguably belong
			in program source. Contrary to the assumptions of the EJB spec, it seldom
			makes sense to modify the transactional characteristics of a method
			(although parameters like transaction timeouts might change!).
		</p><p>
			Although metadata attributes are typically used mainly by framework
			infrastructure to describe the services application classes require, it
			should also be possible for metadata attributes to be queried at runtime.
			This is a key distinction from solutions such as XDoclet, which
			view metadata primarily as a way of generating code such as EJB artefacts.
		</p><p>
			There are a number of solutions in this space, including:
		</p><div class="itemizedlist"><ul type="disc"><li><p><span class="bold"><b>Standard Java Annotations</b></span>: the
                standard Java metadata implementation (developed as JSR-175 and available
                in Java 5). Spring has specific Java 5 annotations for transactional
                demarcation, JMX, and aspects (to be precise they are AspectJ annotations).
                However, since Spring supports Java 1.4 as well, a solution for said
                JVM versions is needed too. Spring metadata support provides such a
                solution.</p></li><li><p><span class="bold"><b>XDoclet</b></span>: well-established
                solution, primarily intended for code generation.</p></li><li><p>Various <span class="bold"><b>open source attribute
                implementations</b></span>, for Java 1.4, of which Commons
                Attributes is the most complete implementation. All these require
                a special pre- or post-compilation step.</p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metadata-spring"></a>25.2.&nbsp;Spring's metadata support</h2></div></div><div></div></div><p>In keeping with its provision of abstractions over important
		concepts, Spring provides a facade to metadata implementations, in the
		form of the <tt class="interfacename">org.springframework.metadata.Attributes</tt>
		interface. Such a facade adds value for several reasons:</p><div class="itemizedlist"><ul type="disc"><li><p>Even though Java 5 provides metadata support at language level, there will
                still be value in providing such an abstraction:
				</p><div class="itemizedlist"><ul type="circle"><li><p>Java 5 metadata is static. It is associated with a class
						at compile time, and cannot be changed in a deployed
						environment (annotation state can actually be changed
						at runtime using reflection, but doing so would really be
						a bad practice). There is a need for hierarchical metadata,
						providing the ability to override certain attribute values in
						deployment - for example, in an XML file.</p></li><li><p>Java 5 metadata is returned through the Java reflection
						API. This makes it impossible to mock during test time. Spring
						provides a simple interface to allow this.</p></li><li><p>There will be a need for metadata support in 1.3 and 1.4
						applications for at least two years. Spring aims to provide
						working solutions <span class="emphasis"><em>now</em></span>; forcing the use of
						Java 5 is not an option in such an important area.</p></li></ul></div></li><li><p>Current metadata APIs, such as Commons Attributes (used by
				Spring 1.0-1.2) are hard to test. Spring provides a simple metadata
				interface that is much easier to mock.</p></li></ul></div><p>The Spring <tt class="interfacename">Attributes</tt> interface looks like this:</p><pre class="programlisting">public interface Attributes {

    Collection getAttributes(Class targetClass);

    Collection getAttributes(Class targetClass, Class filter);

    Collection getAttributes(Method targetMethod);

    Collection getAttributes(Method targetMethod, Class filter);

    Collection getAttributes(Field targetField);

    Collection getAttributes(Field targetField, Class filter);
}</pre><p>
			This is a lowest common denominator interface. JSR-175 offers more
			capabilities than this, such as attributes on method arguments.
		</p><p>
			Note that this interface offers <tt class="classname">Object</tt>
			attributes, like .NET. This distinguishes it from attribute systems such
			as that of Nanning Aspects, which offer only <tt class="classname">String</tt>
			attributes. There is a significant advantage in supporting
			<tt class="classname">Object</tt> attributes, namely that it enables
			attributes to participate in class hierarchies and allows such
			attributes to react intelligently to their configuration parameters.
		</p><p>
			With most attribute providers, attribute classes are configured
			via constructor arguments or JavaBean properties. Commons Attributes
			supports both.
		</p><p>As with all Spring abstraction APIs, <tt class="interfacename">Attributes</tt>
		is an interface. This makes it easy to mock attribute implementations for unit tests.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metadata-annotations"></a>25.3.&nbsp;Annotations</h2></div></div><div></div></div><p>
			The Spring Framework ships with a number of custom Java 5+ annotations.
		</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="metadata-annotations-required"></a>25.3.1.&nbsp;<tt class="interfacename">@Required</tt></h3></div></div><div></div></div><p>The <tt class="interfacename">@Required</tt> annotation in the
			<tt class="literal">org.springframework.beans.factory.annotation</tt>
			package can be used to <span class="emphasis"><em>mark</em></span> a property as
			being <span class="emphasis"><em>'required-to-be-set'</em></span> (i.e. an
			annotated (setter) method of a class must be configured to be
			dependency injected with a value), else an
			<tt class="classname">Exception</tt> will be thrown by the container
			at runtime.</p><p>The best way to illustrate the usage of this annotation is to
			show an example:</p><pre class="programlisting">public class SimpleMovieLister {

    <i class="lineannotation"><span class="lineannotation">// the <tt class="classname">SimpleMovieLister</tt> has a dependency on the <tt class="interfacename">MovieFinder</tt></span></i>
    private MovieFinder movieFinder;

    <i class="lineannotation"><span class="lineannotation">// a setter method so that the Spring container can 'inject' a <tt class="interfacename">MovieFinder</tt></span></i>
    @Required
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }
    
    <i class="lineannotation"><span class="lineannotation">// business logic that actually 'uses' the injected <tt class="interfacename">MovieFinder</tt> is omitted...</span></i>
}</pre><p>
				Hopefully the above class definition reads easy on the eye.
				Any and all <tt class="interfacename">BeanDefinitions</tt> for the
				<tt class="classname">SimpleMovieLister</tt> class must be provided
				with a value.
			</p><p>
				Let's look at an example of some XML configuration that will
				<span class="bold"><b>not</b></span> pass validation.
			</p><pre class="programlisting">&lt;bean id="movieLister" class="x.y.SimpleMovieLister"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- whoops, no MovieFinder is set (and this property is <tt class="interfacename">@Required</tt>) --&gt;</span></i>
&lt;/bean&gt;</pre><p>
				At runtime the following message will be generated by the Spring container
				(the rest of the stack trace has been truncated).
			</p><pre class="programlisting">Exception in thread "main" java.lang.IllegalArgumentException:
    Property 'movieFinder' is required for bean 'movieLister'.</pre><p>
				There is one last little (small, tiny) piece of Spring configuration
				that is required to actually <span class="emphasis"><em>'switch on'</em></span> this
				behavior. Simply annotating the <span class="emphasis"><em>'setter'</em></span> properties
				of your classes is not enough to get this behavior. You need
				to enable a component that is aware of the <tt class="interfacename">@Required</tt>
				annotation and that can process it appropriately.
			</p><p>
				This component is the <tt class="classname">RequiredAnnotationBeanPostProcessor</tt> class.
				This is a special <tt class="interfacename">BeanPostProcessor</tt>
				implementation that is <tt class="interfacename">@Required</tt>-aware
				and actually provides the <span class="emphasis"><em>'blow up if this required property
				has not been set'</em></span> logic. It is <span class="emphasis"><em>very</em></span> easy
				to configure; simply drop the following bean definition into your Spring
				XML configuration.
			</p><pre class="programlisting">&lt;bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"/&gt;</pre><p>
				Finally, one can configure an instance of the
				<tt class="classname">RequiredAnnotationBeanPostProcessor</tt> class to look
				for <span class="emphasis"><em>another</em></span> <tt class="interfacename">Annotation</tt> type.
				This is great if you already have your own
				<tt class="interfacename">@Required</tt>-style annotation. Simply plug it into
				the definition of a <tt class="classname">RequiredAnnotationBeanPostProcessor</tt> and
				you are good to go. 
			</p><p>
				By way of an example, let's suppose you (or your organization / team) have
				defined an attribute called @ <tt class="interfacename">Mandatory</tt>.
				You can make a <tt class="classname">RequiredAnnotationBeanPostProcessor</tt>
				instance <tt class="interfacename">@Mandatory</tt>-aware like so:
			</p><pre class="programlisting">&lt;bean class="org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor"&gt;
    &lt;property name="requiredAnnotationType" value="your.company.package.Mandatory"/&gt;
&lt;/bean&gt;</pre><p>
				Here is the source code for the <tt class="interfacename">@Mandatory</tt>
				annotation. You will need to ensure that your custom annotation type
				is itself annotated with appropriate annotations for its target
				and runtime retention policy.
			</p><pre class="programlisting">package your.company.package;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Mandatory {
}</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="metadata-annotations-other"></a>25.3.2.&nbsp;Other @Annotations in Spring</h3></div></div><div></div></div><p>
				Annotations are also used in a number of other places throughout Spring.
				Rather than being described here, these annotations are described in that
				section or chapter of the reference documentation to which they are most
				relevant.
			</p><div class="itemizedlist"><ul type="disc"><li><p><a href="#transaction-declarative-annotations" title="9.5.6.&nbsp;Using @Transactional">Section&nbsp;9.5.6, &#8220;Using @Transactional&#8221;</a></p></li><li><p><a href="#aop-atconfigurable" title="6.8.1.&nbsp;Using AspectJ to dependency inject domain objects with&#xA;      Spring">Section&nbsp;6.8.1, &#8220;Using AspectJ to dependency inject domain objects with
      Spring&#8221;</a></p></li><li><p><a href="#aop-ataspectj" title="6.2.&nbsp;@AspectJ support">Section&nbsp;6.2, &#8220;@AspectJ support&#8221;</a></p></li><li><p><a href="#beans-annotation-config" title="3.11.&nbsp;Annotation-based configuration">Section&nbsp;3.11, &#8220;Annotation-based configuration&#8221;</a></p></li><li><p><a href="#beans-classpath-scanning" title="3.12.&nbsp;Classpath scanning for managed components">Section&nbsp;3.12, &#8220;Classpath scanning for managed components&#8221;</a></p></li></ul></div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metadata-commons"></a>25.4.&nbsp;Integration with Jakarta Commons Attributes</h2></div></div><div></div></div><p>
			Presently Spring supports only Jakarta Commons Attributes out of the
			box, although it is easy to provide implementations of the
			<tt class="interfacename">org.springframework.metadata.Attributes</tt> interface for
			other metadata providers.
		</p><p>
			<span class="bold"><b>Commons Attributes 2.2</b></span>
			(<a href="http://jakarta.apache.org/commons/attributes/" target="_top">http://jakarta.apache.org/commons/attributes/</a>)
			is a capable attributes solution. It supports attribute configuration via
			constructor arguments and JavaBean properties, which offers better
			self-documentation in attribute definitions. (Support for JavaBean
			properties was added at the request of the Spring team.)
		</p><p>
			We've already seen two examples of Commons Attributes attributes
			definitions. In general, we will need to express:
		</p><div class="itemizedlist"><ul type="disc"><li><p>
					<span class="emphasis"><em>The name of the attribute class</em></span>. This can
					be a fully qualified name (FQN), as shown above. If the relevant attribute class has already
					been imported, the FQN isn't required. It's also possible to specify
					"attribute packages" in attribute compiler configuration.
				</p></li><li><p>
					<span class="emphasis"><em>Any necessary parameterization.</em></span> This is done via
					constructor arguments or JavaBean properties.
				</p></li></ul></div><p>Bean properties look as follows:</p><pre class="programlisting">/**
 * @@MyAttribute(myBooleanJavaBeanProperty=true)
 */</pre><p>
			It's possible to combine constructor arguments and JavaBean
			properties (as in Spring IoC).
		</p><p>
			Because, unlike Java 1.5 attributes, Commons Attributes is not
			integrated with the Java language, it is necessary to run a special
			<span class="emphasis"><em>attribute compilation</em></span> step as part of the build
			process.
		</p><p>
			To run Commons Attributes as part of the build process, you will
			need to do the following:
		</p><p>
			1. Copy the necessary library jars to
			<tt class="literal">$ANT_HOME/lib</tt>. Four Jars are required, and all are
			distributed with Spring:
		</p><div class="itemizedlist"><ul type="disc"><li><p>the Commons Attributes compiler jar and API jar</p></li><li><p>xJavadoc.jar from XDoclet</p></li><li><p>commons-collections.jar from Jakarta Commons</p></li></ul></div><p>
			2. Import the Commons Attributes ant tasks into your project build
			script, as follows:
		</p><pre class="programlisting">&lt;taskdef resource="org/apache/commons/attributes/anttasks.properties"/&gt;</pre><p>
			3. Next, define an attribute compilation task, which will use the
			Commons Attributes attribute-compiler task to "compile" the attributes in
			the source. This process results in the generation of additional sources,
			to a location specified by the <tt class="literal">destdir</tt> attribute. Here we show the use of
			a temporary directory for storing the generated files:
		</p><pre class="programlisting">&lt;target name="compileAttributes"&gt;

  &lt;attribute-compiler destdir="${commons.attributes.tempdir}"&gt;
    &lt;fileset dir="${src.dir}" includes="**/*.java"/&gt;
  &lt;/attribute-compiler&gt;

&lt;/target&gt;</pre><p>
			The compile target that runs javac over the sources should depend on
			this attribute compilation task, and must also compile the generated
			sources, which we output to our destination temporary directory. If there
			are syntax errors in your attribute definitions, they will normally be
			caught by the attribute compiler. However, if the attribute definitions
			are syntactically plausible, but specify invalid types or class names, the
			compilation of the generated attribute classes may fail. In this case, you
			can look at the generated classes to establish the cause of the
			problem.
		</p><i><span class="remark">
			Commons Attributes also provides Maven support. Please refer to
			Commons Attributes documentation for further information.
		</span></i><p>
			While this attribute compilation process may look complex, in fact
			it's a one-off cost. Once set up, attribute compilation is incremental, so
			it doesn't usually noticeably slow the build process. And once the
			compilation process is set up, you may find that use of attributes as
			described in this chapter can save you a lot of time in other
			areas.
		</p><p>
			If you require attribute indexing support (only currently required
			by Spring for attribute-targeted web controllers, discussed below), you
			will need an additional step, which must be performed on a jar file of
			your compiled classes. In this additional step, Commons Attributes will
			create an index of all the attributes defined on your sources, for
			efficient lookup at runtime. The step looks like this:
		</p><pre class="programlisting">&lt;attribute-indexer jarFile="myCompiledSources.jar"&gt;
    
  &lt;classpath refid="master-classpath"/&gt;

&lt;/attribute-indexer&gt;</pre><i><span class="remark">
			See the <tt class="literal">/attributes</tt> directory of the Spring JPetStore sample
			application for an example of this build process. You can take the build
			script it contains and modify it for your own projects.
		</span></i><p>
			If your unit tests depend on attributes, try to express the
			dependency on the Spring Attributes abstraction, rather than Commons
			Attributes. Not only is this more portable - for example, your tests will
			still work if you switch to Java 1.5 attributes in future - it simplifies
			testing. Also, Commons Attributes is a static API, while Spring provides a
			metadata interface that you can easily mock.
		</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="metadata-uses"></a>25.5.&nbsp;Metadata and Spring AOP autoproxying</h2></div></div><div></div></div><p>
			The most important uses of metadata attributes are in conjunction
			with Spring AOP. This provides a .NET-like programming model, where
			declarative services are automatically provided to application objects
			that declare metadata attributes. Such metadata attributes can be
			supported out of the box by the framework, as in the case of declarative
			transaction management, or can be custom.
		</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="metadata-fundamentals"></a>25.5.1.&nbsp;Fundamentals</h3></div></div><div></div></div><p>
				This builds on the Spring AOP autoproxy functionality.
				Configuration might look like this:
			</p><pre class="programlisting">&lt;bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"/&gt;

&lt;bean class="org.springframework.transaction.interceptor.TransactionAttributeSourceAdvisor"&gt;
  &lt;property name="transactionInterceptor" ref="txInterceptor" /&gt;
&lt;/bean&gt;

&lt;bean id="txInterceptor" class="org.springframework.transaction.interceptor.TransactionInterceptor"&gt;
  &lt;property name="transactionManager" ref="transactionManager" /&gt;
  &lt;property name="transactionAttributeSource"&gt;
    &lt;bean class="org.springframework.transaction.interceptor.AttributesTransactionAttributeSource"&gt;
      &lt;property name="attributes" ref="attributes" /&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

&lt;bean id="attributes" class="org.springframework.metadata.commons.CommonsAttributes" /&gt;</pre><p>
				The basic concepts here should be familiar from the discussion of
				autoproxying in the AOP chapter.
			</p><p>
				The most important bean definitions are the auto-proxy creator
				and the advisor. Note that the actual bean names are not important;
				what matters is their class.
			</p><p>
				The bean definition of class
				<tt class="classname">org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator</tt>
				will automatically advise ("auto-proxy") all bean instances in the
				current factory based on matching advisor implementations. This class
				knows nothing about attributes, but relies on advisors' pointcuts
				matching. The pointcuts, however, do know about attributes.
			</p><p>
				Thus we simply need an AOP advisor that will provide declarative
				transaction management based on attributes.
			</p><p>
				It is possible to add arbitrary custom advisor implementations as
				well, and they will also be evaluated and applied automatically. (You
				can use advisors whose pointcuts match on criteria besides attributes in
				the same autoproxy configuration, if necessary.)
			</p><p>
				Finally, the <tt class="literal">attributes</tt> bean is the Commons
				Attributes Attributes implementation. Replace it with another
				implementation of the
				<tt class="interfacename">org.springframework.metadata.Attributes</tt>
				interface to source attributes from a different source.
			</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="metadata-tx"></a>25.5.2.&nbsp;Declarative transaction management</h3></div></div><div></div></div><p>
				The most common use of source-level attributes is to provide
				declarative transaction management. Once the bean definitions
				shown above are in place, you can define any number of application
				objects requiring declarative transactions. Only those classes or
				methods with transaction attributes will be given transaction advice.
				You need to do nothing except define the required transaction
				attributes.
			</p><p>Please note that you can specify transaction attributes at either class
			or method level. Class-level attributes, if specified, will be "inherited"
			by all methods whereas method attributes will wholly override any
			class-level attributes.</p></div></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="xsd-config"></a>Appendix&nbsp;A.&nbsp;XML Schema-based configuration</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xsd-config-introduction"></a>A.1.&nbsp;Introduction</h2></div></div><div></div></div><p>This appendix details the XML Schema-based configuration introduced in Spring 2.0.</p><div class="sidebar"><p class="title"><b>DTD support?</b></p><p>Authoring Spring configuration files using the older DTD style
            is still fully supported.</p><p>Nothing will break if you forego the use of the new XML Schema-based
            approach to authoring Spring XML configuration files. All that you lose
            out on is the opportunity to have more succinct and clearer configuration.
            Regardless of whether the XML configuration is DTD- or Schema-based, in the end
            it all boils down to the same object model in the container (namely one or
            more <tt class="interfacename">BeanDefinition</tt> instances).</p></div><p>The central motivation for moving to XML Schema based configuration files was
        to make Spring XML configuration easier. The <span class="emphasis"><em>'classic'</em></span>
        <tt class="literal">&lt;bean/&gt;</tt>-based approach is good, but its generic-nature comes
        with a price in terms of configuration overhead.</p><p>From the Spring IoC containers point-of-view, <span class="emphasis"><em>everything</em></span>
        is a bean. That's great news for the Spring IoC container, because if everything is
        a bean then everything can be treated in the exact same fashion. The same, however,
        is not true from a developer's point-of-view. The objects defined in a Spring
        XML configuration file are not all generic, vanilla beans. Usually, each bean requires
        some degree of specific configuration.</p><p>Spring 2.0's new XML Schema-based configuration addresses this issue.
        The <tt class="literal">&lt;bean/&gt;</tt> element is still present, and if you
        wanted to, you could continue to write the <span class="emphasis"><em>exact same</em></span>
        style of Spring XML configuration using only <tt class="literal">&lt;bean/&gt;</tt>
        elements. The new XML Schema-based configuration does, however, make
        Spring XML configuration files substantially clearer to read. In addition, it allows
        you to express the intent of a bean definition.</p><p>The key thing to remember is that the new custom tags work best for infrastructure
        or integration beans: for example, AOP, collections, transactions, integration with
        3rd-party frameworks such as Mule, etc., while the existing bean tags are best suited to
        application-specific beans, such as DAOs, service layer objects, validators, etc.</p><p>The examples included below will hopefully convince you that the inclusion
        of XML Schema support in Spring 2.0 was a good idea. The reception in the community
        has been encouraging; also, please note the fact that this new configuration mechanism
        is totally customisable and extensible. This means you can write your own domain-specific
        configuration tags that would better represent your application's domain; the process
        involved in doing so is covered in the appendix entitled <a href="#extensible-xml" title="Appendix&nbsp;B.&nbsp;Extensible XML authoring">Appendix&nbsp;B, <i>Extensible XML authoring</i></a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xsd-config-body"></a>A.2.&nbsp;XML Schema-based configuration</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd-config-body-referencing"></a>A.2.1.&nbsp;Referencing the schemas</h3></div></div><div></div></div><p>To switch over from the DTD-style to the new XML Schema-style, you need
            to make the following change.</p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
    "http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;

&lt;beans&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="literal">&lt;bean/&gt;</tt> definitions here --&gt;</span></i>

&lt;/beans&gt;</pre><p>The equivalent file in the XML Schema-style would be...</p><pre class="programlisting">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="literal">&lt;bean/&gt;</tt> definitions here --&gt;</span></i>

&lt;/beans&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The <tt class="literal">'xsi:schemaLocation'</tt> fragment is not actually required,
                but can be included to reference a local copy of a schema (which can be useful
                during development).</p></td></tr></table></div><p>The above Spring XML configuration fragment is boilerplate that you can copy and paste
            (!) and then plug <tt class="literal">&lt;bean/&gt;</tt> definitions into like you have always
            done. However, the entire point of switching over is to
            take advantage of the new Spring 2.0 XML tags since they make configuration easier. The
            section entitled <a href="#xsd-config-body-schemas-util" title="A.2.2.&nbsp;The util schema">Section&nbsp;A.2.2, &#8220;The util schema&#8221;</a> demonstrates how you can
            start immediately by using some of the more common utility tags.</p></div><p>The rest of this chapter is devoted to showing examples of the new Spring XML Schema
        based configuration, with at least one example for every new tag. The format follows
        a before and after style, with a <span class="emphasis"><em>before</em></span> snippet of XML showing
        the old (but still 100% legal and supported) style, followed immediately
        by an <span class="emphasis"><em>after</em></span> example showing the equivalent in the new XML Schema-based
        style.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd-config-body-schemas-util"></a>A.2.2.&nbsp;The <tt class="literal">util</tt> schema</h3></div></div><div></div></div><p>First up is coverage of the <tt class="literal">util</tt> tags. As the name
            implies, the <tt class="literal">util</tt> tags deal with common, <span class="emphasis"><em>utility</em></span>
            configuration issues, such as configuring collections, referencing constants,
            and suchlike.</p><p>To use the tags in the <tt class="literal">util</tt> schema, you need to have
            the following preamble at the top of your Spring XML configuration file;
            the emboldened text in the snippet below references the correct schema so that
            the tags in the <tt class="literal">util</tt> namespace are available to you.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       <span class="bold"><b>xmlns:util="http://www.springframework.org/schema/util"</b></span>
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
<span class="bold"><b>http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.5.xsd"</b></span>&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="literal">&lt;bean/&gt;</tt> definitions here --&gt;</span></i>

&lt;/beans&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-util-constant"></a>A.2.2.1.&nbsp;<tt class="literal">&lt;util:constant/&gt;</tt></h4></div></div><div></div></div><p>Before...</p><pre class="programlisting">&lt;bean id="..." class="..."&gt;
  &lt;property name="isolation"&gt;
    &lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
    class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" /&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The above configuration uses a Spring <tt class="interfacename">FactoryBean</tt>
                implementation, the <tt class="classname">FieldRetrievingFactoryBean</tt>, to
                set the value of the <tt class="literal">'isolation'</tt> property on a bean
                to the value of the <tt class="literal">'java.sql.Connection.TRANSACTION_SERIALIZABLE'</tt>
                constant. This is all well and good, but it is a tad verbose and (unneccessarily)
                exposes Spring's internal plumbing to the end user.
                </p><p>The following XML Schema-based version is more concise
                and clearly expresses the developer's intent (<span class="emphasis"><em>'inject this constant
                value'</em></span>), and it just reads better.
                </p><pre class="programlisting">&lt;bean id="..." class="..."&gt;
  &lt;property name="isolation"&gt;
    &lt;util:constant static-field="java.sql.Connection.TRANSACTION_SERIALIZABLE"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xsd-config-body-schemas-util-frfb"></a>A.2.2.1.1.&nbsp;Setting a bean property or constructor arg from a field value</h5></div></div><div></div></div><p>
			            <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html" target="_top"><tt class="classname">FieldRetrievingFactoryBean</tt></a>
			            is a <tt class="interfacename">FactoryBean</tt> which retrieves a
			            <tt class="literal">static</tt> or non-static field value. It is typically
			            used for retrieving <tt class="literal">public</tt> <tt class="literal">static</tt>
			            <tt class="literal">final</tt> constants, which may then be used to set a
			            property value or constructor arg for another bean.
		            </p><p>
			            Find below an example which shows how a <tt class="literal">static</tt> field is exposed, by
			            using the <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html#setStaticField(java.lang.String)" target="_top"><tt class="literal">staticField</tt></a>
			            property:
		            </p><pre class="programlisting">&lt;bean id="myField"
        class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"&gt;
  &lt;property name="staticField" value="java.sql.Connection.TRANSACTION_SERIALIZABLE"/&gt;
&lt;/bean&gt;</pre><p>There is also a convenience usage form where the <tt class="literal">static</tt>
                    field is specified as the bean name:</p><pre class="programlisting">&lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
    class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean"/&gt;</pre><p>
			            This does mean that there is no longer any choice in what the bean id is (so
			            any other bean that refers to it will also have to use this longer name),
			            but this form is very concise to define, and very convenient to use as an
			            inner bean since the id doesn't have to be specified for the bean
			            reference:
		            </p><pre class="programlisting">&lt;bean id="..." class="..."&gt;
  &lt;property name="isolation"&gt;
    &lt;bean id="java.sql.Connection.TRANSACTION_SERIALIZABLE"
          class="org.springframework.beans.factory.config.FieldRetrievingFactoryBean" /&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>
			            It is also possible to access a non-static (instance) field of another bean,
			            as described in the API documentation for the 
			            <a href="http://static.springframework.org/spring/docs/2.5.x/api/org/springframework/beans/factory/config/FieldRetrievingFactoryBean.html" target="_top"><tt class="classname">FieldRetrievingFactoryBean</tt></a>
			            class.
		            </p><p>
			            Injecting enum values into beans as either property or constructor arguments is very
			            easy to do in Spring, in that you don't actually have to <span class="emphasis"><em>do</em></span>
			            anything or know anything about the Spring internals (or even about classes such
			            as the <tt class="classname">FieldRetrievingFactoryBean</tt>). Let's look at an example
			            to see how easy injecting an enum value is; consider this JDK 5 enum:
		            </p><pre class="programlisting">package javax.persistence;
     
public enum PersistenceContextType {

    TRANSACTION,
    EXTENDED

}</pre><p>Now consider a setter of type <tt class="classname">PersistenceContextType</tt>:</p><pre class="programlisting">package example;

public class Client {

    private PersistenceContextType persistenceContextType;

    public void setPersistenceContextType(PersistenceContextType type) { 
        this.persistenceContextType = type;
    }
}</pre><p>.. and the corresponding bean definition:</p><pre class="programlisting">&lt;bean class="example.Client"&gt;
    &lt;property name="persistenceContextType" value="TRANSACTION" /&gt;
&lt;/bean&gt;</pre><p>
			            This works for classic type-safe emulated enums (on JDK 1.4 and JDK 1.3) as well;
			            Spring will automatically attempt to match the string property value to a constant
			            on the enum class.
		            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-util-property-path"></a>A.2.2.2.&nbsp;<tt class="literal">&lt;util:property-path/&gt;</tt></h4></div></div><div></div></div><p>Before...</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- target bean to be referenced by name --&gt;</span></i>
&lt;bean id="testBean" class="org.springframework.beans.TestBean" scope="prototype"&gt;
  &lt;property name="age" value="10"/&gt;
  &lt;property name="spouse"&gt;
    &lt;bean class="org.springframework.beans.TestBean"&gt;
      &lt;property name="age" value="11"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- will result in 10, which is the value of property 'age' of bean 'testBean' --&gt;</span></i>
&lt;bean id="testBean.age" class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;</pre><p>The above configuration uses a Spring <tt class="interfacename">FactoryBean</tt>
                implementation, the <tt class="classname">PropertyPathFactoryBean</tt>, to
                create a bean (of type <tt class="classname">int</tt>) called
                <tt class="literal">'testBean.age'</tt> that has a value equal to the <tt class="literal">'age'</tt>
                property of the <tt class="literal">'testBean'</tt> bean.
                </p><p>After...</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- target bean to be referenced by name --&gt;</span></i>
&lt;bean id="testBean" class="org.springframework.beans.TestBean" scope="prototype"&gt;
  &lt;property name="age" value="10"/&gt;
  &lt;property name="spouse"&gt;
    &lt;bean class="org.springframework.beans.TestBean"&gt;
      &lt;property name="age" value="11"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- will result in 10, which is the value of property 'age' of bean 'testBean' --&gt;</span></i>
&lt;util:property-path id="name" path="testBean.age"/&gt;</pre><p>The value of the <tt class="literal">'path'</tt> attribute of the
                <tt class="literal">&lt;property-path/&gt;</tt> tag follows the form <tt class="literal">'beanName.beanProperty'</tt>.</p><div class="section" lang="en"><div class="titlepage"><div><div><h5 class="title"><a name="xsd-config-body-schemas-util-property-path-dependency"></a>A.2.2.2.1.&nbsp;Using <tt class="literal">&lt;util:property-path/&gt;</tt> to set a bean property or constructor-argument</h5></div></div><div></div></div><p><tt class="classname">PropertyPathFactoryBean</tt> is a
			        <tt class="interfacename">FactoryBean</tt> that evaluates a property path on a given
			        target object. The target object can be specified directly or via a bean
			        name. This value may then be used in another bean definition as a property
			        value or constructor argument.</p><p>Here's an example where a path is used against another bean, by name:</p><pre class="programlisting">// target bean to be referenced by name
&lt;bean id="person" class="org.springframework.beans.TestBean" scope="prototype"&gt;
  &lt;property name="age" value="10"/&gt;
  &lt;property name="spouse"&gt;
    &lt;bean class="org.springframework.beans.TestBean"&gt;
      &lt;property name="age" value="11"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
&lt;/bean&gt;

<i class="lineannotation"><span class="lineannotation">// will result in 11, which is the value of property 'spouse.age' of bean 'person'</span></i>
&lt;bean id="theAge"
    class="org.springframework.beans.factory.config.PropertyPathFactoryBean"&gt;
  &lt;property name="targetBeanName" value="person"/&gt;
  &lt;property name="propertyPath" value="spouse.age"/&gt;
&lt;/bean&gt;</pre><p>In this example, a path is evaluated against an inner bean:</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- will result in 12, which is the value of property 'age' of the inner bean --&gt;</span></i>
&lt;bean id="theAge"
    class="org.springframework.beans.factory.config.PropertyPathFactoryBean"&gt;
  &lt;property name="targetObject"&gt;
    &lt;bean class="org.springframework.beans.TestBean"&gt;
      &lt;property name="age" value="12"/&gt;
    &lt;/bean&gt;
  &lt;/property&gt;
  &lt;property name="propertyPath" value="age"/&gt;
&lt;/bean&gt;</pre><p>There is also a shortcut form, where the bean name is the property path.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- will result in 10, which is the value of property 'age' of bean 'person' --&gt;</span></i>
&lt;bean id="person.age"
    class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;</pre><p>This form does mean that there is no choice in the name of the bean.
		            Any reference to it will also have to use the same id, which is the path.
		            Of course, if used as an inner bean, there is no need to refer to it at
		            all:</p><pre class="programlisting">&lt;bean id="..." class="..."&gt;
  &lt;property name="age"&gt;
    &lt;bean id="person.age"
        class="org.springframework.beans.factory.config.PropertyPathFactoryBean"/&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The result type may be specifically set in the actual definition.
			        This is not necessary for most use cases, but can be of use for some.
			        Please see the Javadocs for more info on this feature.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-util-properties"></a>A.2.2.3.&nbsp;<tt class="literal">&lt;util:properties/&gt;</tt></h4></div></div><div></div></div><p>Before...</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- creates a <tt class="classname">java.util.Properties</tt> instance with values loaded from the supplied location --&gt;</span></i>
&lt;bean id="jdbcConfiguration" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt;
  &lt;property name="location" value="classpath:com/foo/jdbc-production.properties"/&gt;
&lt;/bean&gt;</pre><p>The above configuration uses a Spring <tt class="interfacename">FactoryBean</tt>
                implementation, the <tt class="classname">PropertiesFactoryBean</tt>, to
                instantiate a <tt class="classname">java.util.Properties</tt> instance with values loaded from
                the supplied <a href="#resources" title="Chapter&nbsp;4.&nbsp;Resources"><tt class="interfacename">Resource</tt></a> location).
                </p><p>After...</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- creates a <tt class="classname">java.util.Properties</tt> instance with values loaded from the supplied location --&gt;</span></i>
&lt;util:properties id="jdbcConfiguration" location="classpath:com/foo/jdbc-production.properties"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-util-list"></a>A.2.2.4.&nbsp;<tt class="literal">&lt;util:list/&gt;</tt></h4></div></div><div></div></div><p>Before...</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- creates a <tt class="classname">java.util.List</tt> instance with values loaded from the supplied <tt class="literal">'sourceList'</tt> --&gt;</span></i>
&lt;bean id="emails" class="org.springframework.beans.factory.config.ListFactoryBean"&gt;
  &lt;property name="sourceList"&gt;
      &lt;list&gt;
        &lt;value&gt;pechorin@hero.org&lt;/value&gt;
        &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
        &lt;value&gt;stavrogin@gov.org&lt;/value&gt;
        &lt;value&gt;porfiry@gov.org&lt;/value&gt;
      &lt;/list&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The above configuration uses a Spring <tt class="interfacename">FactoryBean</tt>
                implementation, the <tt class="classname">ListFactoryBean</tt>, to
                create a <tt class="classname">java.util.List</tt> instance initialized
                with values taken from the supplied <tt class="literal">'sourceList'</tt>.
                </p><p>After...</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- creates a <tt class="classname">java.util.List</tt> instance with values loaded from the supplied <tt class="literal">'sourceList'</tt> --&gt;</span></i>
&lt;util:list id="emails"&gt;
    &lt;value&gt;pechorin@hero.org&lt;/value&gt;
    &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
    &lt;value&gt;stavrogin@gov.org&lt;/value&gt;
    &lt;value&gt;porfiry@gov.org&lt;/value&gt;
&lt;/util:list&gt;</pre><p>You can also explicitly control the exact type of <tt class="interfacename">List</tt>
                that will be instantiated and populated via the use of the <tt class="literal">'list-class'</tt>
                attribute on the <tt class="literal">&lt;util:list/&gt;</tt> element. For example, if we
                really need a <tt class="classname">java.util.LinkedList</tt> to be instantiated, we could
                use the following configuration:</p><pre class="programlisting">&lt;util:list id="emails" list-class="java.util.LinkedList"&gt;
    &lt;value&gt;jackshaftoe@vagabond.org&lt;/value&gt;
    &lt;value&gt;eliza@thinkingmanscrumpet.org&lt;/value&gt;
    &lt;value&gt;vanhoek@pirate.org&lt;/value&gt;
    &lt;value&gt;d'Arcachon@nemesis.org&lt;/value&gt;
&lt;/util:list&gt;</pre><p>If no <tt class="literal">'list-class'</tt> attribute is supplied, a
                <tt class="interfacename">List</tt> implementation will be chosen by the container.</p><p>Finally, you can also control the merging behavior using the
                <tt class="literal">'merge'</tt> attribute of the <tt class="literal">&lt;util:list/&gt;</tt>
                element; collection merging is described in more detail in the section entitled
                <a href="#beans-collection-elements-merging" title="3.3.2.4.1.&nbsp;Collection merging">Section&nbsp;3.3.2.4.1, &#8220;Collection merging&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-util-map"></a>A.2.2.5.&nbsp;<tt class="literal">&lt;util:map/&gt;</tt></h4></div></div><div></div></div><p>Before...</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- creates a <tt class="classname">java.util.Map</tt> instance with values loaded from the supplied <tt class="literal">'sourceMap'</tt> --&gt;</span></i>
&lt;bean id="emails" class="org.springframework.beans.factory.config.MapFactoryBean"&gt;
  &lt;property name="sourceMap"&gt;
      &lt;map&gt;
        &lt;entry key="pechorin" value="pechorin@hero.org"/&gt;
        &lt;entry key="raskolnikov" value="raskolnikov@slums.org"/&gt;
        &lt;entry key="stavrogin" value="stavrogin@gov.org"/&gt;
        &lt;entry key="porfiry" value="porfiry@gov.org"/&gt;
      &lt;/map&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The above configuration uses a Spring <tt class="interfacename">FactoryBean</tt>
                implementation, the <tt class="classname">MapFactoryBean</tt>, to
                create a <tt class="classname">java.util.Map</tt> instance initialized
                with key-value pairs taken from the supplied <tt class="literal">'sourceMap'</tt>.
                </p><p>After...</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- creates a <tt class="classname">java.util.Map</tt> instance with values loaded from the supplied <tt class="literal">'sourceMap'</tt> --&gt;</span></i>
&lt;util:map id="emails"&gt;
    &lt;entry key="pechorin" value="pechorin@hero.org"/&gt;
    &lt;entry key="raskolnikov" value="raskolnikov@slums.org"/&gt;
    &lt;entry key="stavrogin" value="stavrogin@gov.org"/&gt;
    &lt;entry key="porfiry" value="porfiry@gov.org"/&gt;
&lt;/util:map&gt;</pre><p>You can also explicitly control the exact type of <tt class="interfacename">Map</tt>
                that will be instantiated and populated via the use of the <tt class="literal">'map-class'</tt>
                attribute on the <tt class="literal">&lt;util:map/&gt;</tt> element. For example, if we
                really need a <tt class="classname">java.util.TreeMap</tt> to be instantiated, we could
                use the following configuration:</p><pre class="programlisting">&lt;util:map id="emails" map-class="java.util.TreeMap"&gt;
    &lt;entry key="pechorin" value="pechorin@hero.org"/&gt;
    &lt;entry key="raskolnikov" value="raskolnikov@slums.org"/&gt;
    &lt;entry key="stavrogin" value="stavrogin@gov.org"/&gt;
    &lt;entry key="porfiry" value="porfiry@gov.org"/&gt;
&lt;/util:map&gt;</pre><p>If no <tt class="literal">'map-class'</tt> attribute is supplied, a
                <tt class="interfacename">Map</tt> implementation will be chosen by the container.</p><p>Finally, you can also control the merging behavior using the
                <tt class="literal">'merge'</tt> attribute of the <tt class="literal">&lt;util:map/&gt;</tt>
                element; collection merging is described in more detail in the section entitled
                <a href="#beans-collection-elements-merging" title="3.3.2.4.1.&nbsp;Collection merging">Section&nbsp;3.3.2.4.1, &#8220;Collection merging&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-util-set"></a>A.2.2.6.&nbsp;<tt class="literal">&lt;util:set/&gt;</tt></h4></div></div><div></div></div><p>Before...</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- creates a <tt class="classname">java.util.Set</tt> instance with values loaded from the supplied <tt class="literal">'sourceSet'</tt> --&gt;</span></i>
&lt;bean id="emails" class="org.springframework.beans.factory.config.SetFactoryBean"&gt;
  &lt;property name="sourceSet"&gt;
      &lt;set&gt;
        &lt;value&gt;pechorin@hero.org&lt;/value&gt;
        &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
        &lt;value&gt;stavrogin@gov.org&lt;/value&gt;
        &lt;value&gt;porfiry@gov.org&lt;/value&gt;
      &lt;/set&gt;
  &lt;/property&gt;
&lt;/bean&gt;</pre><p>The above configuration uses a Spring <tt class="interfacename">FactoryBean</tt>
                implementation, the <tt class="classname">SetFactoryBean</tt>, to
                create a <tt class="classname">java.util.Set</tt> instance initialized
                with values taken from the supplied <tt class="literal">'sourceSet'</tt>.
                </p><p>After...</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- creates a <tt class="classname">java.util.Set</tt> instance with values loaded from the supplied <tt class="literal">'sourceSet'</tt> --&gt;</span></i>
&lt;util:set id="emails"&gt;
    &lt;value&gt;pechorin@hero.org&lt;/value&gt;
    &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
    &lt;value&gt;stavrogin@gov.org&lt;/value&gt;
    &lt;value&gt;porfiry@gov.org&lt;/value&gt;
&lt;/util:set&gt;</pre><p>You can also explicitly control the exact type of <tt class="interfacename">Set</tt>
                that will be instantiated and populated via the use of the <tt class="literal">'set-class'</tt>
                attribute on the <tt class="literal">&lt;util:set/&gt;</tt> element. For example, if we
                really need a <tt class="classname">java.util.TreeSet</tt> to be instantiated, we could
                use the following configuration:</p><pre class="programlisting">&lt;util:set id="emails" set-class="java.util.TreeSet"&gt;
    &lt;value&gt;pechorin@hero.org&lt;/value&gt;
    &lt;value&gt;raskolnikov@slums.org&lt;/value&gt;
    &lt;value&gt;stavrogin@gov.org&lt;/value&gt;
    &lt;value&gt;porfiry@gov.org&lt;/value&gt;
&lt;/util:set&gt;</pre><p>If no <tt class="literal">'set-class'</tt> attribute is supplied, a
                <tt class="interfacename">Set</tt> implementation will be chosen by the container.</p><p>Finally, you can also control the merging behavior using the
                <tt class="literal">'merge'</tt> attribute of the <tt class="literal">&lt;util:set/&gt;</tt>
                element; collection merging is described in more detail in the section entitled
                <a href="#beans-collection-elements-merging" title="3.3.2.4.1.&nbsp;Collection merging">Section&nbsp;3.3.2.4.1, &#8220;Collection merging&#8221;</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd-config-body-schemas-jee"></a>A.2.3.&nbsp;The <tt class="literal">jee</tt> schema</h3></div></div><div></div></div><p>The <tt class="literal">jee</tt> tags deal with JEE (Java Enterprise Edition)-related
            configuration issues, such as looking up a JNDI object and defining EJB references.</p><p>To use the tags in the <tt class="literal">jee</tt> schema, you need to have
            the following preamble at the top of your Spring XML configuration file;
            the emboldened text in the following snippet references the correct schema so that
            the tags in the <tt class="literal">jee</tt> namespace are available to you.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       <span class="bold"><b>xmlns:jee="http://www.springframework.org/schema/jee"</b></span>
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
<span class="bold"><b>http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-2.5.xsd"</b></span>&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="literal">&lt;bean/&gt;</tt> definitions here --&gt;</span></i>

&lt;/beans&gt;</pre><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-jee-jndi-lookup"></a>A.2.3.1.&nbsp;<tt class="literal">&lt;jee:jndi-lookup/&gt;</tt> (simple)</h4></div></div><div></div></div><p>Before...</p><pre class="programlisting">&lt;bean id="<span class="bold"><b>dataSource</b></span>" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="jdbc/MyDataSource"/&gt;
&lt;/bean&gt;

&lt;bean id="userDao" class="com.foo.JdbcUserDao"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- Spring will do the cast automatically (as usual) --&gt;</span></i>
    &lt;property name="dataSource" ref="<span class="bold"><b>dataSource</b></span>"/&gt;
&lt;/bean&gt;</pre><p>After...</p><pre class="programlisting">&lt;jee:jndi-lookup id="<span class="bold"><b>dataSource</b></span>" jndi-name="jdbc/MyDataSource"/&gt;

&lt;bean id="userDao" class="com.foo.JdbcUserDao"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- Spring will do the cast automatically (as usual) --&gt;</span></i>
    &lt;property name="dataSource" ref="<span class="bold"><b>dataSource</b></span>"/&gt;
&lt;/bean&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-jee-jndi-lookup-environment-single"></a>A.2.3.2.&nbsp;<tt class="literal">&lt;jee:jndi-lookup/&gt;</tt> (with single JNDI environment setting)</h4></div></div><div></div></div><p>Before...</p><pre class="programlisting">&lt;bean id="simple" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="jdbc/MyDataSource"/&gt;
    &lt;property name="jndiEnvironment"&gt;
        &lt;props&gt;
            &lt;prop key="foo"&gt;bar&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>After...</p><pre class="programlisting">&lt;jee:jndi-lookup id="simple" jndi-name="jdbc/MyDataSource"&gt;
    &lt;jee:environment&gt;foo=bar&lt;/jee:environment&gt;
&lt;/jee:jndi-lookup&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-jee-jndi-lookup-evironment-multiple"></a>A.2.3.3.&nbsp;<tt class="literal">&lt;jee:jndi-lookup/&gt;</tt> (with multiple JNDI environment settings)</h4></div></div><div></div></div><p>Before...</p><pre class="programlisting">&lt;bean id="simple" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="jdbc/MyDataSource"/&gt;
    &lt;property name="jndiEnvironment"&gt;
        &lt;props&gt;
            &lt;prop key="foo"&gt;bar&lt;/prop&gt;
            &lt;prop key="ping"&gt;pong&lt;/prop&gt;
        &lt;/props&gt;
    &lt;/property&gt;
&lt;/bean&gt;</pre><p>After...</p><pre class="programlisting">&lt;jee:jndi-lookup id="simple" jndi-name="jdbc/MyDataSource"&gt;
    <i class="lineannotation"><span class="lineannotation">&lt;!-- newline-separated, key-value pairs for the environment (standard <tt class="classname">Properties</tt> format) --&gt;</span></i>
    &lt;jee:environment&gt;
        foo=bar
        ping=pong
    &lt;/jee:environment&gt;
&lt;/jee:jndi-lookup&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-jee-jndi-lookup-complex"></a>A.2.3.4.&nbsp;<tt class="literal">&lt;jee:jndi-lookup/&gt;</tt> (complex)</h4></div></div><div></div></div><p>Before...</p><pre class="programlisting">&lt;bean id="simple" class="org.springframework.jndi.JndiObjectFactoryBean"&gt;
    &lt;property name="jndiName" value="jdbc/MyDataSource"/&gt;
    &lt;property name="cache" value="true"/&gt;
    &lt;property name="resourceRef" value="true"/&gt;
    &lt;property name="lookupOnStartup" value="false"/&gt;
    &lt;property name="expectedType" value="com.myapp.DefaultFoo"/&gt;
    &lt;property name="proxyInterface" value="com.myapp.Foo"/&gt;
&lt;/bean&gt;</pre><p>After...</p><pre class="programlisting">&lt;jee:jndi-lookup id="simple"
             jndi-name="jdbc/MyDataSource"
             cache="true"
             resource-ref="true"
             lookup-on-startup="false"
             expected-type="com.myapp.DefaultFoo"
             proxy-interface="com.myapp.Foo"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-jee-local-slsb"></a>A.2.3.5.&nbsp;<tt class="literal">&lt;jee:local-slsb/&gt;</tt> (simple)</h4></div></div><div></div></div><p>The <tt class="literal">&lt;jee:local-slsb/&gt;</tt> tag configures a
                reference to an EJB Stateless SessionBean.</p><p>Before...</p><pre class="programlisting">&lt;bean id="simple"
      class="org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean"&gt;
  &lt;property name="jndiName" value="ejb/RentalServiceBean"/&gt;
  &lt;property name="businessInterface" value="com.foo.service.RentalService"/&gt;
&lt;/bean&gt;</pre><p>After...</p><pre class="programlisting">&lt;jee:local-slsb id="simpleSlsb" jndi-name="ejb/RentalServiceBean"
    business-interface="com.foo.service.RentalService"/&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-jee-local-slsb-complex"></a>A.2.3.6.&nbsp;<tt class="literal">&lt;jee:local-slsb/&gt;</tt> (complex)</h4></div></div><div></div></div><pre class="programlisting">&lt;bean id="complexLocalEjb"
      class="org.springframework.ejb.access.LocalStatelessSessionProxyFactoryBean"&gt;
  &lt;property name="jndiName" value="ejb/RentalServiceBean"/&gt;
  &lt;property name="businessInterface" value="com.foo.service.RentalService"/&gt;
  &lt;property name="cacheHome" value="true"/&gt;
  &lt;property name="lookupHomeOnStartup" value="true"/&gt;
  &lt;property name="resourceRef" value="true"/&gt;
&lt;/bean&gt;</pre><p>After...</p><pre class="programlisting">&lt;jee:local-slsb id="complexLocalEjb"
    jndi-name="ejb/RentalServiceBean"
    business-interface="com.foo.service.RentalService"
    cache-home="true"
    lookup-home-on-startup="true"
    resource-ref="true"&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-jee-remote-slsb"></a>A.2.3.7.&nbsp;<tt class="literal">&lt;jee:remote-slsb/&gt;</tt></h4></div></div><div></div></div><p>The <tt class="literal">&lt;jee:remote-slsb/&gt;</tt> tag configures a
                reference to a <tt class="literal">remote</tt> EJB Stateless SessionBean.</p><p>Before...</p><pre class="programlisting">&lt;bean id="complexRemoteEjb"
      class="org.springframework.ejb.access.SimpleRemoteStatelessSessionProxyFactoryBean"&gt;
  &lt;property name="jndiName" value="ejb/MyRemoteBean"/&gt;
  &lt;property name="businessInterface" value="com.foo.service.RentalService"/&gt;
  &lt;property name="cacheHome" value="true"/&gt;
  &lt;property name="lookupHomeOnStartup" value="true"/&gt;
  &lt;property name="resourceRef" value="true"/&gt;
  &lt;property name="homeInterface" value="com.foo.service.RentalService"/&gt;
  &lt;property name="refreshHomeOnConnectFailure" value="true"/&gt;
&lt;/bean&gt;</pre><p>After...</p><pre class="programlisting">&lt;jee:remote-slsb id="complexRemoteEjb"
    jndi-name="ejb/MyRemoteBean"
    business-interface="com.foo.service.RentalService"
    cache-home="true"
    lookup-home-on-startup="true"
    resource-ref="true"
    home-interface="com.foo.service.RentalService"
    refresh-home-on-connect-failure="true"&gt;</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd-config-body-schemas-lang"></a>A.2.4.&nbsp;The <tt class="literal">lang</tt> schema</h3></div></div><div></div></div><p>The <tt class="literal">lang</tt> tags deal with exposing objects that have been
            written in a dynamic language such as JRuby or Groovy as beans in the Spring
            container.</p><p>These tags (and the dynamic language support) are comprehensively covered
            in the chapter entitled <a href="#dynamic-language" title="Chapter&nbsp;24.&nbsp;Dynamic language support">Chapter&nbsp;24, <i>Dynamic language support</i></a>. Please do consult that
            chapter for full details on this support and the <tt class="literal">lang</tt> tags
            themselves.</p><p>In the interest of completeness, to use the tags in the <tt class="literal">lang</tt>
            schema, you need to have the following preamble at the top of your Spring XML
            configuration file; the emboldened text in the following snippet references the
            correct schema so that the tags in the <tt class="literal">lang</tt> namespace are
            available to you.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       <span class="bold"><b>xmlns:lang="http://www.springframework.org/schema/lang"</b></span>
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
<span class="bold"><b>http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang-2.5.xsd"</b></span>&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="literal">&lt;bean/&gt;</tt> definitions here --&gt;</span></i>

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd-config-body-schemas-jms"></a>A.2.5.&nbsp;The <tt class="literal">jms</tt> schema</h3></div></div><div></div></div><p>The <tt class="literal">jms</tt> tags deal with configuring JMS-related
			beans such as Spring's <a href="#jms-mdp" title="19.2.4.&nbsp;Message Listener Containers">MessageListenerContainers</a>.
            These tags are detailed in the section of the <a href="#jms" title="Chapter&nbsp;19.&nbsp;JMS (Java Message Service)">JMS chapter</a>
			entitled <a href="#jms-namespace" title="19.6.&nbsp;JMS Namespace Support">Section&nbsp;19.6, &#8220;JMS Namespace Support&#8221;</a>. Please do consult that
            chapter for full details on this support and the <tt class="literal">jms</tt> tags
            themselves.</p><p>In the interest of completeness, to use the tags in the <tt class="literal">jms</tt>
            schema, you need to have the following preamble at the top of your Spring XML
            configuration file; the emboldened text in the following snippet references the
            correct schema so that the tags in the <tt class="literal">jms</tt> namespace are
            available to you.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       <span class="bold"><b>xmlns:jms="http://www.springframework.org/schema/jms"</b></span>
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
<span class="bold"><b>http://www.springframework.org/schema/jms http://www.springframework.org/schema/jms/spring-jms-2.5.xsd"</b></span>&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="literal">&lt;bean/&gt;</tt> definitions here --&gt;</span></i>

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd-config-body-schemas-tx"></a>A.2.6.&nbsp;The <tt class="literal">tx</tt> (transaction) schema</h3></div></div><div></div></div><p>The <tt class="literal">tx</tt> tags deal with configuring all of those
            beans in Spring's comprehensive support for transactions. These tags are
            covered in the chapter entitled <a href="#transaction" title="Chapter&nbsp;9.&nbsp;Transaction management">Chapter&nbsp;9, <i>Transaction management</i></a>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Tip"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/admons/tip.png"></td><th align="left">Tip</th></tr><tr><td colspan="2" align="left" valign="top"><p>You are strongly encouraged to look at the
                <tt class="filename">'spring-tx-2.5.xsd'</tt> file that ships with the Spring
                distribution. This file is (of course), the XML Schema for Spring's
                transaction configuration, and covers all of the various tags in the
                <tt class="literal">tx</tt> namespace, including attribute defaults and
                suchlike. This file is documented inline, and thus the information is
                not repeated here in the interests of adhering to the DRY (Don't Repeat
                Yourself) principle.</p></td></tr></table></div><p>In the interest of completeness, to use the tags in the <tt class="literal">tx</tt>
            schema, you need to have the following preamble at the top of your Spring XML
            configuration file; the emboldened text in the following snippet references the
            correct schema so that the tags in the <tt class="literal">tx</tt> namespace are
            available to you.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   xmlns:aop="http://www.springframework.org/schema/aop"
	   <span class="bold"><b>xmlns:tx="http://www.springframework.org/schema/tx"</b></span>
	   xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
<span class="bold"><b>http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</b></span>
http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="literal">&lt;bean/&gt;</tt> definitions here --&gt;</span></i>

&lt;/beans&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>Often when using the tags in the <tt class="literal">tx</tt> namespace you will also be using
                the tags from the <tt class="literal">aop</tt> namespace (since the declarative transaction support in Spring is implemented using
                AOP). The above XML snippet contains the relevant lines needed to reference the <tt class="literal">aop</tt> schema
                so that the tags in the <tt class="literal">aop</tt> namespace are available to you.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd-config-body-schemas-aop"></a>A.2.7.&nbsp;The <tt class="literal">aop</tt> schema</h3></div></div><div></div></div><p>The <tt class="literal">aop</tt> tags deal with configuring all things
            AOP in Spring: this includes Spring's own proxy-based AOP framework and Spring's
            integration with the AspectJ AOP framework. These tags are
            comprehensively covered in the chapter entitled <a href="#aop" title="Chapter&nbsp;6.&nbsp;Aspect Oriented Programming with Spring">Chapter&nbsp;6, <i>Aspect Oriented Programming with Spring</i></a>.</p><p>In the interest of completeness, to use the tags in the <tt class="literal">aop</tt>
            schema, you need to have the following preamble at the top of your Spring XML
            configuration file; the emboldened text in the following snippet references the
            correct schema so that the tags in the <tt class="literal">aop</tt> namespace are
            available to you.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   <span class="bold"><b>xmlns:aop="http://www.springframework.org/schema/aop"</b></span>
	   xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
<span class="bold"><b>http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"</b></span>&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="literal">&lt;bean/&gt;</tt> definitions here --&gt;</span></i>

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd-config-body-schemas-context"></a>A.2.8.&nbsp;The <tt class="literal">context</tt> schema</h3></div></div><div></div></div><p>The <tt class="literal">context</tt> tags deal with <tt class="interfacename">ApplicationContext</tt>
			configuration that relates to plumbing - that is, not usually beans that are important to an end-user
			but rather beans that do a lot of grunt work in Spring, such as <tt class="interfacename">BeanfactoryPostProcessors</tt>.
            The following snippet references the correct schema so that the tags in the <tt class="literal">context</tt>
			namespace are available to you.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
	   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	   <span class="bold"><b>xmlns:context="http://www.springframework.org/schema/context"</b></span>
	   xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
<span class="bold"><b>http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd"</b></span>&gt;

<i class="lineannotation"><span class="lineannotation">&lt;!-- <tt class="literal">&lt;bean/&gt;</tt> definitions here --&gt;</span></i>

&lt;/beans&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The <tt class="literal">context</tt> schema was only introduced in Spring 2.5.</p></td></tr></table></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-context-pphc"></a>A.2.8.1.&nbsp;<tt class="literal">&lt;property-placeholder/&gt;</tt></h4></div></div><div></div></div><p>This element activates the replacement of <tt class="literal">${...}</tt> placeholders, resolved
				against the specified properties file (as a <a href="#resources" title="Chapter&nbsp;4.&nbsp;Resources">Spring resource location</a>).
				This element is a convenience mechanism that sets up a
				<a href="#beans-factory-placeholderconfigurer" title="3.7.2.1.&nbsp;Example: the&#xA;        PropertyPlaceholderConfigurer"><tt class="classname">PropertyPlaceholderConfigurer</tt></a>
				for you; if you need more control over the <tt class="classname">PropertyPlaceholderConfigurer</tt>, just
				define one yourself explicitly.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-context-ac"></a>A.2.8.2.&nbsp;<tt class="literal">&lt;annotation-config/&gt;</tt></h4></div></div><div></div></div><p>Activates the Spring infrastructure for various annotations to be detected in bean classes:
				Spring's <a href="#metadata-annotations-required" title="25.3.1.&nbsp;@Required"><tt class="interfacename">@Required</tt></a>
				and <a href="#beans-annotation-config" title="3.11.&nbsp;Annotation-based configuration"><tt class="interfacename">@Autowired</tt></a>, as well as
				JSR 250's <tt class="interfacename">@PostConstruct</tt>, <tt class="interfacename">@PreDestroy</tt> and
				<tt class="interfacename">@Resource</tt> (if available), and JPA's
				<tt class="interfacename">@PersistenceContext</tt> and <tt class="interfacename">@PersistenceUnit</tt>
				(if available). Alternatively, you can choose to activate the individual
				<tt class="interfacename">BeanPostProcessors</tt> for those annotations explictly.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>This element does <span class="emphasis"><em>not</em></span> activate processing of Spring's
					<a href="#transaction-declarative-annotations" title="9.5.6.&nbsp;Using @Transactional"><tt class="interfacename">@Transactional</tt></a>
					annotation. Use the
					<a href="#tx-decl-explained" title="9.5.1.&nbsp;Understanding the Spring Framework's declarative transaction implementation"><tt class="literal">&lt;tx:annotation-driven/&gt;</tt></a> element
					for that purpose.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-context-component-scan"></a>A.2.8.3.&nbsp;<tt class="literal">&lt;component-scan/&gt;</tt></h4></div></div><div></div></div><p>This element is detailed in the section entitled <a href="#beans-annotation-config" title="3.11.&nbsp;Annotation-based configuration">Section&nbsp;3.11, &#8220;Annotation-based configuration&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-context-ltw"></a>A.2.8.4.&nbsp;<tt class="literal">&lt;load-time-weaver/&gt;</tt></h4></div></div><div></div></div><p>This element is detailed in the section entitled <a href="#aop-aj-ltw" title="6.8.4.&nbsp;Load-time weaving with AspectJ in the Spring Framework">Section&nbsp;6.8.4, &#8220;Load-time weaving with AspectJ in the Spring Framework&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-context-sc"></a>A.2.8.5.&nbsp;<tt class="literal">&lt;spring-configured/&gt;</tt></h4></div></div><div></div></div><p>This element is detailed in the section entitled <a href="#aop-atconfigurable" title="6.8.1.&nbsp;Using AspectJ to dependency inject domain objects with&#xA;      Spring">Section&nbsp;6.8.1, &#8220;Using AspectJ to dependency inject domain objects with
      Spring&#8221;</a>.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-body-schemas-context-mbe"></a>A.2.8.6.&nbsp;<tt class="literal">&lt;mbean-export/&gt;</tt></h4></div></div><div></div></div><p>This element is detailed in the section entitled <a href="#jmx-context-mbeanexport" title="20.4.3.&nbsp;The <context:mbean-export/&gt; element">Section&nbsp;20.4.3, &#8220;The &lt;context:mbean-export/&gt; element&#8221;</a>.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd-config-body-schemas-tool"></a>A.2.9.&nbsp;The <tt class="literal">tool</tt> schema</h3></div></div><div></div></div><p>The <tt class="literal">tool</tt> tags are for use when you want to add
            tooling-specific metadata to your custom configuration elements. This metadata
            can then be consumed by tools that are aware of this metadata, and the tools can
            then do pretty much whatever they want with it (validation, etc.).</p><p>The <tt class="literal">tool</tt> tags are not documented in this release of
            Spring as they are currently undergoing review. If you are a third party tool
            vendor and you would like to contribute to this review process, then do mail
            the Spring mailing list. The currently supported <tt class="literal">tool</tt>
            tags can be found in the file <tt class="literal">'spring-tool-2.5.xsd'</tt> in the
            <tt class="literal">'src/org/springframework/beans/factory/xml'</tt> directory of the
            Spring source distribution.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd-config-body-schemas-beans"></a>A.2.10.&nbsp;The <tt class="literal">beans</tt> schema</h3></div></div><div></div></div><p>Last but not least we have the tags in the <tt class="literal">beans</tt> schema.
            These are the same tags that have been in Spring since the very dawn of the framework.
            Examples of the various tags in the <tt class="literal">beans</tt> schema are not shown here
            because they are quite comprehensively covered in the section entitled <a href="#beans-factory-properties-detailed" title="3.3.2.&nbsp;Dependencies and configuration in detail">Section&nbsp;3.3.2, &#8220;Dependencies and configuration in detail&#8221;</a>
            (and indeed in that entire <a href="#beans" title="Chapter&nbsp;3.&nbsp;The IoC container">chapter</a>).</p><p>One thing that is new to the beans tags themselves in Spring 2.0 is the idea
            of arbitrary bean metadata. In Spring 2.0 it is now possible to add zero or more
            key / value pairs to <tt class="literal">&lt;bean/&gt;</tt> XML definitions. What, if
            anything, is done with this extra metadata is totally up to your own custom logic (and
            so is typically only of use if you are writing your own custom tags as described in
            the appendix entitled <a href="#extensible-xml" title="Appendix&nbsp;B.&nbsp;Extensible XML authoring">Appendix&nbsp;B, <i>Extensible XML authoring</i></a>).</p><p>Find below an example of the <tt class="literal">&lt;meta/&gt;</tt> tag in the context
            of a surrounding <tt class="literal">&lt;bean/&gt;</tt> (please note that without any logic
            to interpret it the metadata is effectively useless as-is).</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd"&gt;

    &lt;bean id="foo" class="x.y.Foo"&gt;
        <span class="bold"><b>&lt;meta key="cacheName" value="foo"/&gt;</b></span>
        &lt;property name="name" value="Rick"/&gt;
    &lt;/bean&gt;

&lt;/beans&gt;</pre><p>In the case of the above example, you would assume that there is some
            logic that will consume the bean definition and set up some caching infrastructure
            using the supplied metadata.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="xsd-config-setup"></a>A.3.&nbsp;Setting up your IDE</h2></div></div><div></div></div><p>This final section documents the steps involved in setting up a number of
        popular Java IDEs to effect the easier editing of Spring's XML Schema-based
        configuration files. If your favourite Java IDE or editor is not included in the
		list of documented IDEs, then please do
        <a href="http://opensource.atlassian.com/projects/spring/secure/Dashboard.jspa" target="_top">raise an issue</a>
        and an example with your favorite IDE/editor <span class="emphasis"><em>may</em></span> be included
		in the next release.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd-config-setup-eclipse"></a>A.3.1.&nbsp;Setting up Eclipse</h3></div></div><div></div></div><div class="procedure"><p>The following steps illustrate setting up
            <a href="http://www.eclipse.org/" target="_top">Eclipse</a> to be XSD-aware. 
            The assumption in the following steps is that you already have an Eclipse
            project open (either a brand new project or an already existing one).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The following steps were created using Eclipse <span class="bold"><b>3.2</b></span>.
                The setup will probably be the same (or similar) on an earlier or later
                version of Eclipse.</p></td></tr></table></div><ol type="1"><li><p class="title"><b>Step One</b></p><p>Create a new XML file. You can name this file whatever you want. In the
                example below, the file is named <tt class="literal">'context.xml'</tt>.
                Copy and paste the following text into the file so that it matches the screenshot.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.5.xsd"&gt;

&lt;/beans&gt;</pre><p>
			        </p><div class="mediaobject" align="center"><img src="images/eclipse-setup-1.png" align="middle"></div><p>
		        </p></li><li><p class="title"><b>Step Two</b></p><p>As can be seen in the above screenshot (unless you have a customised
                version of Eclipse with the correct plugins) the XML file will be treated
                as plain text. There is no XML editing support out of the box in Eclipse,
                and as such there is not even any syntax highlighting of elements and attributes.
                To address this, you will have to install an XML editor plugin for Eclipse...</p><div class="table"><a name="xsd-config-setup-eclipse-plugins"></a><p class="title"><b>Table&nbsp;A.1.&nbsp;Eclipse XML editors</b></p><table summary="Eclipse XML editors" border="1"><colgroup><col align="left"><col></colgroup><thead><tr><th align="center">XML Editor</th><th align="center">Link</th></tr></thead><tbody><tr><td align="left"><p>The Eclipse Web Tools Platform (WTP)</p></td><td><a href="http://www.eclipse.org/webtools/" target="_top">http://www.eclipse.org/webtools/</a></td></tr><tr><td align="left"><p>A list of Eclipse XML plugins</p></td><td><a href="http://eclipse-plugins.2y.net/eclipse/plugins.jsp?category=XML" target="_top">http://eclipse-plugins.2y.net/eclipse/plugins.jsp?category=XML</a></td></tr></tbody></table></div><div class="sidebar"><p class="title"><b>Contributing documentation...</b></p><p>Patches showing how to configure an Eclipse XML editor are
                    welcomed. Any such contributions are best submitted as patches via
                    the Spring Framework
                    <a href="http://opensource.atlassian.com/projects/spring/secure/Dashboard.jspa" target="_top">JIRA Issue Tracker</a>
                    and <span class="emphasis"><em>may</em></span> be featured in the next release.</p></div><p>Unfortunately, precisely because there is no standard XML editor for Eclipse,
                there are (bar the one below) no further steps showing you how to configure XML
                Schema support in Eclipse... each XML editor plugin would require its very own
                dedicated section, and this is <span class="emphasis"><em>Spring</em></span> reference documentation,
                not Eclipse XML editor documentation. You will have to read the documentation that
                comes with your XML editor plugin (good luck there) and figure it out for yourself.</p></li><li><p class="title"><b>Spring IDE</b></p><p>There is a dedicated Spring Framework plugin for Eclipse called
				<a href="http://springide.org/blog/" target="_top">Spring IDE</a> and it is pretty darn cool. (There's a
				considered and non-biased opinion for you!) This plugin makes using Spring even easier, and it has more
				than just support for the core Spring Framework... Spring Web Flow is supported too. Details of how to
				install Spring IDE can be found on the
				<a href="http://springide.org/project/wiki/SpringideInstall" target="_top">Spring IDE installation page</a>.</p><p>
			        </p><div class="mediaobject" align="center"><img src="images/eclipse-setup-3.png" align="middle"></div><p>
		        </p></li><li><p class="title"><b>Web Tools Platform (WTP) for Eclipse</b></p><p>If you are using the Web Tools Platform (WTP) for Eclipse, you don't need to
                do anything other than open a Spring XML configuration file using the WTP platform's
                XML editor. As can be seen in the screenshot below, you immediately get some slick
                IDE-level support for autocompleting tags and suchlike.</p><p>
			        </p><div class="mediaobject" align="center"><img src="images/eclipse-setup-2.png" align="middle"></div><p>
		        </p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd-config-setup-idea"></a>A.3.2.&nbsp;Setting up IntelliJ IDEA</h3></div></div><div></div></div><div class="procedure"><p>The following steps illustrate setting up the
            <a href="http://www.jetbrains.com/idea/" target="_top">IntelliJ IDEA</a> IDE to be XSD-aware.
            The assumption in the following steps is that you already have an IDEA project
            open (either a brand new project or an already existing one).</p><p>Repeat as required for setting up IDEA to reference the other Spring XSD files.</p><ol type="1"><li><p class="title"><b>Step One</b></p><p>Create a new XML file (you can name this file whatever you want). In the
                example below, the file is named <tt class="literal">'context.xml'</tt>. Copy and paste
                the following text into the file so that it matches the screenshot.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:util="http://www.springframework.org/schema/util"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
       http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.5.xsd"&gt;

&lt;/beans&gt;</pre><p>
			        </p><div class="mediaobject" align="center"><img src="images/idea-setup-1.png" align="middle"></div><p>
		        </p></li><li><p class="title"><b>Step Two</b></p><p>As can be seen in the above screenshot, the XML file has a number
                of nasty red contextual error markers. To rectify this, IDEA has to be
                made aware of the location of the referenced XSD namespace(s).</p><p>To do this, simply position the cursor over the squiggly red
                area (see the screenshot below); then press the <b class="keycap">Alt</b>-<b class="keycap">Enter</b> keystroke combination, and press the <b class="keycap">Enter</b> key again when the popup becomes active to fetch the external
                 resource.</p><p>
			        </p><div class="mediaobject" align="center"><img src="images/idea-setup-6.png" align="middle"></div><p>
		        </p></li><li><p class="title"><b>Step Three</b></p><p>If the external resource could not be fetched (maybe no active Internet
                connection is available), you can manually configure the resource to
                reference a local copy of the XSD file. Simply open up the <tt class="literal">'Settings'</tt> dialog
                (using the <b class="keycap">Ctrl</b>-<b class="keycap">A</b>-<b class="keycap">S</b> keystroke combination or via the <tt class="literal">'File|Settings'</tt> menu),
                 and click on the <tt class="literal">'Resources'</tt> button.</p><p>
			        </p><div class="mediaobject" align="center"><img src="images/idea-setup-2.png" align="middle"></div><p>
		        </p></li><li><p class="title"><b>Step Four</b></p><p>As can be seen in the following screenshot, this will bring up a dialog
                that allows you to add an explicit reference to a local copy of the
                <tt class="literal">util</tt> schema file. (You can find all of the various Spring
                XSD files in the <tt class="literal">'src'</tt> directory of the Spring distribution.)</p><p>
			        </p><div class="mediaobject" align="center"><img src="images/idea-setup-3.png" align="middle"></div><p>
		        </p></li><li><p class="title"><b>Step Five</b></p><p>Clicking the <tt class="literal">'Add'</tt> button will bring up another dialog
                that allows you to explicitly to associate a namespace URI with the path to the
                relevant XSD file. As can be seen in the following screenshot, the
                <tt class="literal">'http://www.springframework.org/schema/util'</tt> namespace
                is being associated with the file resource
                <tt class="literal">'C:\bench\spring\src\org\springframework\beans\factory\xml\spring-util-2.5.xsd'</tt>.</p><p>
			        </p><div class="mediaobject" align="center"><img src="images/idea-setup-4.png" align="middle"></div><p>
		        </p></li><li><p class="title"><b>Step Six</b></p><p>Exiting out of the nested dialogs by clicking the <tt class="literal">'OK'</tt> button
                will then bring back the main editing window, and as can be seen in the
                following screenshot, the contextual error markers have disappeared; typing
                the <tt class="literal">'&lt;'</tt> character into the editing window now also
                brings up a handy dropdown box that contains all of the imported tags from
                the <tt class="literal">util</tt> namespace.</p><p>
			        </p><div class="mediaobject" align="center"><img src="images/idea-setup-5.png" align="middle"></div><p>
		        </p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="xsd-config-integration"></a>A.3.3.&nbsp;Integration issues</h3></div></div><div></div></div><p>This final section details integration issues that may arise when you switch over
            to using the above XSD-style for Spring 2.0 configuration.</p><p>This section is quite small at the moment (and hopefully it will stay that way).
            It has been included in the Spring documentation as a convenience to Spring users
            so that if you encounter an issue when switching over to the XSD-style in some
            specific environment you can refer to this section for the authoritative answer.</p><div class="section" lang="en"><div class="titlepage"><div><div><h4 class="title"><a name="xsd-config-integration-resin"></a>A.3.3.1.&nbsp;XML parsing errors in the Resin v.3 application server</h4></div></div><div></div></div><p>If you are using the XSD-style for Spring 2.0 XML configuration
                and deploying to v.3 of Caucho's Resin application server, you will need
                to set some configuration options prior to startup so that an XSD-aware
                parser is available to Spring.</p><p>Please do read this resource,
                <a href="http://www.caucho.com/resin-3.0/xml/jaxp.xtp#xerces" target="_top">http://www.caucho.com/resin-3.0/xml/jaxp.xtp#xerces</a>,
                for further details.</p></div></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="extensible-xml"></a>Appendix&nbsp;B.&nbsp;Extensible XML authoring</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensible-xml-introduction"></a>B.1.&nbsp;Introduction</h2></div></div><div></div></div><p>Since version 2.0, Spring has featured a mechanism for schema-based extensions
        to the basic Spring XML format for defining and configuring beans. This section is
        devoted to detailing how you would go about writing your own custom XML bean definition
        parsers and integrating such parsers into the Spring IoC container.</p><p>To facilitate the authoring of configuration files using a schema-aware XML editor,
    	Spring's extensible XML configuration mechanism is based on XML Schema. If you are
    	not familiar with Spring's current XML configuration extensions that come with the
    	standard Spring distribution, please first read the appendix entitled
    	<a href="#xsd-config" title="Appendix&nbsp;A.&nbsp;XML Schema-based configuration">Appendix&nbsp;A, <i>XML Schema-based configuration</i></a>.</p><p>Creating new XML configuration extensions can be done by following these (relatively)
    	simple steps:</p><p>
    	    </p><div class="orderedlist"><ol type="1"><li><p><a href="#extensible-xml-schema" title="B.2.&nbsp;Authoring the schema">Authoring</a> an XML schema to describe your custom element(s).</p></li><li><p><a href="#extensible-xml-namespacehandler" title="B.3.&nbsp;Coding a NamespaceHandler">Coding</a> a custom <tt class="interfacename">NamespaceHandler</tt>
                    implementation (this is an easy step, don't worry).</p></li><li><p><a href="#extensible-xml-parser" title="B.4.&nbsp;Coding a BeanDefinitionParser">Coding</a> one or more <tt class="interfacename">BeanDefinitionParser</tt>
                    implementations (this is where the real work is done).</p></li><li><p><a href="#extensible-xml-registration" title="B.5.&nbsp;Registering the handler and the schema">Registering</a> the above artifacts with Spring (this too is an easy step).</p></li></ol></div><p>
    	</p><p>What follows is a description of each of these steps. For the example, we will create
    	an XML extension (a custom XML element) that allows us to configure objects of the type
    	<tt class="classname">SimpleDateFormat</tt> (from the <tt class="literal">java.text</tt> package)
    	in an easy manner. When we are done, we will be able to define bean definitions of type
    	<tt class="classname">SimpleDateFormat</tt> like this:</p><pre class="programlisting">&lt;myns:dateformat id="dateFormat" 
    pattern="yyyy-MM-dd HH:mm"
    lenient="true"/&gt;
</pre><p><span class="emphasis"><em>(Don't worry about the fact that this example is very simple; much more
        detailed examples follow afterwards. The intent in this first simple example is to walk
        you through the basic steps involved.)</em></span></p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensible-xml-schema"></a>B.2.&nbsp;Authoring the schema</h2></div></div><div></div></div><p>Creating an XML configuration extension for use with Spring's IoC container
    	starts with authoring an XML Schema to describe the extension. What follows
    	is the schema we'll use to configure <tt class="classname">SimpleDateFormat</tt>
    	objects.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation">&lt;!-- myns.xsd (inside package org/springframework/samples/xml) --&gt;</span></i>

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsd:schema xmlns="http://www.mycompany.com/schema/myns"
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns:beans="http://www.springframework.org/schema/beans"
    targetNamespace="http://www.mycompany.com/schema/myns"
    elementFormDefault="qualified"
    attributeFormDefault="unqualified"&gt;

   &lt;xsd:import namespace="http://www.springframework.org/schema/beans"/&gt;

   &lt;xsd:element name="dateformat"&gt;
      &lt;xsd:complexType&gt;
         &lt;xsd:complexContent&gt;
            <span class="bold"><b>&lt;xsd:extension base="beans:identifiedType"&gt;</b></span>
               &lt;xsd:attribute name="lenient" type="xsd:boolean"/&gt;
               &lt;xsd:attribute name="pattern" type="xsd:string" use="required"/&gt;
            &lt;/xsd:extension&gt;
         &lt;/xsd:complexContent&gt;
      &lt;/xsd:complexType&gt;
   &lt;/xsd:element&gt;

&lt;/xsd:schema&gt;</pre><p>(The emphasized line contains an extension base for all tags that
    	will be identifiable (meaning they have an <tt class="literal">id</tt> attribute
    	that will be used as the bean identifier in the container). We are able to use this
    	attribute because we imported the Spring-provided <tt class="literal">'beans'</tt>
    	namespace.)</p><p>The above schema will be used to configure <tt class="classname">SimpleDateFormat</tt>
		objects, directly in an XML application context file using the
		<tt class="literal">&lt;myns:dateformat/&gt;</tt> element.</p><pre class="programlisting">&lt;myns:dateformat id="dateFormat" 
    pattern="yyyy-MM-dd HH:mm"
    lenient="true"/&gt;
</pre><p>Note that after we've created the infrastructure classes, the above snippet of XML
		will essentially be exactly the same as the following XML snippet. In other words,
		we're just creating a bean in the container, identified by the name
		<tt class="literal">'dateFormat'</tt> of type <tt class="classname">SimpleDateFormat</tt>, with a
		couple of properties set.</p><pre class="programlisting">&lt;bean id="dateFormat" class="java.text.SimpleDateFormat"&gt;
    &lt;constructor-arg value="yyyy-HH-dd HH:mm"/&gt;
    &lt;property name="lenient" value="true"/&gt;
&lt;/bean&gt;</pre><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/admons/note.png"></td><th align="left">Note</th></tr><tr><td colspan="2" align="left" valign="top"><p>The schema-based approach to creating configuration format allows for
			tight integration with an IDE that has a schema-aware XML editor. Using a properly
			authored schema, you can use autocompletion to have a user choose between several
			configuration options defined in the enumeration.</p></td></tr></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensible-xml-namespacehandler"></a>B.3.&nbsp;Coding a <tt class="interfacename">NamespaceHandler</tt></h2></div></div><div></div></div><p>In addition to the schema, we need a <tt class="interfacename">NamespaceHandler</tt>
		that will parse all elements of this specific namespace Spring encounters
		while parsing configuration files. The <tt class="interfacename">NamespaceHandler</tt>
		should in our case take care of the parsing of the <tt class="literal">myns:dateformat</tt>
		element.</p><p>The <tt class="interfacename">NamespaceHandler</tt> interface is pretty simple in that 
		it features just three methods:</p><div class="itemizedlist"><ul type="disc" compact><li><p><tt class="methodname">init()</tt> - allows for initialization of
				the <tt class="interfacename">NamespaceHandler</tt> and will be called by Spring
				before the handler is used</p></li><li><p><tt class="methodname">BeanDefinition parse(Element, ParserContext)</tt> - 
				called when Spring encounters a top-level element (not nested inside a bean definition
				or a different namespace). This method can register bean definitions itself and/or
				return a bean definition.</p></li><li><p><tt class="methodname">BeanDefinitionHolder decorate(Node, BeanDefinitionHolder, ParserContext)</tt> -
				called when Spring encounters an attribute or nested element of a different namespace.
				The decoration of one or more bean definitions is used for example with the
				<a href="#beans-factory-scopes" title="3.4.&nbsp;Bean scopes">out-of-the-box	scopes Spring 2.0 supports</a>.
				We'll start by highlighting a simple example, without using decoration, after which
				we will	show decoration in a somewhat more advanced example.</p></li></ul></div><p>Although it is perfectly possible to code your own
		<tt class="interfacename">NamespaceHandler</tt> for the entire namespace
		(and hence provide code that parses each and every element in the namespace),
		it is often the case that each top-level XML element in a Spring XML
		configuration file results in a single bean definition (as in our
		case, where a single <tt class="literal">&lt;myns:dateformat/&gt;</tt> element
		results in a single <tt class="classname">SimpleDateFormat</tt> bean definition).
		Spring features a number of convenience classes that support this scenario.
		In this example, we'll make use the <tt class="classname">NamespaceHandlerSupport</tt> class:</p><pre class="programlisting">package org.springframework.samples.xml;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class MyNamespaceHandler extends NamespaceHandlerSupport {
    
    public void init() {<span class="bold"><b>
        registerBeanDefinitionParser("dateformat", new SimpleDateFormatBeanDefinitionParser());        
    </b></span>}
}</pre><p>The observant reader will notice that there isn't actually a whole lot of
        parsing logic in this class. Indeed... the <tt class="classname">NamespaceHandlerSupport</tt>
        class has a built in notion of delegation. It supports the registration of any number
        of <tt class="interfacename">BeanDefinitionParser</tt> instances, to which it will delegate
        to when it needs to parse an element in its namespace. This clean separation of concerns
        allows a <tt class="interfacename">NamespaceHandler</tt> to handle the orchestration
        of the parsing of <span class="emphasis"><em>all</em></span> of the custom elements in its namespace,
        while delegating to <tt class="literal">BeanDefinitionParsers</tt> to do the grunt work of the
        XML parsing; this means that each <tt class="interfacename">BeanDefinitionParser</tt> will
        contain just the logic for parsing a single custom element, as we can see in the next step</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensible-xml-parser"></a>B.4.&nbsp;Coding a <tt class="interfacename">BeanDefinitionParser</tt></h2></div></div><div></div></div><p>A <tt class="interfacename">BeanDefinitionParser</tt> will be used if the
		<tt class="interfacename">NamespaceHandler</tt> encounters an XML element of the type
		that has been mapped to the specific bean definition parser (which is <tt class="literal">'dateformat'</tt>
		in this case). In other words, the <tt class="interfacename">BeanDefinitionParser</tt> is
		responsible for parsing <span class="emphasis"><em>one</em></span> distinct top-level XML element defined in the
		schema. In the parser, we'll have access to the XML element (and thus its subelements too)
		so that we can parse our custom XML content, as can be seen in the following example:</p><pre class="programlisting">package org.springframework.samples.xml;

import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.AbstractSingleBeanDefinitionParser;
import org.springframework.util.StringUtils;
import org.w3c.dom.Element;

import java.text.SimpleDateFormat;

public class SimpleDateFormatBeanDefinitionParser extends AbstractSingleBeanDefinitionParser { <a name="extensible-xml-parser-simpledateformat-co-1"></a><img src="../images/callouts/1.png" alt="1" border="0">

   protected Class getBeanClass(Element element) {
      return SimpleDateFormat.class; <a name="extensible-xml-parser-simpledateformat-co-2"></a><img src="../images/callouts/2.png" alt="2" border="0">
   }

   protected void doParse(Element element, BeanDefinitionBuilder bean) {
      <i class="lineannotation"><span class="lineannotation">// this will never be null since the schema explicitly requires that a value be supplied</span></i>
      String pattern = element.getAttribute("pattern");
      bean.addConstructorArg(pattern);

      <i class="lineannotation"><span class="lineannotation">// this however is an optional property</span></i>
      String lenient = element.getAttribute("lenient");
      if (StringUtils.hasText(lenient)) {
         bean.addPropertyValue("lenient", Boolean.valueOf(lenient));
      }
   }
}</pre><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><a href="#extensible-xml-parser-simpledateformat-co-1"><img src="../images/callouts/1.png" alt="1" border="0"></a> </td><td valign="top" align="left"><p>We use the Spring-provided <tt class="classname">AbstractSingleBeanDefinitionParser</tt>
			    to handle a lot of the basic grunt work of creating a <span class="emphasis"><em>single</em></span>
			    <tt class="interfacename">BeanDefinition</tt>.</p></td></tr><tr><td width="5%" valign="top" align="left"><a href="#extensible-xml-parser-simpledateformat-co-2"><img src="../images/callouts/2.png" alt="2" border="0"></a> </td><td valign="top" align="left"><p>We supply the <tt class="classname">AbstractSingleBeanDefinitionParser</tt> superclass
			    with the type that our single <tt class="interfacename">BeanDefinition</tt> will represent.</p></td></tr></table></div><p>In this simple case, this is all that we need to do. The creation of our single
		<tt class="interfacename">BeanDefinition</tt> is handled by the <tt class="classname">AbstractSingleBeanDefinitionParser</tt>
		superclass, as is the extraction and setting of the bean definition's unique identifier.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensible-xml-registration"></a>B.5.&nbsp;Registering the handler and the schema</h2></div></div><div></div></div><p>The coding is finished! All that remains to be done is to somehow make the Spring XML
		parsing infrastructure aware of our custom element; we do this by registering our custom
		<tt class="interfacename">namespaceHandler</tt> and custom XSD file in two special purpose
		properties files. These properties files are both placed in a
		<tt class="filename">'META-INF'</tt> directory in your application, and can, for
		example, be distributed alongside your binary classes in a JAR file. The Spring XML parsing
		infrastructurewill automatically pick up your new extension by consuming these special
		properties files, the formats of which are detailed below.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="extensible-xml-registration-spring-handlers"></a>B.5.1.&nbsp;<tt class="filename">'META-INF/spring.handlers'</tt></h3></div></div><div></div></div><p>The properties file called <tt class="filename">'spring.handlers'</tt> contains a mapping
			of XML Schema URIs to namespace handler classes. So for our example, we need to write the
			following:</p><pre class="programlisting">http\://www.mycompany.com/schema/myns=org.springframework.samples.xml.MyNamespaceHandler</pre><p><span class="emphasis"><em>(The <tt class="literal">':'</tt> character is a valid delimiter in the Java properties format,
			and so the <tt class="literal">':'</tt> character in the URI needs to be escaped with a backslash.)</em></span></p><p>The first part (the key) of the key-value pair is the URI associated with your custom namespace
			extension, and needs to <span class="emphasis"><em>match exactly</em></span> the value of the
			<tt class="literal">'targetNamespace'</tt> attribute as specified in your custom XSD schema.</p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="extensible-xml-registration-spring-schemas"></a>B.5.2.&nbsp;<tt class="filename">'META-INF/spring.schemas'</tt></h3></div></div><div></div></div><p>The properties file called <tt class="filename">'spring.schemas'</tt> contains a mapping
			of XML Schema locations (referred to along with the schema declaration in XML files
			that use the schema as part of the <tt class="literal">'xsi:schemaLocation'</tt> attribute)
			to <span class="emphasis"><em>classpath</em></span> resources. This file is needed to prevent Spring from
			absolutely having to use a default <tt class="interfacename">EntityResolver</tt> that requires
			Internet access to retrieve the schema file. If you specify the mapping in this properties file,
			Spring will search for the schema on the classpath (in this case <tt class="literal">'myns.xsd'</tt>
			in the <tt class="literal">'org.springframework.samples.xml'</tt> package):</p><pre class="programlisting">http\://www.mycompany.com/schema/myns/myns.xsd=org/springframework/samples/xml/myns.xsd</pre><p>The upshot of this is that you are encouraged to deploy your XSD file(s) right alongside
			the <tt class="interfacename">NamespaceHandler</tt> and <tt class="interfacename">BeanDefinitionParser</tt>
			classes on the classpath.</p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensible-xml-using"></a>B.6.&nbsp;Using a custom extension in your Spring XML configuration</h2></div></div><div></div></div><p>Using a custom extension that you yourself have implemented is no different from
		using one of the 'custom' extensions that Spring provides straight out of the box. Find below
		an example of using the custom <tt class="literal">&lt;dateformat/&gt;</tt> element developed in the
		previous steps in a Spring XML configuration file.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:myns="http://www.mycompany.com/schema/myns"
      xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.mycompany.com/schema/myns http://www.mycompany.com/schema/myns/myns.xsd"&gt;

   <i class="lineannotation"><span class="lineannotation">&lt;!-- as a top-level bean --&gt;</span></i>
   &lt;myns:dateformat id="defaultDateFormat" pattern="yyyy-MM-dd HH:mm" lenient="true"/&gt;

   &lt;bean id="jobDetailTemplate" abstract="true"&gt;
      &lt;property name="dateFormat"&gt;
         <i class="lineannotation"><span class="lineannotation">&lt;!-- as an inner bean --&gt;</span></i>
         &lt;myns:dateformat pattern="HH:mm MM-dd-yyyy"/&gt;
      &lt;/property&gt;
   &lt;/bean&gt;

&lt;/beans&gt;</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensible-xml-meat"></a>B.7.&nbsp;Meatier examples</h2></div></div><div></div></div><p>Find below some much meatier examples of custom XML extensions.</p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="extensible-xml-custom-nested"></a>B.7.1.&nbsp;Nesting custom tags within custom tags</h3></div></div><div></div></div><p>This example illustrates how you might go about writing the various artifacts
		    required to satisfy a target of the following configuration:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:foo="http://www.foo.com/schema/component"
      xsi:schemaLocation="
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
http://www.foo.com/schema/component http://www.foo.com/schema/component/component.xsd"&gt;

   <i class="lineannotation"><span class="lineannotation">&lt;foo:component id="bionic-family" name="Bionic-1"&gt;
      &lt;foo:component name="Sport-1"/&gt;
      &lt;foo:component name="Rock-1"/&gt;
   &lt;/foo:component&gt;</span></i>

&lt;/beans&gt;</pre><p>The above configuration actually nests custom extensions within each other. The class
            that is actually configured by the above <tt class="literal">&lt;foo:component/&gt;</tt>
            element is the <tt class="classname">Component</tt> class (shown directly below). Notice
            how the <tt class="classname">Component</tt> class does <span class="emphasis"><em>not</em></span> expose
            a setter method for the <tt class="literal">'components'</tt> property; this makes it hard
            (or rather impossible) to configure a bean definition for the <tt class="classname">Component</tt>
            class using setter injection.</p><pre class="programlisting">package com.foo;

import java.util.ArrayList;
import java.util.List;

public class Component {

   private String name;
   private List components = new ArrayList();

   <i class="lineannotation"><span class="lineannotation">// mmm, there is no setter method for the <tt class="literal">'components'</tt></span></i>
   public void addComponent(Component component) {
      this.components.add(component);
   }

   public List getComponents() {
      return components;
   }

   public String getName() {
      return name;
   }

   public void setName(String name) {
      this.name = name;
   }
}</pre><p>The typical solution to this issue is to create a custom <tt class="interfacename">FactoryBean</tt>
            that exposes a setter property for the <tt class="literal">'components'</tt> property.</p><pre class="programlisting">package com.foo;

import org.springframework.beans.factory.FactoryBean;

import java.util.Iterator;
import java.util.List;

public class ComponentFactoryBean implements FactoryBean {

   private Component parent;
   private List children;

   public void setParent(Component parent) {
      this.parent = parent;
   }

   public void setChildren(List children) {
      this.children = children;
   }

   public Object getObject() throws Exception {
      if (this.children != null &amp;&amp; this.children.size() &gt; 0) {
         for (Iterator it = children.iterator(); it.hasNext();) {
            Component childComponent = (Component) it.next();
            this.parent.addComponent(childComponent);
         }
      }
      return this.parent;
   }

   public Class getObjectType() {
      return Component.class;
   }

   public boolean isSingleton() {
      return true;
   }
}</pre><p>This is all very well, and does work nicely, but exposes a lot of Spring plumbing to the
            end user. What we are going to do is write a custom extension that hides away all of this
            Spring plumbing. If we stick to <a href="#extensible-xml-introduction" title="B.1.&nbsp;Introduction">the steps described
            previously</a>, we'll start off by creating the XSD schema to define the structure of
            our custom tag.</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;

&lt;xsd:schema xmlns="http://www.foo.com/schema/component"
         xmlns:xsd="http://www.w3.org/2001/XMLSchema"
         targetNamespace="http://www.foo.com/schema/component"
         elementFormDefault="qualified"
         attributeFormDefault="unqualified"&gt;

   &lt;xsd:element name="component"&gt;
      &lt;xsd:complexType&gt;
         &lt;xsd:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xsd:element ref="component"/&gt;
         &lt;/xsd:choice&gt;
         &lt;xsd:attribute name="id" type="xsd:ID"/&gt;
         &lt;xsd:attribute name="name" use="required" type="xsd:string"/&gt;
      &lt;/xsd:complexType&gt;
   &lt;/xsd:element&gt;

&lt;/xsd:schema&gt;
</pre><p>We'll then create a custom <tt class="interfacename">NamespaceHandler</tt>.</p><pre class="programlisting">package com.foo;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class ComponentNamespaceHandler extends NamespaceHandlerSupport {

   public void init() {
      registerBeanDefinitionParser("component", new ComponentBeanDefinitionParser());
   }
}</pre><p>Next up is the custom <tt class="interfacename">BeanDefinitionParser</tt>. Remember
            that what we are creating is a <tt class="interfacename">BeanDefinition</tt> describing
            a <tt class="classname">ComponentFactoryBean</tt>.</p><pre class="programlisting">package com.foo;

import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.support.ManagedList;
import org.springframework.beans.factory.xml.AbstractBeanDefinitionParser;
import org.springframework.beans.factory.xml.ParserContext;
import org.springframework.util.xml.DomUtils;
import org.w3c.dom.Element;

import java.util.List;

public class ComponentBeanDefinitionParser extends AbstractBeanDefinitionParser {

   protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) {
      BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean.class);
      BeanDefinitionBuilder parent = parseComponent(element);
      factory.addPropertyValue("parent", parent.getBeanDefinition());

      List childElements = DomUtils.getChildElementsByTagName(element, "component");
      if (childElements != null &amp;&amp; childElements.size() &gt; 0) {
         parseChildComponents(childElements, factory);
      }
      return factory.getBeanDefinition();
   }

   private static BeanDefinitionBuilder parseComponent(Element element) {
      BeanDefinitionBuilder component = BeanDefinitionBuilder.rootBeanDefinition(Component.class);
      component.addPropertyValue("name", element.getAttribute("name"));
      return component;
   }

   private static void parseChildComponents(List childElements, BeanDefinitionBuilder factory) {
      ManagedList children = new ManagedList(childElements.size());
      for (int i = 0; i &lt; childElements.size(); ++i) {
         Element childElement = (Element) childElements.get(i);
         BeanDefinitionBuilder child = parseComponent(childElement);
         children.add(child.getBeanDefinition());
      }
      factory.addPropertyValue("children", children);
   }
}</pre><p>Lastly, the various artifacts need to be registered with the Spring XML infrastructure.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation"># in <tt class="filename">'META-INF/spring.handlers'</tt></span></i>
http\://www.foo.com/schema/component=com.foo.ComponentNamespaceHandler</pre><pre class="programlisting"><i class="lineannotation"><span class="lineannotation"># in <tt class="filename">'META-INF/spring.schemas'</tt></span></i>
http\://www.foo.com/schema/component/component.xsd=com/foo/component.xsd</pre></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="extensible-xml-custom-just-attributes"></a>B.7.2.&nbsp;Custom attributes on 'normal' elements</h3></div></div><div></div></div><p>Writing your own custom parser and the associated artifacts isn't hard, but sometimes it
		    is not the right thing to do. Consider the scenario where you need to add metadata to already
		    existing bean definitions. In this case you certainly don't want to have to go off and write
		    your own entire custom extension; rather you just want to add an additional attribute
		    to the existing bean definition element.</p><p>By way of another example, let's say that the service class that you are defining a bean
		    definition for a service object that will (unknown to it) be accessing a clustered
		    <a href="http://jcp.org/en/jsr/detail?id=107" target="_top">JCache</a>, and you want to ensure that
		    the named JCache instance is eagerly started within the surrounding cluster:</p><pre class="programlisting">&lt;bean id="checkingAccountService" class="com.foo.DefaultCheckingAccountService"
      <i class="lineannotation"><span class="lineannotation"><span class="bold"><b>jcache:cache-name="checking.account"&gt;</b></span></span></i>
   <i class="lineannotation"><span class="lineannotation">&lt;!-- other dependencies here... --&gt;</span></i>
&lt;/bean&gt;</pre><p>What we are going to do here is create another <tt class="interfacename">BeanDefinition</tt>
            when the <tt class="literal">'jcache:cache-name'</tt> attribute is parsed; this
            <tt class="interfacename">BeanDefinition</tt> will then initialize the named JCache
            for us. We will also modify the existing <tt class="interfacename">BeanDefinition</tt> for the
            <tt class="literal">'checkingAccountService'</tt> so that it will have a dependency on this
            new JCache-initializing <tt class="interfacename">BeanDefinition</tt>.</p><pre class="programlisting">package com.foo;

public class JCacheInitializer {

   private String name;

   public JCacheInitializer(String name) {
      this.name = name;
   }

   public void initialize() {
      <i class="lineannotation"><span class="lineannotation">// lots of JCache API calls to initialize the named cache...</span></i>
   }
}</pre><p>Now onto the custom extension. Firstly, the authoring of the XSD schema describing the
            custom attribute (quite easy in this case).</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;

&lt;xsd:schema xmlns="http://www.foo.com/schema/jcache"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            targetNamespace="http://www.foo.com/schema/jcache"
            elementFormDefault="qualified"&gt;

   &lt;xsd:attribute name="cache-name" type="xsd:string"/&gt;

&lt;/xsd:schema&gt;
</pre><p>Next, the associated <tt class="interfacename">NamespaceHandler</tt>.</p><pre class="programlisting">package com.foo;

import org.springframework.beans.factory.xml.NamespaceHandlerSupport;

public class JCacheNamespaceHandler extends NamespaceHandlerSupport {

   public void init() {
      super.registerBeanDefinitionDecoratorForAttribute("cache-name",
            new JCacheInitializingBeanDefinitionDecorator());
   }
}
</pre><p>Next, the parser. Note that in this case, because we are going to be parsing an XML
            attribute, we write a <tt class="interfacename">BeanDefinitionDecorator</tt> rather than a
            <tt class="interfacename">BeanDefinitionParser</tt>.</p><pre class="programlisting">package com.foo;

import org.springframework.beans.factory.config.BeanDefinitionHolder;
import org.springframework.beans.factory.support.AbstractBeanDefinition;
import org.springframework.beans.factory.support.BeanDefinitionBuilder;
import org.springframework.beans.factory.xml.BeanDefinitionDecorator;
import org.springframework.beans.factory.xml.ParserContext;
import org.w3c.dom.Attr;
import org.w3c.dom.Node;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class JCacheInitializingBeanDefinitionDecorator implements BeanDefinitionDecorator {
   
   private static final String[] EMPTY_STRING_ARRAY = new String[0];

   public BeanDefinitionHolder decorate(
         Node source, BeanDefinitionHolder holder, ParserContext ctx) {
      String initializerBeanName = registerJCacheInitializer(source, ctx);
      createDependencyOnJCacheInitializer(holder, initializerBeanName);
      return holder;
   }

   private void createDependencyOnJCacheInitializer(BeanDefinitionHolder holder, String initializerBeanName) {
      AbstractBeanDefinition definition = ((AbstractBeanDefinition) holder.getBeanDefinition());
      String[] dependsOn = definition.getDependsOn();
      if (dependsOn == null) {
         dependsOn = new String[]{initializerBeanName};
      } else {
         List dependencies = new ArrayList(Arrays.asList(dependsOn));
         dependencies.add(initializerBeanName);
         dependsOn = (String[]) dependencies.toArray(EMPTY_STRING_ARRAY);
      }
      definition.setDependsOn(dependsOn);
   }

   private String registerJCacheInitializer(Node source, ParserContext ctx) {
      String cacheName = ((Attr) source).getValue();
      String beanName = cacheName + "-initializer";
      if (!ctx.getRegistry().containsBeanDefinition(beanName)) {
         BeanDefinitionBuilder initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer.class);
         initializer.addConstructorArg(cacheName);
         ctx.getRegistry().registerBeanDefinition(beanName, initializer.getBeanDefinition());
      }
      return beanName;
   }
}
</pre><p>Lastly, the various artifacts need to be registered with the Spring XML infrastructure.</p><pre class="programlisting"><i class="lineannotation"><span class="lineannotation"># in <tt class="filename">'META-INF/spring.handlers'</tt></span></i>
http\://www.foo.com/schema/jcache=com.foo.JCacheNamespaceHandler</pre><pre class="programlisting"><i class="lineannotation"><span class="lineannotation"># in <tt class="filename">'META-INF/spring.schemas'</tt></span></i>
http\://www.foo.com/schema/jcache/jcache.xsd=com/foo/jcache.xsd</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="extensible-xml-resources"></a>B.8.&nbsp;Further Resources</h2></div></div><div></div></div><p>Find below links to further resources concerning XML Schema and the extensible XML support
		described in this chapter.</p><div class="itemizedlist"><ul type="disc"><li><p>The <a href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/" target="_top">XML Schema Part 1: Structures Second Edition</a></p></li><li><p>The <a href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/" target="_top">XML Schema Part 2: Datatypes Second Edition</a></p></li></ul></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="springbeansdtd"></a>Appendix&nbsp;C.&nbsp;<tt class="literal">spring-beans-2.0.dtd</tt></h2></div></div><div></div></div><pre class="programlisting">&lt;!--
	Spring XML Beans DTD, version 2.0
	Authors: Rod Johnson, Juergen Hoeller, Alef Arendsen, Colin Sampaleanu, Rob Harrop

	This defines a simple and consistent way of creating a namespace
	of JavaBeans objects, managed by a Spring BeanFactory, read by
	XmlBeanDefinitionReader (with DefaultBeanDefinitionDocumentReader).

	This document type is used by most Spring functionality, including
	web application contexts, which are based on bean factories.

	Each "bean" element in this document defines a JavaBean.
	Typically the bean class is specified, along with JavaBean properties
	and/or constructor arguments.

	A bean instance can be a "singleton" (shared instance) or a "prototype"
	(independent instance). Further scopes can be provided by extended
	bean factories, for example in a web environment.

	References among beans are supported, that is, setting a JavaBean property
	or a constructor argument to refer to another bean in the same factory
	(or an ancestor factory).

	As alternative to bean references, "inner bean definitions" can be used.
	Singleton flags of such inner bean definitions are effectively ignored:
	Inner beans are typically anonymous prototypes.

	There is also support for lists, sets, maps, and java.util.Properties
	as bean property types or constructor argument types.

	For simple purposes, this DTD is sufficient. As of Spring 2.0,
	XSD-based bean definitions are supported as more powerful alternative.

	XML documents that conform to this DTD should declare the following doctype:

	&lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
		"http://www.springframework.org/dtd/spring-beans-2.0.dtd"&gt;
--&gt;


&lt;!--
	The document root. A document can contain bean definitions only,
	imports only, or a mixture of both (typically with imports first).
--&gt;
&lt;!ELEMENT beans (
	description?,
	(import | alias | bean)*
)&gt;

&lt;!--
	Default values for all bean definitions. Can be overridden at
	the "bean" level. See those attribute definitions for details.
--&gt;
&lt;!ATTLIST beans default-lazy-init (true | false) "false"&gt;
&lt;!ATTLIST beans default-autowire (no | byName | byType | constructor | autodetect) "no"&gt;
&lt;!ATTLIST beans default-dependency-check (none | objects | simple | all) "none"&gt;
&lt;!ATTLIST beans default-init-method CDATA #IMPLIED&gt;
&lt;!ATTLIST beans default-destroy-method CDATA #IMPLIED&gt;
&lt;!ATTLIST beans default-merge (true | false) "false"&gt;

&lt;!--
	Element containing informative text describing the purpose of the enclosing
	element. Always optional.
	Used primarily for user documentation of XML bean definition documents.
--&gt;
&lt;!ELEMENT description (#PCDATA)&gt;


&lt;!--
	Specifies an XML bean definition resource to import.
--&gt;
&lt;!ELEMENT import EMPTY&gt;

&lt;!--
	The relative resource location of the XML bean definition file to import,
	for example "myImport.xml" or "includes/myImport.xml" or "../myImport.xml".
--&gt;
&lt;!ATTLIST import resource CDATA #REQUIRED&gt;


&lt;!--
	Defines an alias for a bean, which can reside in a different definition file.
--&gt;
&lt;!ELEMENT alias EMPTY&gt;

&lt;!--
	The name of the bean to define an alias for.
--&gt;
&lt;!ATTLIST alias name CDATA #REQUIRED&gt;

&lt;!--
	The alias name to define for the bean.
--&gt;
&lt;!ATTLIST alias alias CDATA #REQUIRED&gt;

&lt;!--
  Allows for arbitrary metadata to be attached to a bean definition.
--&gt;
&lt;!ELEMENT meta EMPTY&gt;

&lt;!--
  Specifies the key name of the metadata parameter being defined.
--&gt;
&lt;!ATTLIST meta key CDATA #REQUIRED&gt;

&lt;!--
  Specifies the value of the metadata parameter being defined as a String.
--&gt;
&lt;!ATTLIST meta value CDATA #REQUIRED&gt;

&lt;!--
	Defines a single (usually named) bean.

	A bean definition may contain nested tags for constructor arguments,
	property values, lookup methods, and replaced methods. Mixing constructor
	injection and setter injection on the same bean is explicitly supported.
--&gt;
&lt;!ELEMENT bean (
	description?,
	(meta | constructor-arg | property | lookup-method | replaced-method)*
)&gt;

&lt;!--
	Beans can be identified by an id, to enable reference checking.

	There are constraints on a valid XML id: if you want to reference your bean
	in Java code using a name that's illegal as an XML id, use the optional
	"name" attribute. If neither is given, the bean class name is used as id
	(with an appended counter like "#2" if there is already a bean with that name).
--&gt;
&lt;!ATTLIST bean id ID #IMPLIED&gt;

&lt;!--
	Optional. Can be used to create one or more aliases illegal in an id.
	Multiple aliases can be separated by any number of spaces, commas, or
	semi-colons (or indeed any mixture of the three).
--&gt;
&lt;!ATTLIST bean name CDATA #IMPLIED&gt;

&lt;!--
	Each bean definition must specify the fully qualified name of the class,
	except if it pure serves as parent for child bean definitions.
--&gt;
&lt;!ATTLIST bean class CDATA #IMPLIED&gt;

&lt;!--
	Optionally specify a parent bean definition.

	Will use the bean class of the parent if none specified, but can
	also override it. In the latter case, the child bean class must be
	compatible with the parent, i.e. accept the parent's property values
	and constructor argument values, if any.

	A child bean definition will inherit constructor argument values,
	property values and method overrides from the parent, with the option
	to add new values. If init method, destroy method, factory bean and/or factory
	method are specified, they will override the corresponding parent settings.

	The remaining settings will always be taken from the child definition:
	depends on, autowire mode, dependency check, scope, lazy init.
--&gt;
&lt;!ATTLIST bean parent CDATA #IMPLIED&gt;

&lt;!--
	The scope of this bean: typically "singleton" (one shared instance,
	which will be returned by all calls to getBean() with the id),
	or "prototype" (independent instance resulting from each call to
	getBean(). Default is "singleton".

	Singletons are most commonly used, and are ideal for multi-threaded
	service objects. Further scopes, such as "request" or "session",
	might be supported by extended bean factories (for example, in a
	web environment).

	Note: This attribute will not be inherited by child bean definitions.
	Hence, it needs to be specified per concrete bean definition.

	Inner bean definitions inherit the singleton status of their containing
	bean definition, unless explicitly specified: The inner bean will be a
	singleton if the containing bean is a singleton, and a prototype if
	the containing bean has any other scope.
--&gt;
&lt;!ATTLIST bean scope CDATA #IMPLIED&gt;

&lt;!--
	Is this bean "abstract", i.e. not meant to be instantiated itself but
	rather just serving as parent for concrete child bean definitions.
	Default is "false". Specify "true" to tell the bean factory to not try to
	instantiate that particular bean in any case.

	Note: This attribute will not be inherited by child bean definitions.
	Hence, it needs to be specified per abstract bean definition.
--&gt;
&lt;!ATTLIST bean abstract (true | false) #IMPLIED&gt;

&lt;!--
	If this bean should be lazily initialized.
	If false, it will get instantiated on startup by bean factories
	that perform eager initialization of singletons.

	Note: This attribute will not be inherited by child bean definitions.
	Hence, it needs to be specified per concrete bean definition.
--&gt;
&lt;!ATTLIST bean lazy-init (true | false | default) "default"&gt;

&lt;!--
  Indicates whether or not this bean should be considered when looking
  for candidates to satisfy another beans autowiring requirements.
--&gt;
&lt;!ATTLIST bean autowire-candidate (true | false) #IMPLIED&gt;

&lt;!--
	Optional attribute controlling whether to "autowire" bean properties.
	This is an automagical process in which bean references don't need to be coded
	explicitly in the XML bean definition file, but Spring works out dependencies.

	There are 5 modes:

	1. "no"
	The traditional Spring default. No automagical wiring. Bean references
	must be defined in the XML file via the &lt;ref&gt; element. We recommend this
	in most cases as it makes documentation more explicit.

	2. "byName"
	Autowiring by property name. If a bean of class Cat exposes a dog property,
	Spring will try to set this to the value of the bean "dog" in the current factory.
	If there is no matching bean by name, nothing special happens;
	use dependency-check="objects" to raise an error in that case.

	3. "byType"
	Autowiring if there is exactly one bean of the property type in the bean factory.
	If there is more than one, a fatal error is raised, and you can't use byType
	autowiring for that bean. If there is none, nothing special happens;
	use dependency-check="objects" to raise an error in that case.

	4. "constructor"
	Analogous to "byType" for constructor arguments. If there isn't exactly one bean
	of the constructor argument type in the bean factory, a fatal error is raised.

	5. "autodetect"
	Chooses "constructor" or "byType" through introspection of the bean class.
	If a default constructor is found, "byType" gets applied.

	The latter two are similar to PicoContainer and make bean factories simple to
	configure for small namespaces, but doesn't work as well as standard Spring
	behaviour for bigger applications.

	Note that explicit dependencies, i.e. "property" and "constructor-arg" elements,
	always override autowiring. Autowire behavior can be combined with dependency
	checking, which will be performed after all autowiring has been completed.

	Note: This attribute will not be inherited by child bean definitions.
	Hence, it needs to be specified per concrete bean definition.
--&gt;
&lt;!ATTLIST bean autowire (no | byName | byType | constructor | autodetect | default) "default"&gt;

&lt;!--
	Optional attribute controlling whether to check whether all this
	beans dependencies, expressed in its properties, are satisfied.
	Default is no dependency checking.

	"simple" type dependency checking includes primitives and String;
	"objects" includes collaborators (other beans in the factory);
	"all" includes both types of dependency checking.

	Note: This attribute will not be inherited by child bean definitions.
	Hence, it needs to be specified per concrete bean definition.
--&gt;
&lt;!ATTLIST bean dependency-check (none | objects | simple | all | default) "default"&gt;

&lt;!--
	The names of the beans that this bean depends on being initialized.
	The bean factory will guarantee that these beans get initialized before.

	Note that dependencies are normally expressed through bean properties or
	constructor arguments. This property should just be necessary for other kinds
	of dependencies like statics (*ugh*) or database preparation on startup.

	Note: This attribute will not be inherited by child bean definitions.
	Hence, it needs to be specified per concrete bean definition.
--&gt;
&lt;!ATTLIST bean depends-on CDATA #IMPLIED&gt;

&lt;!--
	Optional attribute for the name of the custom initialization method
	to invoke after setting bean properties. The method must have no arguments,
	but may throw any exception.
--&gt;
&lt;!ATTLIST bean init-method CDATA #IMPLIED&gt;

&lt;!--
	Optional attribute for the name of the custom destroy method to invoke
	on bean factory shutdown. The method must have no arguments,
	but may throw any exception.

	Note: Only invoked on beans whose lifecycle is under full control
	of the factory - which is always the case for singletons, but not
	guaranteed for any other scope.
--&gt;
&lt;!ATTLIST bean destroy-method CDATA #IMPLIED&gt;

&lt;!--
	Optional attribute specifying the name of a factory method to use to
	create this object. Use constructor-arg elements to specify arguments
	to the factory method, if it takes arguments. Autowiring does not apply
	to factory methods.

	If the "class" attribute is present, the factory method will be a static
	method on the class specified by the "class" attribute on this bean
	definition. Often this will be the same class as that of the constructed
	object - for example, when the factory method is used as an alternative
	to a constructor. However, it may be on a different class. In that case,
	the created object will *not* be of the class specified in the "class"
	attribute. This is analogous to FactoryBean behavior.

	If the "factory-bean" attribute is present, the "class" attribute is not
	used, and the factory method will be an instance method on the object
	returned from a getBean call with the specified bean name. The factory
	bean may be defined as a singleton or a prototype.

	The factory method can have any number of arguments. Autowiring is not
	supported. Use indexed constructor-arg elements in conjunction with the
	factory-method attribute.

	Setter Injection can be used in conjunction with a factory method.
	Method Injection cannot, as the factory method returns an instance,
	which will be used when the container creates the bean.
--&gt;
&lt;!ATTLIST bean factory-method CDATA #IMPLIED&gt;

&lt;!--
	Alternative to class attribute for factory-method usage.
	If this is specified, no class attribute should be used.
	This should be set to the name of a bean in the current or
	ancestor factories that contains the relevant factory method.
	This allows the factory itself to be configured using Dependency
	Injection, and an instance (rather than static) method to be used.
--&gt;
&lt;!ATTLIST bean factory-bean CDATA #IMPLIED&gt;

&lt;!--
	Bean definitions can specify zero or more constructor arguments.
	This is an alternative to "autowire constructor".
	Arguments correspond to either a specific index of the constructor argument
	list or are supposed to be matched generically by type.

	Note: A single generic argument value will just be used once, rather than
	potentially matched multiple times (as of Spring 1.1).

	constructor-arg elements are also used in conjunction with the factory-method
	element to construct beans using static or instance factory methods.
--&gt;
&lt;!ELEMENT constructor-arg (
	description?,
	(bean | ref | idref | value | null | list | set | map | props)?
)&gt;

&lt;!--
	The constructor-arg tag can have an optional index attribute,
	to specify the exact index in the constructor argument list. Only needed
	to avoid ambiguities, e.g. in case of 2 arguments of the same type.
--&gt;
&lt;!ATTLIST constructor-arg index CDATA #IMPLIED&gt;

&lt;!--
	The constructor-arg tag can have an optional type attribute,
	to specify the exact type of the constructor argument. Only needed
	to avoid ambiguities, e.g. in case of 2 single argument constructors
	that can both be converted from a String.
--&gt;
&lt;!ATTLIST constructor-arg type CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "ref bean=".
--&gt;
&lt;!ATTLIST constructor-arg ref CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "value".
--&gt;
&lt;!ATTLIST constructor-arg value CDATA #IMPLIED&gt;


&lt;!--
	Bean definitions can have zero or more properties.
	Property elements correspond to JavaBean setter methods exposed
	by the bean classes. Spring supports primitives, references to other
	beans in the same or related factories, lists, maps and properties.
--&gt;
&lt;!ELEMENT property (
	description?, meta*,
	(bean | ref | idref | value | null | list | set | map | props)?
)&gt;

&lt;!--
	The property name attribute is the name of the JavaBean property.
	This follows JavaBean conventions: a name of "age" would correspond
	to setAge()/optional getAge() methods.
--&gt;
&lt;!ATTLIST property name CDATA #REQUIRED&gt;

&lt;!--
  A short-cut alternative to a child element "ref bean=".
--&gt;
&lt;!ATTLIST property ref CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "value".
--&gt;
&lt;!ATTLIST property value CDATA #IMPLIED&gt;


&lt;!--
	A lookup method causes the IoC container to override the given method and return
	the bean with the name given in the bean attribute. This is a form of Method Injection.
	It's particularly useful as an alternative to implementing the BeanFactoryAware
	interface, in order to be able to make getBean() calls for non-singleton instances
	at runtime. In this case, Method Injection is a less invasive alternative.
--&gt;
&lt;!ELEMENT lookup-method EMPTY&gt;

&lt;!--
	Name of a lookup method. This method should take no arguments.
--&gt;
&lt;!ATTLIST lookup-method name CDATA #IMPLIED&gt;

&lt;!--
	Name of the bean in the current or ancestor factories that the lookup method
	should resolve to. Often this bean will be a prototype, in which case the
	lookup method will return a distinct instance on every invocation. This
	is useful for single-threaded objects.
--&gt;
&lt;!ATTLIST lookup-method bean CDATA #IMPLIED&gt;


&lt;!--
	Similar to the lookup method mechanism, the replaced-method element is used to control
	IoC container method overriding: Method Injection. This mechanism allows the overriding
	of a method with arbitrary code.
--&gt;
&lt;!ELEMENT replaced-method (
	(arg-type)*
)&gt;

&lt;!--
	Name of the method whose implementation should be replaced by the IoC container.
	If this method is not overloaded, there's no need to use arg-type subelements.
	If this method is overloaded, arg-type subelements must be used for all
	override definitions for the method.
--&gt;
&lt;!ATTLIST replaced-method name CDATA #IMPLIED&gt;

&lt;!--
	Bean name of an implementation of the MethodReplacer interface in the current
	or ancestor factories. This may be a singleton or prototype bean. If it's
	a prototype, a new instance will be used for each method replacement.
	Singleton usage is the norm.
--&gt;
&lt;!ATTLIST replaced-method replacer CDATA #IMPLIED&gt;

&lt;!--
	Subelement of replaced-method identifying an argument for a replaced method
	in the event of method overloading.
--&gt;
&lt;!ELEMENT arg-type (#PCDATA)&gt;

&lt;!--
	Specification of the type of an overloaded method argument as a String.
	For convenience, this may be a substring of the FQN. E.g. all the
	following would match "java.lang.String":
	- java.lang.String
	- String
	- Str

	As the number of arguments will be checked also, this convenience can often
	be used to save typing.
--&gt;
&lt;!ATTLIST arg-type match CDATA #IMPLIED&gt;


&lt;!--
	Defines a reference to another bean in this factory or an external
	factory (parent or included factory).
--&gt;
&lt;!ELEMENT ref EMPTY&gt;

&lt;!--
	References must specify a name of the target bean.
	The "bean" attribute can reference any name from any bean in the context,
	to be checked at runtime.
	Local references, using the "local" attribute, have to use bean ids;
	they can be checked by this DTD, thus should be preferred for references
	within the same bean factory XML file.
--&gt;
&lt;!ATTLIST ref bean CDATA #IMPLIED&gt;
&lt;!ATTLIST ref local IDREF #IMPLIED&gt;
&lt;!ATTLIST ref parent CDATA #IMPLIED&gt;


&lt;!--
	Defines a string property value, which must also be the id of another
	bean in this factory or an external factory (parent or included factory).
	While a regular 'value' element could instead be used for the same effect,
	using idref in this case allows validation of local bean ids by the XML
	parser, and name completion by supporting tools.
--&gt;
&lt;!ELEMENT idref EMPTY&gt;

&lt;!--
	ID refs must specify a name of the target bean.
	The "bean" attribute can reference any name from any bean in the context,
	potentially to be checked at runtime by bean factory implementations.
	Local references, using the "local" attribute, have to use bean ids;
	they can be checked by this DTD, thus should be preferred for references
	within the same bean factory XML file.
--&gt;
&lt;!ATTLIST idref bean CDATA #IMPLIED&gt;
&lt;!ATTLIST idref local IDREF #IMPLIED&gt;


&lt;!--
	Contains a string representation of a property value.
	The property may be a string, or may be converted to the required
	type using the JavaBeans PropertyEditor machinery. This makes it
	possible for application developers to write custom PropertyEditor
	implementations that can convert strings to arbitrary target objects.

	Note that this is recommended for simple objects only.
	Configure more complex objects by populating JavaBean
	properties with references to other beans.
--&gt;
&lt;!ELEMENT value (#PCDATA)&gt;

&lt;!--
	The value tag can have an optional type attribute, to specify the
	exact type that the value should be converted to. Only needed
	if the type of the target property or constructor argument is
	too generic: for example, in case of a collection element.
--&gt;
&lt;!ATTLIST value type CDATA #IMPLIED&gt;

&lt;!--
	Denotes a Java null value. Necessary because an empty "value" tag
	will resolve to an empty String, which will not be resolved to a
	null value unless a special PropertyEditor does so.
--&gt;
&lt;!ELEMENT null (#PCDATA)&gt;


&lt;!--
	A list can contain multiple inner bean, ref, collection, or value elements.
	Java lists are untyped, pending generics support in Java 1.5,
	although references will be strongly typed.
	A list can also map to an array type. The necessary conversion
	is automatically performed by the BeanFactory.
--&gt;
&lt;!ELEMENT list (
	(bean | ref | idref | value | null | list | set | map | props)*
)&gt;

&lt;!--
	Enable/disable merging for collections when using parent/child beans.
--&gt;
&lt;!ATTLIST list merge (true | false | default) "default"&gt;

&lt;!--
	Specify the default Java type for nested values.
--&gt;
&lt;!ATTLIST list value-type CDATA #IMPLIED&gt;


&lt;!--
	A set can contain multiple inner bean, ref, collection, or value elements.
	Java sets are untyped, pending generics support in Java 1.5,
	although references will be strongly typed.
--&gt;
&lt;!ELEMENT set (
	(bean | ref | idref | value | null | list | set | map | props)*
)&gt;

&lt;!--
	Enable/disable merging for collections when using parent/child beans.
--&gt;
&lt;!ATTLIST set merge (true | false | default) "default"&gt;

&lt;!--
	Specify the default Java type for nested values.
--&gt;
&lt;!ATTLIST set value-type CDATA #IMPLIED&gt;


&lt;!--
	A Spring map is a mapping from a string key to object.
	Maps may be empty.
--&gt;
&lt;!ELEMENT map (
	(entry)*
)&gt;

&lt;!--
	Enable/disable merging for collections when using parent/child beans.
--&gt;
&lt;!ATTLIST map merge (true | false | default) "default"&gt;

&lt;!--
	Specify the default Java type for nested entry keys.
--&gt;
&lt;!ATTLIST map key-type CDATA #IMPLIED&gt;

&lt;!--
	Specify the default Java type for nested entry values.
--&gt;
&lt;!ATTLIST map value-type CDATA #IMPLIED&gt;

&lt;!--
	A map entry can be an inner bean, ref, value, or collection.
	The key of the entry is given by the "key" attribute or child element.
--&gt;
&lt;!ELEMENT entry (
  key?,
	(bean | ref | idref | value | null | list | set | map | props)?
)&gt;

&lt;!--
	Each map element must specify its key as attribute or as child element.
	A key attribute is always a String value.
--&gt;
&lt;!ATTLIST entry key CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a "key" element with a "ref bean=" child element.
--&gt;
&lt;!ATTLIST entry key-ref CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "value".
--&gt;
&lt;!ATTLIST entry value CDATA #IMPLIED&gt;

&lt;!--
  A short-cut alternative to a child element "ref bean=".
--&gt;
&lt;!ATTLIST entry value-ref CDATA #IMPLIED&gt;

&lt;!--
	A key element can contain an inner bean, ref, value, or collection.
--&gt;
&lt;!ELEMENT key (
	(bean | ref | idref | value | null | list | set | map | props)
)&gt;


&lt;!--
	Props elements differ from map elements in that values must be strings.
	Props may be empty.
--&gt;
&lt;!ELEMENT props (
	(prop)*
)&gt;

&lt;!--
	Enable/disable merging for collections when using parent/child beans.
--&gt;
&lt;!ATTLIST props merge (true | false | default) "default"&gt;

&lt;!--
	Element content is the string value of the property.
	Note that whitespace is trimmed off to avoid unwanted whitespace
	caused by typical XML formatting.
--&gt;
&lt;!ELEMENT prop (#PCDATA)&gt;

&lt;!--
	Each property element must specify its key.
--&gt;
&lt;!ATTLIST prop key CDATA #REQUIRED&gt;</pre></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="spring.tld"></a>Appendix&nbsp;D.&nbsp;spring.tld</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring.tld-intro"></a>D.1.&nbsp;Introduction</h2></div></div><div></div></div></div><p>One of the view technologies you can use with the Spring Framework
			    is Java Server Pages (JSPs). To help you implement views using Java Server Pages
			    the Spring Framework provides you with some tags for evaluating errors, setting
			    themes and outputting internationalized messages.</p><p>Please note that the various tags generated by this form tag library
                are compliant with the <a href="http://www.w3.org/TR/xhtml1/" target="_top">XHTML-1.0-Strict specification</a> and attendant <a href="http://www.w3.org/TR/xhtml1/dtds.html#a_dtd_XHTML-1.0-Strict" target="_top">DTD</a>.</p><p>This appendix describes the <tt class="literal">spring.tld</tt> tag library.</p><div class="itemizedlist"><ul type="disc"><li><a href="#spring.tld.bind" title="D.2.&nbsp;The bind tag">Section&nbsp;D.2, &#8220;The bind tag&#8221;</a></li><li><a href="#spring.tld.escapeBody" title="D.3.&nbsp;The escapeBody tag">Section&nbsp;D.3, &#8220;The escapeBody tag&#8221;</a></li><li><a href="#spring.tld.hasBindErrors" title="D.4.&nbsp;The hasBindErrors tag">Section&nbsp;D.4, &#8220;The hasBindErrors tag&#8221;</a></li><li><a href="#spring.tld.htmlEscape" title="D.5.&nbsp;The htmlEscape tag">Section&nbsp;D.5, &#8220;The htmlEscape tag&#8221;</a></li><li><a href="#spring.tld.message" title="D.6.&nbsp;The message tag">Section&nbsp;D.6, &#8220;The message tag&#8221;</a></li><li><a href="#spring.tld.nestedPath" title="D.7.&nbsp;The nestedPath tag">Section&nbsp;D.7, &#8220;The nestedPath tag&#8221;</a></li><li><a href="#spring.tld.theme" title="D.8.&nbsp;The theme tag">Section&nbsp;D.8, &#8220;The theme tag&#8221;</a></li><li><a href="#spring.tld.transform" title="D.9.&nbsp;The transform tag">Section&nbsp;D.9, &#8220;The transform tag&#8221;</a></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring.tld.bind"></a>D.2.&nbsp;The <tt class="literal">bind</tt> tag</h2></div></div><div></div></div><p>
			Provides BindStatus object for the given bind path.
			The HTML escaping flag participates in a page-wide or application-wide setting
			(i.e. by HtmlEscapeTag or a "defaultHtmlEscape" context-param in web.xml).
		</p><div class="table"><a name="spring.tld.bind.table"></a><p class="title"><b>Table&nbsp;D.1.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Set HTML escaping for this tag, as boolean value. Overrides
			the default HTML escaping setting for the current page.</p></td></tr><tr><td align="center"><p>ignoreNestedPath</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Set whether to ignore a nested path, if any. Default is to not ignore.</p></td></tr><tr><td align="center"><p>path</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>The path to the bean or bean property to bind status
			information for. For instance account.name, company.address.zipCode
			or just employee. The status object will exported to the page scope,
			specifically for this bean or bean property</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring.tld.escapeBody"></a>D.3.&nbsp;The <tt class="literal">escapeBody</tt> tag</h2></div></div><div></div></div><p>
			Escapes its enclosed body content, applying HTML escaping and/or JavaScript escaping.
			The HTML escaping flag participates in a page-wide or application-wide setting
			(i.e. by HtmlEscapeTag or a "defaultHtmlEscape" context-param in web.xml).
		</p><div class="table"><a name="spring.tld.escapeBody.table"></a><p class="title"><b>Table&nbsp;D.2.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Set HTML escaping for this tag, as boolean value. Overrides the
			default HTML escaping setting for the current page.</p></td></tr><tr><td align="center"><p>javaScriptEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Set JavaScript escaping for this tag, as boolean value.
			Default is false.</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring.tld.hasBindErrors"></a>D.4.&nbsp;The <tt class="literal">hasBindErrors</tt> tag</h2></div></div><div></div></div><p>
			Provides Errors instance in case of bind errors.
			The HTML escaping flag participates in a page-wide or application-wide setting
			(i.e. by HtmlEscapeTag or a "defaultHtmlEscape" context-param in web.xml).
		</p><div class="table"><a name="spring.tld.hasBindErrors.table"></a><p class="title"><b>Table&nbsp;D.3.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Set HTML escaping for this tag, as boolean value.
			Overrides the default HTML escaping setting for the current page.</p></td></tr><tr><td align="center"><p>name</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>The name of the bean in the request, that needs to be
			inspected for errors. If errors are available for this bean, they
			will be bound under the 'errors' key.</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring.tld.htmlEscape"></a>D.5.&nbsp;The <tt class="literal">htmlEscape</tt> tag</h2></div></div><div></div></div><p>
			Sets default HTML escape value for the current page.
			Overrides a "defaultHtmlEscape" context-param in web.xml, if any.
		</p><div class="table"><a name="spring.tld.htmlEscape.table"></a><p class="title"><b>Table&nbsp;D.4.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>defaultHtmlEscape</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>Set the default value for HTML escaping, to be put
				into the current PageContext.</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring.tld.message"></a>D.6.&nbsp;The <tt class="literal">message</tt> tag</h2></div></div><div></div></div><p>
			Retrieves the message with the given code, or text if code isn't resolvable.
			The HTML escaping flag participates in a page-wide or application-wide setting
			(i.e. by HtmlEscapeTag or a "defaultHtmlEscape" context-param in web.xml).
		</p><div class="table"><a name="spring.tld.message.table"></a><p class="title"><b>Table&nbsp;D.5.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>arguments</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Set optional message arguments for this tag, as a
			(comma-)delimited String (each String argument can contain JSP EL),
			an Object array (used as argument array), or a single Object (used
			as single argument).</p></td></tr><tr><td align="center"><p>argumentSeparator</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>The separator character to be used for splitting the
			arguments string value; defaults to a 'comma' (',').</p></td></tr><tr><td align="center"><p>code</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>The code (key) to use when looking up the message.
			If code is not provided, the text attribute will be used.</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Set HTML escaping for this tag, as boolean value.
			Overrides the default HTML escaping setting for the current page.</p></td></tr><tr><td align="center"><p>javaScriptEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Set JavaScript escaping for this tag, as boolean value. Default is false.</p></td></tr><tr><td align="center"><p>message</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>A MessageSourceResolvable argument (direct or through JSP EL).
				Fits nicely when used in conjunction with Spring's own validation error
				classes which all implement the MessageSourceResolvable interface. For
				example, this allows you to iterate over all of the errors in a form,
				passing each error (using a runtime expression) as the value of this
				'message' attribute, thus effecting the easy display of such error
				messages.</p></td></tr><tr><td align="center"><p>scope</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>The scope to use when exporting the result to a variable.
			This attribute is only used when var is also set. Possible values are
			page, request, session and application.</p></td></tr><tr><td align="center"><p>text</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Default text to output when a message for the given code
			could not be found. If both text and code are not set, the tag will
			output null.</p></td></tr><tr><td align="center"><p>var</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>The string to use when binding the result to the page,
			request, session or application scope. If not specified, the result
			gets outputted to the writer (i.e. typically directly to the JSP).</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring.tld.nestedPath"></a>D.7.&nbsp;The <tt class="literal">nestedPath</tt> tag</h2></div></div><div></div></div><p>
			Sets a nested path to be used by the bind tag's path.
		</p><div class="table"><a name="spring.tld.nestedPath.table"></a><p class="title"><b>Table&nbsp;D.6.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>path</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>Set the path that this tag should apply. E.g. 'customer'
			to allow bind paths like 'address.street' rather than
			'customer.address.street'.</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring.tld.theme"></a>D.8.&nbsp;The <tt class="literal">theme</tt> tag</h2></div></div><div></div></div><p>
			Retrieves the theme message with the given code, or text if code isn't resolvable.
			The HTML escaping flag participates in a page-wide or application-wide setting
			(i.e. by HtmlEscapeTag or a "defaultHtmlEscape" context-param in web.xml).
		</p><div class="table"><a name="spring.tld.theme.table"></a><p class="title"><b>Table&nbsp;D.7.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>arguments</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Set optional message arguments for this tag, as a
			(comma-)delimited String (each String argument can contain JSP EL),
			an Object array (used as argument array), or a single Object (used
			as single argument).</p></td></tr><tr><td align="center"><p>argumentSeparator</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>The separator character to be used for splitting the
			arguments string value; defaults to a 'comma' (',').</p></td></tr><tr><td align="center"><p>code</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>The code (key) to use when looking up the message.
			If code is not provided, the text attribute will be used.</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Set HTML escaping for this tag, as boolean value.
			Overrides the default HTML escaping setting for the current page.</p></td></tr><tr><td align="center"><p>javaScriptEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Set JavaScript escaping for this tag, as boolean value. Default is false.</p></td></tr><tr><td align="center"><p>message</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>A MessageSourceResolvable argument (direct or through JSP EL).</p></td></tr><tr><td align="center"><p>scope</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>The scope to use when exporting the result to a variable.
			This attribute is only used when var is also set. Possible values are
			page, request, session and application.</p></td></tr><tr><td align="center"><p>text</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Default text to output when a message for the given code
			could not be found. If both text and code are not set, the tag will
			output null.</p></td></tr><tr><td align="center"><p>var</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>The string to use when binding the result to the page,
			request, session or application scope. If not specified, the result
			gets outputted to the writer (i.e. typically directly to the JSP).</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring.tld.transform"></a>D.9.&nbsp;The <tt class="literal">transform</tt> tag</h2></div></div><div></div></div><p>
			Provides transformation of variables to Strings, using an appropriate
			custom PropertyEditor from BindTag (can only be used inside BindTag).
			The HTML escaping flag participates in a page-wide or application-wide setting
			(i.e. by HtmlEscapeTag or a 'defaultHtmlEscape' context-param in web.xml).
		</p><div class="table"><a name="spring.tld.transform.table"></a><p class="title"><b>Table&nbsp;D.8.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Set HTML escaping for this tag, as boolean value. Overrides
			the default HTML escaping setting for the current page.</p></td></tr><tr><td align="center"><p>scope</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>The scope to use when exported the result to a variable.
			This attribute is only used when var is also set. Possible values are
			page, request, session and application.</p></td></tr><tr><td align="center"><p>value</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>The value to transform. This is the actual object you want
			to have transformed (for instance a Date). Using the PropertyEditor that
			is currently in use by the 'spring:bind' tag.</p></td></tr><tr><td align="center"><p>var</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>The string to use when binding the result to the page,
			request, session or application scope. If not specified, the result gets
			outputted to the writer (i.e. typically directly to the JSP).</p></td></tr></tbody></table></div></div></div><div class="appendix" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="spring-form.tld"></a>Appendix&nbsp;E.&nbsp;spring-form.tld</h2></div></div><div></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld-intro"></a>E.1.&nbsp;Introduction</h2></div></div><div></div></div></div><p>One of the view technologies you can use with the Spring Framework
			    is Java Server Pages (JSPs). To help you implement views using Java Server Pages
			    the Spring Framework provides you with some tags for evaluating errors, setting
			    themes and outputting internationalized messages.</p><p>Please note that the various tags generated by this form tag library
                are compliant with the <a href="http://www.w3.org/TR/xhtml1/" target="_top">XHTML-1.0-Strict specification</a> and attendant <a href="http://www.w3.org/TR/xhtml1/dtds.html#a_dtd_XHTML-1.0-Strict" target="_top">DTD</a>.</p><p>This appendix describes the <tt class="literal">spring-form.tld</tt> tag library.</p><div class="itemizedlist"><ul type="disc"><li><a href="#spring-form.tld.checkbox" title="E.2.&nbsp;The checkbox tag">Section&nbsp;E.2, &#8220;The checkbox tag&#8221;</a></li><li><a href="#spring-form.tld.checkboxes" title="E.3.&nbsp;The checkboxes tag">Section&nbsp;E.3, &#8220;The checkboxes tag&#8221;</a></li><li><a href="#spring-form.tld.errors" title="E.4.&nbsp;The errors tag">Section&nbsp;E.4, &#8220;The errors tag&#8221;</a></li><li><a href="#spring-form.tld.form" title="E.5.&nbsp;The form tag">Section&nbsp;E.5, &#8220;The form tag&#8221;</a></li><li><a href="#spring-form.tld.hidden" title="E.6.&nbsp;The hidden tag">Section&nbsp;E.6, &#8220;The hidden tag&#8221;</a></li><li><a href="#spring-form.tld.input" title="E.7.&nbsp;The input tag">Section&nbsp;E.7, &#8220;The input tag&#8221;</a></li><li><a href="#spring-form.tld.label" title="E.8.&nbsp;The label tag">Section&nbsp;E.8, &#8220;The label tag&#8221;</a></li><li><a href="#spring-form.tld.option" title="E.9.&nbsp;The option tag">Section&nbsp;E.9, &#8220;The option tag&#8221;</a></li><li><a href="#spring-form.tld.options" title="E.10.&nbsp;The options tag">Section&nbsp;E.10, &#8220;The options tag&#8221;</a></li><li><a href="#spring-form.tld.password" title="E.11.&nbsp;The password tag">Section&nbsp;E.11, &#8220;The password tag&#8221;</a></li><li><a href="#spring-form.tld.radiobutton" title="E.12.&nbsp;The radiobutton tag">Section&nbsp;E.12, &#8220;The radiobutton tag&#8221;</a></li><li><a href="#spring-form.tld.radiobuttons" title="E.13.&nbsp;The radiobuttons tag">Section&nbsp;E.13, &#8220;The radiobuttons tag&#8221;</a></li><li><a href="#spring-form.tld.select" title="E.14.&nbsp;The select tag">Section&nbsp;E.14, &#8220;The select tag&#8221;</a></li><li><a href="#spring-form.tld.textarea" title="E.15.&nbsp;The textarea tag">Section&nbsp;E.15, &#8220;The textarea tag&#8221;</a></li></ul></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld.checkbox"></a>E.2.&nbsp;The <tt class="literal">checkbox</tt> tag</h2></div></div><div></div></div><p>Renders an HTML 'input' tag with type 'checkbox'.</p><div class="table"><a name="spring-form.tld.checkbox.table"></a><p class="title"><b>Table&nbsp;E.1.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>accesskey</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>cssClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>cssErrorClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute. Used when the bound field has errors.</p></td></tr><tr><td align="center"><p>cssStyle</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "style" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>dir</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>disabled</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute. Setting the value of this attribute to 'true' (without the quotes) will disable the HTML element.</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Enable/disable HTML escaping of rendered values.</p></td></tr><tr><td align="center"><p>id</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>label</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Value to be displayed as part of the tag</p></td></tr><tr><td align="center"><p>lang</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>onblur</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onchange</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>ondblclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onfocus</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeydown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeypress</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeyup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousedown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousemove</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseout</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseover</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>path</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>Path to property for data binding</p></td></tr><tr><td align="center"><p>tabindex</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>title</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>value</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld.checkboxes"></a>E.3.&nbsp;The <tt class="literal">checkboxes</tt> tag</h2></div></div><div></div></div><p>Renders multiple HTML 'input' tags with type 'checkbox'.</p><div class="table"><a name="spring-form.tld.checkboxes.table"></a><p class="title"><b>Table&nbsp;E.2.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>accesskey</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>cssClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>cssErrorClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute. Used when the bound field has errors.</p></td></tr><tr><td align="center"><p>cssStyle</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "style" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>delimiter</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Delimiter to use between each 'input' tag with type 'checkbox'. There is no delimiter by default.</p></td></tr><tr><td align="center"><p>dir</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>disabled</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute. Setting the value of this attribute to 'true' (without the quotes) will disable the HTML element.</p></td></tr><tr><td align="center"><p>element</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Specifies the HTML element that is used to enclose each 'input' tag with type 'checkbox'.  Defaults to 'span'.</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Enable/disable HTML escaping of rendered values.</p></td></tr><tr><td align="center"><p>id</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>itemLabel</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Value to be displayed as part of the 'input' tags with type 'checkbox'</p></td></tr><tr><td align="center"><p>items</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>The Collection, Map or array of objects used to generate the 'input' tags with type 'checkbox'</p></td></tr><tr><td align="center"><p>itemValue</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Name of the property mapped to 'value' attribute of the 'input' tags with type 'checkbox'</p></td></tr><tr><td align="center"><p>lang</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>onblur</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onchange</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>ondblclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onfocus</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeydown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeypress</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeyup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousedown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousemove</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseout</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseover</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>path</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>Path to property for data binding</p></td></tr><tr><td align="center"><p>tabindex</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>title</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld.errors"></a>E.4.&nbsp;The <tt class="literal">errors</tt> tag</h2></div></div><div></div></div><p>Renders field errors in an HTML 'span' tag.</p><div class="table"><a name="spring-form.tld.errors.table"></a><p class="title"><b>Table&nbsp;E.3.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>cssClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>cssStyle</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "style" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>delimiter</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Delimiter for displaying multiple error messages. Defaults to the br tag.</p></td></tr><tr><td align="center"><p>dir</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>element</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Specifies the HTML element that is used to render the enclosing errors.</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Enable/disable HTML escaping of rendered values.</p></td></tr><tr><td align="center"><p>id</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>lang</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>onclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>ondblclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeydown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeypress</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeyup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousedown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousemove</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseout</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseover</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>path</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Path to errors object for data binding</p></td></tr><tr><td align="center"><p>tabindex</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>title</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld.form"></a>E.5.&nbsp;The <tt class="literal">form</tt> tag</h2></div></div><div></div></div><p>Renders an HTML 'form' tag and exposes a binding path to inner tags for binding.</p><div class="table"><a name="spring-form.tld.form.table"></a><p class="title"><b>Table&nbsp;E.4.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>acceptCharset</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Specifies the list of character encodings for input data that is accepted by the server processing this form. The value is a space- and/or comma-delimited list of charset values. The client must interpret this list as an exclusive-or list, i.e., the server is able to accept any single character encoding per entity received.</p></td></tr><tr><td align="center"><p>action</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Required Attribute</p></td></tr><tr><td align="center"><p>autocomplete</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Common Optional Attribute</p></td></tr><tr><td align="center"><p>commandName</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Name of the model attribute under which the form object is exposed.
				Defaults to 'command'.</p></td></tr><tr><td align="center"><p>cssClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>cssStyle</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "style" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>dir</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>enctype</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Enable/disable HTML escaping of rendered values.</p></td></tr><tr><td align="center"><p>id</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>lang</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>method</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr><tr><td align="center"><p>modelAttribute</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Name of the model attribute under which the form object is exposed.
				Defaults to 'command'.</p></td></tr><tr><td align="center"><p>name</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute - added for backwards compatibility cases</p></td></tr><tr><td align="center"><p>onclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>ondblclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeydown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeypress</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeyup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousedown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousemove</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseout</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseover</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onreset</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onsubmit</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>target</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr><tr><td align="center"><p>title</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld.hidden"></a>E.6.&nbsp;The <tt class="literal">hidden</tt> tag</h2></div></div><div></div></div><p>Renders an HTML 'input' tag with type 'hidden' using the bound value.</p><div class="table"><a name="spring-form.tld.hidden.table"></a><p class="title"><b>Table&nbsp;E.5.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Enable/disable HTML escaping of rendered values.</p></td></tr><tr><td align="center"><p>id</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>path</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>Path to property for data binding</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld.input"></a>E.7.&nbsp;The <tt class="literal">input</tt> tag</h2></div></div><div></div></div><p>Renders an HTML 'input' tag with type 'text' using the bound value.</p><div class="table"><a name="spring-form.tld.input.table"></a><p class="title"><b>Table&nbsp;E.6.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>accesskey</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>alt</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr><tr><td align="center"><p>autocomplete</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Common Optional Attribute</p></td></tr><tr><td align="center"><p>cssClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>cssErrorClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute. Used when the bound field has errors.</p></td></tr><tr><td align="center"><p>cssStyle</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "style" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>dir</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>disabled</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute. Setting the value of this attribute to 'true' (without the quotes) will disable the HTML element.</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Enable/disable HTML escaping of rendered values.</p></td></tr><tr><td align="center"><p>id</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>lang</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>maxlength</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr><tr><td align="center"><p>onblur</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onchange</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>ondblclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onfocus</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeydown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeypress</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeyup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousedown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousemove</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseout</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseover</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onselect</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>path</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>Path to property for data binding</p></td></tr><tr><td align="center"><p>readonly</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute. Setting the value of this attribute to 'true' (without the quotes) will make the HTML element readonly.</p></td></tr><tr><td align="center"><p>size</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr><tr><td align="center"><p>tabindex</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>title</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld.label"></a>E.8.&nbsp;The <tt class="literal">label</tt> tag</h2></div></div><div></div></div><p>Renders a form field label in an HTML 'label' tag.</p><div class="table"><a name="spring-form.tld.label.table"></a><p class="title"><b>Table&nbsp;E.7.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>cssClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute.</p></td></tr><tr><td align="center"><p>cssErrorClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute. Used only when errors are present.</p></td></tr><tr><td align="center"><p>cssStyle</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "style" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>dir</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>for</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Enable/disable HTML escaping of rendered values.</p></td></tr><tr><td align="center"><p>id</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>lang</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>onclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>ondblclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeydown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeypress</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeyup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousedown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousemove</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseout</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseover</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>path</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>Path to errors object for data binding</p></td></tr><tr><td align="center"><p>tabindex</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>title</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld.option"></a>E.9.&nbsp;The <tt class="literal">option</tt> tag</h2></div></div><div></div></div><p>Renders a single HTML 'option'. Sets 'selected' as appropriate based on bound value.</p><div class="table"><a name="spring-form.tld.option.table"></a><p class="title"><b>Table&nbsp;E.8.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>cssClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>cssErrorClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute. Used when the bound field has errors.</p></td></tr><tr><td align="center"><p>cssStyle</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "style" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>dir</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>disabled</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute. Setting the value of this attribute to 'true' (without the quotes) will disable the HTML element.</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Enable/disable HTML escaping of rendered values.</p></td></tr><tr><td align="center"><p>id</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>label</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr><tr><td align="center"><p>lang</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>onclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>ondblclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeydown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeypress</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeyup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousedown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousemove</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseout</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseover</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>tabindex</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>title</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>value</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld.options"></a>E.10.&nbsp;The <tt class="literal">options</tt> tag</h2></div></div><div></div></div><p>Renders a list of HTML 'option' tags. Sets 'selected' as appropriate based on bound value.</p><div class="table"><a name="spring-form.tld.options.table"></a><p class="title"><b>Table&nbsp;E.9.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>cssClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>cssErrorClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute. Used when the bound field has errors.</p></td></tr><tr><td align="center"><p>cssStyle</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "style" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>dir</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>disabled</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute. Setting the value of this attribute to 'true' (without the quotes) will disable the HTML element.</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Enable/disable HTML escaping of rendered values.</p></td></tr><tr><td align="center"><p>id</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>itemLabel</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Name of the property mapped to the inner text of the 'option' tag</p></td></tr><tr><td align="center"><p>items</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>The Collection, Map or array of objects used to generate the inner 'option' tags</p></td></tr><tr><td align="center"><p>itemValue</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Name of the property mapped to 'value' attribute of the 'option' tag</p></td></tr><tr><td align="center"><p>lang</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>onclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>ondblclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeydown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeypress</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeyup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousedown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousemove</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseout</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseover</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>tabindex</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>title</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld.password"></a>E.11.&nbsp;The <tt class="literal">password</tt> tag</h2></div></div><div></div></div><p>Renders an HTML 'input' tag with type 'password' using the bound value.</p><div class="table"><a name="spring-form.tld.password.table"></a><p class="title"><b>Table&nbsp;E.10.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>accesskey</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>alt</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr><tr><td align="center"><p>autocomplete</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Common Optional Attribute</p></td></tr><tr><td align="center"><p>cssClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>cssErrorClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute. Used when the bound field has errors.</p></td></tr><tr><td align="center"><p>cssStyle</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "style" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>dir</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>disabled</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute. Setting the value of this attribute to 'true' (without the quotes) will disable the HTML element.</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Enable/disable HTML escaping of rendered values.</p></td></tr><tr><td align="center"><p>id</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>lang</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>maxlength</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr><tr><td align="center"><p>onblur</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onchange</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>ondblclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onfocus</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeydown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeypress</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeyup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousedown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousemove</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseout</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseover</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onselect</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>path</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>Path to property for data binding</p></td></tr><tr><td align="center"><p>readonly</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute. Setting the value of this attribute to 'true' (without the quotes) will make the HTML element readonly.</p></td></tr><tr><td align="center"><p>showPassword</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Is the password value to be shown? Defaults to false.</p></td></tr><tr><td align="center"><p>size</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr><tr><td align="center"><p>tabindex</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>title</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld.radiobutton"></a>E.12.&nbsp;The <tt class="literal">radiobutton</tt> tag</h2></div></div><div></div></div><p>Renders an HTML 'input' tag with type 'radio'.</p><div class="table"><a name="spring-form.tld.radiobutton.table"></a><p class="title"><b>Table&nbsp;E.11.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>accesskey</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>cssClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>cssErrorClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute. Used when the bound field has errors.</p></td></tr><tr><td align="center"><p>cssStyle</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "style" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>dir</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>disabled</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute. Setting the value of this attribute to 'true' (without the quotes) will disable the HTML element.</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Enable/disable HTML escaping of rendered values.</p></td></tr><tr><td align="center"><p>id</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>label</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Value to be displayed as part of the tag</p></td></tr><tr><td align="center"><p>lang</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>onblur</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onchange</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>ondblclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onfocus</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeydown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeypress</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeyup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousedown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousemove</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseout</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseover</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>path</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>Path to property for data binding</p></td></tr><tr><td align="center"><p>tabindex</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>title</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>value</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld.radiobuttons"></a>E.13.&nbsp;The <tt class="literal">radiobuttons</tt> tag</h2></div></div><div></div></div><p>Renders multiple HTML 'input' tags with type 'radio'.</p><div class="table"><a name="spring-form.tld.radiobuttons.table"></a><p class="title"><b>Table&nbsp;E.12.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>accesskey</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>cssClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>cssErrorClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute. Used when the bound field has errors.</p></td></tr><tr><td align="center"><p>cssStyle</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "style" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>delimiter</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Delimiter to use between each 'input' tag with type 'radio'. There is no delimiter by default.</p></td></tr><tr><td align="center"><p>dir</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>disabled</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute. Setting the value of this attribute to 'true' (without the quotes) will disable the HTML element.</p></td></tr><tr><td align="center"><p>element</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Specifies the HTML element that is used to enclose each 'input' tag with type 'radio'.  Defaults to 'span'.</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Enable/disable HTML escaping of rendered values.</p></td></tr><tr><td align="center"><p>id</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>itemLabel</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Value to be displayed as part of the 'input' tags with type 'radio'</p></td></tr><tr><td align="center"><p>items</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>The Collection, Map or array of objects used to generate the 'input' tags with type 'radio'</p></td></tr><tr><td align="center"><p>itemValue</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Name of the property mapped to 'value' attribute of the 'input' tags with type 'radio'</p></td></tr><tr><td align="center"><p>lang</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>onblur</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onchange</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>ondblclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onfocus</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeydown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeypress</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeyup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousedown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousemove</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseout</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseover</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>path</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>Path to property for data binding</p></td></tr><tr><td align="center"><p>tabindex</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>title</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld.select"></a>E.14.&nbsp;The <tt class="literal">select</tt> tag</h2></div></div><div></div></div><p>Renders an HTML 'select' element. Supports databinding to the selected option.</p><div class="table"><a name="spring-form.tld.select.table"></a><p class="title"><b>Table&nbsp;E.13.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>accesskey</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>cssClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>cssErrorClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute. Used when the bound field has errors.</p></td></tr><tr><td align="center"><p>cssStyle</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "style" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>dir</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>disabled</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute. Setting the value of this attribute to 'true' (without the quotes) will disable the HTML element.</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Enable/disable HTML escaping of rendered values.</p></td></tr><tr><td align="center"><p>id</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>itemLabel</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Name of the property mapped to the inner text of the 'option' tag</p></td></tr><tr><td align="center"><p>items</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>The Collection, Map or array of objects used to generate the inner 'option' tags</p></td></tr><tr><td align="center"><p>itemValue</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Name of the property mapped to 'value' attribute of the 'option' tag</p></td></tr><tr><td align="center"><p>lang</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>multiple</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr><tr><td align="center"><p>onblur</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onchange</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>ondblclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onfocus</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeydown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeypress</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeyup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousedown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousemove</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseout</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseover</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>path</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>Path to property for data binding</p></td></tr><tr><td align="center"><p>size</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute</p></td></tr><tr><td align="center"><p>tabindex</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>title</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr></tbody></table></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="spring-form.tld.textarea"></a>E.15.&nbsp;The <tt class="literal">textarea</tt> tag</h2></div></div><div></div></div><p>Renders an HTML 'textarea'.</p><div class="table"><a name="spring-form.tld.textarea.table"></a><p class="title"><b>Table&nbsp;E.14.&nbsp;Attributes</b></p><table summary="Attributes" border="1"><colgroup><col align="center"><col align="center"><col align="center"></colgroup><thead><tr><th align="center">Attribute</th><th align="center">Required?</th><th align="center">Runtime Expression?</th><th align="left">Description</th></tr></thead><tbody><tr><td align="center"><p>accesskey</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>cols</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Required Attribute</p></td></tr><tr><td align="center"><p>cssClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>cssErrorClass</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "class" - HTML Optional Attribute. Used when the bound field has errors.</p></td></tr><tr><td align="center"><p>cssStyle</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Equivalent to "style" - HTML Optional Attribute</p></td></tr><tr><td align="center"><p>dir</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>disabled</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute. Setting the value of this attribute to 'true' (without the quotes) will disable the HTML element.</p></td></tr><tr><td align="center"><p>htmlEscape</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>Enable/disable HTML escaping of rendered values.</p></td></tr><tr><td align="center"><p>id</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>lang</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>onblur</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onchange</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>ondblclick</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onfocus</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeydown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeypress</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onkeyup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousedown</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmousemove</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseout</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseover</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onmouseup</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>onselect</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Event Attribute</p></td></tr><tr><td align="center"><p>path</p></td><td align="center"><p>true</p></td><td align="center"><p>true</p></td><td align="left"><p>Path to property for data binding</p></td></tr><tr><td align="center"><p>readonly</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Optional Attribute. Setting the value of this attribute to 'true' (without the quotes) will make the HTML element readonly.</p></td></tr><tr><td align="center"><p>rows</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Required Attribute</p></td></tr><tr><td align="center"><p>tabindex</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr><tr><td align="center"><p>title</p></td><td align="center"><p>false</p></td><td align="center"><p>true</p></td><td align="left"><p>HTML Standard Attribute</p></td></tr></tbody></table></div></div></div></div><!--Begin LoopFuse code--><script xmlns="http://www.w3.org/TR/xhtml1/transitional" src="http://loopfuse.net/webrecorder/js/listen.js" type="text/javascript"></script><script xmlns="http://www.w3.org/TR/xhtml1/transitional" type="text/javascript"> 
            _lf_cid = "LF_48be82fa";
            _lf_remora();
        </script><!--End LoopFuse code--></body></html>